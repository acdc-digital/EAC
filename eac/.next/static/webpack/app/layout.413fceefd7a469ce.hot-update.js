"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/layout",{

/***/ "(app-pages-browser)/./app/globals.css":
/*!*************************!*\
  !*** ./app/globals.css ***!
  \*************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"d2479edc333c\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9nbG9iYWxzLmNzcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsaUVBQWUsY0FBYztBQUM3QixJQUFJLElBQVUsSUFBSSxpQkFBaUIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYXR0aGV3c2ltb24vUHJvamVjdHMvZWFjL2VhYy9hcHAvZ2xvYmFscy5jc3MiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgXCJkMjQ3OWVkYzMzM2NcIlxuaWYgKG1vZHVsZS5ob3QpIHsgbW9kdWxlLmhvdC5hY2NlcHQoKSB9XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/globals.css\n"));

/***/ }),

/***/ "(app-pages-browser)/./store/editor/index.ts":
/*!*******************************!*\
  !*** ./store/editor/index.ts ***!
  \*******************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useEditorStore: () => (/* binding */ useEditorStore)\n/* harmony export */ });\n/* harmony import */ var _barrel_optimize_names_AtSign_Braces_Calendar_Camera_FileCode_FileSpreadsheet_FileText_FileType_HelpCircle_MessageSquare_lucide_react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! __barrel_optimize__?names=AtSign,Braces,Calendar,Camera,FileCode,FileSpreadsheet,FileText,FileType,HelpCircle,MessageSquare!=!lucide-react */ \"(app-pages-browser)/../node_modules/.pnpm/lucide-react@0.525.0_react@18.3.1/node_modules/lucide-react/dist/esm/icons/file-code.js\");\n/* harmony import */ var _barrel_optimize_names_AtSign_Braces_Calendar_Camera_FileCode_FileSpreadsheet_FileText_FileType_HelpCircle_MessageSquare_lucide_react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! __barrel_optimize__?names=AtSign,Braces,Calendar,Camera,FileCode,FileSpreadsheet,FileText,FileType,HelpCircle,MessageSquare!=!lucide-react */ \"(app-pages-browser)/../node_modules/.pnpm/lucide-react@0.525.0_react@18.3.1/node_modules/lucide-react/dist/esm/icons/braces.js\");\n/* harmony import */ var _barrel_optimize_names_AtSign_Braces_Calendar_Camera_FileCode_FileSpreadsheet_FileText_FileType_HelpCircle_MessageSquare_lucide_react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! __barrel_optimize__?names=AtSign,Braces,Calendar,Camera,FileCode,FileSpreadsheet,FileText,FileType,HelpCircle,MessageSquare!=!lucide-react */ \"(app-pages-browser)/../node_modules/.pnpm/lucide-react@0.525.0_react@18.3.1/node_modules/lucide-react/dist/esm/icons/file-spreadsheet.js\");\n/* harmony import */ var _barrel_optimize_names_AtSign_Braces_Calendar_Camera_FileCode_FileSpreadsheet_FileText_FileType_HelpCircle_MessageSquare_lucide_react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! __barrel_optimize__?names=AtSign,Braces,Calendar,Camera,FileCode,FileSpreadsheet,FileText,FileType,HelpCircle,MessageSquare!=!lucide-react */ \"(app-pages-browser)/../node_modules/.pnpm/lucide-react@0.525.0_react@18.3.1/node_modules/lucide-react/dist/esm/icons/file-text.js\");\n/* harmony import */ var _barrel_optimize_names_AtSign_Braces_Calendar_Camera_FileCode_FileSpreadsheet_FileText_FileType_HelpCircle_MessageSquare_lucide_react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! __barrel_optimize__?names=AtSign,Braces,Calendar,Camera,FileCode,FileSpreadsheet,FileText,FileType,HelpCircle,MessageSquare!=!lucide-react */ \"(app-pages-browser)/../node_modules/.pnpm/lucide-react@0.525.0_react@18.3.1/node_modules/lucide-react/dist/esm/icons/file-type.js\");\n/* harmony import */ var _barrel_optimize_names_AtSign_Braces_Calendar_Camera_FileCode_FileSpreadsheet_FileText_FileType_HelpCircle_MessageSquare_lucide_react__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! __barrel_optimize__?names=AtSign,Braces,Calendar,Camera,FileCode,FileSpreadsheet,FileText,FileType,HelpCircle,MessageSquare!=!lucide-react */ \"(app-pages-browser)/../node_modules/.pnpm/lucide-react@0.525.0_react@18.3.1/node_modules/lucide-react/dist/esm/icons/message-square.js\");\n/* harmony import */ var _barrel_optimize_names_AtSign_Braces_Calendar_Camera_FileCode_FileSpreadsheet_FileText_FileType_HelpCircle_MessageSquare_lucide_react__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! __barrel_optimize__?names=AtSign,Braces,Calendar,Camera,FileCode,FileSpreadsheet,FileText,FileType,HelpCircle,MessageSquare!=!lucide-react */ \"(app-pages-browser)/../node_modules/.pnpm/lucide-react@0.525.0_react@18.3.1/node_modules/lucide-react/dist/esm/icons/camera.js\");\n/* harmony import */ var _barrel_optimize_names_AtSign_Braces_Calendar_Camera_FileCode_FileSpreadsheet_FileText_FileType_HelpCircle_MessageSquare_lucide_react__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! __barrel_optimize__?names=AtSign,Braces,Calendar,Camera,FileCode,FileSpreadsheet,FileText,FileType,HelpCircle,MessageSquare!=!lucide-react */ \"(app-pages-browser)/../node_modules/.pnpm/lucide-react@0.525.0_react@18.3.1/node_modules/lucide-react/dist/esm/icons/at-sign.js\");\n/* harmony import */ var _barrel_optimize_names_AtSign_Braces_Calendar_Camera_FileCode_FileSpreadsheet_FileText_FileType_HelpCircle_MessageSquare_lucide_react__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! __barrel_optimize__?names=AtSign,Braces,Calendar,Camera,FileCode,FileSpreadsheet,FileText,FileType,HelpCircle,MessageSquare!=!lucide-react */ \"(app-pages-browser)/../node_modules/.pnpm/lucide-react@0.525.0_react@18.3.1/node_modules/lucide-react/dist/esm/icons/calendar.js\");\n/* harmony import */ var _barrel_optimize_names_AtSign_Braces_Calendar_Camera_FileCode_FileSpreadsheet_FileText_FileType_HelpCircle_MessageSquare_lucide_react__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! __barrel_optimize__?names=AtSign,Braces,Calendar,Camera,FileCode,FileSpreadsheet,FileText,FileType,HelpCircle,MessageSquare!=!lucide-react */ \"(app-pages-browser)/../node_modules/.pnpm/lucide-react@0.525.0_react@18.3.1/node_modules/lucide-react/dist/esm/icons/circle-question-mark.js\");\n/* harmony import */ var zustand__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! zustand */ \"(app-pages-browser)/../node_modules/.pnpm/zustand@5.0.6_@types+react@19.1.9_react@18.3.1_use-sync-external-store@1.5.0_react@18.3.1_/node_modules/zustand/esm/react.mjs\");\n/* harmony import */ var zustand_middleware__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! zustand/middleware */ \"(app-pages-browser)/../node_modules/.pnpm/zustand@5.0.6_@types+react@19.1.9_react@18.3.1_use-sync-external-store@1.5.0_react@18.3.1_/node_modules/zustand/esm/middleware.mjs\");\n// Editor Store\n// /Users/matthewsimon/Projects/EAC/eac/store/editor/index.ts\n\n\n\n// Helper function to get icon based on file type\nconst getFileIcon = (type)=>{\n    switch(type){\n        case 'typescript':\n            return _barrel_optimize_names_AtSign_Braces_Calendar_Camera_FileCode_FileSpreadsheet_FileText_FileType_HelpCircle_MessageSquare_lucide_react__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\n        case 'javascript':\n            return _barrel_optimize_names_AtSign_Braces_Calendar_Camera_FileCode_FileSpreadsheet_FileText_FileType_HelpCircle_MessageSquare_lucide_react__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\n        case 'json':\n            return _barrel_optimize_names_AtSign_Braces_Calendar_Camera_FileCode_FileSpreadsheet_FileText_FileType_HelpCircle_MessageSquare_lucide_react__WEBPACK_IMPORTED_MODULE_1__[\"default\"];\n        case 'excel':\n            return _barrel_optimize_names_AtSign_Braces_Calendar_Camera_FileCode_FileSpreadsheet_FileText_FileType_HelpCircle_MessageSquare_lucide_react__WEBPACK_IMPORTED_MODULE_2__[\"default\"];\n        case 'markdown':\n            return _barrel_optimize_names_AtSign_Braces_Calendar_Camera_FileCode_FileSpreadsheet_FileText_FileType_HelpCircle_MessageSquare_lucide_react__WEBPACK_IMPORTED_MODULE_3__[\"default\"];\n        case 'pdf':\n            return _barrel_optimize_names_AtSign_Braces_Calendar_Camera_FileCode_FileSpreadsheet_FileText_FileType_HelpCircle_MessageSquare_lucide_react__WEBPACK_IMPORTED_MODULE_4__[\"default\"];\n        case 'generals':\n            return _barrel_optimize_names_AtSign_Braces_Calendar_Camera_FileCode_FileSpreadsheet_FileText_FileType_HelpCircle_MessageSquare_lucide_react__WEBPACK_IMPORTED_MODULE_3__[\"default\"];\n        case 'percent-complete':\n            return _barrel_optimize_names_AtSign_Braces_Calendar_Camera_FileCode_FileSpreadsheet_FileText_FileType_HelpCircle_MessageSquare_lucide_react__WEBPACK_IMPORTED_MODULE_2__[\"default\"];\n        case 'schedule':\n            return _barrel_optimize_names_AtSign_Braces_Calendar_Camera_FileCode_FileSpreadsheet_FileText_FileType_HelpCircle_MessageSquare_lucide_react__WEBPACK_IMPORTED_MODULE_2__[\"default\"];\n        case 'materials':\n            return _barrel_optimize_names_AtSign_Braces_Calendar_Camera_FileCode_FileSpreadsheet_FileText_FileType_HelpCircle_MessageSquare_lucide_react__WEBPACK_IMPORTED_MODULE_2__[\"default\"];\n        case 'facebook':\n            return _barrel_optimize_names_AtSign_Braces_Calendar_Camera_FileCode_FileSpreadsheet_FileText_FileType_HelpCircle_MessageSquare_lucide_react__WEBPACK_IMPORTED_MODULE_5__[\"default\"];\n        case 'reddit':\n            return 'r/'; // Changed from Hash to r/ text\n        case 'instagram':\n            return _barrel_optimize_names_AtSign_Braces_Calendar_Camera_FileCode_FileSpreadsheet_FileText_FileType_HelpCircle_MessageSquare_lucide_react__WEBPACK_IMPORTED_MODULE_6__[\"default\"];\n        case 'x':\n            return _barrel_optimize_names_AtSign_Braces_Calendar_Camera_FileCode_FileSpreadsheet_FileText_FileType_HelpCircle_MessageSquare_lucide_react__WEBPACK_IMPORTED_MODULE_7__[\"default\"];\n        case 'calendar':\n            return _barrel_optimize_names_AtSign_Braces_Calendar_Camera_FileCode_FileSpreadsheet_FileText_FileType_HelpCircle_MessageSquare_lucide_react__WEBPACK_IMPORTED_MODULE_8__[\"default\"];\n        case 'platform-instructions':\n            return _barrel_optimize_names_AtSign_Braces_Calendar_Camera_FileCode_FileSpreadsheet_FileText_FileType_HelpCircle_MessageSquare_lucide_react__WEBPACK_IMPORTED_MODULE_9__[\"default\"];\n        default:\n            return _barrel_optimize_names_AtSign_Braces_Calendar_Camera_FileCode_FileSpreadsheet_FileText_FileType_HelpCircle_MessageSquare_lucide_react__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\n    }\n};\n// Helper function to get file extension\n// Helper function to get file extension\nconst getFileExtension = (type)=>{\n    switch(type){\n        case 'typescript':\n            return '.ts';\n        case 'javascript':\n            return '.js';\n        case 'json':\n            return '.json';\n        case 'excel':\n            return '.xlsx';\n        case 'pdf':\n            return '.pdf';\n        case 'generals':\n            return '.generals';\n        case 'percent-complete':\n            return '.percent';\n        case 'schedule':\n            return '.schedule';\n        case 'materials':\n            return '.materials';\n        case 'facebook':\n            return '.facebook';\n        case 'reddit':\n            return '.reddit';\n        case 'instagram':\n            return '.instagram';\n        case 'x':\n            return '.x';\n        case 'markdown':\n            return '.md';\n        default:\n            return '.txt';\n    }\n};\n// Helper function to generate default content for new files\nconst getDefaultContent = (type, name)=>{\n    switch(type){\n        case 'typescript':\n            return \"// \".concat(name, \"\\n// Auto-generated TypeScript file\\n\\nimport React from 'react';\\n\\ninterface \").concat(name.replace(/[^a-zA-Z0-9]/g, ''), \"Props {\\n  // Define props here\\n}\\n\\nexport function \").concat(name.replace(/[^a-zA-Z0-9]/g, ''), \"({ }: \").concat(name.replace(/[^a-zA-Z0-9]/g, ''), 'Props) {\\n  return (\\n    <div className=\"p-4\">\\n      <h1 className=\"text-xl font-bold\">New Component: ').concat(name, '</h1>\\n      <p className=\"text-gray-600\">Start building your component here...</p>\\n    </div>\\n  );\\n}');\n        case 'javascript':\n            return \"// \".concat(name, \"\\n// Auto-generated JavaScript file\\n\\nexport function \").concat(name.replace(/[^a-zA-Z0-9]/g, ''), \"() {\\n  return {\\n    message: 'Hello from \").concat(name, \"!',\\n    data: []\\n  };\\n}\");\n        case 'json':\n            return '{\\n  \"name\": \"'.concat(name, '\",\\n  \"description\": \"Auto-generated JSON file\",\\n  \"version\": \"1.0.0\",\\n  \"data\": {}\\n}');\n        case 'markdown':\n            return \"Start writing your content here...\";\n        case 'generals':\n            return \"// \".concat(name, \" - Project General Information\\n// This file contains general project details and financial information\\n// Created on: \").concat(new Date().toISOString(), \"\\n\\nProject: \").concat(name, \"\\nStatus: Active\\nCreated: \").concat(new Date().toLocaleDateString(), \"\\n\\n// This file will display the project generals module interface\");\n        case 'percent-complete':\n            return \"// \".concat(name, \" - Percent Complete Tracker\\n// This file contains project completion tracking data\\n// Created on: \").concat(new Date().toISOString(), \"\\n\\nProject: \").concat(name, \"\\nType: Percent Complete Tracker\\nCreated: \").concat(new Date().toLocaleDateString(), \"\\n\\n// This file will display the percent complete tracking interface\");\n        case 'schedule':\n            return \"// \".concat(name, \" - Project Schedule\\n// This file contains project schedule and timeline data\\n// Created on: \").concat(new Date().toISOString(), \"\\n\\nProject: \").concat(name, \"\\nType: Project Schedule\\nCreated: \").concat(new Date().toLocaleDateString(), \"\\n\\n// This file will display the project schedule interface with Gantt chart\");\n        case 'materials':\n            return \"// \".concat(name, \" - Materials Management\\n// This file contains materials tracking and management data\\n// Created on: \").concat(new Date().toISOString(), \"\\n\\nProject: \").concat(name, \"\\nType: Materials Management\\nCreated: \").concat(new Date().toLocaleDateString(), \"\\n\\n// This file will display the materials management interface with manufactured and miscellaneous materials\");\n        case 'facebook':\n            return \"# \".concat(name, \" - Facebook Post\\nPlatform: Facebook\\nCreated: \").concat(new Date().toLocaleDateString(), \"\\n\\n## Post Content\\nWrite your Facebook post content here...\\n\\n## Settings\\n- Audience: Public\\n- Schedule: Now\\n- Hashtags: #example\\n\\n## Media\\n- Images: []\\n- Videos: []\\n\\n## Analytics\\n- Engagement: 0\\n- Reach: 0\\n- Clicks: 0\");\n        case 'reddit':\n            return \"# \".concat(name, \" - Reddit Post\\nPlatform: Reddit\\nCreated: \").concat(new Date().toLocaleDateString(), \"\\n\\n## Post Content\\nWrite your Reddit post content here...\\n\\n## Settings\\n- Subreddit: r/test\\n- Post Type: Text/Link/Image\\n- Flair: Discussion\\n- NSFW: No\\n\\n## Media\\n- Images: []\\n- Links: []\\n\\n## Analytics\\n- Upvotes: 0\\n- Comments: 0\\n- Awards: 0\");\n        case 'instagram':\n            return \"# \".concat(name, \" - Instagram Post\\nPlatform: Instagram\\nCreated: \").concat(new Date().toLocaleDateString(), \"\\n\\n## Post Content\\nWrite your Instagram post content here...\\n\\n## Settings\\n- Post Type: Feed/Story/Reel\\n- Location: City, Country\\n- Alt Text: Describe image\\n- Comment Settings: Public\\n\\n## Media\\n- Images: []\\n- Videos: []\\n\\n## Hashtags\\n#hashtag1 #hashtag2 #hashtag3\\n\\n## Analytics\\n- Likes: 0\\n- Comments: 0\\n- Shares: 0\\n- Reach: 0\");\n        case 'x':\n            return \"# \".concat(name, \" - X/Twitter Post\\nPlatform: X (Twitter)\\nCreated: \").concat(new Date().toLocaleDateString(), \"\\n\\n## Post Content\\nWrite your X post content here... (280 character limit)\\n\\n## Settings\\n- Reply Settings: Everyone\\n- Schedule: Now\\n- Thread: Single Tweet\\n\\n## Media\\n- Images: []\\n- Videos: []\\n- GIFs: []\\n\\n## Analytics\\n- Impressions: 0\\n- Engagements: 0\\n- Retweets: 0\\n- Likes: 0\\n- Replies: 0\");\n        default:\n            return \"# \".concat(name, \"\\n\\nThis is a new file created in the EAC Dashboard.\\nCreated on: \").concat(new Date().toISOString());\n    }\n};\n// Initial project files - empty by default, only created when needed\nconst initialProjectFiles = [];\n// Initial financial files - empty by default, only created when needed  \nconst initialFinancialFiles = [];\n// Initial project folders - only created when explicitly needed, not on storage clear\nconst initialProjectFolders = [];\nconst useEditorStore = (0,zustand__WEBPACK_IMPORTED_MODULE_10__.create)()((0,zustand_middleware__WEBPACK_IMPORTED_MODULE_11__.devtools)((set, get)=>({\n        // Initial state\n        openTabs: [],\n        activeTab: '',\n        projectFiles: initialProjectFiles,\n        financialFiles: initialFinancialFiles,\n        projectFolders: initialProjectFolders,\n        financialFolders: [],\n        trashItems: [],\n        showProjectsCategory: true,\n        showFinancialCategory: false,\n        isLoading: false,\n        error: null,\n        // Actions\n        openTab: (file)=>{\n            var _file_content, _file_content1;\n            const { openTabs } = get();\n            console.log('ðŸ” Opening tab for file:', {\n                id: file.id,\n                name: file.name,\n                contentLength: ((_file_content = file.content) === null || _file_content === void 0 ? void 0 : _file_content.length) || 0,\n                contentPreview: ((_file_content1 = file.content) === null || _file_content1 === void 0 ? void 0 : _file_content1.substring(0, 100)) || 'NO CONTENT',\n                type: file.type,\n                platform: file.platform,\n                rawContent: file.content\n            });\n            // Check if tab is already open\n            const existingTab = openTabs.find((tab)=>tab.id === file.id);\n            if (existingTab) {\n                console.log('ðŸ“‚ Tab already exists, activating:', existingTab.id);\n                // Update the existing tab content with the current file content\n                const updatedTabs = openTabs.map((tab)=>tab.id === file.id ? {\n                        ...tab,\n                        content: file.content || getDefaultContent(file.type, file.name)\n                    } : tab);\n                set({\n                    openTabs: updatedTabs,\n                    activeTab: existingTab.id\n                });\n                return;\n            }\n            // Define which file types should be auto-pinned\n            // You can add more file types here if needed\n            const autoPinFileTypes = [\n                'calendar',\n                'social-connect',\n                'user-profile',\n                'post-creator'\n            ];\n            const shouldAutoPinn = autoPinFileTypes.includes(file.type);\n            let pinnedOrder;\n            if (shouldAutoPinn) {\n                // Get the highest pinned order for auto-pinned tabs\n                const pinnedTabs = openTabs.filter((t)=>t.pinned);\n                pinnedOrder = pinnedTabs.length > 0 ? Math.max(...pinnedTabs.map((t)=>t.pinnedOrder || 0)) + 1 : 1;\n            }\n            // Create new tab with content\n            const tabContent = file.content || getDefaultContent(file.type, file.name);\n            console.log('ðŸ†• Creating new tab with content:', {\n                fileId: file.id,\n                fileName: file.name,\n                hasCustomContent: !!file.content,\n                contentLength: tabContent.length,\n                contentPreview: tabContent.substring(0, 100)\n            });\n            const newTab = {\n                id: file.id,\n                name: file.name,\n                modified: false,\n                content: tabContent,\n                filePath: file.filePath,\n                type: file.type,\n                pinned: shouldAutoPinn,\n                pinnedOrder: shouldAutoPinn ? pinnedOrder : undefined\n            };\n            let newTabs;\n            if (shouldAutoPinn) {\n                // For auto-pinned tabs, insert in correct pinned position\n                const otherTabs = [\n                    ...openTabs\n                ];\n                const insertIndex = otherTabs.filter((t)=>t.pinned && (t.pinnedOrder || 0) < (pinnedOrder || 0)).length;\n                otherTabs.splice(insertIndex, 0, newTab);\n                newTabs = otherTabs;\n            } else {\n                // For non-auto-pinned tabs, insert after all pinned tabs\n                const pinnedTabs = openTabs.filter((tab)=>tab.pinned);\n                const unpinnedTabs = openTabs.filter((tab)=>!tab.pinned);\n                newTabs = [\n                    ...pinnedTabs,\n                    ...unpinnedTabs,\n                    newTab\n                ];\n            }\n            set({\n                openTabs: newTabs,\n                activeTab: newTab.id\n            });\n        },\n        openSpecialTab: (id, name, type)=>{\n            const { openTabs } = get();\n            // Check if tab is already open\n            const existingTab = openTabs.find((tab)=>tab.id === id);\n            if (existingTab) {\n                set({\n                    activeTab: existingTab.id\n                });\n                return;\n            }\n            // Define which tab types should be auto-pinned\n            const autoPinTypes = [\n                'user-profile',\n                'calendar',\n                'social-connect',\n                'post-creator',\n                'platform-instructions',\n                'logo-generator',\n                'subscription'\n            ];\n            const shouldAutoPinn = autoPinTypes.includes(type);\n            let pinnedOrder;\n            if (shouldAutoPinn) {\n                // Get the highest pinned order for auto-pinned tabs\n                const pinnedTabs = openTabs.filter((t)=>t.pinned);\n                pinnedOrder = pinnedTabs.length > 0 ? Math.max(...pinnedTabs.map((t)=>t.pinnedOrder || 0)) + 1 : 1;\n            }\n            // Create new special tab\n            const newTab = {\n                id,\n                name,\n                modified: false,\n                content: '',\n                filePath: \"/\".concat(type),\n                type,\n                pinned: shouldAutoPinn,\n                pinnedOrder: shouldAutoPinn ? pinnedOrder : undefined\n            };\n            let newTabs;\n            if (shouldAutoPinn) {\n                // For auto-pinned tabs, insert in correct pinned position\n                const otherTabs = [\n                    ...openTabs\n                ];\n                const insertIndex = otherTabs.filter((t)=>t.pinned && (t.pinnedOrder || 0) < (pinnedOrder || 0)).length;\n                otherTabs.splice(insertIndex, 0, newTab);\n                newTabs = otherTabs;\n            } else {\n                // For non-auto-pinned tabs, insert after all pinned tabs\n                const pinnedTabs = openTabs.filter((tab)=>tab.pinned);\n                const unpinnedTabs = openTabs.filter((tab)=>!tab.pinned);\n                newTabs = [\n                    ...pinnedTabs,\n                    ...unpinnedTabs,\n                    newTab\n                ];\n            }\n            set({\n                openTabs: newTabs,\n                activeTab: newTab.id\n            });\n        },\n        closeTab: (tabId)=>{\n            const { openTabs, activeTab } = get();\n            const tabIndex = openTabs.findIndex((tab)=>tab.id === tabId);\n            if (tabIndex === -1) return;\n            const newTabs = openTabs.filter((tab)=>tab.id !== tabId);\n            let newActiveTab = activeTab;\n            // If closing the active tab, switch to another tab\n            if (activeTab === tabId) {\n                if (newTabs.length > 0) {\n                    // Switch to the tab to the right, or the last tab if closing the last one\n                    const nextIndex = tabIndex < newTabs.length ? tabIndex : newTabs.length - 1;\n                    newActiveTab = newTabs[nextIndex].id;\n                } else {\n                    newActiveTab = '';\n                }\n            }\n            set({\n                openTabs: newTabs,\n                activeTab: newActiveTab\n            });\n        },\n        closeAllTabs: ()=>{\n            set({\n                openTabs: [],\n                activeTab: ''\n            });\n        },\n        setActiveTab: (tabId)=>{\n            const { openTabs, activeTab: currentActiveTab } = get();\n            const tabExists = openTabs.some((tab)=>tab.id === tabId);\n            console.log('ðŸ”„ setActiveTab called:', {\n                newTabId: tabId,\n                currentActiveTab,\n                tabExists,\n                openTabsCount: openTabs.length,\n                availableTabs: openTabs.map((t)=>{\n                    var _t_content;\n                    return {\n                        id: t.id,\n                        name: t.name,\n                        contentLength: ((_t_content = t.content) === null || _t_content === void 0 ? void 0 : _t_content.length) || 0\n                    };\n                })\n            });\n            if (tabExists) {\n                set({\n                    activeTab: tabId\n                });\n                console.log('âœ… Active tab set to:', tabId);\n            } else {\n                console.warn('âŒ Attempted to set non-existent tab as active:', tabId);\n            }\n        },\n        reorderTabs: (fromTabId, toTabId)=>{\n            const { openTabs } = get();\n            const fromIndex = openTabs.findIndex((tab)=>tab.id === fromTabId);\n            const toIndex = openTabs.findIndex((tab)=>tab.id === toTabId);\n            if (fromIndex !== -1 && toIndex !== -1 && fromIndex !== toIndex) {\n                const newTabs = [\n                    ...openTabs\n                ];\n                const [movedTab] = newTabs.splice(fromIndex, 1);\n                newTabs.splice(toIndex, 0, movedTab);\n                set({\n                    openTabs: newTabs\n                });\n            }\n        },\n        pinTab: (tabId)=>{\n            const { openTabs } = get();\n            const tabIndex = openTabs.findIndex((tab)=>tab.id === tabId);\n            if (tabIndex !== -1) {\n                const tab = openTabs[tabIndex];\n                // Don't pin if already pinned\n                if (tab.pinned) return;\n                // Get the highest pinned order\n                const pinnedTabs = openTabs.filter((t)=>t.pinned);\n                const nextPinnedOrder = pinnedTabs.length > 0 ? Math.max(...pinnedTabs.map((t)=>t.pinnedOrder || 0)) + 1 : 1;\n                // Update the tab to be pinned\n                const updatedTab = {\n                    ...tab,\n                    pinned: true,\n                    pinnedOrder: nextPinnedOrder\n                };\n                // Remove tab from current position and add to correct pinned position\n                const newTabs = [\n                    ...openTabs\n                ];\n                newTabs.splice(tabIndex, 1);\n                // Find the correct position among pinned tabs\n                const insertIndex = newTabs.filter((t)=>t.pinned && (t.pinnedOrder || 0) < nextPinnedOrder).length;\n                newTabs.splice(insertIndex, 0, updatedTab);\n                set({\n                    openTabs: newTabs\n                });\n            }\n        },\n        unpinTab: (tabId)=>{\n            const { openTabs } = get();\n            const tabIndex = openTabs.findIndex((tab)=>tab.id === tabId);\n            if (tabIndex !== -1) {\n                const tab = openTabs[tabIndex];\n                // Don't unpin if not pinned\n                if (!tab.pinned) return;\n                // Update the tab to be unpinned\n                const updatedTab = {\n                    ...tab,\n                    pinned: false,\n                    pinnedOrder: undefined\n                };\n                // Remove tab from current position\n                const newTabs = [\n                    ...openTabs\n                ];\n                newTabs.splice(tabIndex, 1);\n                // Find the position after all pinned tabs\n                const pinnedCount = newTabs.filter((t)=>t.pinned).length;\n                newTabs.splice(pinnedCount, 0, updatedTab);\n                set({\n                    openTabs: newTabs\n                });\n            }\n        },\n        updateTabContent: (tabId, content)=>{\n            const { openTabs } = get();\n            const updatedTabs = openTabs.map((tab)=>tab.id === tabId ? {\n                    ...tab,\n                    content,\n                    modified: true\n                } : tab);\n            set({\n                openTabs: updatedTabs\n            });\n        },\n        updateFileContent: (tabId, content)=>{\n            const { openTabs } = get();\n            console.log('ðŸ“ updateFileContent called:', {\n                tabId,\n                contentLength: content.length,\n                contentPreview: content.substring(0, 100),\n                currentTabsCount: openTabs.length\n            });\n            const existingTab = openTabs.find((tab)=>tab.id === tabId);\n            if (existingTab) {\n                var _existingTab_content;\n                console.log('ðŸ“‹ Found existing tab to update:', {\n                    id: existingTab.id,\n                    name: existingTab.name,\n                    currentContentLength: ((_existingTab_content = existingTab.content) === null || _existingTab_content === void 0 ? void 0 : _existingTab_content.length) || 0,\n                    newContentLength: content.length,\n                    contentChanged: existingTab.content !== content\n                });\n            } else {\n                console.warn('âš ï¸ Tab not found for update:', tabId);\n            }\n            const updatedTabs = openTabs.map((tab)=>tab.id === tabId ? {\n                    ...tab,\n                    content,\n                    modified: true\n                } : tab);\n            console.log('âœ… Tab content update complete:', {\n                tabId,\n                updatedTabsCount: updatedTabs.length,\n                hasMatchingTab: !!updatedTabs.find((t)=>t.id === tabId)\n            });\n            set({\n                openTabs: updatedTabs\n            });\n        },\n        updateFileContentInStore: (fileId, content)=>{\n            const { projectFiles, financialFiles, openTabs } = get();\n            console.log('ðŸ”„ updateFileContentInStore called:', {\n                fileId,\n                contentLength: content.length,\n                contentPreview: content.substring(0, 100),\n                currentProjectFilesCount: projectFiles.length,\n                currentFinancialFilesCount: financialFiles.length,\n                currentOpenTabsCount: openTabs.length\n            });\n            // Find the file to see current state\n            const existingProjectFile = projectFiles.find((f)=>f.id === fileId);\n            const existingFinancialFile = financialFiles.find((f)=>f.id === fileId);\n            const existingFile = existingProjectFile || existingFinancialFile;\n            if (existingFile) {\n                var _existingFile_content;\n                console.log('ðŸ“„ Found existing file:', {\n                    id: existingFile.id,\n                    name: existingFile.name,\n                    currentContentLength: ((_existingFile_content = existingFile.content) === null || _existingFile_content === void 0 ? void 0 : _existingFile_content.length) || 0,\n                    newContentLength: content.length,\n                    contentChanged: existingFile.content !== content\n                });\n            } else {\n                console.warn('âš ï¸ File not found in store:', fileId);\n            }\n            // Update the file in the appropriate store\n            const updatedProjectFiles = projectFiles.map((file)=>file.id === fileId ? {\n                    ...file,\n                    content,\n                    modifiedAt: new Date()\n                } : file);\n            const updatedFinancialFiles = financialFiles.map((file)=>file.id === fileId ? {\n                    ...file,\n                    content,\n                    modifiedAt: new Date()\n                } : file);\n            // Also update the tab if it's open\n            const existingTab = openTabs.find((tab)=>tab.id === fileId);\n            if (existingTab) {\n                var _existingTab_content;\n                console.log('ðŸ“‹ Updating existing tab:', {\n                    tabId: fileId,\n                    tabName: existingTab.name,\n                    currentTabContentLength: ((_existingTab_content = existingTab.content) === null || _existingTab_content === void 0 ? void 0 : _existingTab_content.length) || 0,\n                    newContentLength: content.length,\n                    tabContentChanged: existingTab.content !== content\n                });\n            }\n            const updatedTabs = openTabs.map((tab)=>tab.id === fileId ? {\n                    ...tab,\n                    content,\n                    modified: true\n                } : tab);\n            console.log('âœ… Store update complete:', {\n                fileId,\n                projectFilesUpdated: updatedProjectFiles.length,\n                financialFilesUpdated: updatedFinancialFiles.length,\n                tabsUpdated: updatedTabs.length,\n                hasMatchingTab: !!updatedTabs.find((t)=>t.id === fileId)\n            });\n            set({\n                projectFiles: updatedProjectFiles,\n                financialFiles: updatedFinancialFiles,\n                openTabs: updatedTabs\n            });\n        },\n        updateFileStatus: (fileId, status)=>{\n            const { projectFiles, financialFiles, openTabs } = get();\n            console.log('ðŸ”„ updateFileStatus called:', {\n                fileId,\n                status,\n                projectFilesCount: projectFiles.length,\n                allProjectFileIds: projectFiles.map((f)=>({\n                        id: f.id,\n                        name: f.name,\n                        currentStatus: f.status\n                    }))\n            });\n            // Update in project files\n            const updatedProjectFiles = projectFiles.map((file)=>file.id === fileId ? {\n                    ...file,\n                    status,\n                    modifiedAt: new Date()\n                } : file);\n            // Check if any file was actually updated by id\n            let updatedFile = updatedProjectFiles.find((f)=>f.id === fileId);\n            console.log('ðŸ“ File status update result:', {\n                fileId,\n                newStatus: status,\n                foundFile: !!updatedFile,\n                updatedFileStatus: updatedFile === null || updatedFile === void 0 ? void 0 : updatedFile.status,\n                wasChanged: (updatedFile === null || updatedFile === void 0 ? void 0 : updatedFile.status) === status\n            });\n            // Fallback: if not found by id, attempt match by file name from open tab\n            if (!updatedFile) {\n                const tab = openTabs.find((t)=>t.id === fileId);\n                if (tab) {\n                    const matchedByNameIndex = updatedProjectFiles.findIndex((f)=>f.name === tab.name);\n                    if (matchedByNameIndex !== -1) {\n                        const byName = updatedProjectFiles[matchedByNameIndex];\n                        updatedProjectFiles[matchedByNameIndex] = {\n                            ...byName,\n                            status,\n                            modifiedAt: new Date()\n                        };\n                        updatedFile = updatedProjectFiles[matchedByNameIndex];\n                        console.log('ðŸ§© Fallback status update by name:', {\n                            name: tab.name,\n                            status\n                        });\n                    }\n                }\n            }\n            // Update in financial files\n            const updatedFinancialFiles = financialFiles.map((file)=>file.id === fileId ? {\n                    ...file,\n                    status,\n                    modifiedAt: new Date()\n                } : file);\n            set({\n                projectFiles: updatedProjectFiles,\n                financialFiles: updatedFinancialFiles\n            });\n        },\n        updateFileConvexId: (fileId, convexId)=>{\n            const { projectFiles, financialFiles } = get();\n            // Update in project files\n            const updatedProjectFiles = projectFiles.map((file)=>file.id === fileId ? {\n                    ...file,\n                    convexId,\n                    modifiedAt: new Date()\n                } : file);\n            // Update in financial files\n            const updatedFinancialFiles = financialFiles.map((file)=>file.id === fileId ? {\n                    ...file,\n                    convexId,\n                    modifiedAt: new Date()\n                } : file);\n            set({\n                projectFiles: updatedProjectFiles,\n                financialFiles: updatedFinancialFiles\n            });\n        },\n        updateFolderConvexId: (folderId, convexId)=>{\n            const { projectFolders, financialFolders } = get();\n            // Update in project folders\n            const updatedProjectFolders = projectFolders.map((folder)=>folder.id === folderId ? {\n                    ...folder,\n                    convexId\n                } : folder);\n            // Update in financial folders\n            const updatedFinancialFolders = financialFolders.map((folder)=>folder.id === folderId ? {\n                    ...folder,\n                    convexId\n                } : folder);\n            set({\n                projectFolders: updatedProjectFolders,\n                financialFolders: updatedFinancialFolders\n            });\n        },\n        createNewFile: function(name, type) {\n            let category = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 'project', folderId = arguments.length > 3 ? arguments[3] : void 0, customContent = arguments.length > 4 ? arguments[4] : void 0, skipSync = arguments.length > 5 ? arguments[5] : void 0;\n            var _newFile_content;\n            const { projectFiles, financialFiles } = get();\n            console.log('ðŸ”§ createNewFile called with:', {\n                name,\n                type,\n                category,\n                folderId,\n                hasCustomContent: !!customContent,\n                customContentLength: (customContent === null || customContent === void 0 ? void 0 : customContent.length) || 0,\n                customContentPreview: (customContent === null || customContent === void 0 ? void 0 : customContent.substring(0, 100)) || 'NO CUSTOM CONTENT'\n            });\n            // Generate unique ID\n            const id = \"\".concat(name.toLowerCase().replace(/[^a-z0-9]/g, '-'), \"-\").concat(Date.now());\n            const fileName = \"\".concat(name).concat(getFileExtension(type));\n            const basePath = category === 'financial' ? '/financial-data' : '/eac-projects';\n            // Use custom content if provided, otherwise use default\n            const fileContent = customContent || getDefaultContent(type, name);\n            console.log('ðŸ“„ Final file content:', {\n                fileName,\n                contentLength: fileContent.length,\n                contentPreview: fileContent.substring(0, 100),\n                isCustom: !!customContent\n            });\n            // Create new file\n            const newFile = {\n                id,\n                name: fileName,\n                icon: getFileIcon(type),\n                type,\n                category,\n                content: fileContent,\n                filePath: \"\".concat(basePath, \"/\").concat(fileName),\n                createdAt: new Date(),\n                modifiedAt: new Date(),\n                folderId,\n                status: [\n                    'facebook',\n                    'reddit',\n                    'instagram',\n                    'x'\n                ].includes(type) ? 'draft' : undefined\n            };\n            // Add to appropriate file array and ensure category is visible\n            if (category === 'financial') {\n                set({\n                    financialFiles: [\n                        ...financialFiles,\n                        newFile\n                    ],\n                    showFinancialCategory: true\n                });\n            } else {\n                set({\n                    projectFiles: [\n                        ...projectFiles,\n                        newFile\n                    ],\n                    showProjectsCategory: true\n                });\n            }\n            console.log('ðŸ“ File added to store, about to open tab:', {\n                fileId: id,\n                fileName: fileName,\n                contentLength: ((_newFile_content = newFile.content) === null || _newFile_content === void 0 ? void 0 : _newFile_content.length) || 0,\n                hasContent: !!newFile.content\n            });\n            // Automatically open the new file with a small delay to ensure state is set\n            setTimeout(()=>{\n                console.log('â° Opening tab after timeout for file:', id);\n                get().openTab(newFile);\n            }, 10);\n            console.log('âœ… Tab will open for new file:', {\n                fileId: id,\n                fileName: fileName\n            });\n            // Save to Convex database (async - don't block UI)\n            // Skip if this is a sync operation to prevent loops\n            if (!skipSync) {\n                try {\n                    // TEMPORARILY DISABLED TO STOP INFINITE LOOP\n                    console.log('ðŸš« TEMPORARILY DISABLED: File created locally (not dispatching event):', newFile);\n                // Get the folder's convex ID if available\n                // let projectId = null;\n                // if (folderId) {\n                //   const { projectFolders, financialFolders } = get();\n                //   const allFolders = [...projectFolders, ...financialFolders];\n                //   const folder = allFolders.find(f => f.id === folderId);\n                //   projectId = folder?.convexId || null;\n                // }\n                // Dispatch custom event that components can listen to\n                // TEMPORARILY DISABLED TO STOP INFINITE LOOP\n                // if (typeof window !== 'undefined') {\n                //   window.dispatchEvent(new CustomEvent('fileCreated', { \n                //     detail: { \n                //       file: newFile,\n                //       projectId: projectId // Use folder's convexId if available\n                //     } \n                //   }));\n                // }\n                } catch (error) {\n                    console.error('Failed to save file to database:', error);\n                }\n            } else {\n                console.log('ðŸ”„ File created from sync, skipping database save:', newFile.name);\n            }\n            // Return the file ID so caller can reference it\n            return id;\n        },\n        createFolder: (name, category, convexId)=>{\n            const { projectFolders, financialFolders, updateFolderConvexId } = get();\n            // Check if folder with this name already exists\n            const existingFolders = category === 'financial' ? financialFolders : projectFolders;\n            const existingFolder = existingFolders.find((folder)=>folder.name.toLowerCase() === name.toLowerCase());\n            if (existingFolder) {\n                // If folder exists but doesn't have a convexId, update it\n                if (convexId && !existingFolder.convexId) {\n                    console.log('Updating existing folder \"'.concat(name, '\" with Convex ID: ').concat(convexId));\n                    updateFolderConvexId(existingFolder.id, convexId);\n                } else {\n                    console.log('Folder \"'.concat(name, '\" already exists in ').concat(category, \" category, skipping creation\"));\n                }\n                return;\n            }\n            // Generate truly unique ID using crypto if available, otherwise fallback to timestamp + random\n            let uniqueId;\n            if (typeof crypto !== 'undefined' && crypto.randomUUID) {\n                uniqueId = \"folder-\".concat(name.toLowerCase().replace(/[^a-z0-9]/g, '-'), \"-\").concat(crypto.randomUUID());\n            } else {\n                // Fallback for environments without crypto.randomUUID\n                const timestamp = Date.now();\n                const random = Math.random().toString(36).substring(2, 12);\n                const counter = Math.floor(Math.random() * 10000);\n                uniqueId = \"folder-\".concat(name.toLowerCase().replace(/[^a-z0-9]/g, '-'), \"-\").concat(timestamp, \"-\").concat(random, \"-\").concat(counter);\n            }\n            // Double-check uniqueness against all existing folder IDs\n            const allFolders = [\n                ...projectFolders,\n                ...financialFolders\n            ];\n            while(allFolders.some((folder)=>folder.id === uniqueId)){\n                const randomSuffix = Math.random().toString(36).substring(2, 8);\n                uniqueId = \"\".concat(uniqueId, \"-\").concat(randomSuffix);\n            }\n            // Create new folder\n            const newFolder = {\n                id: uniqueId,\n                name,\n                category,\n                createdAt: new Date(),\n                convexId\n            };\n            // Add to appropriate folder array and ensure category is visible\n            if (category === 'financial') {\n                set({\n                    financialFolders: [\n                        newFolder,\n                        ...financialFolders\n                    ],\n                    showFinancialCategory: true\n                });\n            } else {\n                set({\n                    projectFolders: [\n                        newFolder,\n                        ...projectFolders\n                    ],\n                    showProjectsCategory: true\n                });\n            }\n        },\n        // Emergency cleanup function for duplicate folder IDs\n        cleanupDuplicateFolders: ()=>{\n            const { projectFolders, financialFolders } = get();\n            // Function to remove duplicates and fix bad IDs\n            const cleanupFolders = (folders)=>{\n                const seen = new Set();\n                const cleaned = folders.filter((folder)=>{\n                    // Remove folders with the problematic key pattern\n                    if (folder.id.includes('folder-index-1753064508939')) {\n                        console.log(\"\\uD83E\\uDDF9 Removing problematic folder: \".concat(folder.id, \" (\").concat(folder.name, \")\"));\n                        return false;\n                    }\n                    // Remove duplicate IDs\n                    if (seen.has(folder.id)) {\n                        console.log(\"\\uD83E\\uDDF9 Removing duplicate folder: \".concat(folder.id, \" (\").concat(folder.name, \")\"));\n                        return false;\n                    }\n                    seen.add(folder.id);\n                    return true;\n                });\n                // Regenerate IDs for any remaining folders with old patterns\n                return cleaned.map((folder)=>{\n                    if (folder.id.startsWith('folder-index-') || folder.id.length < 20) {\n                        const newId = typeof crypto !== 'undefined' && crypto.randomUUID ? \"folder-\".concat(folder.name.toLowerCase().replace(/[^a-z0-9]/g, '-'), \"-\").concat(crypto.randomUUID()) : \"folder-\".concat(folder.name.toLowerCase().replace(/[^a-z0-9]/g, '-'), \"-\").concat(Date.now(), \"-\").concat(Math.random().toString(36).substring(2, 12));\n                        console.log(\"\\uD83D\\uDD04 Regenerating ID for folder: \".concat(folder.id, \" â†’ \").concat(newId, \" (\").concat(folder.name, \")\"));\n                        return {\n                            ...folder,\n                            id: newId\n                        };\n                    }\n                    return folder;\n                });\n            };\n            const cleanedProjectFolders = cleanupFolders(projectFolders);\n            const cleanedFinancialFolders = cleanupFolders(financialFolders);\n            if (cleanedProjectFolders.length !== projectFolders.length || cleanedFinancialFolders.length !== financialFolders.length) {\n                console.log('ðŸ§¹ Cleanup completed, updating store...');\n                set({\n                    projectFolders: cleanedProjectFolders,\n                    financialFolders: cleanedFinancialFolders\n                });\n            }\n        },\n        deleteFile: (fileId)=>{\n            const { projectFiles, financialFiles, openTabs } = get();\n            // Find and remove from appropriate array\n            const updatedProjectFiles = projectFiles.filter((file)=>file.id !== fileId);\n            const updatedFinancialFiles = financialFiles.filter((file)=>file.id !== fileId);\n            // Close tab if it's open\n            const tabToClose = openTabs.find((tab)=>tab.id === fileId);\n            if (tabToClose) {\n                get().closeTab(fileId);\n            }\n            set({\n                projectFiles: updatedProjectFiles,\n                financialFiles: updatedFinancialFiles\n            });\n        },\n        renameFile: (fileId, newName)=>{\n            const { projectFiles, financialFiles, openTabs } = get();\n            // Find the file to get its type and generate new filename with extension\n            const projectFile = projectFiles.find((file)=>file.id === fileId);\n            const financialFile = financialFiles.find((file)=>file.id === fileId);\n            const file = projectFile || financialFile;\n            if (!file) return;\n            // Generate new filename with appropriate extension\n            const newFileName = \"\".concat(newName).concat(getFileExtension(file.type));\n            const basePath = file.category === 'financial' ? '/financial-data' : '/eac-projects';\n            const newFilePath = \"\".concat(basePath, \"/\").concat(newFileName);\n            // Update the file in appropriate array\n            const updatedProjectFiles = projectFiles.map((f)=>f.id === fileId ? {\n                    ...f,\n                    name: newFileName,\n                    filePath: newFilePath,\n                    modifiedAt: new Date()\n                } : f);\n            const updatedFinancialFiles = financialFiles.map((f)=>f.id === fileId ? {\n                    ...f,\n                    name: newFileName,\n                    filePath: newFilePath,\n                    modifiedAt: new Date()\n                } : f);\n            // Update open tabs if the file is open\n            const updatedTabs = openTabs.map((tab)=>tab.id === fileId ? {\n                    ...tab,\n                    name: newFileName,\n                    filePath: newFilePath,\n                    modified: true\n                } : tab);\n            set({\n                projectFiles: updatedProjectFiles,\n                financialFiles: updatedFinancialFiles,\n                openTabs: updatedTabs\n            });\n        },\n        renameFolder: (folderId, newName)=>{\n            const { projectFolders, financialFolders } = get();\n            // Update the folder in appropriate array\n            const updatedProjectFolders = projectFolders.map((folder)=>folder.id === folderId ? {\n                    ...folder,\n                    name: newName\n                } : folder);\n            const updatedFinancialFolders = financialFolders.map((folder)=>folder.id === folderId ? {\n                    ...folder,\n                    name: newName\n                } : folder);\n            set({\n                projectFolders: updatedProjectFolders,\n                financialFolders: updatedFinancialFolders\n            });\n        },\n        deleteFolder: (folderId)=>{\n            const { projectFolders, financialFolders, projectFiles, financialFiles, openTabs } = get();\n            // Find all files that were in this folder\n            const filesToDelete = [\n                ...projectFiles.filter((file)=>file.folderId === folderId),\n                ...financialFiles.filter((file)=>file.folderId === folderId)\n            ];\n            // Close tabs for all files in this folder\n            filesToDelete.forEach((file)=>{\n                const tabToClose = openTabs.find((tab)=>tab.id === file.id);\n                if (tabToClose) {\n                    get().closeTab(file.id);\n                }\n            });\n            // Remove from appropriate folder array\n            const updatedProjectFolders = projectFolders.filter((folder)=>folder.id !== folderId);\n            const updatedFinancialFolders = financialFolders.filter((folder)=>folder.id !== folderId);\n            // Also remove any files that were in this folder\n            const updatedProjectFiles = projectFiles.filter((file)=>file.folderId !== folderId);\n            const updatedFinancialFiles = financialFiles.filter((file)=>file.folderId !== folderId);\n            set({\n                projectFolders: updatedProjectFolders,\n                financialFolders: updatedFinancialFolders,\n                projectFiles: updatedProjectFiles,\n                financialFiles: updatedFinancialFiles\n            });\n        },\n        moveToTrash: (item, type)=>{\n            const { trashItems, projectFiles, financialFiles, projectFolders, financialFolders, openTabs } = get();\n            // Create trash item\n            const trashItem = {\n                id: \"trash_\".concat(item.id, \"_\").concat(Date.now()),\n                name: item.name,\n                type,\n                originalData: item,\n                deletedAt: new Date(),\n                category: item.category\n            };\n            if (type === 'file') {\n                const file = item;\n                // Close tab if it's open\n                const tabToClose = openTabs.find((tab)=>tab.id === file.id);\n                if (tabToClose) {\n                    get().closeTab(file.id);\n                }\n                // Remove from appropriate file array\n                const updatedProjectFiles = projectFiles.filter((f)=>f.id !== file.id);\n                const updatedFinancialFiles = financialFiles.filter((f)=>f.id !== file.id);\n                set({\n                    trashItems: [\n                        ...trashItems,\n                        trashItem\n                    ],\n                    projectFiles: updatedProjectFiles,\n                    financialFiles: updatedFinancialFiles\n                });\n            } else {\n                const folder = item;\n                // Find all files that were in this folder and move them to trash too\n                const filesToTrash = [\n                    ...projectFiles.filter((file)=>file.folderId === folder.id),\n                    ...financialFiles.filter((file)=>file.folderId === folder.id)\n                ];\n                // Close tabs for all files in this folder\n                filesToTrash.forEach((file)=>{\n                    const tabToClose = openTabs.find((tab)=>tab.id === file.id);\n                    if (tabToClose) {\n                        get().closeTab(file.id);\n                    }\n                });\n                // Create trash items for all files in the folder\n                const fileTrashItems = filesToTrash.map((file)=>({\n                        id: \"trash_\".concat(file.id, \"_\").concat(Date.now()),\n                        name: file.name,\n                        type: 'file',\n                        originalData: file,\n                        deletedAt: new Date(),\n                        category: file.category\n                    }));\n                // Remove folder and its files from arrays\n                const updatedProjectFolders = projectFolders.filter((f)=>f.id !== folder.id);\n                const updatedFinancialFolders = financialFolders.filter((f)=>f.id !== folder.id);\n                const updatedProjectFiles = projectFiles.filter((file)=>file.folderId !== folder.id);\n                const updatedFinancialFiles = financialFiles.filter((file)=>file.folderId !== folder.id);\n                set({\n                    trashItems: [\n                        ...trashItems,\n                        trashItem,\n                        ...fileTrashItems\n                    ],\n                    projectFolders: updatedProjectFolders,\n                    financialFolders: updatedFinancialFolders,\n                    projectFiles: updatedProjectFiles,\n                    financialFiles: updatedFinancialFiles\n                });\n            }\n        },\n        restoreFromTrash: (trashItemId)=>{\n            const { trashItems, projectFiles, financialFiles, projectFolders, financialFolders } = get();\n            const trashItem = trashItems.find((item)=>item.id === trashItemId);\n            if (!trashItem) return;\n            // Remove from trash\n            const updatedTrashItems = trashItems.filter((item)=>item.id !== trashItemId);\n            // Restore to appropriate array\n            if (trashItem.type === 'file') {\n                const file = trashItem.originalData;\n                if (file.category === 'project') {\n                    set({\n                        trashItems: updatedTrashItems,\n                        projectFiles: [\n                            ...projectFiles,\n                            {\n                                ...file,\n                                modifiedAt: new Date()\n                            }\n                        ]\n                    });\n                } else {\n                    set({\n                        trashItems: updatedTrashItems,\n                        financialFiles: [\n                            ...financialFiles,\n                            {\n                                ...file,\n                                modifiedAt: new Date()\n                            }\n                        ]\n                    });\n                }\n            } else {\n                const folder = trashItem.originalData;\n                if (folder.category === 'project') {\n                    set({\n                        trashItems: updatedTrashItems,\n                        projectFolders: [\n                            ...projectFolders,\n                            folder\n                        ]\n                    });\n                } else {\n                    set({\n                        trashItems: updatedTrashItems,\n                        financialFolders: [\n                            ...financialFolders,\n                            folder\n                        ]\n                    });\n                }\n            }\n        },\n        permanentlyDelete: (trashItemId)=>{\n            const { trashItems } = get();\n            // Remove from trash permanently\n            const updatedTrashItems = trashItems.filter((item)=>item.id !== trashItemId);\n            set({\n                trashItems: updatedTrashItems\n            });\n        },\n        emptyTrash: ()=>{\n            set({\n                trashItems: []\n            });\n        },\n        clearProjectCategory: ()=>{\n            const { openTabs } = get();\n            // Close all project-related tabs\n            const projectTabIds = openTabs.filter((tab)=>{\n                // Find the corresponding file to check its category\n                const { projectFiles } = get();\n                const file = projectFiles.find((f)=>f.id === tab.id);\n                return (file === null || file === void 0 ? void 0 : file.category) === 'project';\n            }).map((tab)=>tab.id);\n            projectTabIds.forEach((tabId)=>get().closeTab(tabId));\n            // Clear all project files and folders\n            set({\n                projectFiles: [],\n                projectFolders: []\n            });\n        },\n        clearFinancialCategory: ()=>{\n            const { openTabs } = get();\n            // Close all financial-related tabs\n            const financialTabIds = openTabs.filter((tab)=>{\n                // Find the corresponding file to check its category\n                const { financialFiles } = get();\n                const file = financialFiles.find((f)=>f.id === tab.id);\n                return (file === null || file === void 0 ? void 0 : file.category) === 'financial';\n            }).map((tab)=>tab.id);\n            financialTabIds.forEach((tabId)=>get().closeTab(tabId));\n            // Clear all financial files and folders\n            set({\n                financialFiles: [],\n                financialFolders: []\n            });\n        },\n        deleteProjectsCategory: ()=>{\n            get().clearProjectCategory();\n            set({\n                showProjectsCategory: false\n            });\n        },\n        deleteFinancialCategory: ()=>{\n            get().clearFinancialCategory();\n            set({\n                showFinancialCategory: false\n            });\n        },\n        reorderProjectFolders: (fromIndex, toIndex)=>{\n            const { projectFolders } = get();\n            const newFolders = [\n                ...projectFolders\n            ];\n            const [movedFolder] = newFolders.splice(fromIndex, 1);\n            newFolders.splice(toIndex, 0, movedFolder);\n            set({\n                projectFolders: newFolders\n            });\n        },\n        updateProjectFolders: (folders)=>{\n            set({\n                projectFolders: folders\n            });\n        },\n        reorderFilesInFolder: (folderId, fromIndex, toIndex, category)=>{\n            const { projectFiles, financialFiles } = get();\n            if (category === 'project') {\n                // Filter files in the specific folder\n                const folderFiles = projectFiles.filter((file)=>file.folderId === folderId);\n                const otherFiles = projectFiles.filter((file)=>file.folderId !== folderId);\n                // Reorder files within the folder\n                const reorderedFolderFiles = [\n                    ...folderFiles\n                ];\n                const [movedFile] = reorderedFolderFiles.splice(fromIndex, 1);\n                reorderedFolderFiles.splice(toIndex, 0, movedFile);\n                // Combine with other files\n                const newProjectFiles = [\n                    ...otherFiles,\n                    ...reorderedFolderFiles\n                ];\n                set({\n                    projectFiles: newProjectFiles\n                });\n            } else {\n                // Similar logic for financial files\n                const folderFiles = financialFiles.filter((file)=>file.folderId === folderId);\n                const otherFiles = financialFiles.filter((file)=>file.folderId !== folderId);\n                const reorderedFolderFiles = [\n                    ...folderFiles\n                ];\n                const [movedFile] = reorderedFolderFiles.splice(fromIndex, 1);\n                reorderedFolderFiles.splice(toIndex, 0, movedFile);\n                const newFinancialFiles = [\n                    ...otherFiles,\n                    ...reorderedFolderFiles\n                ];\n                set({\n                    financialFiles: newFinancialFiles\n                });\n            }\n        },\n        saveFile: (tabId)=>{\n            const { openTabs, projectFiles, financialFiles } = get();\n            const tab = openTabs.find((t)=>t.id === tabId);\n            if (!tab) return;\n            // Update the file content in appropriate array\n            const updatedProjectFiles = projectFiles.map((file)=>file.id === tabId ? {\n                    ...file,\n                    content: tab.content,\n                    modifiedAt: new Date()\n                } : file);\n            const updatedFinancialFiles = financialFiles.map((file)=>file.id === tabId ? {\n                    ...file,\n                    content: tab.content,\n                    modifiedAt: new Date()\n                } : file);\n            const updatedTabs = openTabs.map((t)=>t.id === tabId ? {\n                    ...t,\n                    modified: false\n                } : t);\n            set({\n                projectFiles: updatedProjectFiles,\n                financialFiles: updatedFinancialFiles,\n                openTabs: updatedTabs\n            });\n        },\n        setError: (error)=>{\n            set({\n                error\n            });\n        },\n        // Fix files that don't have content\n        repairFilesWithoutContent: ()=>{\n            const { projectFiles, financialFiles } = get();\n            const repairedProjectFiles = projectFiles.map((file)=>{\n                if (!file.content || file.content.trim() === '') {\n                    return {\n                        ...file,\n                        content: getDefaultContent(file.type, file.name),\n                        modifiedAt: new Date()\n                    };\n                }\n                return file;\n            });\n            const repairedFinancialFiles = financialFiles.map((file)=>{\n                if (!file.content || file.content.trim() === '') {\n                    return {\n                        ...file,\n                        content: getDefaultContent(file.type, file.name),\n                        modifiedAt: new Date()\n                    };\n                }\n                return file;\n            });\n            set({\n                projectFiles: repairedProjectFiles,\n                financialFiles: repairedFinancialFiles\n            });\n        },\n        reset: ()=>{\n            set({\n                openTabs: [],\n                activeTab: '',\n                projectFiles: initialProjectFiles,\n                financialFiles: initialFinancialFiles,\n                projectFolders: [],\n                financialFolders: [],\n                showProjectsCategory: true,\n                showFinancialCategory: false,\n                isLoading: false,\n                error: null\n            });\n        },\n        // Clear user data when signing out (but keep UI state like theme, etc.)\n        clearUserData: ()=>{\n            set({\n                openTabs: [],\n                activeTab: '',\n                projectFiles: [],\n                financialFiles: [],\n                projectFolders: [],\n                financialFolders: [],\n                trashItems: [],\n                showProjectsCategory: true,\n                showFinancialCategory: false\n            });\n        },\n        // Debug function to help troubleshoot file persistence issues\n        debugStorage: ()=>{\n            const state = get();\n            console.log('ðŸ” Current store state:', {\n                projectFiles: state.projectFiles.length,\n                financialFiles: state.financialFiles.length,\n                projectFolders: state.projectFolders.length,\n                financialFolders: state.financialFolders.length,\n                trashItems: state.trashItems.length,\n                openTabs: state.openTabs.length,\n                activeTab: state.activeTab,\n                showProjectsCategory: state.showProjectsCategory,\n                showFinancialCategory: state.showFinancialCategory\n            });\n            if (state.projectFiles.length > 0) {\n                console.log('ðŸ“ Project files:');\n                state.projectFiles.forEach((file, index)=>{\n                    console.log(\"  \".concat(index + 1, \". \").concat(file.name, \" (\").concat(file.type, \") - Created: \").concat(file.createdAt));\n                });\n            }\n            if (state.financialFiles.length > 0) {\n                console.log('ðŸ’° Financial files:');\n                state.financialFiles.forEach((file, index)=>{\n                    console.log(\"  \".concat(index + 1, \". \").concat(file.name, \" (\").concat(file.type, \") - Created: \").concat(file.createdAt));\n                });\n            }\n            // Check localStorage\n            if ( true && window.localStorage) {\n                const stored = localStorage.getItem('editor-storage');\n                if (stored) {\n                    var _parsed_state_projectFiles, _parsed_state, _parsed_state_financialFiles, _parsed_state1;\n                    const parsed = JSON.parse(stored);\n                    console.log('ðŸ’¾ Stored state:', {\n                        projectFiles: ((_parsed_state = parsed.state) === null || _parsed_state === void 0 ? void 0 : (_parsed_state_projectFiles = _parsed_state.projectFiles) === null || _parsed_state_projectFiles === void 0 ? void 0 : _parsed_state_projectFiles.length) || 0,\n                        financialFiles: ((_parsed_state1 = parsed.state) === null || _parsed_state1 === void 0 ? void 0 : (_parsed_state_financialFiles = _parsed_state1.financialFiles) === null || _parsed_state_financialFiles === void 0 ? void 0 : _parsed_state_financialFiles.length) || 0,\n                        version: parsed.version\n                    });\n                } else {\n                    console.log('âŒ No data in localStorage');\n                }\n            }\n        },\n        // Emergency function to clear all storage and reset to initial state\n        clearStorage: ()=>{\n            console.log('ðŸ§¹ Clearing all storage and resetting to initial state...');\n            // Clear localStorage\n            if ( true && window.localStorage) {\n                localStorage.removeItem('editor-storage');\n                console.log('âœ… localStorage cleared');\n            }\n            // Reset store to initial state\n            set({\n                openTabs: [],\n                activeTab: '',\n                projectFiles: [],\n                financialFiles: [],\n                projectFolders: [],\n                financialFolders: [],\n                trashItems: [],\n                showProjectsCategory: true,\n                showFinancialCategory: false,\n                isLoading: false,\n                error: null\n            });\n            console.log('âœ… Store reset to initial state');\n            console.log('ðŸ”„ Please refresh the page to complete the reset');\n        },\n        // Replace project files with database files (for aggressive sync)\n        replaceWithDatabaseFiles: (databaseFiles)=>{\n            console.log('ðŸ”„ Replacing local project files with database files...');\n            console.log(\"\\uD83D\\uDCC1 Replacing \".concat(get().projectFiles.length, \" local files with \").concat(databaseFiles.length, \" database files\"));\n            set({\n                projectFiles: databaseFiles,\n                showProjectsCategory: databaseFiles.length > 0\n            });\n            console.log('âœ… Project files replaced with database files');\n        }\n    }), {\n    name: 'editor-store'\n}));\n// Make store available globally for debugging\nif (true) {\n    window.useEditorStore = useEditorStore;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3N0b3JlL2VkaXRvci9pbmRleC50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsZUFBZTtBQUNmLDZEQUE2RDtBQUU2RTtBQUN6RztBQUNhO0FBRzlDLGlEQUFpRDtBQUNqRCxNQUFNWSxjQUFjLENBQUNDO0lBQ25CLE9BQVFBO1FBQ04sS0FBSztZQUNILE9BQU9ULDZLQUFRQTtRQUNqQixLQUFLO1lBQ0gsT0FBT0EsNktBQVFBO1FBQ2pCLEtBQUs7WUFDSCxPQUFPSCw2S0FBTUE7UUFDZixLQUFLO1lBQ0gsT0FBT0ksNktBQWVBO1FBQ3hCLEtBQUs7WUFDSCxPQUFPQyw2S0FBUUE7UUFDakIsS0FBSztZQUNILE9BQU9DLDZLQUFRQTtRQUNqQixLQUFLO1lBQ0gsT0FBT0QsNktBQVFBO1FBQ2pCLEtBQUs7WUFDSCxPQUFPRCw2S0FBZUE7UUFDeEIsS0FBSztZQUNILE9BQU9BLDZLQUFlQTtRQUN4QixLQUFLO1lBQ0gsT0FBT0EsNktBQWVBO1FBQ3hCLEtBQUs7WUFDSCxPQUFPSSw2S0FBYUE7UUFDdEIsS0FBSztZQUNILE9BQU8sTUFBTSwrQkFBK0I7UUFDOUMsS0FBSztZQUNILE9BQU9OLDZLQUFNQTtRQUNmLEtBQUs7WUFDSCxPQUFPSCw2S0FBTUE7UUFDZixLQUFLO1lBQ0gsT0FBT0UsNktBQVFBO1FBQ2pCLEtBQUs7WUFDSCxPQUFPTSw2S0FBVUE7UUFDbkI7WUFDRSxPQUFPSiw2S0FBUUE7SUFDbkI7QUFDRjtBQUVBLHdDQUF3QztBQUN4Qyx3Q0FBd0M7QUFDeEMsTUFBTVUsbUJBQW1CLENBQUNEO0lBQ3hCLE9BQVFBO1FBQ04sS0FBSztZQUNILE9BQU87UUFDVCxLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7WUFDSCxPQUFPO1FBQ1QsS0FBSztZQUNILE9BQU87UUFDVCxLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7WUFDSCxPQUFPO1FBQ1QsS0FBSztZQUNILE9BQU87UUFDVCxLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7WUFDSCxPQUFPO1FBQ1QsS0FBSztZQUNILE9BQU87UUFDVCxLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7WUFDSCxPQUFPO1FBQ1QsS0FBSztZQUNILE9BQU87UUFDVCxLQUFLO1lBQ0gsT0FBTztRQUNUO1lBQ0UsT0FBTztJQUNYO0FBQ0Y7QUFFQSw0REFBNEQ7QUFDNUQsTUFBTUUsb0JBQW9CLENBQUNGLE1BQTJCRztJQUNwRCxPQUFRSDtRQUNOLEtBQUs7WUFDSCxPQUFPLE1BS0RHLE9BTE9BLE1BQUssbUZBU05BLE9BSk5BLEtBQUtDLE9BQU8sQ0FBQyxpQkFBaUIsS0FBSSwwREFJY0QsT0FBMUNBLEtBQUtDLE9BQU8sQ0FBQyxpQkFBaUIsS0FBSSxVQUdLRCxPQUhHQSxLQUFLQyxPQUFPLENBQUMsaUJBQWlCLEtBQUksNEdBR2hDLE9BQUxELE1BQUs7UUFLMUQsS0FBSztZQUNILE9BQU8sTUFHS0EsT0FIQ0EsTUFBSywyREFLR0EsT0FGVEEsS0FBS0MsT0FBTyxDQUFDLGlCQUFpQixLQUFJLCtDQUVwQixPQUFMRCxNQUFLO1FBSTVCLEtBQUs7WUFDSCxPQUFPLGlCQUNLLE9BQUxBLE1BQUs7UUFLZCxLQUFLO1lBQ0gsT0FBUTtRQUNWLEtBQUs7WUFDSCxPQUFPLE1BRUksT0FGRUEsTUFBSyw0SEFJYkEsT0FGTSxJQUFJRSxPQUFPQyxXQUFXLElBQUcsaUJBSS9CLE9BRkFILE1BQUssK0JBRTJCLE9BQWhDLElBQUlFLE9BQU9FLGtCQUFrQixJQUFHO1FBR3ZDLEtBQUs7WUFDSCxPQUFPLE1BRUksT0FGRUosTUFBSyx3R0FJYkEsT0FGTSxJQUFJRSxPQUFPQyxXQUFXLElBQUcsaUJBSS9CLE9BRkFILE1BQUssK0NBRTJCLE9BQWhDLElBQUlFLE9BQU9FLGtCQUFrQixJQUFHO1FBR3ZDLEtBQUs7WUFDSCxPQUFPLE1BRUksT0FGRUosTUFBSyxrR0FJYkEsT0FGTSxJQUFJRSxPQUFPQyxXQUFXLElBQUcsaUJBSS9CLE9BRkFILE1BQUssdUNBRTJCLE9BQWhDLElBQUlFLE9BQU9FLGtCQUFrQixJQUFHO1FBR3ZDLEtBQUs7WUFDSCxPQUFPLE1BRUksT0FGRUosTUFBSywwR0FJYkEsT0FGTSxJQUFJRSxPQUFPQyxXQUFXLElBQUcsaUJBSS9CLE9BRkFILE1BQUssMkNBRTJCLE9BQWhDLElBQUlFLE9BQU9FLGtCQUFrQixJQUFHO1FBR3ZDLEtBQUs7WUFDSCxPQUFPLEtBRUYsT0FGT0osTUFBSyxtREFFb0IsT0FBaEMsSUFBSUUsT0FBT0Usa0JBQWtCLElBQUc7UUFrQnZDLEtBQUs7WUFDSCxPQUFPLEtBRUYsT0FGT0osTUFBSywrQ0FFb0IsT0FBaEMsSUFBSUUsT0FBT0Usa0JBQWtCLElBQUc7UUFtQnZDLEtBQUs7WUFDSCxPQUFPLEtBRUYsT0FGT0osTUFBSyxxREFFb0IsT0FBaEMsSUFBSUUsT0FBT0Usa0JBQWtCLElBQUc7UUF1QnZDLEtBQUs7WUFDSCxPQUFPLEtBRUYsT0FGT0osTUFBSyx1REFFb0IsT0FBaEMsSUFBSUUsT0FBT0Usa0JBQWtCLElBQUc7UUFxQnZDO1lBQ0UsT0FBTyxLQUdDLE9BSElKLE1BQUssc0VBR2dCLE9BQXpCLElBQUlFLE9BQU9DLFdBQVc7SUFDbEM7QUFDRjtBQUVBLHFFQUFxRTtBQUNyRSxNQUFNRSxzQkFBcUMsRUFBRTtBQUU3Qyx5RUFBeUU7QUFDekUsTUFBTUMsd0JBQXVDLEVBQUU7QUFFL0Msc0ZBQXNGO0FBQ3RGLE1BQU1DLHdCQUF5QyxFQUFFO0FBRTFDLE1BQU1DLGlCQUFpQmQsZ0RBQU1BLEdBQ2xDQyw2REFBUUEsQ0FDTixDQUFDYyxLQUFLQyxNQUFTO1FBQ1gsZ0JBQWdCO1FBQ2hCQyxVQUFVLEVBQUU7UUFDWkMsV0FBVztRQUNYQyxjQUFjUjtRQUNkUyxnQkFBZ0JSO1FBQ2hCUyxnQkFBZ0JSO1FBQ2hCUyxrQkFBa0IsRUFBRTtRQUNwQkMsWUFBWSxFQUFFO1FBQ2RDLHNCQUFzQjtRQUN0QkMsdUJBQXVCO1FBQ3ZCQyxXQUFXO1FBQ1hDLE9BQU87UUFFUCxVQUFVO1FBQ1ZDLFNBQVMsQ0FBQ0M7Z0JBTVNBLGVBQ0NBO1lBTmxCLE1BQU0sRUFBRVosUUFBUSxFQUFFLEdBQUdEO1lBRXJCYyxRQUFRQyxHQUFHLENBQUMsNEJBQTRCO2dCQUN0Q0MsSUFBSUgsS0FBS0csRUFBRTtnQkFDWDFCLE1BQU11QixLQUFLdkIsSUFBSTtnQkFDZjJCLGVBQWVKLEVBQUFBLGdCQUFBQSxLQUFLSyxPQUFPLGNBQVpMLG9DQUFBQSxjQUFjTSxNQUFNLEtBQUk7Z0JBQ3ZDQyxnQkFBZ0JQLEVBQUFBLGlCQUFBQSxLQUFLSyxPQUFPLGNBQVpMLHFDQUFBQSxlQUFjUSxTQUFTLENBQUMsR0FBRyxTQUFRO2dCQUNuRGxDLE1BQU0wQixLQUFLMUIsSUFBSTtnQkFDZm1DLFVBQVUsS0FBY0EsUUFBUTtnQkFDaENDLFlBQVlWLEtBQUtLLE9BQU87WUFDMUI7WUFFQSwrQkFBK0I7WUFDL0IsTUFBTU0sY0FBY3ZCLFNBQVN3QixJQUFJLENBQUNDLENBQUFBLE1BQU9BLElBQUlWLEVBQUUsS0FBS0gsS0FBS0csRUFBRTtZQUMzRCxJQUFJUSxhQUFhO2dCQUNmVixRQUFRQyxHQUFHLENBQUMsc0NBQXNDUyxZQUFZUixFQUFFO2dCQUNoRSxnRUFBZ0U7Z0JBQ2hFLE1BQU1XLGNBQWMxQixTQUFTMkIsR0FBRyxDQUFDRixDQUFBQSxNQUMvQkEsSUFBSVYsRUFBRSxLQUFLSCxLQUFLRyxFQUFFLEdBQ2Q7d0JBQUUsR0FBR1UsR0FBRzt3QkFBRVIsU0FBU0wsS0FBS0ssT0FBTyxJQUFJN0Isa0JBQWtCd0IsS0FBSzFCLElBQUksRUFBRTBCLEtBQUt2QixJQUFJO29CQUFFLElBQzNFb0M7Z0JBRU4zQixJQUFJO29CQUNGRSxVQUFVMEI7b0JBQ1Z6QixXQUFXc0IsWUFBWVIsRUFBRTtnQkFDM0I7Z0JBQ0E7WUFDRjtZQUVBLGdEQUFnRDtZQUNoRCw2Q0FBNkM7WUFDN0MsTUFBTWEsbUJBQW1CO2dCQUFDO2dCQUFZO2dCQUFrQjtnQkFBZ0I7YUFBZTtZQUN2RixNQUFNQyxpQkFBaUJELGlCQUFpQkUsUUFBUSxDQUFDbEIsS0FBSzFCLElBQUk7WUFFMUQsSUFBSTZDO1lBQ0osSUFBSUYsZ0JBQWdCO2dCQUNsQixvREFBb0Q7Z0JBQ3BELE1BQU1HLGFBQWFoQyxTQUFTaUMsTUFBTSxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFQyxNQUFNO2dCQUNoREosY0FBY0MsV0FBV2QsTUFBTSxHQUFHLElBQUlrQixLQUFLQyxHQUFHLElBQUlMLFdBQVdMLEdBQUcsQ0FBQ08sQ0FBQUEsSUFBS0EsRUFBRUgsV0FBVyxJQUFJLE1BQU0sSUFBSTtZQUNuRztZQUVBLDhCQUE4QjtZQUM5QixNQUFNTyxhQUFhMUIsS0FBS0ssT0FBTyxJQUFJN0Isa0JBQWtCd0IsS0FBSzFCLElBQUksRUFBRTBCLEtBQUt2QixJQUFJO1lBQ3pFd0IsUUFBUUMsR0FBRyxDQUFDLHFDQUFxQztnQkFDL0N5QixRQUFRM0IsS0FBS0csRUFBRTtnQkFDZnlCLFVBQVU1QixLQUFLdkIsSUFBSTtnQkFDbkJvRCxrQkFBa0IsQ0FBQyxDQUFDN0IsS0FBS0ssT0FBTztnQkFDaENELGVBQWVzQixXQUFXcEIsTUFBTTtnQkFDaENDLGdCQUFnQm1CLFdBQVdsQixTQUFTLENBQUMsR0FBRztZQUMxQztZQUVBLE1BQU1zQixTQUFvQjtnQkFDeEIzQixJQUFJSCxLQUFLRyxFQUFFO2dCQUNYMUIsTUFBTXVCLEtBQUt2QixJQUFJO2dCQUNmc0QsVUFBVTtnQkFDVjFCLFNBQVNxQjtnQkFDVE0sVUFBVWhDLEtBQUtnQyxRQUFRO2dCQUN2QjFELE1BQU0wQixLQUFLMUIsSUFBSTtnQkFDZmlELFFBQVFOO2dCQUNSRSxhQUFhRixpQkFBaUJFLGNBQWNjO1lBQzlDO1lBRUEsSUFBSUM7WUFDSixJQUFJakIsZ0JBQWdCO2dCQUNsQiwwREFBMEQ7Z0JBQzFELE1BQU1rQixZQUFZO3VCQUFJL0M7aUJBQVM7Z0JBQy9CLE1BQU1nRCxjQUFjRCxVQUFVZCxNQUFNLENBQUNDLENBQUFBLElBQUtBLEVBQUVDLE1BQU0sSUFBSSxDQUFDRCxFQUFFSCxXQUFXLElBQUksS0FBTUEsQ0FBQUEsZUFBZSxJQUFJYixNQUFNO2dCQUN2RzZCLFVBQVVFLE1BQU0sQ0FBQ0QsYUFBYSxHQUFHTjtnQkFDakNJLFVBQVVDO1lBQ1osT0FBTztnQkFDTCx5REFBeUQ7Z0JBQ3pELE1BQU1mLGFBQWFoQyxTQUFTaUMsTUFBTSxDQUFDUixDQUFBQSxNQUFPQSxJQUFJVSxNQUFNO2dCQUNwRCxNQUFNZSxlQUFlbEQsU0FBU2lDLE1BQU0sQ0FBQ1IsQ0FBQUEsTUFBTyxDQUFDQSxJQUFJVSxNQUFNO2dCQUN2RFcsVUFBVTt1QkFBSWQ7dUJBQWVrQjtvQkFBY1I7aUJBQU87WUFDcEQ7WUFFQTVDLElBQUk7Z0JBQ0ZFLFVBQVU4QztnQkFDVjdDLFdBQVd5QyxPQUFPM0IsRUFBRTtZQUN0QjtRQUNGO1FBRUFvQyxnQkFBZ0IsQ0FBQ3BDLElBQVkxQixNQUFjSDtZQUN6QyxNQUFNLEVBQUVjLFFBQVEsRUFBRSxHQUFHRDtZQUVyQiwrQkFBK0I7WUFDL0IsTUFBTXdCLGNBQWN2QixTQUFTd0IsSUFBSSxDQUFDQyxDQUFBQSxNQUFPQSxJQUFJVixFQUFFLEtBQUtBO1lBQ3BELElBQUlRLGFBQWE7Z0JBQ2Z6QixJQUFJO29CQUFFRyxXQUFXc0IsWUFBWVIsRUFBRTtnQkFBQztnQkFDaEM7WUFDRjtZQUVBLCtDQUErQztZQUMvQyxNQUFNcUMsZUFBZTtnQkFBQztnQkFBZ0I7Z0JBQVk7Z0JBQWtCO2dCQUFnQjtnQkFBeUI7Z0JBQWtCO2FBQWU7WUFDOUksTUFBTXZCLGlCQUFpQnVCLGFBQWF0QixRQUFRLENBQUM1QztZQUU3QyxJQUFJNkM7WUFDSixJQUFJRixnQkFBZ0I7Z0JBQ2xCLG9EQUFvRDtnQkFDcEQsTUFBTUcsYUFBYWhDLFNBQVNpQyxNQUFNLENBQUNDLENBQUFBLElBQUtBLEVBQUVDLE1BQU07Z0JBQ2hESixjQUFjQyxXQUFXZCxNQUFNLEdBQUcsSUFBSWtCLEtBQUtDLEdBQUcsSUFBSUwsV0FBV0wsR0FBRyxDQUFDTyxDQUFBQSxJQUFLQSxFQUFFSCxXQUFXLElBQUksTUFBTSxJQUFJO1lBQ25HO1lBRUEseUJBQXlCO1lBQ3pCLE1BQU1XLFNBQW9CO2dCQUN4QjNCO2dCQUNBMUI7Z0JBQ0FzRCxVQUFVO2dCQUNWMUIsU0FBUztnQkFDVDJCLFVBQVUsSUFBUyxPQUFMMUQ7Z0JBQ2RBO2dCQUNBaUQsUUFBUU47Z0JBQ1JFLGFBQWFGLGlCQUFpQkUsY0FBY2M7WUFDOUM7WUFFQSxJQUFJQztZQUNKLElBQUlqQixnQkFBZ0I7Z0JBQ2xCLDBEQUEwRDtnQkFDMUQsTUFBTWtCLFlBQVk7dUJBQUkvQztpQkFBUztnQkFDL0IsTUFBTWdELGNBQWNELFVBQVVkLE1BQU0sQ0FBQ0MsQ0FBQUEsSUFBS0EsRUFBRUMsTUFBTSxJQUFJLENBQUNELEVBQUVILFdBQVcsSUFBSSxLQUFNQSxDQUFBQSxlQUFlLElBQUliLE1BQU07Z0JBQ3ZHNkIsVUFBVUUsTUFBTSxDQUFDRCxhQUFhLEdBQUdOO2dCQUNqQ0ksVUFBVUM7WUFDWixPQUFPO2dCQUNMLHlEQUF5RDtnQkFDekQsTUFBTWYsYUFBYWhDLFNBQVNpQyxNQUFNLENBQUNSLENBQUFBLE1BQU9BLElBQUlVLE1BQU07Z0JBQ3BELE1BQU1lLGVBQWVsRCxTQUFTaUMsTUFBTSxDQUFDUixDQUFBQSxNQUFPLENBQUNBLElBQUlVLE1BQU07Z0JBQ3ZEVyxVQUFVO3VCQUFJZDt1QkFBZWtCO29CQUFjUjtpQkFBTztZQUNwRDtZQUVBNUMsSUFBSTtnQkFDRkUsVUFBVThDO2dCQUNWN0MsV0FBV3lDLE9BQU8zQixFQUFFO1lBQ3RCO1FBQ0Y7UUFFQXNDLFVBQVUsQ0FBQ0M7WUFDVCxNQUFNLEVBQUV0RCxRQUFRLEVBQUVDLFNBQVMsRUFBRSxHQUFHRjtZQUNoQyxNQUFNd0QsV0FBV3ZELFNBQVN3RCxTQUFTLENBQUMvQixDQUFBQSxNQUFPQSxJQUFJVixFQUFFLEtBQUt1QztZQUV0RCxJQUFJQyxhQUFhLENBQUMsR0FBRztZQUVyQixNQUFNVCxVQUFVOUMsU0FBU2lDLE1BQU0sQ0FBQ1IsQ0FBQUEsTUFBT0EsSUFBSVYsRUFBRSxLQUFLdUM7WUFDbEQsSUFBSUcsZUFBZXhEO1lBRW5CLG1EQUFtRDtZQUNuRCxJQUFJQSxjQUFjcUQsT0FBTztnQkFDdkIsSUFBSVIsUUFBUTVCLE1BQU0sR0FBRyxHQUFHO29CQUN0QiwwRUFBMEU7b0JBQzFFLE1BQU13QyxZQUFZSCxXQUFXVCxRQUFRNUIsTUFBTSxHQUFHcUMsV0FBV1QsUUFBUTVCLE1BQU0sR0FBRztvQkFDMUV1QyxlQUFlWCxPQUFPLENBQUNZLFVBQVUsQ0FBQzNDLEVBQUU7Z0JBQ3RDLE9BQU87b0JBQ0wwQyxlQUFlO2dCQUNqQjtZQUNGO1lBRUEzRCxJQUFJO2dCQUNGRSxVQUFVOEM7Z0JBQ1Y3QyxXQUFXd0Q7WUFDYjtRQUNGO1FBRUFFLGNBQWM7WUFDWjdELElBQUk7Z0JBQ0ZFLFVBQVUsRUFBRTtnQkFDWkMsV0FBVztZQUNiO1FBQ0Y7UUFFQTJELGNBQWMsQ0FBQ047WUFDYixNQUFNLEVBQUV0RCxRQUFRLEVBQUVDLFdBQVc0RCxnQkFBZ0IsRUFBRSxHQUFHOUQ7WUFDbEQsTUFBTStELFlBQVk5RCxTQUFTK0QsSUFBSSxDQUFDdEMsQ0FBQUEsTUFBT0EsSUFBSVYsRUFBRSxLQUFLdUM7WUFFbER6QyxRQUFRQyxHQUFHLENBQUMsMkJBQTJCO2dCQUNyQ2tELFVBQVVWO2dCQUNWTztnQkFDQUM7Z0JBQ0FHLGVBQWVqRSxTQUFTa0IsTUFBTTtnQkFDOUJnRCxlQUFlbEUsU0FBUzJCLEdBQUcsQ0FBQ08sQ0FBQUE7d0JBQStDQTsyQkFBekM7d0JBQUVuQixJQUFJbUIsRUFBRW5CLEVBQUU7d0JBQUUxQixNQUFNNkMsRUFBRTdDLElBQUk7d0JBQUUyQixlQUFla0IsRUFBQUEsYUFBQUEsRUFBRWpCLE9BQU8sY0FBVGlCLGlDQUFBQSxXQUFXaEIsTUFBTSxLQUFJO29CQUFFOztZQUNwRztZQUVBLElBQUk0QyxXQUFXO2dCQUNiaEUsSUFBSTtvQkFBRUcsV0FBV3FEO2dCQUFNO2dCQUN2QnpDLFFBQVFDLEdBQUcsQ0FBQyx3QkFBd0J3QztZQUN0QyxPQUFPO2dCQUNMekMsUUFBUXNELElBQUksQ0FBQyxrREFBa0RiO1lBQ2pFO1FBQ0Y7UUFFQWMsYUFBYSxDQUFDQyxXQUFtQkM7WUFDL0IsTUFBTSxFQUFFdEUsUUFBUSxFQUFFLEdBQUdEO1lBQ3JCLE1BQU13RSxZQUFZdkUsU0FBU3dELFNBQVMsQ0FBQy9CLENBQUFBLE1BQU9BLElBQUlWLEVBQUUsS0FBS3NEO1lBQ3ZELE1BQU1HLFVBQVV4RSxTQUFTd0QsU0FBUyxDQUFDL0IsQ0FBQUEsTUFBT0EsSUFBSVYsRUFBRSxLQUFLdUQ7WUFFckQsSUFBSUMsY0FBYyxDQUFDLEtBQUtDLFlBQVksQ0FBQyxLQUFLRCxjQUFjQyxTQUFTO2dCQUMvRCxNQUFNMUIsVUFBVTt1QkFBSTlDO2lCQUFTO2dCQUM3QixNQUFNLENBQUN5RSxTQUFTLEdBQUczQixRQUFRRyxNQUFNLENBQUNzQixXQUFXO2dCQUM3Q3pCLFFBQVFHLE1BQU0sQ0FBQ3VCLFNBQVMsR0FBR0M7Z0JBQzNCM0UsSUFBSTtvQkFBRUUsVUFBVThDO2dCQUFRO1lBQzFCO1FBQ0Y7UUFFQTRCLFFBQVEsQ0FBQ3BCO1lBQ1AsTUFBTSxFQUFFdEQsUUFBUSxFQUFFLEdBQUdEO1lBQ3JCLE1BQU13RCxXQUFXdkQsU0FBU3dELFNBQVMsQ0FBQy9CLENBQUFBLE1BQU9BLElBQUlWLEVBQUUsS0FBS3VDO1lBRXRELElBQUlDLGFBQWEsQ0FBQyxHQUFHO2dCQUNuQixNQUFNOUIsTUFBTXpCLFFBQVEsQ0FBQ3VELFNBQVM7Z0JBRTlCLDhCQUE4QjtnQkFDOUIsSUFBSTlCLElBQUlVLE1BQU0sRUFBRTtnQkFFaEIsK0JBQStCO2dCQUMvQixNQUFNSCxhQUFhaEMsU0FBU2lDLE1BQU0sQ0FBQ0MsQ0FBQUEsSUFBS0EsRUFBRUMsTUFBTTtnQkFDaEQsTUFBTXdDLGtCQUFrQjNDLFdBQVdkLE1BQU0sR0FBRyxJQUFJa0IsS0FBS0MsR0FBRyxJQUFJTCxXQUFXTCxHQUFHLENBQUNPLENBQUFBLElBQUtBLEVBQUVILFdBQVcsSUFBSSxNQUFNLElBQUk7Z0JBRTNHLDhCQUE4QjtnQkFDOUIsTUFBTTZDLGFBQWE7b0JBQUUsR0FBR25ELEdBQUc7b0JBQUVVLFFBQVE7b0JBQU1KLGFBQWE0QztnQkFBZ0I7Z0JBRXhFLHNFQUFzRTtnQkFDdEUsTUFBTTdCLFVBQVU7dUJBQUk5QztpQkFBUztnQkFDN0I4QyxRQUFRRyxNQUFNLENBQUNNLFVBQVU7Z0JBRXpCLDhDQUE4QztnQkFDOUMsTUFBTVAsY0FBY0YsUUFBUWIsTUFBTSxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFQyxNQUFNLElBQUksQ0FBQ0QsRUFBRUgsV0FBVyxJQUFJLEtBQUs0QyxpQkFBaUJ6RCxNQUFNO2dCQUNsRzRCLFFBQVFHLE1BQU0sQ0FBQ0QsYUFBYSxHQUFHNEI7Z0JBRS9COUUsSUFBSTtvQkFBRUUsVUFBVThDO2dCQUFRO1lBQzFCO1FBQ0Y7UUFFQStCLFVBQVUsQ0FBQ3ZCO1lBQ1QsTUFBTSxFQUFFdEQsUUFBUSxFQUFFLEdBQUdEO1lBQ3JCLE1BQU13RCxXQUFXdkQsU0FBU3dELFNBQVMsQ0FBQy9CLENBQUFBLE1BQU9BLElBQUlWLEVBQUUsS0FBS3VDO1lBRXRELElBQUlDLGFBQWEsQ0FBQyxHQUFHO2dCQUNuQixNQUFNOUIsTUFBTXpCLFFBQVEsQ0FBQ3VELFNBQVM7Z0JBRTlCLDRCQUE0QjtnQkFDNUIsSUFBSSxDQUFDOUIsSUFBSVUsTUFBTSxFQUFFO2dCQUVqQixnQ0FBZ0M7Z0JBQ2hDLE1BQU15QyxhQUFhO29CQUFFLEdBQUduRCxHQUFHO29CQUFFVSxRQUFRO29CQUFPSixhQUFhYztnQkFBVTtnQkFFbkUsbUNBQW1DO2dCQUNuQyxNQUFNQyxVQUFVO3VCQUFJOUM7aUJBQVM7Z0JBQzdCOEMsUUFBUUcsTUFBTSxDQUFDTSxVQUFVO2dCQUV6QiwwQ0FBMEM7Z0JBQzFDLE1BQU11QixjQUFjaEMsUUFBUWIsTUFBTSxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFQyxNQUFNLEVBQUVqQixNQUFNO2dCQUN4RDRCLFFBQVFHLE1BQU0sQ0FBQzZCLGFBQWEsR0FBR0Y7Z0JBRS9COUUsSUFBSTtvQkFBRUUsVUFBVThDO2dCQUFRO1lBQzFCO1FBQ0Y7UUFFQWlDLGtCQUFrQixDQUFDekIsT0FBZXJDO1lBQ2hDLE1BQU0sRUFBRWpCLFFBQVEsRUFBRSxHQUFHRDtZQUNyQixNQUFNMkIsY0FBYzFCLFNBQVMyQixHQUFHLENBQUMsQ0FBQ0YsTUFDaENBLElBQUlWLEVBQUUsS0FBS3VDLFFBQ1A7b0JBQUUsR0FBRzdCLEdBQUc7b0JBQUVSO29CQUFTMEIsVUFBVTtnQkFBSyxJQUNsQ2xCO1lBR04zQixJQUFJO2dCQUFFRSxVQUFVMEI7WUFBWTtRQUM5QjtRQUVBc0QsbUJBQW1CLENBQUMxQixPQUFlckM7WUFDakMsTUFBTSxFQUFFakIsUUFBUSxFQUFFLEdBQUdEO1lBRXJCYyxRQUFRQyxHQUFHLENBQUMsZ0NBQWdDO2dCQUMxQ3dDO2dCQUNBdEMsZUFBZUMsUUFBUUMsTUFBTTtnQkFDN0JDLGdCQUFnQkYsUUFBUUcsU0FBUyxDQUFDLEdBQUc7Z0JBQ3JDNkQsa0JBQWtCakYsU0FBU2tCLE1BQU07WUFDbkM7WUFFQSxNQUFNSyxjQUFjdkIsU0FBU3dCLElBQUksQ0FBQ0MsQ0FBQUEsTUFBT0EsSUFBSVYsRUFBRSxLQUFLdUM7WUFDcEQsSUFBSS9CLGFBQWE7b0JBSVNBO2dCQUh4QlYsUUFBUUMsR0FBRyxDQUFDLG9DQUFvQztvQkFDOUNDLElBQUlRLFlBQVlSLEVBQUU7b0JBQ2xCMUIsTUFBTWtDLFlBQVlsQyxJQUFJO29CQUN0QjZGLHNCQUFzQjNELEVBQUFBLHVCQUFBQSxZQUFZTixPQUFPLGNBQW5CTSwyQ0FBQUEscUJBQXFCTCxNQUFNLEtBQUk7b0JBQ3JEaUUsa0JBQWtCbEUsUUFBUUMsTUFBTTtvQkFDaENrRSxnQkFBZ0I3RCxZQUFZTixPQUFPLEtBQUtBO2dCQUMxQztZQUNGLE9BQU87Z0JBQ0xKLFFBQVFzRCxJQUFJLENBQUMsZ0NBQWdDYjtZQUMvQztZQUVBLE1BQU01QixjQUFjMUIsU0FBUzJCLEdBQUcsQ0FBQyxDQUFDRixNQUNoQ0EsSUFBSVYsRUFBRSxLQUFLdUMsUUFDUDtvQkFBRSxHQUFHN0IsR0FBRztvQkFBRVI7b0JBQVMwQixVQUFVO2dCQUFLLElBQ2xDbEI7WUFHTlosUUFBUUMsR0FBRyxDQUFDLGtDQUFrQztnQkFDNUN3QztnQkFDQStCLGtCQUFrQjNELFlBQVlSLE1BQU07Z0JBQ3BDb0UsZ0JBQWdCLENBQUMsQ0FBQzVELFlBQVlGLElBQUksQ0FBQ1UsQ0FBQUEsSUFBS0EsRUFBRW5CLEVBQUUsS0FBS3VDO1lBQ25EO1lBRUF4RCxJQUFJO2dCQUFFRSxVQUFVMEI7WUFBWTtRQUM5QjtRQUVBNkQsMEJBQTBCLENBQUNoRCxRQUFnQnRCO1lBQ3pDLE1BQU0sRUFBRWYsWUFBWSxFQUFFQyxjQUFjLEVBQUVILFFBQVEsRUFBRSxHQUFHRDtZQUVuRGMsUUFBUUMsR0FBRyxDQUFDLHVDQUF1QztnQkFDakR5QjtnQkFDQXZCLGVBQWVDLFFBQVFDLE1BQU07Z0JBQzdCQyxnQkFBZ0JGLFFBQVFHLFNBQVMsQ0FBQyxHQUFHO2dCQUNyQ29FLDBCQUEwQnRGLGFBQWFnQixNQUFNO2dCQUM3Q3VFLDRCQUE0QnRGLGVBQWVlLE1BQU07Z0JBQ2pEd0Usc0JBQXNCMUYsU0FBU2tCLE1BQU07WUFDdkM7WUFFQSxxQ0FBcUM7WUFDckMsTUFBTXlFLHNCQUFzQnpGLGFBQWFzQixJQUFJLENBQUNvRSxDQUFBQSxJQUFLQSxFQUFFN0UsRUFBRSxLQUFLd0I7WUFDNUQsTUFBTXNELHdCQUF3QjFGLGVBQWVxQixJQUFJLENBQUNvRSxDQUFBQSxJQUFLQSxFQUFFN0UsRUFBRSxLQUFLd0I7WUFDaEUsTUFBTXVELGVBQWVILHVCQUF1QkU7WUFFNUMsSUFBSUMsY0FBYztvQkFJUUE7Z0JBSHhCakYsUUFBUUMsR0FBRyxDQUFDLDJCQUEyQjtvQkFDckNDLElBQUkrRSxhQUFhL0UsRUFBRTtvQkFDbkIxQixNQUFNeUcsYUFBYXpHLElBQUk7b0JBQ3ZCNkYsc0JBQXNCWSxFQUFBQSx3QkFBQUEsYUFBYTdFLE9BQU8sY0FBcEI2RSw0Q0FBQUEsc0JBQXNCNUUsTUFBTSxLQUFJO29CQUN0RGlFLGtCQUFrQmxFLFFBQVFDLE1BQU07b0JBQ2hDa0UsZ0JBQWdCVSxhQUFhN0UsT0FBTyxLQUFLQTtnQkFDM0M7WUFDRixPQUFPO2dCQUNMSixRQUFRc0QsSUFBSSxDQUFDLCtCQUErQjVCO1lBQzlDO1lBRUEsMkNBQTJDO1lBQzNDLE1BQU13RCxzQkFBc0I3RixhQUFheUIsR0FBRyxDQUFDZixDQUFBQSxPQUMzQ0EsS0FBS0csRUFBRSxLQUFLd0IsU0FBUztvQkFBRSxHQUFHM0IsSUFBSTtvQkFBRUs7b0JBQVMrRSxZQUFZLElBQUl6RztnQkFBTyxJQUFJcUI7WUFHdEUsTUFBTXFGLHdCQUF3QjlGLGVBQWV3QixHQUFHLENBQUNmLENBQUFBLE9BQy9DQSxLQUFLRyxFQUFFLEtBQUt3QixTQUFTO29CQUFFLEdBQUczQixJQUFJO29CQUFFSztvQkFBUytFLFlBQVksSUFBSXpHO2dCQUFPLElBQUlxQjtZQUd0RSxtQ0FBbUM7WUFDbkMsTUFBTVcsY0FBY3ZCLFNBQVN3QixJQUFJLENBQUNDLENBQUFBLE1BQU9BLElBQUlWLEVBQUUsS0FBS3dCO1lBQ3BELElBQUloQixhQUFhO29CQUlZQTtnQkFIM0JWLFFBQVFDLEdBQUcsQ0FBQyw2QkFBNkI7b0JBQ3ZDd0MsT0FBT2Y7b0JBQ1AyRCxTQUFTM0UsWUFBWWxDLElBQUk7b0JBQ3pCOEcseUJBQXlCNUUsRUFBQUEsdUJBQUFBLFlBQVlOLE9BQU8sY0FBbkJNLDJDQUFBQSxxQkFBcUJMLE1BQU0sS0FBSTtvQkFDeERpRSxrQkFBa0JsRSxRQUFRQyxNQUFNO29CQUNoQ2tGLG1CQUFtQjdFLFlBQVlOLE9BQU8sS0FBS0E7Z0JBQzdDO1lBQ0Y7WUFFQSxNQUFNUyxjQUFjMUIsU0FBUzJCLEdBQUcsQ0FBQyxDQUFDRixNQUNoQ0EsSUFBSVYsRUFBRSxLQUFLd0IsU0FDUDtvQkFBRSxHQUFHZCxHQUFHO29CQUFFUjtvQkFBUzBCLFVBQVU7Z0JBQUssSUFDbENsQjtZQUdOWixRQUFRQyxHQUFHLENBQUMsNEJBQTRCO2dCQUN0Q3lCO2dCQUNBOEQscUJBQXFCTixvQkFBb0I3RSxNQUFNO2dCQUMvQ29GLHVCQUF1Qkwsc0JBQXNCL0UsTUFBTTtnQkFDbkRxRixhQUFhN0UsWUFBWVIsTUFBTTtnQkFDL0JvRSxnQkFBZ0IsQ0FBQyxDQUFDNUQsWUFBWUYsSUFBSSxDQUFDVSxDQUFBQSxJQUFLQSxFQUFFbkIsRUFBRSxLQUFLd0I7WUFDbkQ7WUFFQXpDLElBQUk7Z0JBQ0ZJLGNBQWM2RjtnQkFDZDVGLGdCQUFnQjhGO2dCQUNoQmpHLFVBQVUwQjtZQUNaO1FBQ0Y7UUFFQThFLGtCQUFrQixDQUFDakUsUUFBZ0JrRTtZQUNqQyxNQUFNLEVBQUV2RyxZQUFZLEVBQUVDLGNBQWMsRUFBRUgsUUFBUSxFQUFFLEdBQUdEO1lBRW5EYyxRQUFRQyxHQUFHLENBQUMsK0JBQStCO2dCQUN6Q3lCO2dCQUNBa0U7Z0JBQ0FDLG1CQUFtQnhHLGFBQWFnQixNQUFNO2dCQUN0Q3lGLG1CQUFtQnpHLGFBQWF5QixHQUFHLENBQUNpRSxDQUFBQSxJQUFNO3dCQUFFN0UsSUFBSTZFLEVBQUU3RSxFQUFFO3dCQUFFMUIsTUFBTXVHLEVBQUV2RyxJQUFJO3dCQUFFdUgsZUFBZWhCLEVBQUVhLE1BQU07b0JBQUM7WUFDOUY7WUFFQSwwQkFBMEI7WUFDMUIsTUFBTVYsc0JBQXNCN0YsYUFBYXlCLEdBQUcsQ0FBQ2YsQ0FBQUEsT0FDM0NBLEtBQUtHLEVBQUUsS0FBS3dCLFNBQVM7b0JBQUUsR0FBRzNCLElBQUk7b0JBQUU2RjtvQkFBUVQsWUFBWSxJQUFJekc7Z0JBQU8sSUFBSXFCO1lBR3JFLCtDQUErQztZQUMvQyxJQUFJaUcsY0FBY2Qsb0JBQW9CdkUsSUFBSSxDQUFDb0UsQ0FBQUEsSUFBS0EsRUFBRTdFLEVBQUUsS0FBS3dCO1lBQ3pEMUIsUUFBUUMsR0FBRyxDQUFDLGlDQUFpQztnQkFDM0N5QjtnQkFDQXVFLFdBQVdMO2dCQUNYTSxXQUFXLENBQUMsQ0FBQ0Y7Z0JBQ2JHLGlCQUFpQixFQUFFSCx3QkFBQUEsa0NBQUFBLFlBQWFKLE1BQU07Z0JBQ3RDUSxZQUFZSixDQUFBQSx3QkFBQUEsa0NBQUFBLFlBQWFKLE1BQU0sTUFBS0E7WUFDdEM7WUFFQSx5RUFBeUU7WUFDekUsSUFBSSxDQUFDSSxhQUFhO2dCQUNoQixNQUFNcEYsTUFBTXpCLFNBQVN3QixJQUFJLENBQUNVLENBQUFBLElBQUtBLEVBQUVuQixFQUFFLEtBQUt3QjtnQkFDeEMsSUFBSWQsS0FBSztvQkFDUCxNQUFNeUYscUJBQXFCbkIsb0JBQW9CdkMsU0FBUyxDQUFDb0MsQ0FBQUEsSUFBS0EsRUFBRXZHLElBQUksS0FBS29DLElBQUlwQyxJQUFJO29CQUNqRixJQUFJNkgsdUJBQXVCLENBQUMsR0FBRzt3QkFDN0IsTUFBTUMsU0FBU3BCLG1CQUFtQixDQUFDbUIsbUJBQW1CO3dCQUN0RG5CLG1CQUFtQixDQUFDbUIsbUJBQW1CLEdBQUc7NEJBQ3hDLEdBQUdDLE1BQU07NEJBQ1RWOzRCQUNBVCxZQUFZLElBQUl6Rzt3QkFDbEI7d0JBQ0FzSCxjQUFjZCxtQkFBbUIsQ0FBQ21CLG1CQUFtQjt3QkFDckRyRyxRQUFRQyxHQUFHLENBQUMsc0NBQXNDOzRCQUFFekIsTUFBTW9DLElBQUlwQyxJQUFJOzRCQUFFb0g7d0JBQU87b0JBQzdFO2dCQUNGO1lBQ0Y7WUFFQSw0QkFBNEI7WUFDNUIsTUFBTVIsd0JBQXdCOUYsZUFBZXdCLEdBQUcsQ0FBQ2YsQ0FBQUEsT0FDL0NBLEtBQUtHLEVBQUUsS0FBS3dCLFNBQVM7b0JBQUUsR0FBRzNCLElBQUk7b0JBQUU2RjtvQkFBUVQsWUFBWSxJQUFJekc7Z0JBQU8sSUFBSXFCO1lBR3JFZCxJQUFJO2dCQUNGSSxjQUFjNkY7Z0JBQ2Q1RixnQkFBZ0I4RjtZQUNsQjtRQUNGO1FBRUFtQixvQkFBb0IsQ0FBQzdFLFFBQWdCOEU7WUFDbkMsTUFBTSxFQUFFbkgsWUFBWSxFQUFFQyxjQUFjLEVBQUUsR0FBR0o7WUFFekMsMEJBQTBCO1lBQzFCLE1BQU1nRyxzQkFBc0I3RixhQUFheUIsR0FBRyxDQUFDZixDQUFBQSxPQUMzQ0EsS0FBS0csRUFBRSxLQUFLd0IsU0FBUztvQkFBRSxHQUFHM0IsSUFBSTtvQkFBRXlHO29CQUFVckIsWUFBWSxJQUFJekc7Z0JBQU8sSUFBSXFCO1lBR3ZFLDRCQUE0QjtZQUM1QixNQUFNcUYsd0JBQXdCOUYsZUFBZXdCLEdBQUcsQ0FBQ2YsQ0FBQUEsT0FDL0NBLEtBQUtHLEVBQUUsS0FBS3dCLFNBQVM7b0JBQUUsR0FBRzNCLElBQUk7b0JBQUV5RztvQkFBVXJCLFlBQVksSUFBSXpHO2dCQUFPLElBQUlxQjtZQUd2RWQsSUFBSTtnQkFDRkksY0FBYzZGO2dCQUNkNUYsZ0JBQWdCOEY7WUFDbEI7UUFDRjtRQUVBcUIsc0JBQXNCLENBQUNDLFVBQWtCRjtZQUN2QyxNQUFNLEVBQUVqSCxjQUFjLEVBQUVDLGdCQUFnQixFQUFFLEdBQUdOO1lBRTdDLDRCQUE0QjtZQUM1QixNQUFNeUgsd0JBQXdCcEgsZUFBZXVCLEdBQUcsQ0FBQzhGLENBQUFBLFNBQy9DQSxPQUFPMUcsRUFBRSxLQUFLd0csV0FBVztvQkFBRSxHQUFHRSxNQUFNO29CQUFFSjtnQkFBUyxJQUFJSTtZQUdyRCw4QkFBOEI7WUFDOUIsTUFBTUMsMEJBQTBCckgsaUJBQWlCc0IsR0FBRyxDQUFDOEYsQ0FBQUEsU0FDbkRBLE9BQU8xRyxFQUFFLEtBQUt3RyxXQUFXO29CQUFFLEdBQUdFLE1BQU07b0JBQUVKO2dCQUFTLElBQUlJO1lBR3JEM0gsSUFBSTtnQkFDRk0sZ0JBQWdCb0g7Z0JBQ2hCbkgsa0JBQWtCcUg7WUFDcEI7UUFDRjtRQUVBQyxlQUFlLFNBQUN0SSxNQUFjSDtnQkFBMkIwSSw0RUFBb0MsV0FBV0wseURBQW1CTSw4REFBd0JDO2dCQTJEaElDO1lBMURqQixNQUFNLEVBQUU3SCxZQUFZLEVBQUVDLGNBQWMsRUFBRSxHQUFHSjtZQUV6Q2MsUUFBUUMsR0FBRyxDQUFDLGlDQUFpQztnQkFDM0N6QjtnQkFDQUg7Z0JBQ0EwSTtnQkFDQUw7Z0JBQ0E5RSxrQkFBa0IsQ0FBQyxDQUFDb0Y7Z0JBQ3BCRyxxQkFBcUJILENBQUFBLDBCQUFBQSxvQ0FBQUEsY0FBZTNHLE1BQU0sS0FBSTtnQkFDOUMrRyxzQkFBc0JKLENBQUFBLDBCQUFBQSxvQ0FBQUEsY0FBZXpHLFNBQVMsQ0FBQyxHQUFHLFNBQVE7WUFDNUQ7WUFFQSxxQkFBcUI7WUFDckIsTUFBTUwsS0FBSyxHQUFvRHhCLE9BQWpERixLQUFLNkksV0FBVyxHQUFHNUksT0FBTyxDQUFDLGNBQWMsTUFBSyxLQUFjLE9BQVhDLEtBQUs0SSxHQUFHO1lBQ3ZFLE1BQU0zRixXQUFXLEdBQVVyRCxPQUFQRSxNQUE4QixPQUF2QkYsaUJBQWlCRDtZQUM1QyxNQUFNa0osV0FBV1IsYUFBYSxjQUFjLG9CQUFvQjtZQUVoRSx3REFBd0Q7WUFDeEQsTUFBTVMsY0FBY1IsaUJBQWlCekksa0JBQWtCRixNQUFNRztZQUU3RHdCLFFBQVFDLEdBQUcsQ0FBQywwQkFBMEI7Z0JBQ3BDMEI7Z0JBQ0F4QixlQUFlcUgsWUFBWW5ILE1BQU07Z0JBQ2pDQyxnQkFBZ0JrSCxZQUFZakgsU0FBUyxDQUFDLEdBQUc7Z0JBQ3pDa0gsVUFBVSxDQUFDLENBQUNUO1lBQ2Q7WUFFQSxrQkFBa0I7WUFDbEIsTUFBTUUsVUFBdUI7Z0JBQzNCaEg7Z0JBQ0ExQixNQUFNbUQ7Z0JBQ04rRixNQUFNdEosWUFBWUM7Z0JBQ2xCQTtnQkFDQTBJO2dCQUNBM0csU0FBU29IO2dCQUNUekYsVUFBVSxHQUFlSixPQUFaNEYsVUFBUyxLQUFZLE9BQVQ1RjtnQkFDekJnRyxXQUFXLElBQUlqSjtnQkFDZnlHLFlBQVksSUFBSXpHO2dCQUNoQmdJO2dCQUNBZCxRQUFRO29CQUFDO29CQUFZO29CQUFVO29CQUFhO2lCQUFJLENBQUMzRSxRQUFRLENBQUM1QyxRQUFRLFVBQVUyRDtZQUM5RTtZQUVBLCtEQUErRDtZQUMvRCxJQUFJK0UsYUFBYSxhQUFhO2dCQUM1QjlILElBQUk7b0JBQ0ZLLGdCQUFnQjsyQkFBSUE7d0JBQWdCNEg7cUJBQVE7b0JBQzVDdkgsdUJBQXVCO2dCQUN6QjtZQUNGLE9BQU87Z0JBQ0xWLElBQUk7b0JBQ0ZJLGNBQWM7MkJBQUlBO3dCQUFjNkg7cUJBQVE7b0JBQ3hDeEgsc0JBQXNCO2dCQUN4QjtZQUNGO1lBRUFNLFFBQVFDLEdBQUcsQ0FBQyw4Q0FBOEM7Z0JBQ3hEeUIsUUFBUXhCO2dCQUNSeUIsVUFBVUE7Z0JBQ1Z4QixlQUFlK0csRUFBQUEsbUJBQUFBLFFBQVE5RyxPQUFPLGNBQWY4Ryx1Q0FBQUEsaUJBQWlCN0csTUFBTSxLQUFJO2dCQUMxQ3VILFlBQVksQ0FBQyxDQUFDVixRQUFROUcsT0FBTztZQUMvQjtZQUVBLDRFQUE0RTtZQUM1RXlILFdBQVc7Z0JBQ1Q3SCxRQUFRQyxHQUFHLENBQUMseUNBQXlDQztnQkFDckRoQixNQUFNWSxPQUFPLENBQUNvSDtZQUNoQixHQUFHO1lBRUhsSCxRQUFRQyxHQUFHLENBQUMsaUNBQWlDO2dCQUMzQ3lCLFFBQVF4QjtnQkFDUnlCLFVBQVVBO1lBQ1o7WUFFQSxtREFBbUQ7WUFDbkQsb0RBQW9EO1lBQ3BELElBQUksQ0FBQ3NGLFVBQVU7Z0JBQ2IsSUFBSTtvQkFDRiw2Q0FBNkM7b0JBQzdDakgsUUFBUUMsR0FBRyxDQUFDLDBFQUEwRWlIO2dCQUV0RiwwQ0FBMEM7Z0JBQzFDLHdCQUF3QjtnQkFDeEIsa0JBQWtCO2dCQUNsQix3REFBd0Q7Z0JBQ3hELGlFQUFpRTtnQkFDakUsNERBQTREO2dCQUM1RCwwQ0FBMEM7Z0JBQzFDLElBQUk7Z0JBRUosc0RBQXNEO2dCQUN0RCw2Q0FBNkM7Z0JBQzdDLHVDQUF1QztnQkFDdkMsMkRBQTJEO2dCQUMzRCxpQkFBaUI7Z0JBQ2pCLHVCQUF1QjtnQkFDdkIsbUVBQW1FO2dCQUNuRSxTQUFTO2dCQUNULFNBQVM7Z0JBQ1QsSUFBSTtnQkFFTixFQUFFLE9BQU9ySCxPQUFPO29CQUNkRyxRQUFRSCxLQUFLLENBQUMsb0NBQW9DQTtnQkFDcEQ7WUFDRixPQUFPO2dCQUNMRyxRQUFRQyxHQUFHLENBQUMsc0RBQXNEaUgsUUFBUTFJLElBQUk7WUFDaEY7WUFFQSxnREFBZ0Q7WUFDaEQsT0FBTzBCO1FBQ1Q7UUFFQTRILGNBQWMsQ0FBQ3RKLE1BQWN1SSxVQUFtQ1A7WUFDOUQsTUFBTSxFQUFFakgsY0FBYyxFQUFFQyxnQkFBZ0IsRUFBRWlILG9CQUFvQixFQUFFLEdBQUd2SDtZQUVuRSxnREFBZ0Q7WUFDaEQsTUFBTTZJLGtCQUFrQmhCLGFBQWEsY0FBY3ZILG1CQUFtQkQ7WUFDdEUsTUFBTXlJLGlCQUFpQkQsZ0JBQWdCcEgsSUFBSSxDQUFDaUcsQ0FBQUEsU0FDMUNBLE9BQU9wSSxJQUFJLENBQUM2SSxXQUFXLE9BQU83SSxLQUFLNkksV0FBVztZQUdoRCxJQUFJVyxnQkFBZ0I7Z0JBQ2xCLDBEQUEwRDtnQkFDMUQsSUFBSXhCLFlBQVksQ0FBQ3dCLGVBQWV4QixRQUFRLEVBQUU7b0JBQ3hDeEcsUUFBUUMsR0FBRyxDQUFDLDZCQUFzRHVHLE9BQXpCaEksTUFBSyxzQkFBNkIsT0FBVGdJO29CQUNsRUMscUJBQXFCdUIsZUFBZTlILEVBQUUsRUFBRXNHO2dCQUMxQyxPQUFPO29CQUNMeEcsUUFBUUMsR0FBRyxDQUFDLFdBQXNDOEcsT0FBM0J2SSxNQUFLLHdCQUErQixPQUFUdUksVUFBUztnQkFDN0Q7Z0JBQ0E7WUFDRjtZQUVBLCtGQUErRjtZQUMvRixJQUFJa0I7WUFDSixJQUFJLE9BQU9DLFdBQVcsZUFBZUEsT0FBT0MsVUFBVSxFQUFFO2dCQUN0REYsV0FBVyxVQUEyREMsT0FBakQxSixLQUFLNkksV0FBVyxHQUFHNUksT0FBTyxDQUFDLGNBQWMsTUFBSyxLQUF1QixPQUFwQnlKLE9BQU9DLFVBQVU7WUFDekYsT0FBTztnQkFDTCxzREFBc0Q7Z0JBQ3RELE1BQU1DLFlBQVkxSixLQUFLNEksR0FBRztnQkFDMUIsTUFBTWUsU0FBUzlHLEtBQUs4RyxNQUFNLEdBQUdDLFFBQVEsQ0FBQyxJQUFJL0gsU0FBUyxDQUFDLEdBQUc7Z0JBQ3ZELE1BQU1nSSxVQUFVaEgsS0FBS2lILEtBQUssQ0FBQ2pILEtBQUs4RyxNQUFNLEtBQUs7Z0JBQzNDSixXQUFXLFVBQTJERyxPQUFqRDVKLEtBQUs2SSxXQUFXLEdBQUc1SSxPQUFPLENBQUMsY0FBYyxNQUFLLEtBQWdCNEosT0FBYkQsV0FBVSxLQUFhRyxPQUFWRixRQUFPLEtBQVcsT0FBUkU7WUFDL0Y7WUFFQSwwREFBMEQ7WUFDMUQsTUFBTUUsYUFBYTttQkFBSWxKO21CQUFtQkM7YUFBaUI7WUFDM0QsTUFBT2lKLFdBQVd2RixJQUFJLENBQUMwRCxDQUFBQSxTQUFVQSxPQUFPMUcsRUFBRSxLQUFLK0gsVUFBVztnQkFDeEQsTUFBTVMsZUFBZW5ILEtBQUs4RyxNQUFNLEdBQUdDLFFBQVEsQ0FBQyxJQUFJL0gsU0FBUyxDQUFDLEdBQUc7Z0JBQzdEMEgsV0FBVyxHQUFlUyxPQUFaVCxVQUFTLEtBQWdCLE9BQWJTO1lBQzVCO1lBRUEsb0JBQW9CO1lBQ3BCLE1BQU1DLFlBQTJCO2dCQUMvQnpJLElBQUkrSDtnQkFDSnpKO2dCQUNBdUk7Z0JBQ0FZLFdBQVcsSUFBSWpKO2dCQUNmOEg7WUFDRjtZQUVBLGlFQUFpRTtZQUNqRSxJQUFJTyxhQUFhLGFBQWE7Z0JBQzVCOUgsSUFBSTtvQkFDRk8sa0JBQWtCO3dCQUFDbUo7MkJBQWNuSjtxQkFBaUI7b0JBQ2xERyx1QkFBdUI7Z0JBQ3pCO1lBQ0YsT0FBTztnQkFDTFYsSUFBSTtvQkFDRk0sZ0JBQWdCO3dCQUFDb0o7MkJBQWNwSjtxQkFBZTtvQkFDOUNHLHNCQUFzQjtnQkFDeEI7WUFDRjtRQUNGO1FBRUEsc0RBQXNEO1FBQ3REa0oseUJBQXlCO1lBQ3ZCLE1BQU0sRUFBRXJKLGNBQWMsRUFBRUMsZ0JBQWdCLEVBQUUsR0FBR047WUFFN0MsZ0RBQWdEO1lBQ2hELE1BQU0ySixpQkFBaUIsQ0FBQ0M7Z0JBQ3RCLE1BQU1DLE9BQU8sSUFBSUM7Z0JBQ2pCLE1BQU1DLFVBQVVILFFBQVExSCxNQUFNLENBQUN3RixDQUFBQTtvQkFDN0Isa0RBQWtEO29CQUNsRCxJQUFJQSxPQUFPMUcsRUFBRSxDQUFDZSxRQUFRLENBQUMsK0JBQStCO3dCQUNwRGpCLFFBQVFDLEdBQUcsQ0FBQyw2Q0FBaUQyRyxPQUFkQSxPQUFPMUcsRUFBRSxFQUFDLE1BQWdCLE9BQVowRyxPQUFPcEksSUFBSSxFQUFDO3dCQUN6RSxPQUFPO29CQUNUO29CQUVBLHVCQUF1QjtvQkFDdkIsSUFBSXVLLEtBQUtHLEdBQUcsQ0FBQ3RDLE9BQU8xRyxFQUFFLEdBQUc7d0JBQ3ZCRixRQUFRQyxHQUFHLENBQUMsMkNBQStDMkcsT0FBZEEsT0FBTzFHLEVBQUUsRUFBQyxNQUFnQixPQUFaMEcsT0FBT3BJLElBQUksRUFBQzt3QkFDdkUsT0FBTztvQkFDVDtvQkFFQXVLLEtBQUtJLEdBQUcsQ0FBQ3ZDLE9BQU8xRyxFQUFFO29CQUNsQixPQUFPO2dCQUNUO2dCQUVBLDZEQUE2RDtnQkFDN0QsT0FBTytJLFFBQVFuSSxHQUFHLENBQUM4RixDQUFBQTtvQkFDakIsSUFBSUEsT0FBTzFHLEVBQUUsQ0FBQ2tKLFVBQVUsQ0FBQyxvQkFBb0J4QyxPQUFPMUcsRUFBRSxDQUFDRyxNQUFNLEdBQUcsSUFBSTt3QkFDbEUsTUFBTWdKLFFBQVEsT0FBT25CLFdBQVcsZUFBZUEsT0FBT0MsVUFBVSxHQUM1RCxVQUFrRUQsT0FBeER0QixPQUFPcEksSUFBSSxDQUFDNkksV0FBVyxHQUFHNUksT0FBTyxDQUFDLGNBQWMsTUFBSyxLQUF1QixPQUFwQnlKLE9BQU9DLFVBQVUsTUFDbkYsVUFBa0V6SixPQUF4RGtJLE9BQU9wSSxJQUFJLENBQUM2SSxXQUFXLEdBQUc1SSxPQUFPLENBQUMsY0FBYyxNQUFLLEtBQWlCOEMsT0FBZDdDLEtBQUs0SSxHQUFHLElBQUcsS0FBK0MsT0FBNUMvRixLQUFLOEcsTUFBTSxHQUFHQyxRQUFRLENBQUMsSUFBSS9ILFNBQVMsQ0FBQyxHQUFHO3dCQUU1SFAsUUFBUUMsR0FBRyxDQUFDLDRDQUFpRG9KLE9BQWZ6QyxPQUFPMUcsRUFBRSxFQUFDLE9BQWUwRyxPQUFWeUMsT0FBTSxNQUFnQixPQUFaekMsT0FBT3BJLElBQUksRUFBQzt3QkFFbkYsT0FBTzs0QkFBRSxHQUFHb0ksTUFBTTs0QkFBRTFHLElBQUltSjt3QkFBTTtvQkFDaEM7b0JBQ0EsT0FBT3pDO2dCQUNUO1lBQ0Y7WUFFQSxNQUFNMEMsd0JBQXdCVCxlQUFldEo7WUFDN0MsTUFBTWdLLDBCQUEwQlYsZUFBZXJKO1lBRS9DLElBQUk4SixzQkFBc0JqSixNQUFNLEtBQUtkLGVBQWVjLE1BQU0sSUFDdERrSix3QkFBd0JsSixNQUFNLEtBQUtiLGlCQUFpQmEsTUFBTSxFQUFFO2dCQUM5REwsUUFBUUMsR0FBRyxDQUFDO2dCQUNaaEIsSUFBSTtvQkFDRk0sZ0JBQWdCK0o7b0JBQ2hCOUosa0JBQWtCK0o7Z0JBQ3BCO1lBQ0Y7UUFDRjtRQUVBQyxZQUFZLENBQUM5SDtZQUNYLE1BQU0sRUFBRXJDLFlBQVksRUFBRUMsY0FBYyxFQUFFSCxRQUFRLEVBQUUsR0FBR0Q7WUFFbkQseUNBQXlDO1lBQ3pDLE1BQU1nRyxzQkFBc0I3RixhQUFhK0IsTUFBTSxDQUFDLENBQUNyQixPQUFzQkEsS0FBS0csRUFBRSxLQUFLd0I7WUFDbkYsTUFBTTBELHdCQUF3QjlGLGVBQWU4QixNQUFNLENBQUMsQ0FBQ3JCLE9BQXNCQSxLQUFLRyxFQUFFLEtBQUt3QjtZQUV2Rix5QkFBeUI7WUFDekIsTUFBTStILGFBQWF0SyxTQUFTd0IsSUFBSSxDQUFDLENBQUNDLE1BQW1CQSxJQUFJVixFQUFFLEtBQUt3QjtZQUNoRSxJQUFJK0gsWUFBWTtnQkFDZHZLLE1BQU1zRCxRQUFRLENBQUNkO1lBQ2pCO1lBRUF6QyxJQUFJO2dCQUNGSSxjQUFjNkY7Z0JBQ2Q1RixnQkFBZ0I4RjtZQUNsQjtRQUNGO1FBRUFzRSxZQUFZLENBQUNoSSxRQUFnQmlJO1lBQzNCLE1BQU0sRUFBRXRLLFlBQVksRUFBRUMsY0FBYyxFQUFFSCxRQUFRLEVBQUUsR0FBR0Q7WUFFbkQseUVBQXlFO1lBQ3pFLE1BQU0wSyxjQUFjdkssYUFBYXNCLElBQUksQ0FBQyxDQUFDWixPQUFzQkEsS0FBS0csRUFBRSxLQUFLd0I7WUFDekUsTUFBTW1JLGdCQUFnQnZLLGVBQWVxQixJQUFJLENBQUMsQ0FBQ1osT0FBc0JBLEtBQUtHLEVBQUUsS0FBS3dCO1lBQzdFLE1BQU0zQixPQUFPNkosZUFBZUM7WUFFNUIsSUFBSSxDQUFDOUosTUFBTTtZQUVYLG1EQUFtRDtZQUNuRCxNQUFNK0osY0FBYyxHQUFheEwsT0FBVnFMLFNBQXNDLE9BQTVCckwsaUJBQWlCeUIsS0FBSzFCLElBQUk7WUFDM0QsTUFBTWtKLFdBQVd4SCxLQUFLZ0gsUUFBUSxLQUFLLGNBQWMsb0JBQW9CO1lBQ3JFLE1BQU1nRCxjQUFjLEdBQWVELE9BQVp2QyxVQUFTLEtBQWUsT0FBWnVDO1lBRW5DLHVDQUF1QztZQUN2QyxNQUFNNUUsc0JBQXNCN0YsYUFBYXlCLEdBQUcsQ0FBQyxDQUFDaUUsSUFDNUNBLEVBQUU3RSxFQUFFLEtBQUt3QixTQUNMO29CQUFFLEdBQUdxRCxDQUFDO29CQUFFdkcsTUFBTXNMO29CQUFhL0gsVUFBVWdJO29CQUFhNUUsWUFBWSxJQUFJekc7Z0JBQU8sSUFDekVxRztZQUdOLE1BQU1LLHdCQUF3QjlGLGVBQWV3QixHQUFHLENBQUMsQ0FBQ2lFLElBQ2hEQSxFQUFFN0UsRUFBRSxLQUFLd0IsU0FDTDtvQkFBRSxHQUFHcUQsQ0FBQztvQkFBRXZHLE1BQU1zTDtvQkFBYS9ILFVBQVVnSTtvQkFBYTVFLFlBQVksSUFBSXpHO2dCQUFPLElBQ3pFcUc7WUFHTix1Q0FBdUM7WUFDdkMsTUFBTWxFLGNBQWMxQixTQUFTMkIsR0FBRyxDQUFDLENBQUNGLE1BQ2hDQSxJQUFJVixFQUFFLEtBQUt3QixTQUNQO29CQUFFLEdBQUdkLEdBQUc7b0JBQUVwQyxNQUFNc0w7b0JBQWEvSCxVQUFVZ0k7b0JBQWFqSSxVQUFVO2dCQUFLLElBQ25FbEI7WUFHTjNCLElBQUk7Z0JBQ0ZJLGNBQWM2RjtnQkFDZDVGLGdCQUFnQjhGO2dCQUNoQmpHLFVBQVUwQjtZQUNaO1FBQ0Y7UUFFQW1KLGNBQWMsQ0FBQ3RELFVBQWtCaUQ7WUFDL0IsTUFBTSxFQUFFcEssY0FBYyxFQUFFQyxnQkFBZ0IsRUFBRSxHQUFHTjtZQUU3Qyx5Q0FBeUM7WUFDekMsTUFBTXlILHdCQUF3QnBILGVBQWV1QixHQUFHLENBQUMsQ0FBQzhGLFNBQ2hEQSxPQUFPMUcsRUFBRSxLQUFLd0csV0FDVjtvQkFBRSxHQUFHRSxNQUFNO29CQUFFcEksTUFBTW1MO2dCQUFRLElBQzNCL0M7WUFHTixNQUFNQywwQkFBMEJySCxpQkFBaUJzQixHQUFHLENBQUMsQ0FBQzhGLFNBQ3BEQSxPQUFPMUcsRUFBRSxLQUFLd0csV0FDVjtvQkFBRSxHQUFHRSxNQUFNO29CQUFFcEksTUFBTW1MO2dCQUFRLElBQzNCL0M7WUFHTjNILElBQUk7Z0JBQ0ZNLGdCQUFnQm9IO2dCQUNoQm5ILGtCQUFrQnFIO1lBQ3BCO1FBQ0Y7UUFFQW9ELGNBQWMsQ0FBQ3ZEO1lBQ2IsTUFBTSxFQUFFbkgsY0FBYyxFQUFFQyxnQkFBZ0IsRUFBRUgsWUFBWSxFQUFFQyxjQUFjLEVBQUVILFFBQVEsRUFBRSxHQUFHRDtZQUVyRiwwQ0FBMEM7WUFDMUMsTUFBTWdMLGdCQUFnQjttQkFDakI3SyxhQUFhK0IsTUFBTSxDQUFDLENBQUNyQixPQUFzQkEsS0FBSzJHLFFBQVEsS0FBS0E7bUJBQzdEcEgsZUFBZThCLE1BQU0sQ0FBQyxDQUFDckIsT0FBc0JBLEtBQUsyRyxRQUFRLEtBQUtBO2FBQ25FO1lBRUQsMENBQTBDO1lBQzFDd0QsY0FBY0MsT0FBTyxDQUFDLENBQUNwSztnQkFDckIsTUFBTTBKLGFBQWF0SyxTQUFTd0IsSUFBSSxDQUFDLENBQUNDLE1BQW1CQSxJQUFJVixFQUFFLEtBQUtILEtBQUtHLEVBQUU7Z0JBQ3ZFLElBQUl1SixZQUFZO29CQUNkdkssTUFBTXNELFFBQVEsQ0FBQ3pDLEtBQUtHLEVBQUU7Z0JBQ3hCO1lBQ0Y7WUFFQSx1Q0FBdUM7WUFDdkMsTUFBTXlHLHdCQUF3QnBILGVBQWU2QixNQUFNLENBQUMsQ0FBQ3dGLFNBQTBCQSxPQUFPMUcsRUFBRSxLQUFLd0c7WUFDN0YsTUFBTUcsMEJBQTBCckgsaUJBQWlCNEIsTUFBTSxDQUFDLENBQUN3RixTQUEwQkEsT0FBTzFHLEVBQUUsS0FBS3dHO1lBRWpHLGlEQUFpRDtZQUNqRCxNQUFNeEIsc0JBQXNCN0YsYUFBYStCLE1BQU0sQ0FBQyxDQUFDckIsT0FBc0JBLEtBQUsyRyxRQUFRLEtBQUtBO1lBQ3pGLE1BQU10Qix3QkFBd0I5RixlQUFlOEIsTUFBTSxDQUFDLENBQUNyQixPQUFzQkEsS0FBSzJHLFFBQVEsS0FBS0E7WUFFN0Z6SCxJQUFJO2dCQUNGTSxnQkFBZ0JvSDtnQkFDaEJuSCxrQkFBa0JxSDtnQkFDbEJ4SCxjQUFjNkY7Z0JBQ2Q1RixnQkFBZ0I4RjtZQUNsQjtRQUNGO1FBRUFnRixhQUFhLENBQUNDLE1BQW1DaE07WUFDL0MsTUFBTSxFQUFFb0IsVUFBVSxFQUFFSixZQUFZLEVBQUVDLGNBQWMsRUFBRUMsY0FBYyxFQUFFQyxnQkFBZ0IsRUFBRUwsUUFBUSxFQUFFLEdBQUdEO1lBRWpHLG9CQUFvQjtZQUNwQixNQUFNb0wsWUFBdUI7Z0JBQzNCcEssSUFBSSxTQUFvQnhCLE9BQVgyTCxLQUFLbkssRUFBRSxFQUFDLEtBQWMsT0FBWHhCLEtBQUs0SSxHQUFHO2dCQUNoQzlJLE1BQU02TCxLQUFLN0wsSUFBSTtnQkFDZkg7Z0JBQ0FrTSxjQUFjRjtnQkFDZEcsV0FBVyxJQUFJOUw7Z0JBQ2ZxSSxVQUFVc0QsS0FBS3RELFFBQVE7WUFDekI7WUFFQSxJQUFJMUksU0FBUyxRQUFRO2dCQUNuQixNQUFNMEIsT0FBT3NLO2dCQUViLHlCQUF5QjtnQkFDekIsTUFBTVosYUFBYXRLLFNBQVN3QixJQUFJLENBQUMsQ0FBQ0MsTUFBbUJBLElBQUlWLEVBQUUsS0FBS0gsS0FBS0csRUFBRTtnQkFDdkUsSUFBSXVKLFlBQVk7b0JBQ2R2SyxNQUFNc0QsUUFBUSxDQUFDekMsS0FBS0csRUFBRTtnQkFDeEI7Z0JBRUEscUNBQXFDO2dCQUNyQyxNQUFNZ0Ysc0JBQXNCN0YsYUFBYStCLE1BQU0sQ0FBQyxDQUFDMkQsSUFBbUJBLEVBQUU3RSxFQUFFLEtBQUtILEtBQUtHLEVBQUU7Z0JBQ3BGLE1BQU1rRix3QkFBd0I5RixlQUFlOEIsTUFBTSxDQUFDLENBQUMyRCxJQUFtQkEsRUFBRTdFLEVBQUUsS0FBS0gsS0FBS0csRUFBRTtnQkFFeEZqQixJQUFJO29CQUNGUSxZQUFZOzJCQUFJQTt3QkFBWTZLO3FCQUFVO29CQUN0Q2pMLGNBQWM2RjtvQkFDZDVGLGdCQUFnQjhGO2dCQUNsQjtZQUNGLE9BQU87Z0JBQ0wsTUFBTXdCLFNBQVN5RDtnQkFFZixxRUFBcUU7Z0JBQ3JFLE1BQU1JLGVBQWU7dUJBQ2hCcEwsYUFBYStCLE1BQU0sQ0FBQyxDQUFDckIsT0FBc0JBLEtBQUsyRyxRQUFRLEtBQUtFLE9BQU8xRyxFQUFFO3VCQUN0RVosZUFBZThCLE1BQU0sQ0FBQyxDQUFDckIsT0FBc0JBLEtBQUsyRyxRQUFRLEtBQUtFLE9BQU8xRyxFQUFFO2lCQUM1RTtnQkFFRCwwQ0FBMEM7Z0JBQzFDdUssYUFBYU4sT0FBTyxDQUFDLENBQUNwSztvQkFDcEIsTUFBTTBKLGFBQWF0SyxTQUFTd0IsSUFBSSxDQUFDLENBQUNDLE1BQW1CQSxJQUFJVixFQUFFLEtBQUtILEtBQUtHLEVBQUU7b0JBQ3ZFLElBQUl1SixZQUFZO3dCQUNkdkssTUFBTXNELFFBQVEsQ0FBQ3pDLEtBQUtHLEVBQUU7b0JBQ3hCO2dCQUNGO2dCQUVBLGlEQUFpRDtnQkFDakQsTUFBTXdLLGlCQUFpQkQsYUFBYTNKLEdBQUcsQ0FBQyxDQUFDZixPQUF1Qjt3QkFDOURHLElBQUksU0FBb0J4QixPQUFYcUIsS0FBS0csRUFBRSxFQUFDLEtBQWMsT0FBWHhCLEtBQUs0SSxHQUFHO3dCQUNoQzlJLE1BQU11QixLQUFLdkIsSUFBSTt3QkFDZkgsTUFBTTt3QkFDTmtNLGNBQWN4Szt3QkFDZHlLLFdBQVcsSUFBSTlMO3dCQUNmcUksVUFBVWhILEtBQUtnSCxRQUFRO29CQUN6QjtnQkFFQSwwQ0FBMEM7Z0JBQzFDLE1BQU1KLHdCQUF3QnBILGVBQWU2QixNQUFNLENBQUMsQ0FBQzJELElBQXFCQSxFQUFFN0UsRUFBRSxLQUFLMEcsT0FBTzFHLEVBQUU7Z0JBQzVGLE1BQU0yRywwQkFBMEJySCxpQkFBaUI0QixNQUFNLENBQUMsQ0FBQzJELElBQXFCQSxFQUFFN0UsRUFBRSxLQUFLMEcsT0FBTzFHLEVBQUU7Z0JBQ2hHLE1BQU1nRixzQkFBc0I3RixhQUFhK0IsTUFBTSxDQUFDLENBQUNyQixPQUFzQkEsS0FBSzJHLFFBQVEsS0FBS0UsT0FBTzFHLEVBQUU7Z0JBQ2xHLE1BQU1rRix3QkFBd0I5RixlQUFlOEIsTUFBTSxDQUFDLENBQUNyQixPQUFzQkEsS0FBSzJHLFFBQVEsS0FBS0UsT0FBTzFHLEVBQUU7Z0JBRXRHakIsSUFBSTtvQkFDRlEsWUFBWTsyQkFBSUE7d0JBQVk2SzsyQkFBY0k7cUJBQWU7b0JBQ3pEbkwsZ0JBQWdCb0g7b0JBQ2hCbkgsa0JBQWtCcUg7b0JBQ2xCeEgsY0FBYzZGO29CQUNkNUYsZ0JBQWdCOEY7Z0JBQ2xCO1lBQ0Y7UUFDRjtRQUVBdUYsa0JBQWtCLENBQUNDO1lBQ2pCLE1BQU0sRUFBRW5MLFVBQVUsRUFBRUosWUFBWSxFQUFFQyxjQUFjLEVBQUVDLGNBQWMsRUFBRUMsZ0JBQWdCLEVBQUUsR0FBR047WUFFdkYsTUFBTW9MLFlBQVk3SyxXQUFXa0IsSUFBSSxDQUFDMEosQ0FBQUEsT0FBUUEsS0FBS25LLEVBQUUsS0FBSzBLO1lBQ3RELElBQUksQ0FBQ04sV0FBVztZQUVoQixvQkFBb0I7WUFDcEIsTUFBTU8sb0JBQW9CcEwsV0FBVzJCLE1BQU0sQ0FBQ2lKLENBQUFBLE9BQVFBLEtBQUtuSyxFQUFFLEtBQUswSztZQUVoRSwrQkFBK0I7WUFDL0IsSUFBSU4sVUFBVWpNLElBQUksS0FBSyxRQUFRO2dCQUM3QixNQUFNMEIsT0FBT3VLLFVBQVVDLFlBQVk7Z0JBQ25DLElBQUl4SyxLQUFLZ0gsUUFBUSxLQUFLLFdBQVc7b0JBQy9COUgsSUFBSTt3QkFDRlEsWUFBWW9MO3dCQUNaeEwsY0FBYzsrQkFBSUE7NEJBQWM7Z0NBQUUsR0FBR1UsSUFBSTtnQ0FBRW9GLFlBQVksSUFBSXpHOzRCQUFPO3lCQUFFO29CQUN0RTtnQkFDRixPQUFPO29CQUNMTyxJQUFJO3dCQUNGUSxZQUFZb0w7d0JBQ1p2TCxnQkFBZ0I7K0JBQUlBOzRCQUFnQjtnQ0FBRSxHQUFHUyxJQUFJO2dDQUFFb0YsWUFBWSxJQUFJekc7NEJBQU87eUJBQUU7b0JBQzFFO2dCQUNGO1lBQ0YsT0FBTztnQkFDTCxNQUFNa0ksU0FBUzBELFVBQVVDLFlBQVk7Z0JBQ3JDLElBQUkzRCxPQUFPRyxRQUFRLEtBQUssV0FBVztvQkFDakM5SCxJQUFJO3dCQUNGUSxZQUFZb0w7d0JBQ1p0TCxnQkFBZ0I7K0JBQUlBOzRCQUFnQnFIO3lCQUFPO29CQUM3QztnQkFDRixPQUFPO29CQUNMM0gsSUFBSTt3QkFDRlEsWUFBWW9MO3dCQUNackwsa0JBQWtCOytCQUFJQTs0QkFBa0JvSDt5QkFBTztvQkFDakQ7Z0JBQ0Y7WUFDRjtRQUNGO1FBRUFrRSxtQkFBbUIsQ0FBQ0Y7WUFDbEIsTUFBTSxFQUFFbkwsVUFBVSxFQUFFLEdBQUdQO1lBRXZCLGdDQUFnQztZQUNoQyxNQUFNMkwsb0JBQW9CcEwsV0FBVzJCLE1BQU0sQ0FBQ2lKLENBQUFBLE9BQVFBLEtBQUtuSyxFQUFFLEtBQUswSztZQUNoRTNMLElBQUk7Z0JBQUVRLFlBQVlvTDtZQUFrQjtRQUN0QztRQUVBRSxZQUFZO1lBQ1Y5TCxJQUFJO2dCQUFFUSxZQUFZLEVBQUU7WUFBQztRQUN2QjtRQUVBdUwsc0JBQXNCO1lBQ3BCLE1BQU0sRUFBRTdMLFFBQVEsRUFBRSxHQUFHRDtZQUVyQixpQ0FBaUM7WUFDakMsTUFBTStMLGdCQUFnQjlMLFNBQ25CaUMsTUFBTSxDQUFDLENBQUNSO2dCQUNQLG9EQUFvRDtnQkFDcEQsTUFBTSxFQUFFdkIsWUFBWSxFQUFFLEdBQUdIO2dCQUN6QixNQUFNYSxPQUFPVixhQUFhc0IsSUFBSSxDQUFDLENBQUNvRSxJQUFtQkEsRUFBRTdFLEVBQUUsS0FBS1UsSUFBSVYsRUFBRTtnQkFDbEUsT0FBT0gsQ0FBQUEsaUJBQUFBLDJCQUFBQSxLQUFNZ0gsUUFBUSxNQUFLO1lBQzVCLEdBQ0NqRyxHQUFHLENBQUMsQ0FBQ0YsTUFBbUJBLElBQUlWLEVBQUU7WUFFakMrSyxjQUFjZCxPQUFPLENBQUMsQ0FBQzFILFFBQWtCdkQsTUFBTXNELFFBQVEsQ0FBQ0M7WUFFeEQsc0NBQXNDO1lBQ3RDeEQsSUFBSTtnQkFDRkksY0FBYyxFQUFFO2dCQUNoQkUsZ0JBQWdCLEVBQUU7WUFDcEI7UUFDRjtRQUVBMkwsd0JBQXdCO1lBQ3RCLE1BQU0sRUFBRS9MLFFBQVEsRUFBRSxHQUFHRDtZQUVyQixtQ0FBbUM7WUFDbkMsTUFBTWlNLGtCQUFrQmhNLFNBQ3JCaUMsTUFBTSxDQUFDLENBQUNSO2dCQUNQLG9EQUFvRDtnQkFDcEQsTUFBTSxFQUFFdEIsY0FBYyxFQUFFLEdBQUdKO2dCQUMzQixNQUFNYSxPQUFPVCxlQUFlcUIsSUFBSSxDQUFDLENBQUNvRSxJQUFtQkEsRUFBRTdFLEVBQUUsS0FBS1UsSUFBSVYsRUFBRTtnQkFDcEUsT0FBT0gsQ0FBQUEsaUJBQUFBLDJCQUFBQSxLQUFNZ0gsUUFBUSxNQUFLO1lBQzVCLEdBQ0NqRyxHQUFHLENBQUMsQ0FBQ0YsTUFBbUJBLElBQUlWLEVBQUU7WUFFakNpTCxnQkFBZ0JoQixPQUFPLENBQUMsQ0FBQzFILFFBQWtCdkQsTUFBTXNELFFBQVEsQ0FBQ0M7WUFFMUQsd0NBQXdDO1lBQ3hDeEQsSUFBSTtnQkFDRkssZ0JBQWdCLEVBQUU7Z0JBQ2xCRSxrQkFBa0IsRUFBRTtZQUN0QjtRQUNGO1FBRUE0TCx3QkFBd0I7WUFDdEJsTSxNQUFNOEwsb0JBQW9CO1lBQzFCL0wsSUFBSTtnQkFBRVMsc0JBQXNCO1lBQU07UUFDcEM7UUFFQTJMLHlCQUF5QjtZQUN2Qm5NLE1BQU1nTSxzQkFBc0I7WUFDNUJqTSxJQUFJO2dCQUFFVSx1QkFBdUI7WUFBTTtRQUNyQztRQUVBMkwsdUJBQXVCLENBQUM1SCxXQUFtQkM7WUFDekMsTUFBTSxFQUFFcEUsY0FBYyxFQUFFLEdBQUdMO1lBQzNCLE1BQU1xTSxhQUFhO21CQUFJaE07YUFBZTtZQUN0QyxNQUFNLENBQUNpTSxZQUFZLEdBQUdELFdBQVduSixNQUFNLENBQUNzQixXQUFXO1lBQ25ENkgsV0FBV25KLE1BQU0sQ0FBQ3VCLFNBQVMsR0FBRzZIO1lBRTlCdk0sSUFBSTtnQkFBRU0sZ0JBQWdCZ007WUFBVztRQUNuQztRQUVBRSxzQkFBc0IsQ0FBQzNDO1lBQ3JCN0osSUFBSTtnQkFBRU0sZ0JBQWdCdUo7WUFBUTtRQUNoQztRQUVBNEMsc0JBQXNCLENBQUNoRixVQUFrQmhELFdBQW1CQyxTQUFpQm9EO1lBQzNFLE1BQU0sRUFBRTFILFlBQVksRUFBRUMsY0FBYyxFQUFFLEdBQUdKO1lBRXpDLElBQUk2SCxhQUFhLFdBQVc7Z0JBQzFCLHNDQUFzQztnQkFDdEMsTUFBTTRFLGNBQWN0TSxhQUFhK0IsTUFBTSxDQUFDckIsQ0FBQUEsT0FBUUEsS0FBSzJHLFFBQVEsS0FBS0E7Z0JBQ2xFLE1BQU1rRixhQUFhdk0sYUFBYStCLE1BQU0sQ0FBQ3JCLENBQUFBLE9BQVFBLEtBQUsyRyxRQUFRLEtBQUtBO2dCQUVqRSxrQ0FBa0M7Z0JBQ2xDLE1BQU1tRix1QkFBdUI7dUJBQUlGO2lCQUFZO2dCQUM3QyxNQUFNLENBQUNHLFVBQVUsR0FBR0QscUJBQXFCekosTUFBTSxDQUFDc0IsV0FBVztnQkFDM0RtSSxxQkFBcUJ6SixNQUFNLENBQUN1QixTQUFTLEdBQUdtSTtnQkFFeEMsMkJBQTJCO2dCQUMzQixNQUFNQyxrQkFBa0I7dUJBQUlIO3VCQUFlQztpQkFBcUI7Z0JBQ2hFNU0sSUFBSTtvQkFBRUksY0FBYzBNO2dCQUFnQjtZQUN0QyxPQUFPO2dCQUNMLG9DQUFvQztnQkFDcEMsTUFBTUosY0FBY3JNLGVBQWU4QixNQUFNLENBQUNyQixDQUFBQSxPQUFRQSxLQUFLMkcsUUFBUSxLQUFLQTtnQkFDcEUsTUFBTWtGLGFBQWF0TSxlQUFlOEIsTUFBTSxDQUFDckIsQ0FBQUEsT0FBUUEsS0FBSzJHLFFBQVEsS0FBS0E7Z0JBRW5FLE1BQU1tRix1QkFBdUI7dUJBQUlGO2lCQUFZO2dCQUM3QyxNQUFNLENBQUNHLFVBQVUsR0FBR0QscUJBQXFCekosTUFBTSxDQUFDc0IsV0FBVztnQkFDM0RtSSxxQkFBcUJ6SixNQUFNLENBQUN1QixTQUFTLEdBQUdtSTtnQkFFeEMsTUFBTUUsb0JBQW9CO3VCQUFJSjt1QkFBZUM7aUJBQXFCO2dCQUNsRTVNLElBQUk7b0JBQUVLLGdCQUFnQjBNO2dCQUFrQjtZQUMxQztRQUNGO1FBRUFDLFVBQVUsQ0FBQ3hKO1lBQ1QsTUFBTSxFQUFFdEQsUUFBUSxFQUFFRSxZQUFZLEVBQUVDLGNBQWMsRUFBRSxHQUFHSjtZQUNuRCxNQUFNMEIsTUFBTXpCLFNBQVN3QixJQUFJLENBQUMsQ0FBQ1UsSUFBaUJBLEVBQUVuQixFQUFFLEtBQUt1QztZQUVyRCxJQUFJLENBQUM3QixLQUFLO1lBRVYsK0NBQStDO1lBQy9DLE1BQU1zRSxzQkFBc0I3RixhQUFheUIsR0FBRyxDQUFDLENBQUNmLE9BQzVDQSxLQUFLRyxFQUFFLEtBQUt1QyxRQUNSO29CQUFFLEdBQUcxQyxJQUFJO29CQUFFSyxTQUFTUSxJQUFJUixPQUFPO29CQUFFK0UsWUFBWSxJQUFJekc7Z0JBQU8sSUFDeERxQjtZQUdOLE1BQU1xRix3QkFBd0I5RixlQUFld0IsR0FBRyxDQUFDLENBQUNmLE9BQ2hEQSxLQUFLRyxFQUFFLEtBQUt1QyxRQUNSO29CQUFFLEdBQUcxQyxJQUFJO29CQUFFSyxTQUFTUSxJQUFJUixPQUFPO29CQUFFK0UsWUFBWSxJQUFJekc7Z0JBQU8sSUFDeERxQjtZQUdOLE1BQU1jLGNBQWMxQixTQUFTMkIsR0FBRyxDQUFDLENBQUNPLElBQ2hDQSxFQUFFbkIsRUFBRSxLQUFLdUMsUUFDTDtvQkFBRSxHQUFHcEIsQ0FBQztvQkFBRVMsVUFBVTtnQkFBTSxJQUN4QlQ7WUFHTnBDLElBQUk7Z0JBQ0ZJLGNBQWM2RjtnQkFDZDVGLGdCQUFnQjhGO2dCQUNoQmpHLFVBQVUwQjtZQUNaO1FBQ0Y7UUFFQXFMLFVBQVUsQ0FBQ3JNO1lBQ1RaLElBQUk7Z0JBQUVZO1lBQU07UUFDZDtRQUVBLG9DQUFvQztRQUNwQ3NNLDJCQUEyQjtZQUN6QixNQUFNLEVBQUU5TSxZQUFZLEVBQUVDLGNBQWMsRUFBRSxHQUFHSjtZQUV6QyxNQUFNa04sdUJBQXVCL00sYUFBYXlCLEdBQUcsQ0FBQ2YsQ0FBQUE7Z0JBQzVDLElBQUksQ0FBQ0EsS0FBS0ssT0FBTyxJQUFJTCxLQUFLSyxPQUFPLENBQUNpTSxJQUFJLE9BQU8sSUFBSTtvQkFDL0MsT0FBTzt3QkFDTCxHQUFHdE0sSUFBSTt3QkFDUEssU0FBUzdCLGtCQUFrQndCLEtBQUsxQixJQUFJLEVBQUUwQixLQUFLdkIsSUFBSTt3QkFDL0MyRyxZQUFZLElBQUl6RztvQkFDbEI7Z0JBQ0Y7Z0JBQ0EsT0FBT3FCO1lBQ1Q7WUFFQSxNQUFNdU0seUJBQXlCaE4sZUFBZXdCLEdBQUcsQ0FBQ2YsQ0FBQUE7Z0JBQ2hELElBQUksQ0FBQ0EsS0FBS0ssT0FBTyxJQUFJTCxLQUFLSyxPQUFPLENBQUNpTSxJQUFJLE9BQU8sSUFBSTtvQkFDL0MsT0FBTzt3QkFDTCxHQUFHdE0sSUFBSTt3QkFDUEssU0FBUzdCLGtCQUFrQndCLEtBQUsxQixJQUFJLEVBQUUwQixLQUFLdkIsSUFBSTt3QkFDL0MyRyxZQUFZLElBQUl6RztvQkFDbEI7Z0JBQ0Y7Z0JBQ0EsT0FBT3FCO1lBQ1Q7WUFFQWQsSUFBSTtnQkFDRkksY0FBYytNO2dCQUNkOU0sZ0JBQWdCZ047WUFDbEI7UUFDRjtRQUVBQyxPQUFPO1lBQ0x0TixJQUFJO2dCQUNGRSxVQUFVLEVBQUU7Z0JBQ1pDLFdBQVc7Z0JBQ1hDLGNBQWNSO2dCQUNkUyxnQkFBZ0JSO2dCQUNoQlMsZ0JBQWdCLEVBQUU7Z0JBQ2xCQyxrQkFBa0IsRUFBRTtnQkFDcEJFLHNCQUFzQjtnQkFDdEJDLHVCQUF1QjtnQkFDdkJDLFdBQVc7Z0JBQ1hDLE9BQU87WUFDVDtRQUNGO1FBRUEsd0VBQXdFO1FBQ3hFMk0sZUFBZTtZQUNidk4sSUFBSTtnQkFDRkUsVUFBVSxFQUFFO2dCQUNaQyxXQUFXO2dCQUNYQyxjQUFjLEVBQUU7Z0JBQ2hCQyxnQkFBZ0IsRUFBRTtnQkFDbEJDLGdCQUFnQixFQUFFO2dCQUNsQkMsa0JBQWtCLEVBQUU7Z0JBQ3BCQyxZQUFZLEVBQUU7Z0JBQ2RDLHNCQUFzQjtnQkFDdEJDLHVCQUF1QjtZQUN6QjtRQUNGO1FBRUEsOERBQThEO1FBQzlEOE0sY0FBYztZQUNaLE1BQU1DLFFBQVF4TjtZQUNkYyxRQUFRQyxHQUFHLENBQUMsMkJBQTJCO2dCQUNyQ1osY0FBY3FOLE1BQU1yTixZQUFZLENBQUNnQixNQUFNO2dCQUN2Q2YsZ0JBQWdCb04sTUFBTXBOLGNBQWMsQ0FBQ2UsTUFBTTtnQkFDM0NkLGdCQUFnQm1OLE1BQU1uTixjQUFjLENBQUNjLE1BQU07Z0JBQzNDYixrQkFBa0JrTixNQUFNbE4sZ0JBQWdCLENBQUNhLE1BQU07Z0JBQy9DWixZQUFZaU4sTUFBTWpOLFVBQVUsQ0FBQ1ksTUFBTTtnQkFDbkNsQixVQUFVdU4sTUFBTXZOLFFBQVEsQ0FBQ2tCLE1BQU07Z0JBQy9CakIsV0FBV3NOLE1BQU10TixTQUFTO2dCQUMxQk0sc0JBQXNCZ04sTUFBTWhOLG9CQUFvQjtnQkFDaERDLHVCQUF1QitNLE1BQU0vTSxxQkFBcUI7WUFDcEQ7WUFFQSxJQUFJK00sTUFBTXJOLFlBQVksQ0FBQ2dCLE1BQU0sR0FBRyxHQUFHO2dCQUNqQ0wsUUFBUUMsR0FBRyxDQUFDO2dCQUNaeU0sTUFBTXJOLFlBQVksQ0FBQzhLLE9BQU8sQ0FBQyxDQUFDcEssTUFBTTRNO29CQUNoQzNNLFFBQVFDLEdBQUcsQ0FBQyxLQUFtQkYsT0FBZDRNLFFBQVEsR0FBRSxNQUFrQjVNLE9BQWRBLEtBQUt2QixJQUFJLEVBQUMsTUFBNkJ1QixPQUF6QkEsS0FBSzFCLElBQUksRUFBQyxpQkFBOEIsT0FBZjBCLEtBQUs0SCxTQUFTO2dCQUN0RjtZQUNGO1lBRUEsSUFBSStFLE1BQU1wTixjQUFjLENBQUNlLE1BQU0sR0FBRyxHQUFHO2dCQUNuQ0wsUUFBUUMsR0FBRyxDQUFDO2dCQUNaeU0sTUFBTXBOLGNBQWMsQ0FBQzZLLE9BQU8sQ0FBQyxDQUFDcEssTUFBTTRNO29CQUNsQzNNLFFBQVFDLEdBQUcsQ0FBQyxLQUFtQkYsT0FBZDRNLFFBQVEsR0FBRSxNQUFrQjVNLE9BQWRBLEtBQUt2QixJQUFJLEVBQUMsTUFBNkJ1QixPQUF6QkEsS0FBSzFCLElBQUksRUFBQyxpQkFBOEIsT0FBZjBCLEtBQUs0SCxTQUFTO2dCQUN0RjtZQUNGO1lBRUEscUJBQXFCO1lBQ3JCLElBQUksS0FBNkIsSUFBSWlGLE9BQU9DLFlBQVksRUFBRTtnQkFDeEQsTUFBTUMsU0FBU0QsYUFBYUUsT0FBTyxDQUFDO2dCQUNwQyxJQUFJRCxRQUFRO3dCQUdNRSw0QkFBQUEsZUFDRUEsOEJBQUFBO29CQUhsQixNQUFNQSxTQUFTQyxLQUFLQyxLQUFLLENBQUNKO29CQUMxQjlNLFFBQVFDLEdBQUcsQ0FBQyxvQkFBb0I7d0JBQzlCWixjQUFjMk4sRUFBQUEsZ0JBQUFBLE9BQU9OLEtBQUssY0FBWk0scUNBQUFBLDZCQUFBQSxjQUFjM04sWUFBWSxjQUExQjJOLGlEQUFBQSwyQkFBNEIzTSxNQUFNLEtBQUk7d0JBQ3BEZixnQkFBZ0IwTixFQUFBQSxpQkFBQUEsT0FBT04sS0FBSyxjQUFaTSxzQ0FBQUEsK0JBQUFBLGVBQWMxTixjQUFjLGNBQTVCME4sbURBQUFBLDZCQUE4QjNNLE1BQU0sS0FBSTt3QkFDeEQ4TSxTQUFTSCxPQUFPRyxPQUFPO29CQUN6QjtnQkFDRixPQUFPO29CQUNMbk4sUUFBUUMsR0FBRyxDQUFDO2dCQUNkO1lBQ0Y7UUFDRjtRQUVBLHFFQUFxRTtRQUNyRW1OLGNBQWM7WUFDWnBOLFFBQVFDLEdBQUcsQ0FBQztZQUVaLHFCQUFxQjtZQUNyQixJQUFJLEtBQTZCLElBQUkyTSxPQUFPQyxZQUFZLEVBQUU7Z0JBQ3hEQSxhQUFhUSxVQUFVLENBQUM7Z0JBQ3hCck4sUUFBUUMsR0FBRyxDQUFDO1lBQ2Q7WUFFQSwrQkFBK0I7WUFDL0JoQixJQUFJO2dCQUNGRSxVQUFVLEVBQUU7Z0JBQ1pDLFdBQVc7Z0JBQ1hDLGNBQWMsRUFBRTtnQkFDaEJDLGdCQUFnQixFQUFFO2dCQUNsQkMsZ0JBQWdCLEVBQUU7Z0JBQ2xCQyxrQkFBa0IsRUFBRTtnQkFDcEJDLFlBQVksRUFBRTtnQkFDZEMsc0JBQXNCO2dCQUN0QkMsdUJBQXVCO2dCQUN2QkMsV0FBVztnQkFDWEMsT0FBTztZQUNUO1lBRUFHLFFBQVFDLEdBQUcsQ0FBQztZQUNaRCxRQUFRQyxHQUFHLENBQUM7UUFDZDtRQUVBLGtFQUFrRTtRQUNsRXFOLDBCQUEwQixDQUFDQztZQUN6QnZOLFFBQVFDLEdBQUcsQ0FBQztZQUNaRCxRQUFRQyxHQUFHLENBQUMsMEJBQThEc04sT0FBOUNyTyxNQUFNRyxZQUFZLENBQUNnQixNQUFNLEVBQUMsc0JBQXlDLE9BQXJCa04sY0FBY2xOLE1BQU0sRUFBQztZQUUvRnBCLElBQUk7Z0JBQ0ZJLGNBQWNrTztnQkFDZDdOLHNCQUFzQjZOLGNBQWNsTixNQUFNLEdBQUc7WUFDL0M7WUFFQUwsUUFBUUMsR0FBRyxDQUFDO1FBQ2Q7SUFDRixJQUNGO0lBQUV6QixNQUFNO0FBQWUsSUFFekI7QUFFRiw4Q0FBOEM7QUFDOUMsSUFBSSxJQUE2QixFQUFFO0lBQ2hDb08sT0FBZTVOLGNBQWMsR0FBR0E7QUFDbkMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYXR0aGV3c2ltb24vUHJvamVjdHMvZWFjL2VhYy9zdG9yZS9lZGl0b3IvaW5kZXgudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gRWRpdG9yIFN0b3JlXG4vLyAvVXNlcnMvbWF0dGhld3NpbW9uL1Byb2plY3RzL0VBQy9lYWMvc3RvcmUvZWRpdG9yL2luZGV4LnRzXG5cbmltcG9ydCB7IEF0U2lnbiwgQnJhY2VzLCBDYWxlbmRhciwgQ2FtZXJhLCBGaWxlQ29kZSwgRmlsZVNwcmVhZHNoZWV0LCBGaWxlVGV4dCwgRmlsZVR5cGUsIEhlbHBDaXJjbGUsIE1lc3NhZ2VTcXVhcmUgfSBmcm9tICdsdWNpZGUtcmVhY3QnO1xuaW1wb3J0IHsgY3JlYXRlIH0gZnJvbSAnenVzdGFuZCc7XG5pbXBvcnQgeyBkZXZ0b29scyB9IGZyb20gJ3p1c3RhbmQvbWlkZGxld2FyZSc7XG5pbXBvcnQgeyBFZGl0b3JTdGF0ZSwgRWRpdG9yVGFiLCBQcm9qZWN0RmlsZSwgUHJvamVjdEZvbGRlciwgVHJhc2hJdGVtIH0gZnJvbSAnLi90eXBlcyc7XG5cbi8vIEhlbHBlciBmdW5jdGlvbiB0byBnZXQgaWNvbiBiYXNlZCBvbiBmaWxlIHR5cGVcbmNvbnN0IGdldEZpbGVJY29uID0gKHR5cGU6IFByb2plY3RGaWxlWyd0eXBlJ10pID0+IHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAndHlwZXNjcmlwdCc6XG4gICAgICByZXR1cm4gRmlsZUNvZGU7XG4gICAgY2FzZSAnamF2YXNjcmlwdCc6XG4gICAgICByZXR1cm4gRmlsZUNvZGU7XG4gICAgY2FzZSAnanNvbic6XG4gICAgICByZXR1cm4gQnJhY2VzO1xuICAgIGNhc2UgJ2V4Y2VsJzpcbiAgICAgIHJldHVybiBGaWxlU3ByZWFkc2hlZXQ7XG4gICAgY2FzZSAnbWFya2Rvd24nOlxuICAgICAgcmV0dXJuIEZpbGVUZXh0O1xuICAgIGNhc2UgJ3BkZic6XG4gICAgICByZXR1cm4gRmlsZVR5cGU7XG4gICAgY2FzZSAnZ2VuZXJhbHMnOlxuICAgICAgcmV0dXJuIEZpbGVUZXh0O1xuICAgIGNhc2UgJ3BlcmNlbnQtY29tcGxldGUnOlxuICAgICAgcmV0dXJuIEZpbGVTcHJlYWRzaGVldDtcbiAgICBjYXNlICdzY2hlZHVsZSc6XG4gICAgICByZXR1cm4gRmlsZVNwcmVhZHNoZWV0O1xuICAgIGNhc2UgJ21hdGVyaWFscyc6XG4gICAgICByZXR1cm4gRmlsZVNwcmVhZHNoZWV0O1xuICAgIGNhc2UgJ2ZhY2Vib29rJzpcbiAgICAgIHJldHVybiBNZXNzYWdlU3F1YXJlO1xuICAgIGNhc2UgJ3JlZGRpdCc6XG4gICAgICByZXR1cm4gJ3IvJzsgLy8gQ2hhbmdlZCBmcm9tIEhhc2ggdG8gci8gdGV4dFxuICAgIGNhc2UgJ2luc3RhZ3JhbSc6XG4gICAgICByZXR1cm4gQ2FtZXJhO1xuICAgIGNhc2UgJ3gnOlxuICAgICAgcmV0dXJuIEF0U2lnbjtcbiAgICBjYXNlICdjYWxlbmRhcic6XG4gICAgICByZXR1cm4gQ2FsZW5kYXI7XG4gICAgY2FzZSAncGxhdGZvcm0taW5zdHJ1Y3Rpb25zJzpcbiAgICAgIHJldHVybiBIZWxwQ2lyY2xlO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gRmlsZUNvZGU7XG4gIH1cbn07XG5cbi8vIEhlbHBlciBmdW5jdGlvbiB0byBnZXQgZmlsZSBleHRlbnNpb25cbi8vIEhlbHBlciBmdW5jdGlvbiB0byBnZXQgZmlsZSBleHRlbnNpb25cbmNvbnN0IGdldEZpbGVFeHRlbnNpb24gPSAodHlwZTogUHJvamVjdEZpbGVbJ3R5cGUnXSk6IHN0cmluZyA9PiB7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ3R5cGVzY3JpcHQnOlxuICAgICAgcmV0dXJuICcudHMnO1xuICAgIGNhc2UgJ2phdmFzY3JpcHQnOlxuICAgICAgcmV0dXJuICcuanMnO1xuICAgIGNhc2UgJ2pzb24nOlxuICAgICAgcmV0dXJuICcuanNvbic7XG4gICAgY2FzZSAnZXhjZWwnOlxuICAgICAgcmV0dXJuICcueGxzeCc7XG4gICAgY2FzZSAncGRmJzpcbiAgICAgIHJldHVybiAnLnBkZic7XG4gICAgY2FzZSAnZ2VuZXJhbHMnOlxuICAgICAgcmV0dXJuICcuZ2VuZXJhbHMnO1xuICAgIGNhc2UgJ3BlcmNlbnQtY29tcGxldGUnOlxuICAgICAgcmV0dXJuICcucGVyY2VudCc7XG4gICAgY2FzZSAnc2NoZWR1bGUnOlxuICAgICAgcmV0dXJuICcuc2NoZWR1bGUnO1xuICAgIGNhc2UgJ21hdGVyaWFscyc6XG4gICAgICByZXR1cm4gJy5tYXRlcmlhbHMnO1xuICAgIGNhc2UgJ2ZhY2Vib29rJzpcbiAgICAgIHJldHVybiAnLmZhY2Vib29rJztcbiAgICBjYXNlICdyZWRkaXQnOlxuICAgICAgcmV0dXJuICcucmVkZGl0JztcbiAgICBjYXNlICdpbnN0YWdyYW0nOlxuICAgICAgcmV0dXJuICcuaW5zdGFncmFtJztcbiAgICBjYXNlICd4JzpcbiAgICAgIHJldHVybiAnLngnO1xuICAgIGNhc2UgJ21hcmtkb3duJzpcbiAgICAgIHJldHVybiAnLm1kJztcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuICcudHh0JztcbiAgfVxufTtcblxuLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGdlbmVyYXRlIGRlZmF1bHQgY29udGVudCBmb3IgbmV3IGZpbGVzXG5jb25zdCBnZXREZWZhdWx0Q29udGVudCA9ICh0eXBlOiBQcm9qZWN0RmlsZVsndHlwZSddLCBuYW1lOiBzdHJpbmcpID0+IHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAndHlwZXNjcmlwdCc6XG4gICAgICByZXR1cm4gYC8vICR7bmFtZX1cbi8vIEF1dG8tZ2VuZXJhdGVkIFR5cGVTY3JpcHQgZmlsZVxuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5pbnRlcmZhY2UgJHtuYW1lLnJlcGxhY2UoL1teYS16QS1aMC05XS9nLCAnJyl9UHJvcHMge1xuICAvLyBEZWZpbmUgcHJvcHMgaGVyZVxufVxuXG5leHBvcnQgZnVuY3Rpb24gJHtuYW1lLnJlcGxhY2UoL1teYS16QS1aMC05XS9nLCAnJyl9KHsgfTogJHtuYW1lLnJlcGxhY2UoL1teYS16QS1aMC05XS9nLCAnJyl9UHJvcHMpIHtcbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT1cInAtNFwiPlxuICAgICAgPGgxIGNsYXNzTmFtZT1cInRleHQteGwgZm9udC1ib2xkXCI+TmV3IENvbXBvbmVudDogJHtuYW1lfTwvaDE+XG4gICAgICA8cCBjbGFzc05hbWU9XCJ0ZXh0LWdyYXktNjAwXCI+U3RhcnQgYnVpbGRpbmcgeW91ciBjb21wb25lbnQgaGVyZS4uLjwvcD5cbiAgICA8L2Rpdj5cbiAgKTtcbn1gO1xuICAgIGNhc2UgJ2phdmFzY3JpcHQnOlxuICAgICAgcmV0dXJuIGAvLyAke25hbWV9XG4vLyBBdXRvLWdlbmVyYXRlZCBKYXZhU2NyaXB0IGZpbGVcblxuZXhwb3J0IGZ1bmN0aW9uICR7bmFtZS5yZXBsYWNlKC9bXmEtekEtWjAtOV0vZywgJycpfSgpIHtcbiAgcmV0dXJuIHtcbiAgICBtZXNzYWdlOiAnSGVsbG8gZnJvbSAke25hbWV9IScsXG4gICAgZGF0YTogW11cbiAgfTtcbn1gO1xuICAgIGNhc2UgJ2pzb24nOlxuICAgICAgcmV0dXJuIGB7XG4gIFwibmFtZVwiOiBcIiR7bmFtZX1cIixcbiAgXCJkZXNjcmlwdGlvblwiOiBcIkF1dG8tZ2VuZXJhdGVkIEpTT04gZmlsZVwiLFxuICBcInZlcnNpb25cIjogXCIxLjAuMFwiLFxuICBcImRhdGFcIjoge31cbn1gO1xuICAgIGNhc2UgJ21hcmtkb3duJzpcbiAgICAgIHJldHVybiBgU3RhcnQgd3JpdGluZyB5b3VyIGNvbnRlbnQgaGVyZS4uLmA7XG4gICAgY2FzZSAnZ2VuZXJhbHMnOlxuICAgICAgcmV0dXJuIGAvLyAke25hbWV9IC0gUHJvamVjdCBHZW5lcmFsIEluZm9ybWF0aW9uXG4vLyBUaGlzIGZpbGUgY29udGFpbnMgZ2VuZXJhbCBwcm9qZWN0IGRldGFpbHMgYW5kIGZpbmFuY2lhbCBpbmZvcm1hdGlvblxuLy8gQ3JlYXRlZCBvbjogJHtuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCl9XG5cblByb2plY3Q6ICR7bmFtZX1cblN0YXR1czogQWN0aXZlXG5DcmVhdGVkOiAke25ldyBEYXRlKCkudG9Mb2NhbGVEYXRlU3RyaW5nKCl9XG5cbi8vIFRoaXMgZmlsZSB3aWxsIGRpc3BsYXkgdGhlIHByb2plY3QgZ2VuZXJhbHMgbW9kdWxlIGludGVyZmFjZWA7XG4gICAgY2FzZSAncGVyY2VudC1jb21wbGV0ZSc6XG4gICAgICByZXR1cm4gYC8vICR7bmFtZX0gLSBQZXJjZW50IENvbXBsZXRlIFRyYWNrZXJcbi8vIFRoaXMgZmlsZSBjb250YWlucyBwcm9qZWN0IGNvbXBsZXRpb24gdHJhY2tpbmcgZGF0YVxuLy8gQ3JlYXRlZCBvbjogJHtuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCl9XG5cblByb2plY3Q6ICR7bmFtZX1cblR5cGU6IFBlcmNlbnQgQ29tcGxldGUgVHJhY2tlclxuQ3JlYXRlZDogJHtuZXcgRGF0ZSgpLnRvTG9jYWxlRGF0ZVN0cmluZygpfVxuXG4vLyBUaGlzIGZpbGUgd2lsbCBkaXNwbGF5IHRoZSBwZXJjZW50IGNvbXBsZXRlIHRyYWNraW5nIGludGVyZmFjZWA7XG4gICAgY2FzZSAnc2NoZWR1bGUnOlxuICAgICAgcmV0dXJuIGAvLyAke25hbWV9IC0gUHJvamVjdCBTY2hlZHVsZVxuLy8gVGhpcyBmaWxlIGNvbnRhaW5zIHByb2plY3Qgc2NoZWR1bGUgYW5kIHRpbWVsaW5lIGRhdGFcbi8vIENyZWF0ZWQgb246ICR7bmV3IERhdGUoKS50b0lTT1N0cmluZygpfVxuXG5Qcm9qZWN0OiAke25hbWV9XG5UeXBlOiBQcm9qZWN0IFNjaGVkdWxlXG5DcmVhdGVkOiAke25ldyBEYXRlKCkudG9Mb2NhbGVEYXRlU3RyaW5nKCl9XG5cbi8vIFRoaXMgZmlsZSB3aWxsIGRpc3BsYXkgdGhlIHByb2plY3Qgc2NoZWR1bGUgaW50ZXJmYWNlIHdpdGggR2FudHQgY2hhcnRgO1xuICAgIGNhc2UgJ21hdGVyaWFscyc6XG4gICAgICByZXR1cm4gYC8vICR7bmFtZX0gLSBNYXRlcmlhbHMgTWFuYWdlbWVudFxuLy8gVGhpcyBmaWxlIGNvbnRhaW5zIG1hdGVyaWFscyB0cmFja2luZyBhbmQgbWFuYWdlbWVudCBkYXRhXG4vLyBDcmVhdGVkIG9uOiAke25ldyBEYXRlKCkudG9JU09TdHJpbmcoKX1cblxuUHJvamVjdDogJHtuYW1lfVxuVHlwZTogTWF0ZXJpYWxzIE1hbmFnZW1lbnRcbkNyZWF0ZWQ6ICR7bmV3IERhdGUoKS50b0xvY2FsZURhdGVTdHJpbmcoKX1cblxuLy8gVGhpcyBmaWxlIHdpbGwgZGlzcGxheSB0aGUgbWF0ZXJpYWxzIG1hbmFnZW1lbnQgaW50ZXJmYWNlIHdpdGggbWFudWZhY3R1cmVkIGFuZCBtaXNjZWxsYW5lb3VzIG1hdGVyaWFsc2A7XG4gICAgY2FzZSAnZmFjZWJvb2snOlxuICAgICAgcmV0dXJuIGAjICR7bmFtZX0gLSBGYWNlYm9vayBQb3N0XG5QbGF0Zm9ybTogRmFjZWJvb2tcbkNyZWF0ZWQ6ICR7bmV3IERhdGUoKS50b0xvY2FsZURhdGVTdHJpbmcoKX1cblxuIyMgUG9zdCBDb250ZW50XG5Xcml0ZSB5b3VyIEZhY2Vib29rIHBvc3QgY29udGVudCBoZXJlLi4uXG5cbiMjIFNldHRpbmdzXG4tIEF1ZGllbmNlOiBQdWJsaWNcbi0gU2NoZWR1bGU6IE5vd1xuLSBIYXNodGFnczogI2V4YW1wbGVcblxuIyMgTWVkaWFcbi0gSW1hZ2VzOiBbXVxuLSBWaWRlb3M6IFtdXG5cbiMjIEFuYWx5dGljc1xuLSBFbmdhZ2VtZW50OiAwXG4tIFJlYWNoOiAwXG4tIENsaWNrczogMGA7XG4gICAgY2FzZSAncmVkZGl0JzpcbiAgICAgIHJldHVybiBgIyAke25hbWV9IC0gUmVkZGl0IFBvc3RcblBsYXRmb3JtOiBSZWRkaXRcbkNyZWF0ZWQ6ICR7bmV3IERhdGUoKS50b0xvY2FsZURhdGVTdHJpbmcoKX1cblxuIyMgUG9zdCBDb250ZW50XG5Xcml0ZSB5b3VyIFJlZGRpdCBwb3N0IGNvbnRlbnQgaGVyZS4uLlxuXG4jIyBTZXR0aW5nc1xuLSBTdWJyZWRkaXQ6IHIvdGVzdFxuLSBQb3N0IFR5cGU6IFRleHQvTGluay9JbWFnZVxuLSBGbGFpcjogRGlzY3Vzc2lvblxuLSBOU0ZXOiBOb1xuXG4jIyBNZWRpYVxuLSBJbWFnZXM6IFtdXG4tIExpbmtzOiBbXVxuXG4jIyBBbmFseXRpY3Ncbi0gVXB2b3RlczogMFxuLSBDb21tZW50czogMFxuLSBBd2FyZHM6IDBgO1xuICAgIGNhc2UgJ2luc3RhZ3JhbSc6XG4gICAgICByZXR1cm4gYCMgJHtuYW1lfSAtIEluc3RhZ3JhbSBQb3N0XG5QbGF0Zm9ybTogSW5zdGFncmFtXG5DcmVhdGVkOiAke25ldyBEYXRlKCkudG9Mb2NhbGVEYXRlU3RyaW5nKCl9XG5cbiMjIFBvc3QgQ29udGVudFxuV3JpdGUgeW91ciBJbnN0YWdyYW0gcG9zdCBjb250ZW50IGhlcmUuLi5cblxuIyMgU2V0dGluZ3Ncbi0gUG9zdCBUeXBlOiBGZWVkL1N0b3J5L1JlZWxcbi0gTG9jYXRpb246IENpdHksIENvdW50cnlcbi0gQWx0IFRleHQ6IERlc2NyaWJlIGltYWdlXG4tIENvbW1lbnQgU2V0dGluZ3M6IFB1YmxpY1xuXG4jIyBNZWRpYVxuLSBJbWFnZXM6IFtdXG4tIFZpZGVvczogW11cblxuIyMgSGFzaHRhZ3NcbiNoYXNodGFnMSAjaGFzaHRhZzIgI2hhc2h0YWczXG5cbiMjIEFuYWx5dGljc1xuLSBMaWtlczogMFxuLSBDb21tZW50czogMFxuLSBTaGFyZXM6IDBcbi0gUmVhY2g6IDBgO1xuICAgIGNhc2UgJ3gnOlxuICAgICAgcmV0dXJuIGAjICR7bmFtZX0gLSBYL1R3aXR0ZXIgUG9zdFxuUGxhdGZvcm06IFggKFR3aXR0ZXIpXG5DcmVhdGVkOiAke25ldyBEYXRlKCkudG9Mb2NhbGVEYXRlU3RyaW5nKCl9XG5cbiMjIFBvc3QgQ29udGVudFxuV3JpdGUgeW91ciBYIHBvc3QgY29udGVudCBoZXJlLi4uICgyODAgY2hhcmFjdGVyIGxpbWl0KVxuXG4jIyBTZXR0aW5nc1xuLSBSZXBseSBTZXR0aW5nczogRXZlcnlvbmVcbi0gU2NoZWR1bGU6IE5vd1xuLSBUaHJlYWQ6IFNpbmdsZSBUd2VldFxuXG4jIyBNZWRpYVxuLSBJbWFnZXM6IFtdXG4tIFZpZGVvczogW11cbi0gR0lGczogW11cblxuIyMgQW5hbHl0aWNzXG4tIEltcHJlc3Npb25zOiAwXG4tIEVuZ2FnZW1lbnRzOiAwXG4tIFJldHdlZXRzOiAwXG4tIExpa2VzOiAwXG4tIFJlcGxpZXM6IDBgO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gYCMgJHtuYW1lfVxuXG5UaGlzIGlzIGEgbmV3IGZpbGUgY3JlYXRlZCBpbiB0aGUgRUFDIERhc2hib2FyZC5cbkNyZWF0ZWQgb246ICR7bmV3IERhdGUoKS50b0lTT1N0cmluZygpfWA7XG4gIH1cbn07XG5cbi8vIEluaXRpYWwgcHJvamVjdCBmaWxlcyAtIGVtcHR5IGJ5IGRlZmF1bHQsIG9ubHkgY3JlYXRlZCB3aGVuIG5lZWRlZFxuY29uc3QgaW5pdGlhbFByb2plY3RGaWxlczogUHJvamVjdEZpbGVbXSA9IFtdO1xuXG4vLyBJbml0aWFsIGZpbmFuY2lhbCBmaWxlcyAtIGVtcHR5IGJ5IGRlZmF1bHQsIG9ubHkgY3JlYXRlZCB3aGVuIG5lZWRlZCAgXG5jb25zdCBpbml0aWFsRmluYW5jaWFsRmlsZXM6IFByb2plY3RGaWxlW10gPSBbXTtcblxuLy8gSW5pdGlhbCBwcm9qZWN0IGZvbGRlcnMgLSBvbmx5IGNyZWF0ZWQgd2hlbiBleHBsaWNpdGx5IG5lZWRlZCwgbm90IG9uIHN0b3JhZ2UgY2xlYXJcbmNvbnN0IGluaXRpYWxQcm9qZWN0Rm9sZGVyczogUHJvamVjdEZvbGRlcltdID0gW107XG5cbmV4cG9ydCBjb25zdCB1c2VFZGl0b3JTdG9yZSA9IGNyZWF0ZTxFZGl0b3JTdGF0ZT4oKShcbiAgZGV2dG9vbHMoXG4gICAgKHNldCwgZ2V0KSA9PiAoe1xuICAgICAgICAvLyBJbml0aWFsIHN0YXRlXG4gICAgICAgIG9wZW5UYWJzOiBbXSxcbiAgICAgICAgYWN0aXZlVGFiOiAnJyxcbiAgICAgICAgcHJvamVjdEZpbGVzOiBpbml0aWFsUHJvamVjdEZpbGVzLFxuICAgICAgICBmaW5hbmNpYWxGaWxlczogaW5pdGlhbEZpbmFuY2lhbEZpbGVzLFxuICAgICAgICBwcm9qZWN0Rm9sZGVyczogaW5pdGlhbFByb2plY3RGb2xkZXJzLFxuICAgICAgICBmaW5hbmNpYWxGb2xkZXJzOiBbXSxcbiAgICAgICAgdHJhc2hJdGVtczogW10sXG4gICAgICAgIHNob3dQcm9qZWN0c0NhdGVnb3J5OiB0cnVlLFxuICAgICAgICBzaG93RmluYW5jaWFsQ2F0ZWdvcnk6IGZhbHNlLCAvLyBEb24ndCBzaG93IGJ5IGRlZmF1bHQgLSBvbmx5IHNob3cgd2hlbiB1c2VyIGNyZWF0ZXMgZmluYW5jaWFsIGNvbnRlbnRcbiAgICAgICAgaXNMb2FkaW5nOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6IG51bGwsXG5cbiAgICAgICAgLy8gQWN0aW9uc1xuICAgICAgICBvcGVuVGFiOiAoZmlsZTogUHJvamVjdEZpbGUpID0+IHtcbiAgICAgICAgICBjb25zdCB7IG9wZW5UYWJzIH0gPSBnZXQoKTtcbiAgICAgICAgICBcbiAgICAgICAgICBjb25zb2xlLmxvZygn8J+UjSBPcGVuaW5nIHRhYiBmb3IgZmlsZTonLCB7XG4gICAgICAgICAgICBpZDogZmlsZS5pZCxcbiAgICAgICAgICAgIG5hbWU6IGZpbGUubmFtZSxcbiAgICAgICAgICAgIGNvbnRlbnRMZW5ndGg6IGZpbGUuY29udGVudD8ubGVuZ3RoIHx8IDAsXG4gICAgICAgICAgICBjb250ZW50UHJldmlldzogZmlsZS5jb250ZW50Py5zdWJzdHJpbmcoMCwgMTAwKSB8fCAnTk8gQ09OVEVOVCcsXG4gICAgICAgICAgICB0eXBlOiBmaWxlLnR5cGUsXG4gICAgICAgICAgICBwbGF0Zm9ybTogKGZpbGUgYXMgYW55KS5wbGF0Zm9ybSxcbiAgICAgICAgICAgIHJhd0NvbnRlbnQ6IGZpbGUuY29udGVudFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIENoZWNrIGlmIHRhYiBpcyBhbHJlYWR5IG9wZW5cbiAgICAgICAgICBjb25zdCBleGlzdGluZ1RhYiA9IG9wZW5UYWJzLmZpbmQodGFiID0+IHRhYi5pZCA9PT0gZmlsZS5pZCk7XG4gICAgICAgICAgaWYgKGV4aXN0aW5nVGFiKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygn8J+TgiBUYWIgYWxyZWFkeSBleGlzdHMsIGFjdGl2YXRpbmc6JywgZXhpc3RpbmdUYWIuaWQpO1xuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBleGlzdGluZyB0YWIgY29udGVudCB3aXRoIHRoZSBjdXJyZW50IGZpbGUgY29udGVudFxuICAgICAgICAgICAgY29uc3QgdXBkYXRlZFRhYnMgPSBvcGVuVGFicy5tYXAodGFiID0+IFxuICAgICAgICAgICAgICB0YWIuaWQgPT09IGZpbGUuaWQgXG4gICAgICAgICAgICAgICAgPyB7IC4uLnRhYiwgY29udGVudDogZmlsZS5jb250ZW50IHx8IGdldERlZmF1bHRDb250ZW50KGZpbGUudHlwZSwgZmlsZS5uYW1lKSB9XG4gICAgICAgICAgICAgICAgOiB0YWJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBzZXQoeyBcbiAgICAgICAgICAgICAgb3BlblRhYnM6IHVwZGF0ZWRUYWJzLFxuICAgICAgICAgICAgICBhY3RpdmVUYWI6IGV4aXN0aW5nVGFiLmlkIFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gRGVmaW5lIHdoaWNoIGZpbGUgdHlwZXMgc2hvdWxkIGJlIGF1dG8tcGlubmVkXG4gICAgICAgICAgLy8gWW91IGNhbiBhZGQgbW9yZSBmaWxlIHR5cGVzIGhlcmUgaWYgbmVlZGVkXG4gICAgICAgICAgY29uc3QgYXV0b1BpbkZpbGVUeXBlcyA9IFsnY2FsZW5kYXInLCAnc29jaWFsLWNvbm5lY3QnLCAndXNlci1wcm9maWxlJywgJ3Bvc3QtY3JlYXRvciddO1xuICAgICAgICAgIGNvbnN0IHNob3VsZEF1dG9QaW5uID0gYXV0b1BpbkZpbGVUeXBlcy5pbmNsdWRlcyhmaWxlLnR5cGUpO1xuICAgICAgICAgIFxuICAgICAgICAgIGxldCBwaW5uZWRPcmRlcjogbnVtYmVyIHwgdW5kZWZpbmVkO1xuICAgICAgICAgIGlmIChzaG91bGRBdXRvUGlubikge1xuICAgICAgICAgICAgLy8gR2V0IHRoZSBoaWdoZXN0IHBpbm5lZCBvcmRlciBmb3IgYXV0by1waW5uZWQgdGFic1xuICAgICAgICAgICAgY29uc3QgcGlubmVkVGFicyA9IG9wZW5UYWJzLmZpbHRlcih0ID0+IHQucGlubmVkKTtcbiAgICAgICAgICAgIHBpbm5lZE9yZGVyID0gcGlubmVkVGFicy5sZW5ndGggPiAwID8gTWF0aC5tYXgoLi4ucGlubmVkVGFicy5tYXAodCA9PiB0LnBpbm5lZE9yZGVyIHx8IDApKSArIDEgOiAxO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIENyZWF0ZSBuZXcgdGFiIHdpdGggY29udGVudFxuICAgICAgICAgIGNvbnN0IHRhYkNvbnRlbnQgPSBmaWxlLmNvbnRlbnQgfHwgZ2V0RGVmYXVsdENvbnRlbnQoZmlsZS50eXBlLCBmaWxlLm5hbWUpO1xuICAgICAgICAgIGNvbnNvbGUubG9nKCfwn4aVIENyZWF0aW5nIG5ldyB0YWIgd2l0aCBjb250ZW50OicsIHtcbiAgICAgICAgICAgIGZpbGVJZDogZmlsZS5pZCxcbiAgICAgICAgICAgIGZpbGVOYW1lOiBmaWxlLm5hbWUsXG4gICAgICAgICAgICBoYXNDdXN0b21Db250ZW50OiAhIWZpbGUuY29udGVudCxcbiAgICAgICAgICAgIGNvbnRlbnRMZW5ndGg6IHRhYkNvbnRlbnQubGVuZ3RoLFxuICAgICAgICAgICAgY29udGVudFByZXZpZXc6IHRhYkNvbnRlbnQuc3Vic3RyaW5nKDAsIDEwMClcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBcbiAgICAgICAgICBjb25zdCBuZXdUYWI6IEVkaXRvclRhYiA9IHtcbiAgICAgICAgICAgIGlkOiBmaWxlLmlkLFxuICAgICAgICAgICAgbmFtZTogZmlsZS5uYW1lLFxuICAgICAgICAgICAgbW9kaWZpZWQ6IGZhbHNlLFxuICAgICAgICAgICAgY29udGVudDogdGFiQ29udGVudCxcbiAgICAgICAgICAgIGZpbGVQYXRoOiBmaWxlLmZpbGVQYXRoLFxuICAgICAgICAgICAgdHlwZTogZmlsZS50eXBlLFxuICAgICAgICAgICAgcGlubmVkOiBzaG91bGRBdXRvUGlubixcbiAgICAgICAgICAgIHBpbm5lZE9yZGVyOiBzaG91bGRBdXRvUGlubiA/IHBpbm5lZE9yZGVyIDogdW5kZWZpbmVkLFxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBsZXQgbmV3VGFiczogRWRpdG9yVGFiW107XG4gICAgICAgICAgaWYgKHNob3VsZEF1dG9QaW5uKSB7XG4gICAgICAgICAgICAvLyBGb3IgYXV0by1waW5uZWQgdGFicywgaW5zZXJ0IGluIGNvcnJlY3QgcGlubmVkIHBvc2l0aW9uXG4gICAgICAgICAgICBjb25zdCBvdGhlclRhYnMgPSBbLi4ub3BlblRhYnNdO1xuICAgICAgICAgICAgY29uc3QgaW5zZXJ0SW5kZXggPSBvdGhlclRhYnMuZmlsdGVyKHQgPT4gdC5waW5uZWQgJiYgKHQucGlubmVkT3JkZXIgfHwgMCkgPCAocGlubmVkT3JkZXIgfHwgMCkpLmxlbmd0aDtcbiAgICAgICAgICAgIG90aGVyVGFicy5zcGxpY2UoaW5zZXJ0SW5kZXgsIDAsIG5ld1RhYik7XG4gICAgICAgICAgICBuZXdUYWJzID0gb3RoZXJUYWJzO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBGb3Igbm9uLWF1dG8tcGlubmVkIHRhYnMsIGluc2VydCBhZnRlciBhbGwgcGlubmVkIHRhYnNcbiAgICAgICAgICAgIGNvbnN0IHBpbm5lZFRhYnMgPSBvcGVuVGFicy5maWx0ZXIodGFiID0+IHRhYi5waW5uZWQpO1xuICAgICAgICAgICAgY29uc3QgdW5waW5uZWRUYWJzID0gb3BlblRhYnMuZmlsdGVyKHRhYiA9PiAhdGFiLnBpbm5lZCk7XG4gICAgICAgICAgICBuZXdUYWJzID0gWy4uLnBpbm5lZFRhYnMsIC4uLnVucGlubmVkVGFicywgbmV3VGFiXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzZXQoe1xuICAgICAgICAgICAgb3BlblRhYnM6IG5ld1RhYnMsXG4gICAgICAgICAgICBhY3RpdmVUYWI6IG5ld1RhYi5pZCxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBvcGVuU3BlY2lhbFRhYjogKGlkOiBzdHJpbmcsIG5hbWU6IHN0cmluZywgdHlwZTogJ3NvY2lhbC1jb25uZWN0JyB8ICdwb3N0LWNyZWF0b3InIHwgJ2NhbGVuZGFyJyB8ICd1c2VyLXByb2ZpbGUnIHwgJ3NpZ24taW4nIHwgJ3BsYXRmb3JtLWluc3RydWN0aW9ucycgfCAnbG9nby1nZW5lcmF0b3InIHwgJ3N1YnNjcmlwdGlvbicpID0+IHtcbiAgICAgICAgICBjb25zdCB7IG9wZW5UYWJzIH0gPSBnZXQoKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBDaGVjayBpZiB0YWIgaXMgYWxyZWFkeSBvcGVuXG4gICAgICAgICAgY29uc3QgZXhpc3RpbmdUYWIgPSBvcGVuVGFicy5maW5kKHRhYiA9PiB0YWIuaWQgPT09IGlkKTtcbiAgICAgICAgICBpZiAoZXhpc3RpbmdUYWIpIHtcbiAgICAgICAgICAgIHNldCh7IGFjdGl2ZVRhYjogZXhpc3RpbmdUYWIuaWQgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gRGVmaW5lIHdoaWNoIHRhYiB0eXBlcyBzaG91bGQgYmUgYXV0by1waW5uZWRcbiAgICAgICAgICBjb25zdCBhdXRvUGluVHlwZXMgPSBbJ3VzZXItcHJvZmlsZScsICdjYWxlbmRhcicsICdzb2NpYWwtY29ubmVjdCcsICdwb3N0LWNyZWF0b3InLCAncGxhdGZvcm0taW5zdHJ1Y3Rpb25zJywgJ2xvZ28tZ2VuZXJhdG9yJywgJ3N1YnNjcmlwdGlvbiddO1xuICAgICAgICAgIGNvbnN0IHNob3VsZEF1dG9QaW5uID0gYXV0b1BpblR5cGVzLmluY2x1ZGVzKHR5cGUpO1xuICAgICAgICAgIFxuICAgICAgICAgIGxldCBwaW5uZWRPcmRlcjogbnVtYmVyIHwgdW5kZWZpbmVkO1xuICAgICAgICAgIGlmIChzaG91bGRBdXRvUGlubikge1xuICAgICAgICAgICAgLy8gR2V0IHRoZSBoaWdoZXN0IHBpbm5lZCBvcmRlciBmb3IgYXV0by1waW5uZWQgdGFic1xuICAgICAgICAgICAgY29uc3QgcGlubmVkVGFicyA9IG9wZW5UYWJzLmZpbHRlcih0ID0+IHQucGlubmVkKTtcbiAgICAgICAgICAgIHBpbm5lZE9yZGVyID0gcGlubmVkVGFicy5sZW5ndGggPiAwID8gTWF0aC5tYXgoLi4ucGlubmVkVGFicy5tYXAodCA9PiB0LnBpbm5lZE9yZGVyIHx8IDApKSArIDEgOiAxO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIENyZWF0ZSBuZXcgc3BlY2lhbCB0YWJcbiAgICAgICAgICBjb25zdCBuZXdUYWI6IEVkaXRvclRhYiA9IHtcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIG1vZGlmaWVkOiBmYWxzZSxcbiAgICAgICAgICAgIGNvbnRlbnQ6ICcnLFxuICAgICAgICAgICAgZmlsZVBhdGg6IGAvJHt0eXBlfWAsXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgcGlubmVkOiBzaG91bGRBdXRvUGlubixcbiAgICAgICAgICAgIHBpbm5lZE9yZGVyOiBzaG91bGRBdXRvUGlubiA/IHBpbm5lZE9yZGVyIDogdW5kZWZpbmVkLFxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBsZXQgbmV3VGFiczogRWRpdG9yVGFiW107XG4gICAgICAgICAgaWYgKHNob3VsZEF1dG9QaW5uKSB7XG4gICAgICAgICAgICAvLyBGb3IgYXV0by1waW5uZWQgdGFicywgaW5zZXJ0IGluIGNvcnJlY3QgcGlubmVkIHBvc2l0aW9uXG4gICAgICAgICAgICBjb25zdCBvdGhlclRhYnMgPSBbLi4ub3BlblRhYnNdO1xuICAgICAgICAgICAgY29uc3QgaW5zZXJ0SW5kZXggPSBvdGhlclRhYnMuZmlsdGVyKHQgPT4gdC5waW5uZWQgJiYgKHQucGlubmVkT3JkZXIgfHwgMCkgPCAocGlubmVkT3JkZXIgfHwgMCkpLmxlbmd0aDtcbiAgICAgICAgICAgIG90aGVyVGFicy5zcGxpY2UoaW5zZXJ0SW5kZXgsIDAsIG5ld1RhYik7XG4gICAgICAgICAgICBuZXdUYWJzID0gb3RoZXJUYWJzO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBGb3Igbm9uLWF1dG8tcGlubmVkIHRhYnMsIGluc2VydCBhZnRlciBhbGwgcGlubmVkIHRhYnNcbiAgICAgICAgICAgIGNvbnN0IHBpbm5lZFRhYnMgPSBvcGVuVGFicy5maWx0ZXIodGFiID0+IHRhYi5waW5uZWQpO1xuICAgICAgICAgICAgY29uc3QgdW5waW5uZWRUYWJzID0gb3BlblRhYnMuZmlsdGVyKHRhYiA9PiAhdGFiLnBpbm5lZCk7XG4gICAgICAgICAgICBuZXdUYWJzID0gWy4uLnBpbm5lZFRhYnMsIC4uLnVucGlubmVkVGFicywgbmV3VGFiXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzZXQoe1xuICAgICAgICAgICAgb3BlblRhYnM6IG5ld1RhYnMsXG4gICAgICAgICAgICBhY3RpdmVUYWI6IG5ld1RhYi5pZCxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBjbG9zZVRhYjogKHRhYklkOiBzdHJpbmcpID0+IHtcbiAgICAgICAgICBjb25zdCB7IG9wZW5UYWJzLCBhY3RpdmVUYWIgfSA9IGdldCgpO1xuICAgICAgICAgIGNvbnN0IHRhYkluZGV4ID0gb3BlblRhYnMuZmluZEluZGV4KHRhYiA9PiB0YWIuaWQgPT09IHRhYklkKTtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAodGFiSW5kZXggPT09IC0xKSByZXR1cm47XG5cbiAgICAgICAgICBjb25zdCBuZXdUYWJzID0gb3BlblRhYnMuZmlsdGVyKHRhYiA9PiB0YWIuaWQgIT09IHRhYklkKTtcbiAgICAgICAgICBsZXQgbmV3QWN0aXZlVGFiID0gYWN0aXZlVGFiO1xuXG4gICAgICAgICAgLy8gSWYgY2xvc2luZyB0aGUgYWN0aXZlIHRhYiwgc3dpdGNoIHRvIGFub3RoZXIgdGFiXG4gICAgICAgICAgaWYgKGFjdGl2ZVRhYiA9PT0gdGFiSWQpIHtcbiAgICAgICAgICAgIGlmIChuZXdUYWJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgLy8gU3dpdGNoIHRvIHRoZSB0YWIgdG8gdGhlIHJpZ2h0LCBvciB0aGUgbGFzdCB0YWIgaWYgY2xvc2luZyB0aGUgbGFzdCBvbmVcbiAgICAgICAgICAgICAgY29uc3QgbmV4dEluZGV4ID0gdGFiSW5kZXggPCBuZXdUYWJzLmxlbmd0aCA/IHRhYkluZGV4IDogbmV3VGFicy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICBuZXdBY3RpdmVUYWIgPSBuZXdUYWJzW25leHRJbmRleF0uaWQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBuZXdBY3RpdmVUYWIgPSAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzZXQoe1xuICAgICAgICAgICAgb3BlblRhYnM6IG5ld1RhYnMsXG4gICAgICAgICAgICBhY3RpdmVUYWI6IG5ld0FjdGl2ZVRhYixcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBjbG9zZUFsbFRhYnM6ICgpID0+IHtcbiAgICAgICAgICBzZXQoe1xuICAgICAgICAgICAgb3BlblRhYnM6IFtdLFxuICAgICAgICAgICAgYWN0aXZlVGFiOiAnJyxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXRBY3RpdmVUYWI6ICh0YWJJZDogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgY29uc3QgeyBvcGVuVGFicywgYWN0aXZlVGFiOiBjdXJyZW50QWN0aXZlVGFiIH0gPSBnZXQoKTtcbiAgICAgICAgICBjb25zdCB0YWJFeGlzdHMgPSBvcGVuVGFicy5zb21lKHRhYiA9PiB0YWIuaWQgPT09IHRhYklkKTtcbiAgICAgICAgICBcbiAgICAgICAgICBjb25zb2xlLmxvZygn8J+UhCBzZXRBY3RpdmVUYWIgY2FsbGVkOicsIHtcbiAgICAgICAgICAgIG5ld1RhYklkOiB0YWJJZCxcbiAgICAgICAgICAgIGN1cnJlbnRBY3RpdmVUYWIsXG4gICAgICAgICAgICB0YWJFeGlzdHMsXG4gICAgICAgICAgICBvcGVuVGFic0NvdW50OiBvcGVuVGFicy5sZW5ndGgsXG4gICAgICAgICAgICBhdmFpbGFibGVUYWJzOiBvcGVuVGFicy5tYXAodCA9PiAoeyBpZDogdC5pZCwgbmFtZTogdC5uYW1lLCBjb250ZW50TGVuZ3RoOiB0LmNvbnRlbnQ/Lmxlbmd0aCB8fCAwIH0pKVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIFxuICAgICAgICAgIGlmICh0YWJFeGlzdHMpIHtcbiAgICAgICAgICAgIHNldCh7IGFjdGl2ZVRhYjogdGFiSWQgfSk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygn4pyFIEFjdGl2ZSB0YWIgc2V0IHRvOicsIHRhYklkKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCfinYwgQXR0ZW1wdGVkIHRvIHNldCBub24tZXhpc3RlbnQgdGFiIGFzIGFjdGl2ZTonLCB0YWJJZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHJlb3JkZXJUYWJzOiAoZnJvbVRhYklkOiBzdHJpbmcsIHRvVGFiSWQ6IHN0cmluZykgPT4ge1xuICAgICAgICAgIGNvbnN0IHsgb3BlblRhYnMgfSA9IGdldCgpO1xuICAgICAgICAgIGNvbnN0IGZyb21JbmRleCA9IG9wZW5UYWJzLmZpbmRJbmRleCh0YWIgPT4gdGFiLmlkID09PSBmcm9tVGFiSWQpO1xuICAgICAgICAgIGNvbnN0IHRvSW5kZXggPSBvcGVuVGFicy5maW5kSW5kZXgodGFiID0+IHRhYi5pZCA9PT0gdG9UYWJJZCk7XG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKGZyb21JbmRleCAhPT0gLTEgJiYgdG9JbmRleCAhPT0gLTEgJiYgZnJvbUluZGV4ICE9PSB0b0luZGV4KSB7XG4gICAgICAgICAgICBjb25zdCBuZXdUYWJzID0gWy4uLm9wZW5UYWJzXTtcbiAgICAgICAgICAgIGNvbnN0IFttb3ZlZFRhYl0gPSBuZXdUYWJzLnNwbGljZShmcm9tSW5kZXgsIDEpO1xuICAgICAgICAgICAgbmV3VGFicy5zcGxpY2UodG9JbmRleCwgMCwgbW92ZWRUYWIpO1xuICAgICAgICAgICAgc2V0KHsgb3BlblRhYnM6IG5ld1RhYnMgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHBpblRhYjogKHRhYklkOiBzdHJpbmcpID0+IHtcbiAgICAgICAgICBjb25zdCB7IG9wZW5UYWJzIH0gPSBnZXQoKTtcbiAgICAgICAgICBjb25zdCB0YWJJbmRleCA9IG9wZW5UYWJzLmZpbmRJbmRleCh0YWIgPT4gdGFiLmlkID09PSB0YWJJZCk7XG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKHRhYkluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgY29uc3QgdGFiID0gb3BlblRhYnNbdGFiSW5kZXhdO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBEb24ndCBwaW4gaWYgYWxyZWFkeSBwaW5uZWRcbiAgICAgICAgICAgIGlmICh0YWIucGlubmVkKSByZXR1cm47XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIEdldCB0aGUgaGlnaGVzdCBwaW5uZWQgb3JkZXJcbiAgICAgICAgICAgIGNvbnN0IHBpbm5lZFRhYnMgPSBvcGVuVGFicy5maWx0ZXIodCA9PiB0LnBpbm5lZCk7XG4gICAgICAgICAgICBjb25zdCBuZXh0UGlubmVkT3JkZXIgPSBwaW5uZWRUYWJzLmxlbmd0aCA+IDAgPyBNYXRoLm1heCguLi5waW5uZWRUYWJzLm1hcCh0ID0+IHQucGlubmVkT3JkZXIgfHwgMCkpICsgMSA6IDE7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgdGFiIHRvIGJlIHBpbm5lZFxuICAgICAgICAgICAgY29uc3QgdXBkYXRlZFRhYiA9IHsgLi4udGFiLCBwaW5uZWQ6IHRydWUsIHBpbm5lZE9yZGVyOiBuZXh0UGlubmVkT3JkZXIgfTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gUmVtb3ZlIHRhYiBmcm9tIGN1cnJlbnQgcG9zaXRpb24gYW5kIGFkZCB0byBjb3JyZWN0IHBpbm5lZCBwb3NpdGlvblxuICAgICAgICAgICAgY29uc3QgbmV3VGFicyA9IFsuLi5vcGVuVGFic107XG4gICAgICAgICAgICBuZXdUYWJzLnNwbGljZSh0YWJJbmRleCwgMSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIEZpbmQgdGhlIGNvcnJlY3QgcG9zaXRpb24gYW1vbmcgcGlubmVkIHRhYnNcbiAgICAgICAgICAgIGNvbnN0IGluc2VydEluZGV4ID0gbmV3VGFicy5maWx0ZXIodCA9PiB0LnBpbm5lZCAmJiAodC5waW5uZWRPcmRlciB8fCAwKSA8IG5leHRQaW5uZWRPcmRlcikubGVuZ3RoO1xuICAgICAgICAgICAgbmV3VGFicy5zcGxpY2UoaW5zZXJ0SW5kZXgsIDAsIHVwZGF0ZWRUYWIpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBzZXQoeyBvcGVuVGFiczogbmV3VGFicyB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgdW5waW5UYWI6ICh0YWJJZDogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgY29uc3QgeyBvcGVuVGFicyB9ID0gZ2V0KCk7XG4gICAgICAgICAgY29uc3QgdGFiSW5kZXggPSBvcGVuVGFicy5maW5kSW5kZXgodGFiID0+IHRhYi5pZCA9PT0gdGFiSWQpO1xuICAgICAgICAgIFxuICAgICAgICAgIGlmICh0YWJJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhYiA9IG9wZW5UYWJzW3RhYkluZGV4XTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gRG9uJ3QgdW5waW4gaWYgbm90IHBpbm5lZFxuICAgICAgICAgICAgaWYgKCF0YWIucGlubmVkKSByZXR1cm47XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgdGFiIHRvIGJlIHVucGlubmVkXG4gICAgICAgICAgICBjb25zdCB1cGRhdGVkVGFiID0geyAuLi50YWIsIHBpbm5lZDogZmFsc2UsIHBpbm5lZE9yZGVyOiB1bmRlZmluZWQgfTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gUmVtb3ZlIHRhYiBmcm9tIGN1cnJlbnQgcG9zaXRpb25cbiAgICAgICAgICAgIGNvbnN0IG5ld1RhYnMgPSBbLi4ub3BlblRhYnNdO1xuICAgICAgICAgICAgbmV3VGFicy5zcGxpY2UodGFiSW5kZXgsIDEpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBGaW5kIHRoZSBwb3NpdGlvbiBhZnRlciBhbGwgcGlubmVkIHRhYnNcbiAgICAgICAgICAgIGNvbnN0IHBpbm5lZENvdW50ID0gbmV3VGFicy5maWx0ZXIodCA9PiB0LnBpbm5lZCkubGVuZ3RoO1xuICAgICAgICAgICAgbmV3VGFicy5zcGxpY2UocGlubmVkQ291bnQsIDAsIHVwZGF0ZWRUYWIpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBzZXQoeyBvcGVuVGFiczogbmV3VGFicyB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgdXBkYXRlVGFiQ29udGVudDogKHRhYklkOiBzdHJpbmcsIGNvbnRlbnQ6IHN0cmluZykgPT4ge1xuICAgICAgICAgIGNvbnN0IHsgb3BlblRhYnMgfSA9IGdldCgpO1xuICAgICAgICAgIGNvbnN0IHVwZGF0ZWRUYWJzID0gb3BlblRhYnMubWFwKCh0YWI6IEVkaXRvclRhYikgPT4gXG4gICAgICAgICAgICB0YWIuaWQgPT09IHRhYklkIFxuICAgICAgICAgICAgICA/IHsgLi4udGFiLCBjb250ZW50LCBtb2RpZmllZDogdHJ1ZSB9XG4gICAgICAgICAgICAgIDogdGFiXG4gICAgICAgICAgKTtcbiAgICAgICAgICBcbiAgICAgICAgICBzZXQoeyBvcGVuVGFiczogdXBkYXRlZFRhYnMgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdXBkYXRlRmlsZUNvbnRlbnQ6ICh0YWJJZDogc3RyaW5nLCBjb250ZW50OiBzdHJpbmcpID0+IHtcbiAgICAgICAgICBjb25zdCB7IG9wZW5UYWJzIH0gPSBnZXQoKTtcbiAgICAgICAgICBcbiAgICAgICAgICBjb25zb2xlLmxvZygn8J+TnSB1cGRhdGVGaWxlQ29udGVudCBjYWxsZWQ6Jywge1xuICAgICAgICAgICAgdGFiSWQsXG4gICAgICAgICAgICBjb250ZW50TGVuZ3RoOiBjb250ZW50Lmxlbmd0aCxcbiAgICAgICAgICAgIGNvbnRlbnRQcmV2aWV3OiBjb250ZW50LnN1YnN0cmluZygwLCAxMDApLFxuICAgICAgICAgICAgY3VycmVudFRhYnNDb3VudDogb3BlblRhYnMubGVuZ3RoXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgXG4gICAgICAgICAgY29uc3QgZXhpc3RpbmdUYWIgPSBvcGVuVGFicy5maW5kKHRhYiA9PiB0YWIuaWQgPT09IHRhYklkKTtcbiAgICAgICAgICBpZiAoZXhpc3RpbmdUYWIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCfwn5OLIEZvdW5kIGV4aXN0aW5nIHRhYiB0byB1cGRhdGU6Jywge1xuICAgICAgICAgICAgICBpZDogZXhpc3RpbmdUYWIuaWQsXG4gICAgICAgICAgICAgIG5hbWU6IGV4aXN0aW5nVGFiLm5hbWUsXG4gICAgICAgICAgICAgIGN1cnJlbnRDb250ZW50TGVuZ3RoOiBleGlzdGluZ1RhYi5jb250ZW50Py5sZW5ndGggfHwgMCxcbiAgICAgICAgICAgICAgbmV3Q29udGVudExlbmd0aDogY29udGVudC5sZW5ndGgsXG4gICAgICAgICAgICAgIGNvbnRlbnRDaGFuZ2VkOiBleGlzdGluZ1RhYi5jb250ZW50ICE9PSBjb250ZW50XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCfimqDvuI8gVGFiIG5vdCBmb3VuZCBmb3IgdXBkYXRlOicsIHRhYklkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgY29uc3QgdXBkYXRlZFRhYnMgPSBvcGVuVGFicy5tYXAoKHRhYjogRWRpdG9yVGFiKSA9PiBcbiAgICAgICAgICAgIHRhYi5pZCA9PT0gdGFiSWQgXG4gICAgICAgICAgICAgID8geyAuLi50YWIsIGNvbnRlbnQsIG1vZGlmaWVkOiB0cnVlIH1cbiAgICAgICAgICAgICAgOiB0YWJcbiAgICAgICAgICApO1xuICAgICAgICAgIFxuICAgICAgICAgIGNvbnNvbGUubG9nKCfinIUgVGFiIGNvbnRlbnQgdXBkYXRlIGNvbXBsZXRlOicsIHtcbiAgICAgICAgICAgIHRhYklkLFxuICAgICAgICAgICAgdXBkYXRlZFRhYnNDb3VudDogdXBkYXRlZFRhYnMubGVuZ3RoLFxuICAgICAgICAgICAgaGFzTWF0Y2hpbmdUYWI6ICEhdXBkYXRlZFRhYnMuZmluZCh0ID0+IHQuaWQgPT09IHRhYklkKVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIFxuICAgICAgICAgIHNldCh7IG9wZW5UYWJzOiB1cGRhdGVkVGFicyB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICB1cGRhdGVGaWxlQ29udGVudEluU3RvcmU6IChmaWxlSWQ6IHN0cmluZywgY29udGVudDogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgY29uc3QgeyBwcm9qZWN0RmlsZXMsIGZpbmFuY2lhbEZpbGVzLCBvcGVuVGFicyB9ID0gZ2V0KCk7XG4gICAgICAgICAgXG4gICAgICAgICAgY29uc29sZS5sb2coJ/CflIQgdXBkYXRlRmlsZUNvbnRlbnRJblN0b3JlIGNhbGxlZDonLCB7XG4gICAgICAgICAgICBmaWxlSWQsXG4gICAgICAgICAgICBjb250ZW50TGVuZ3RoOiBjb250ZW50Lmxlbmd0aCxcbiAgICAgICAgICAgIGNvbnRlbnRQcmV2aWV3OiBjb250ZW50LnN1YnN0cmluZygwLCAxMDApLFxuICAgICAgICAgICAgY3VycmVudFByb2plY3RGaWxlc0NvdW50OiBwcm9qZWN0RmlsZXMubGVuZ3RoLFxuICAgICAgICAgICAgY3VycmVudEZpbmFuY2lhbEZpbGVzQ291bnQ6IGZpbmFuY2lhbEZpbGVzLmxlbmd0aCxcbiAgICAgICAgICAgIGN1cnJlbnRPcGVuVGFic0NvdW50OiBvcGVuVGFicy5sZW5ndGhcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBGaW5kIHRoZSBmaWxlIHRvIHNlZSBjdXJyZW50IHN0YXRlXG4gICAgICAgICAgY29uc3QgZXhpc3RpbmdQcm9qZWN0RmlsZSA9IHByb2plY3RGaWxlcy5maW5kKGYgPT4gZi5pZCA9PT0gZmlsZUlkKTtcbiAgICAgICAgICBjb25zdCBleGlzdGluZ0ZpbmFuY2lhbEZpbGUgPSBmaW5hbmNpYWxGaWxlcy5maW5kKGYgPT4gZi5pZCA9PT0gZmlsZUlkKTtcbiAgICAgICAgICBjb25zdCBleGlzdGluZ0ZpbGUgPSBleGlzdGluZ1Byb2plY3RGaWxlIHx8IGV4aXN0aW5nRmluYW5jaWFsRmlsZTtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAoZXhpc3RpbmdGaWxlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygn8J+ThCBGb3VuZCBleGlzdGluZyBmaWxlOicsIHtcbiAgICAgICAgICAgICAgaWQ6IGV4aXN0aW5nRmlsZS5pZCxcbiAgICAgICAgICAgICAgbmFtZTogZXhpc3RpbmdGaWxlLm5hbWUsXG4gICAgICAgICAgICAgIGN1cnJlbnRDb250ZW50TGVuZ3RoOiBleGlzdGluZ0ZpbGUuY29udGVudD8ubGVuZ3RoIHx8IDAsXG4gICAgICAgICAgICAgIG5ld0NvbnRlbnRMZW5ndGg6IGNvbnRlbnQubGVuZ3RoLFxuICAgICAgICAgICAgICBjb250ZW50Q2hhbmdlZDogZXhpc3RpbmdGaWxlLmNvbnRlbnQgIT09IGNvbnRlbnRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ+KaoO+4jyBGaWxlIG5vdCBmb3VuZCBpbiBzdG9yZTonLCBmaWxlSWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBVcGRhdGUgdGhlIGZpbGUgaW4gdGhlIGFwcHJvcHJpYXRlIHN0b3JlXG4gICAgICAgICAgY29uc3QgdXBkYXRlZFByb2plY3RGaWxlcyA9IHByb2plY3RGaWxlcy5tYXAoZmlsZSA9PlxuICAgICAgICAgICAgZmlsZS5pZCA9PT0gZmlsZUlkID8geyAuLi5maWxlLCBjb250ZW50LCBtb2RpZmllZEF0OiBuZXcgRGF0ZSgpIH0gOiBmaWxlXG4gICAgICAgICAgKTtcbiAgICAgICAgICBcbiAgICAgICAgICBjb25zdCB1cGRhdGVkRmluYW5jaWFsRmlsZXMgPSBmaW5hbmNpYWxGaWxlcy5tYXAoZmlsZSA9PlxuICAgICAgICAgICAgZmlsZS5pZCA9PT0gZmlsZUlkID8geyAuLi5maWxlLCBjb250ZW50LCBtb2RpZmllZEF0OiBuZXcgRGF0ZSgpIH0gOiBmaWxlXG4gICAgICAgICAgKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBBbHNvIHVwZGF0ZSB0aGUgdGFiIGlmIGl0J3Mgb3BlblxuICAgICAgICAgIGNvbnN0IGV4aXN0aW5nVGFiID0gb3BlblRhYnMuZmluZCh0YWIgPT4gdGFiLmlkID09PSBmaWxlSWQpO1xuICAgICAgICAgIGlmIChleGlzdGluZ1RhYikge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ/Cfk4sgVXBkYXRpbmcgZXhpc3RpbmcgdGFiOicsIHtcbiAgICAgICAgICAgICAgdGFiSWQ6IGZpbGVJZCxcbiAgICAgICAgICAgICAgdGFiTmFtZTogZXhpc3RpbmdUYWIubmFtZSxcbiAgICAgICAgICAgICAgY3VycmVudFRhYkNvbnRlbnRMZW5ndGg6IGV4aXN0aW5nVGFiLmNvbnRlbnQ/Lmxlbmd0aCB8fCAwLFxuICAgICAgICAgICAgICBuZXdDb250ZW50TGVuZ3RoOiBjb250ZW50Lmxlbmd0aCxcbiAgICAgICAgICAgICAgdGFiQ29udGVudENoYW5nZWQ6IGV4aXN0aW5nVGFiLmNvbnRlbnQgIT09IGNvbnRlbnRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICBjb25zdCB1cGRhdGVkVGFicyA9IG9wZW5UYWJzLm1hcCgodGFiOiBFZGl0b3JUYWIpID0+IFxuICAgICAgICAgICAgdGFiLmlkID09PSBmaWxlSWQgXG4gICAgICAgICAgICAgID8geyAuLi50YWIsIGNvbnRlbnQsIG1vZGlmaWVkOiB0cnVlIH1cbiAgICAgICAgICAgICAgOiB0YWJcbiAgICAgICAgICApO1xuICAgICAgICAgIFxuICAgICAgICAgIGNvbnNvbGUubG9nKCfinIUgU3RvcmUgdXBkYXRlIGNvbXBsZXRlOicsIHtcbiAgICAgICAgICAgIGZpbGVJZCxcbiAgICAgICAgICAgIHByb2plY3RGaWxlc1VwZGF0ZWQ6IHVwZGF0ZWRQcm9qZWN0RmlsZXMubGVuZ3RoLFxuICAgICAgICAgICAgZmluYW5jaWFsRmlsZXNVcGRhdGVkOiB1cGRhdGVkRmluYW5jaWFsRmlsZXMubGVuZ3RoLFxuICAgICAgICAgICAgdGFic1VwZGF0ZWQ6IHVwZGF0ZWRUYWJzLmxlbmd0aCxcbiAgICAgICAgICAgIGhhc01hdGNoaW5nVGFiOiAhIXVwZGF0ZWRUYWJzLmZpbmQodCA9PiB0LmlkID09PSBmaWxlSWQpXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgXG4gICAgICAgICAgc2V0KHsgXG4gICAgICAgICAgICBwcm9qZWN0RmlsZXM6IHVwZGF0ZWRQcm9qZWN0RmlsZXMsXG4gICAgICAgICAgICBmaW5hbmNpYWxGaWxlczogdXBkYXRlZEZpbmFuY2lhbEZpbGVzLFxuICAgICAgICAgICAgb3BlblRhYnM6IHVwZGF0ZWRUYWJzXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdXBkYXRlRmlsZVN0YXR1czogKGZpbGVJZDogc3RyaW5nLCBzdGF0dXM6ICdkcmFmdCcgfCAnc2NoZWR1bGVkJyB8ICdwb3N0aW5nJyB8ICdwb3N0ZWQnIHwgJ2ZhaWxlZCcgfCAnY29tcGxldGUnKSA9PiB7XG4gICAgICAgICAgY29uc3QgeyBwcm9qZWN0RmlsZXMsIGZpbmFuY2lhbEZpbGVzLCBvcGVuVGFicyB9ID0gZ2V0KCk7XG5cbiAgICAgICAgICBjb25zb2xlLmxvZygn8J+UhCB1cGRhdGVGaWxlU3RhdHVzIGNhbGxlZDonLCB7XG4gICAgICAgICAgICBmaWxlSWQsXG4gICAgICAgICAgICBzdGF0dXMsXG4gICAgICAgICAgICBwcm9qZWN0RmlsZXNDb3VudDogcHJvamVjdEZpbGVzLmxlbmd0aCxcbiAgICAgICAgICAgIGFsbFByb2plY3RGaWxlSWRzOiBwcm9qZWN0RmlsZXMubWFwKGYgPT4gKHsgaWQ6IGYuaWQsIG5hbWU6IGYubmFtZSwgY3VycmVudFN0YXR1czogZi5zdGF0dXMgfSkpXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICAvLyBVcGRhdGUgaW4gcHJvamVjdCBmaWxlc1xuICAgICAgICAgIGNvbnN0IHVwZGF0ZWRQcm9qZWN0RmlsZXMgPSBwcm9qZWN0RmlsZXMubWFwKGZpbGUgPT5cbiAgICAgICAgICAgIGZpbGUuaWQgPT09IGZpbGVJZCA/IHsgLi4uZmlsZSwgc3RhdHVzLCBtb2RpZmllZEF0OiBuZXcgRGF0ZSgpIH0gOiBmaWxlXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIC8vIENoZWNrIGlmIGFueSBmaWxlIHdhcyBhY3R1YWxseSB1cGRhdGVkIGJ5IGlkXG4gICAgICAgICAgbGV0IHVwZGF0ZWRGaWxlID0gdXBkYXRlZFByb2plY3RGaWxlcy5maW5kKGYgPT4gZi5pZCA9PT0gZmlsZUlkKTtcbiAgICAgICAgICBjb25zb2xlLmxvZygn8J+TnSBGaWxlIHN0YXR1cyB1cGRhdGUgcmVzdWx0OicsIHtcbiAgICAgICAgICAgIGZpbGVJZCxcbiAgICAgICAgICAgIG5ld1N0YXR1czogc3RhdHVzLFxuICAgICAgICAgICAgZm91bmRGaWxlOiAhIXVwZGF0ZWRGaWxlLFxuICAgICAgICAgICAgdXBkYXRlZEZpbGVTdGF0dXM6IHVwZGF0ZWRGaWxlPy5zdGF0dXMsXG4gICAgICAgICAgICB3YXNDaGFuZ2VkOiB1cGRhdGVkRmlsZT8uc3RhdHVzID09PSBzdGF0dXNcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIC8vIEZhbGxiYWNrOiBpZiBub3QgZm91bmQgYnkgaWQsIGF0dGVtcHQgbWF0Y2ggYnkgZmlsZSBuYW1lIGZyb20gb3BlbiB0YWJcbiAgICAgICAgICBpZiAoIXVwZGF0ZWRGaWxlKSB7XG4gICAgICAgICAgICBjb25zdCB0YWIgPSBvcGVuVGFicy5maW5kKHQgPT4gdC5pZCA9PT0gZmlsZUlkKTtcbiAgICAgICAgICAgIGlmICh0YWIpIHtcbiAgICAgICAgICAgICAgY29uc3QgbWF0Y2hlZEJ5TmFtZUluZGV4ID0gdXBkYXRlZFByb2plY3RGaWxlcy5maW5kSW5kZXgoZiA9PiBmLm5hbWUgPT09IHRhYi5uYW1lKTtcbiAgICAgICAgICAgICAgaWYgKG1hdGNoZWRCeU5hbWVJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBieU5hbWUgPSB1cGRhdGVkUHJvamVjdEZpbGVzW21hdGNoZWRCeU5hbWVJbmRleF07XG4gICAgICAgICAgICAgICAgdXBkYXRlZFByb2plY3RGaWxlc1ttYXRjaGVkQnlOYW1lSW5kZXhdID0ge1xuICAgICAgICAgICAgICAgICAgLi4uYnlOYW1lLFxuICAgICAgICAgICAgICAgICAgc3RhdHVzLFxuICAgICAgICAgICAgICAgICAgbW9kaWZpZWRBdDogbmV3IERhdGUoKVxuICAgICAgICAgICAgICAgIH0gYXMgYW55O1xuICAgICAgICAgICAgICAgIHVwZGF0ZWRGaWxlID0gdXBkYXRlZFByb2plY3RGaWxlc1ttYXRjaGVkQnlOYW1lSW5kZXhdO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCfwn6epIEZhbGxiYWNrIHN0YXR1cyB1cGRhdGUgYnkgbmFtZTonLCB7IG5hbWU6IHRhYi5uYW1lLCBzdGF0dXMgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBVcGRhdGUgaW4gZmluYW5jaWFsIGZpbGVzXG4gICAgICAgICAgY29uc3QgdXBkYXRlZEZpbmFuY2lhbEZpbGVzID0gZmluYW5jaWFsRmlsZXMubWFwKGZpbGUgPT5cbiAgICAgICAgICAgIGZpbGUuaWQgPT09IGZpbGVJZCA/IHsgLi4uZmlsZSwgc3RhdHVzLCBtb2RpZmllZEF0OiBuZXcgRGF0ZSgpIH0gOiBmaWxlXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIHNldCh7XG4gICAgICAgICAgICBwcm9qZWN0RmlsZXM6IHVwZGF0ZWRQcm9qZWN0RmlsZXMsXG4gICAgICAgICAgICBmaW5hbmNpYWxGaWxlczogdXBkYXRlZEZpbmFuY2lhbEZpbGVzXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdXBkYXRlRmlsZUNvbnZleElkOiAoZmlsZUlkOiBzdHJpbmcsIGNvbnZleElkOiBzdHJpbmcpID0+IHtcbiAgICAgICAgICBjb25zdCB7IHByb2plY3RGaWxlcywgZmluYW5jaWFsRmlsZXMgfSA9IGdldCgpO1xuXG4gICAgICAgICAgLy8gVXBkYXRlIGluIHByb2plY3QgZmlsZXNcbiAgICAgICAgICBjb25zdCB1cGRhdGVkUHJvamVjdEZpbGVzID0gcHJvamVjdEZpbGVzLm1hcChmaWxlID0+XG4gICAgICAgICAgICBmaWxlLmlkID09PSBmaWxlSWQgPyB7IC4uLmZpbGUsIGNvbnZleElkLCBtb2RpZmllZEF0OiBuZXcgRGF0ZSgpIH0gOiBmaWxlXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIC8vIFVwZGF0ZSBpbiBmaW5hbmNpYWwgZmlsZXNcbiAgICAgICAgICBjb25zdCB1cGRhdGVkRmluYW5jaWFsRmlsZXMgPSBmaW5hbmNpYWxGaWxlcy5tYXAoZmlsZSA9PlxuICAgICAgICAgICAgZmlsZS5pZCA9PT0gZmlsZUlkID8geyAuLi5maWxlLCBjb252ZXhJZCwgbW9kaWZpZWRBdDogbmV3IERhdGUoKSB9IDogZmlsZVxuICAgICAgICAgICk7XG5cbiAgICAgICAgICBzZXQoe1xuICAgICAgICAgICAgcHJvamVjdEZpbGVzOiB1cGRhdGVkUHJvamVjdEZpbGVzLFxuICAgICAgICAgICAgZmluYW5jaWFsRmlsZXM6IHVwZGF0ZWRGaW5hbmNpYWxGaWxlc1xuICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIHVwZGF0ZUZvbGRlckNvbnZleElkOiAoZm9sZGVySWQ6IHN0cmluZywgY29udmV4SWQ6IHN0cmluZykgPT4ge1xuICAgICAgICAgIGNvbnN0IHsgcHJvamVjdEZvbGRlcnMsIGZpbmFuY2lhbEZvbGRlcnMgfSA9IGdldCgpO1xuXG4gICAgICAgICAgLy8gVXBkYXRlIGluIHByb2plY3QgZm9sZGVyc1xuICAgICAgICAgIGNvbnN0IHVwZGF0ZWRQcm9qZWN0Rm9sZGVycyA9IHByb2plY3RGb2xkZXJzLm1hcChmb2xkZXIgPT5cbiAgICAgICAgICAgIGZvbGRlci5pZCA9PT0gZm9sZGVySWQgPyB7IC4uLmZvbGRlciwgY29udmV4SWQgfSA6IGZvbGRlclxuICAgICAgICAgICk7XG5cbiAgICAgICAgICAvLyBVcGRhdGUgaW4gZmluYW5jaWFsIGZvbGRlcnNcbiAgICAgICAgICBjb25zdCB1cGRhdGVkRmluYW5jaWFsRm9sZGVycyA9IGZpbmFuY2lhbEZvbGRlcnMubWFwKGZvbGRlciA9PlxuICAgICAgICAgICAgZm9sZGVyLmlkID09PSBmb2xkZXJJZCA/IHsgLi4uZm9sZGVyLCBjb252ZXhJZCB9IDogZm9sZGVyXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIHNldCh7XG4gICAgICAgICAgICBwcm9qZWN0Rm9sZGVyczogdXBkYXRlZFByb2plY3RGb2xkZXJzLFxuICAgICAgICAgICAgZmluYW5jaWFsRm9sZGVyczogdXBkYXRlZEZpbmFuY2lhbEZvbGRlcnNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBjcmVhdGVOZXdGaWxlOiAobmFtZTogc3RyaW5nLCB0eXBlOiBQcm9qZWN0RmlsZVsndHlwZSddLCBjYXRlZ29yeTogUHJvamVjdEZpbGVbJ2NhdGVnb3J5J10gPSAncHJvamVjdCcsIGZvbGRlcklkPzogc3RyaW5nLCBjdXN0b21Db250ZW50Pzogc3RyaW5nLCBza2lwU3luYz86IGJvb2xlYW4pID0+IHtcbiAgICAgICAgICBjb25zdCB7IHByb2plY3RGaWxlcywgZmluYW5jaWFsRmlsZXMgfSA9IGdldCgpO1xuICAgICAgICAgIFxuICAgICAgICAgIGNvbnNvbGUubG9nKCfwn5SnIGNyZWF0ZU5ld0ZpbGUgY2FsbGVkIHdpdGg6Jywge1xuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICBjYXRlZ29yeSxcbiAgICAgICAgICAgIGZvbGRlcklkLFxuICAgICAgICAgICAgaGFzQ3VzdG9tQ29udGVudDogISFjdXN0b21Db250ZW50LFxuICAgICAgICAgICAgY3VzdG9tQ29udGVudExlbmd0aDogY3VzdG9tQ29udGVudD8ubGVuZ3RoIHx8IDAsXG4gICAgICAgICAgICBjdXN0b21Db250ZW50UHJldmlldzogY3VzdG9tQ29udGVudD8uc3Vic3RyaW5nKDAsIDEwMCkgfHwgJ05PIENVU1RPTSBDT05URU5UJ1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIEdlbmVyYXRlIHVuaXF1ZSBJRFxuICAgICAgICAgIGNvbnN0IGlkID0gYCR7bmFtZS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1teYS16MC05XS9nLCAnLScpfS0ke0RhdGUubm93KCl9YDtcbiAgICAgICAgICBjb25zdCBmaWxlTmFtZSA9IGAke25hbWV9JHtnZXRGaWxlRXh0ZW5zaW9uKHR5cGUpfWA7XG4gICAgICAgICAgY29uc3QgYmFzZVBhdGggPSBjYXRlZ29yeSA9PT0gJ2ZpbmFuY2lhbCcgPyAnL2ZpbmFuY2lhbC1kYXRhJyA6ICcvZWFjLXByb2plY3RzJztcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBVc2UgY3VzdG9tIGNvbnRlbnQgaWYgcHJvdmlkZWQsIG90aGVyd2lzZSB1c2UgZGVmYXVsdFxuICAgICAgICAgIGNvbnN0IGZpbGVDb250ZW50ID0gY3VzdG9tQ29udGVudCB8fCBnZXREZWZhdWx0Q29udGVudCh0eXBlLCBuYW1lKTtcbiAgICAgICAgICBcbiAgICAgICAgICBjb25zb2xlLmxvZygn8J+ThCBGaW5hbCBmaWxlIGNvbnRlbnQ6Jywge1xuICAgICAgICAgICAgZmlsZU5hbWUsXG4gICAgICAgICAgICBjb250ZW50TGVuZ3RoOiBmaWxlQ29udGVudC5sZW5ndGgsXG4gICAgICAgICAgICBjb250ZW50UHJldmlldzogZmlsZUNvbnRlbnQuc3Vic3RyaW5nKDAsIDEwMCksXG4gICAgICAgICAgICBpc0N1c3RvbTogISFjdXN0b21Db250ZW50XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQ3JlYXRlIG5ldyBmaWxlXG4gICAgICAgICAgY29uc3QgbmV3RmlsZTogUHJvamVjdEZpbGUgPSB7XG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIG5hbWU6IGZpbGVOYW1lLFxuICAgICAgICAgICAgaWNvbjogZ2V0RmlsZUljb24odHlwZSksXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgY2F0ZWdvcnksXG4gICAgICAgICAgICBjb250ZW50OiBmaWxlQ29udGVudCxcbiAgICAgICAgICAgIGZpbGVQYXRoOiBgJHtiYXNlUGF0aH0vJHtmaWxlTmFtZX1gLFxuICAgICAgICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLFxuICAgICAgICAgICAgbW9kaWZpZWRBdDogbmV3IERhdGUoKSxcbiAgICAgICAgICAgIGZvbGRlcklkLCAvLyBBZGQgZm9sZGVyIGFzc2lnbm1lbnRcbiAgICAgICAgICAgIHN0YXR1czogWydmYWNlYm9vaycsICdyZWRkaXQnLCAnaW5zdGFncmFtJywgJ3gnXS5pbmNsdWRlcyh0eXBlKSA/ICdkcmFmdCcgOiB1bmRlZmluZWQsIC8vIERlZmF1bHQgc29jaWFsIG1lZGlhIGZpbGVzIHRvIGRyYWZ0XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIC8vIEFkZCB0byBhcHByb3ByaWF0ZSBmaWxlIGFycmF5IGFuZCBlbnN1cmUgY2F0ZWdvcnkgaXMgdmlzaWJsZVxuICAgICAgICAgIGlmIChjYXRlZ29yeSA9PT0gJ2ZpbmFuY2lhbCcpIHtcbiAgICAgICAgICAgIHNldCh7XG4gICAgICAgICAgICAgIGZpbmFuY2lhbEZpbGVzOiBbLi4uZmluYW5jaWFsRmlsZXMsIG5ld0ZpbGVdLFxuICAgICAgICAgICAgICBzaG93RmluYW5jaWFsQ2F0ZWdvcnk6IHRydWUsIC8vIEVuc3VyZSBmaW5hbmNpYWwgY2F0ZWdvcnkgaXMgdmlzaWJsZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNldCh7XG4gICAgICAgICAgICAgIHByb2plY3RGaWxlczogWy4uLnByb2plY3RGaWxlcywgbmV3RmlsZV0sXG4gICAgICAgICAgICAgIHNob3dQcm9qZWN0c0NhdGVnb3J5OiB0cnVlLCAvLyBFbnN1cmUgcHJvamVjdHMgY2F0ZWdvcnkgaXMgdmlzaWJsZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc29sZS5sb2coJ/Cfk4EgRmlsZSBhZGRlZCB0byBzdG9yZSwgYWJvdXQgdG8gb3BlbiB0YWI6Jywge1xuICAgICAgICAgICAgZmlsZUlkOiBpZCxcbiAgICAgICAgICAgIGZpbGVOYW1lOiBmaWxlTmFtZSxcbiAgICAgICAgICAgIGNvbnRlbnRMZW5ndGg6IG5ld0ZpbGUuY29udGVudD8ubGVuZ3RoIHx8IDAsXG4gICAgICAgICAgICBoYXNDb250ZW50OiAhIW5ld0ZpbGUuY29udGVudFxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgLy8gQXV0b21hdGljYWxseSBvcGVuIHRoZSBuZXcgZmlsZSB3aXRoIGEgc21hbGwgZGVsYXkgdG8gZW5zdXJlIHN0YXRlIGlzIHNldFxuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ+KPsCBPcGVuaW5nIHRhYiBhZnRlciB0aW1lb3V0IGZvciBmaWxlOicsIGlkKTtcbiAgICAgICAgICAgIGdldCgpLm9wZW5UYWIobmV3RmlsZSk7XG4gICAgICAgICAgfSwgMTApO1xuXG4gICAgICAgICAgY29uc29sZS5sb2coJ+KchSBUYWIgd2lsbCBvcGVuIGZvciBuZXcgZmlsZTonLCB7XG4gICAgICAgICAgICBmaWxlSWQ6IGlkLFxuICAgICAgICAgICAgZmlsZU5hbWU6IGZpbGVOYW1lXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICAvLyBTYXZlIHRvIENvbnZleCBkYXRhYmFzZSAoYXN5bmMgLSBkb24ndCBibG9jayBVSSlcbiAgICAgICAgICAvLyBTa2lwIGlmIHRoaXMgaXMgYSBzeW5jIG9wZXJhdGlvbiB0byBwcmV2ZW50IGxvb3BzXG4gICAgICAgICAgaWYgKCFza2lwU3luYykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgLy8gVEVNUE9SQVJJTFkgRElTQUJMRUQgVE8gU1RPUCBJTkZJTklURSBMT09QXG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKCfwn5qrIFRFTVBPUkFSSUxZIERJU0FCTEVEOiBGaWxlIGNyZWF0ZWQgbG9jYWxseSAobm90IGRpc3BhdGNoaW5nIGV2ZW50KTonLCBuZXdGaWxlKTtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIC8vIEdldCB0aGUgZm9sZGVyJ3MgY29udmV4IElEIGlmIGF2YWlsYWJsZVxuICAgICAgICAgICAgICAvLyBsZXQgcHJvamVjdElkID0gbnVsbDtcbiAgICAgICAgICAgICAgLy8gaWYgKGZvbGRlcklkKSB7XG4gICAgICAgICAgICAgIC8vICAgY29uc3QgeyBwcm9qZWN0Rm9sZGVycywgZmluYW5jaWFsRm9sZGVycyB9ID0gZ2V0KCk7XG4gICAgICAgICAgICAgIC8vICAgY29uc3QgYWxsRm9sZGVycyA9IFsuLi5wcm9qZWN0Rm9sZGVycywgLi4uZmluYW5jaWFsRm9sZGVyc107XG4gICAgICAgICAgICAgIC8vICAgY29uc3QgZm9sZGVyID0gYWxsRm9sZGVycy5maW5kKGYgPT4gZi5pZCA9PT0gZm9sZGVySWQpO1xuICAgICAgICAgICAgICAvLyAgIHByb2plY3RJZCA9IGZvbGRlcj8uY29udmV4SWQgfHwgbnVsbDtcbiAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgLy8gRGlzcGF0Y2ggY3VzdG9tIGV2ZW50IHRoYXQgY29tcG9uZW50cyBjYW4gbGlzdGVuIHRvXG4gICAgICAgICAgICAgIC8vIFRFTVBPUkFSSUxZIERJU0FCTEVEIFRPIFNUT1AgSU5GSU5JVEUgTE9PUFxuICAgICAgICAgICAgICAvLyBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgLy8gICB3aW5kb3cuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ2ZpbGVDcmVhdGVkJywgeyBcbiAgICAgICAgICAgICAgLy8gICAgIGRldGFpbDogeyBcbiAgICAgICAgICAgICAgLy8gICAgICAgZmlsZTogbmV3RmlsZSxcbiAgICAgICAgICAgICAgLy8gICAgICAgcHJvamVjdElkOiBwcm9qZWN0SWQgLy8gVXNlIGZvbGRlcidzIGNvbnZleElkIGlmIGF2YWlsYWJsZVxuICAgICAgICAgICAgICAvLyAgICAgfSBcbiAgICAgICAgICAgICAgLy8gICB9KSk7XG4gICAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gc2F2ZSBmaWxlIHRvIGRhdGFiYXNlOicsIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ/CflIQgRmlsZSBjcmVhdGVkIGZyb20gc3luYywgc2tpcHBpbmcgZGF0YWJhc2Ugc2F2ZTonLCBuZXdGaWxlLm5hbWUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFJldHVybiB0aGUgZmlsZSBJRCBzbyBjYWxsZXIgY2FuIHJlZmVyZW5jZSBpdFxuICAgICAgICAgIHJldHVybiBpZDtcbiAgICAgICAgfSxcblxuICAgICAgICBjcmVhdGVGb2xkZXI6IChuYW1lOiBzdHJpbmcsIGNhdGVnb3J5OiAncHJvamVjdCcgfCAnZmluYW5jaWFsJywgY29udmV4SWQ/OiBzdHJpbmcpID0+IHtcbiAgICAgICAgICBjb25zdCB7IHByb2plY3RGb2xkZXJzLCBmaW5hbmNpYWxGb2xkZXJzLCB1cGRhdGVGb2xkZXJDb252ZXhJZCB9ID0gZ2V0KCk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQ2hlY2sgaWYgZm9sZGVyIHdpdGggdGhpcyBuYW1lIGFscmVhZHkgZXhpc3RzXG4gICAgICAgICAgY29uc3QgZXhpc3RpbmdGb2xkZXJzID0gY2F0ZWdvcnkgPT09ICdmaW5hbmNpYWwnID8gZmluYW5jaWFsRm9sZGVycyA6IHByb2plY3RGb2xkZXJzO1xuICAgICAgICAgIGNvbnN0IGV4aXN0aW5nRm9sZGVyID0gZXhpc3RpbmdGb2xkZXJzLmZpbmQoZm9sZGVyID0+IFxuICAgICAgICAgICAgZm9sZGVyLm5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZS50b0xvd2VyQ2FzZSgpXG4gICAgICAgICAgKTtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAoZXhpc3RpbmdGb2xkZXIpIHtcbiAgICAgICAgICAgIC8vIElmIGZvbGRlciBleGlzdHMgYnV0IGRvZXNuJ3QgaGF2ZSBhIGNvbnZleElkLCB1cGRhdGUgaXRcbiAgICAgICAgICAgIGlmIChjb252ZXhJZCAmJiAhZXhpc3RpbmdGb2xkZXIuY29udmV4SWQpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coYFVwZGF0aW5nIGV4aXN0aW5nIGZvbGRlciBcIiR7bmFtZX1cIiB3aXRoIENvbnZleCBJRDogJHtjb252ZXhJZH1gKTtcbiAgICAgICAgICAgICAgdXBkYXRlRm9sZGVyQ29udmV4SWQoZXhpc3RpbmdGb2xkZXIuaWQsIGNvbnZleElkKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBGb2xkZXIgXCIke25hbWV9XCIgYWxyZWFkeSBleGlzdHMgaW4gJHtjYXRlZ29yeX0gY2F0ZWdvcnksIHNraXBwaW5nIGNyZWF0aW9uYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIEdlbmVyYXRlIHRydWx5IHVuaXF1ZSBJRCB1c2luZyBjcnlwdG8gaWYgYXZhaWxhYmxlLCBvdGhlcndpc2UgZmFsbGJhY2sgdG8gdGltZXN0YW1wICsgcmFuZG9tXG4gICAgICAgICAgbGV0IHVuaXF1ZUlkOiBzdHJpbmc7XG4gICAgICAgICAgaWYgKHR5cGVvZiBjcnlwdG8gIT09ICd1bmRlZmluZWQnICYmIGNyeXB0by5yYW5kb21VVUlEKSB7XG4gICAgICAgICAgICB1bmlxdWVJZCA9IGBmb2xkZXItJHtuYW1lLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvW15hLXowLTldL2csICctJyl9LSR7Y3J5cHRvLnJhbmRvbVVVSUQoKX1gO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBGYWxsYmFjayBmb3IgZW52aXJvbm1lbnRzIHdpdGhvdXQgY3J5cHRvLnJhbmRvbVVVSURcbiAgICAgICAgICAgIGNvbnN0IHRpbWVzdGFtcCA9IERhdGUubm93KCk7XG4gICAgICAgICAgICBjb25zdCByYW5kb20gPSBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMiwgMTIpO1xuICAgICAgICAgICAgY29uc3QgY291bnRlciA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDAwKTtcbiAgICAgICAgICAgIHVuaXF1ZUlkID0gYGZvbGRlci0ke25hbWUudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9bXmEtejAtOV0vZywgJy0nKX0tJHt0aW1lc3RhbXB9LSR7cmFuZG9tfS0ke2NvdW50ZXJ9YDtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gRG91YmxlLWNoZWNrIHVuaXF1ZW5lc3MgYWdhaW5zdCBhbGwgZXhpc3RpbmcgZm9sZGVyIElEc1xuICAgICAgICAgIGNvbnN0IGFsbEZvbGRlcnMgPSBbLi4ucHJvamVjdEZvbGRlcnMsIC4uLmZpbmFuY2lhbEZvbGRlcnNdO1xuICAgICAgICAgIHdoaWxlIChhbGxGb2xkZXJzLnNvbWUoZm9sZGVyID0+IGZvbGRlci5pZCA9PT0gdW5pcXVlSWQpKSB7XG4gICAgICAgICAgICBjb25zdCByYW5kb21TdWZmaXggPSBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMiwgOCk7XG4gICAgICAgICAgICB1bmlxdWVJZCA9IGAke3VuaXF1ZUlkfS0ke3JhbmRvbVN1ZmZpeH1gO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBDcmVhdGUgbmV3IGZvbGRlclxuICAgICAgICAgIGNvbnN0IG5ld0ZvbGRlcjogUHJvamVjdEZvbGRlciA9IHtcbiAgICAgICAgICAgIGlkOiB1bmlxdWVJZCxcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICBjYXRlZ29yeSxcbiAgICAgICAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKSxcbiAgICAgICAgICAgIGNvbnZleElkLCAvLyBTdG9yZSB0aGUgQ29udmV4IHByb2plY3QgSURcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgLy8gQWRkIHRvIGFwcHJvcHJpYXRlIGZvbGRlciBhcnJheSBhbmQgZW5zdXJlIGNhdGVnb3J5IGlzIHZpc2libGVcbiAgICAgICAgICBpZiAoY2F0ZWdvcnkgPT09ICdmaW5hbmNpYWwnKSB7XG4gICAgICAgICAgICBzZXQoe1xuICAgICAgICAgICAgICBmaW5hbmNpYWxGb2xkZXJzOiBbbmV3Rm9sZGVyLCAuLi5maW5hbmNpYWxGb2xkZXJzXSxcbiAgICAgICAgICAgICAgc2hvd0ZpbmFuY2lhbENhdGVnb3J5OiB0cnVlLCAvLyBFbnN1cmUgZmluYW5jaWFsIGNhdGVnb3J5IGlzIHZpc2libGVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZXQoe1xuICAgICAgICAgICAgICBwcm9qZWN0Rm9sZGVyczogW25ld0ZvbGRlciwgLi4ucHJvamVjdEZvbGRlcnNdLFxuICAgICAgICAgICAgICBzaG93UHJvamVjdHNDYXRlZ29yeTogdHJ1ZSwgLy8gRW5zdXJlIHByb2plY3RzIGNhdGVnb3J5IGlzIHZpc2libGVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvLyBFbWVyZ2VuY3kgY2xlYW51cCBmdW5jdGlvbiBmb3IgZHVwbGljYXRlIGZvbGRlciBJRHNcbiAgICAgICAgY2xlYW51cER1cGxpY2F0ZUZvbGRlcnM6ICgpID0+IHtcbiAgICAgICAgICBjb25zdCB7IHByb2plY3RGb2xkZXJzLCBmaW5hbmNpYWxGb2xkZXJzIH0gPSBnZXQoKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBGdW5jdGlvbiB0byByZW1vdmUgZHVwbGljYXRlcyBhbmQgZml4IGJhZCBJRHNcbiAgICAgICAgICBjb25zdCBjbGVhbnVwRm9sZGVycyA9IChmb2xkZXJzOiBQcm9qZWN0Rm9sZGVyW10pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHNlZW4gPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgICAgICAgICAgIGNvbnN0IGNsZWFuZWQgPSBmb2xkZXJzLmZpbHRlcihmb2xkZXIgPT4ge1xuICAgICAgICAgICAgICAvLyBSZW1vdmUgZm9sZGVycyB3aXRoIHRoZSBwcm9ibGVtYXRpYyBrZXkgcGF0dGVyblxuICAgICAgICAgICAgICBpZiAoZm9sZGVyLmlkLmluY2x1ZGVzKCdmb2xkZXItaW5kZXgtMTc1MzA2NDUwODkzOScpKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYPCfp7kgUmVtb3ZpbmcgcHJvYmxlbWF0aWMgZm9sZGVyOiAke2ZvbGRlci5pZH0gKCR7Zm9sZGVyLm5hbWV9KWApO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgLy8gUmVtb3ZlIGR1cGxpY2F0ZSBJRHNcbiAgICAgICAgICAgICAgaWYgKHNlZW4uaGFzKGZvbGRlci5pZCkpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhg8J+nuSBSZW1vdmluZyBkdXBsaWNhdGUgZm9sZGVyOiAke2ZvbGRlci5pZH0gKCR7Zm9sZGVyLm5hbWV9KWApO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgc2Vlbi5hZGQoZm9sZGVyLmlkKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gUmVnZW5lcmF0ZSBJRHMgZm9yIGFueSByZW1haW5pbmcgZm9sZGVycyB3aXRoIG9sZCBwYXR0ZXJuc1xuICAgICAgICAgICAgcmV0dXJuIGNsZWFuZWQubWFwKGZvbGRlciA9PiB7XG4gICAgICAgICAgICAgIGlmIChmb2xkZXIuaWQuc3RhcnRzV2l0aCgnZm9sZGVyLWluZGV4LScpIHx8IGZvbGRlci5pZC5sZW5ndGggPCAyMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0lkID0gdHlwZW9mIGNyeXB0byAhPT0gJ3VuZGVmaW5lZCcgJiYgY3J5cHRvLnJhbmRvbVVVSURcbiAgICAgICAgICAgICAgICAgID8gYGZvbGRlci0ke2ZvbGRlci5uYW1lLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvW15hLXowLTldL2csICctJyl9LSR7Y3J5cHRvLnJhbmRvbVVVSUQoKX1gXG4gICAgICAgICAgICAgICAgICA6IGBmb2xkZXItJHtmb2xkZXIubmFtZS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1teYS16MC05XS9nLCAnLScpfS0ke0RhdGUubm93KCl9LSR7TWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDIsIDEyKX1gO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGDwn5SEIFJlZ2VuZXJhdGluZyBJRCBmb3IgZm9sZGVyOiAke2ZvbGRlci5pZH0g4oaSICR7bmV3SWR9ICgke2ZvbGRlci5uYW1lfSlgKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICByZXR1cm4geyAuLi5mb2xkZXIsIGlkOiBuZXdJZCB9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBmb2xkZXI7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIFxuICAgICAgICAgIGNvbnN0IGNsZWFuZWRQcm9qZWN0Rm9sZGVycyA9IGNsZWFudXBGb2xkZXJzKHByb2plY3RGb2xkZXJzKTtcbiAgICAgICAgICBjb25zdCBjbGVhbmVkRmluYW5jaWFsRm9sZGVycyA9IGNsZWFudXBGb2xkZXJzKGZpbmFuY2lhbEZvbGRlcnMpO1xuICAgICAgICAgIFxuICAgICAgICAgIGlmIChjbGVhbmVkUHJvamVjdEZvbGRlcnMubGVuZ3RoICE9PSBwcm9qZWN0Rm9sZGVycy5sZW5ndGggfHwgXG4gICAgICAgICAgICAgIGNsZWFuZWRGaW5hbmNpYWxGb2xkZXJzLmxlbmd0aCAhPT0gZmluYW5jaWFsRm9sZGVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCfwn6e5IENsZWFudXAgY29tcGxldGVkLCB1cGRhdGluZyBzdG9yZS4uLicpO1xuICAgICAgICAgICAgc2V0KHtcbiAgICAgICAgICAgICAgcHJvamVjdEZvbGRlcnM6IGNsZWFuZWRQcm9qZWN0Rm9sZGVycyxcbiAgICAgICAgICAgICAgZmluYW5jaWFsRm9sZGVyczogY2xlYW5lZEZpbmFuY2lhbEZvbGRlcnNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBkZWxldGVGaWxlOiAoZmlsZUlkOiBzdHJpbmcpID0+IHtcbiAgICAgICAgICBjb25zdCB7IHByb2plY3RGaWxlcywgZmluYW5jaWFsRmlsZXMsIG9wZW5UYWJzIH0gPSBnZXQoKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBGaW5kIGFuZCByZW1vdmUgZnJvbSBhcHByb3ByaWF0ZSBhcnJheVxuICAgICAgICAgIGNvbnN0IHVwZGF0ZWRQcm9qZWN0RmlsZXMgPSBwcm9qZWN0RmlsZXMuZmlsdGVyKChmaWxlOiBQcm9qZWN0RmlsZSkgPT4gZmlsZS5pZCAhPT0gZmlsZUlkKTtcbiAgICAgICAgICBjb25zdCB1cGRhdGVkRmluYW5jaWFsRmlsZXMgPSBmaW5hbmNpYWxGaWxlcy5maWx0ZXIoKGZpbGU6IFByb2plY3RGaWxlKSA9PiBmaWxlLmlkICE9PSBmaWxlSWQpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIENsb3NlIHRhYiBpZiBpdCdzIG9wZW5cbiAgICAgICAgICBjb25zdCB0YWJUb0Nsb3NlID0gb3BlblRhYnMuZmluZCgodGFiOiBFZGl0b3JUYWIpID0+IHRhYi5pZCA9PT0gZmlsZUlkKTtcbiAgICAgICAgICBpZiAodGFiVG9DbG9zZSkge1xuICAgICAgICAgICAgZ2V0KCkuY2xvc2VUYWIoZmlsZUlkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgc2V0KHsgXG4gICAgICAgICAgICBwcm9qZWN0RmlsZXM6IHVwZGF0ZWRQcm9qZWN0RmlsZXMsXG4gICAgICAgICAgICBmaW5hbmNpYWxGaWxlczogdXBkYXRlZEZpbmFuY2lhbEZpbGVzIFxuICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlbmFtZUZpbGU6IChmaWxlSWQ6IHN0cmluZywgbmV3TmFtZTogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgY29uc3QgeyBwcm9qZWN0RmlsZXMsIGZpbmFuY2lhbEZpbGVzLCBvcGVuVGFicyB9ID0gZ2V0KCk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gRmluZCB0aGUgZmlsZSB0byBnZXQgaXRzIHR5cGUgYW5kIGdlbmVyYXRlIG5ldyBmaWxlbmFtZSB3aXRoIGV4dGVuc2lvblxuICAgICAgICAgIGNvbnN0IHByb2plY3RGaWxlID0gcHJvamVjdEZpbGVzLmZpbmQoKGZpbGU6IFByb2plY3RGaWxlKSA9PiBmaWxlLmlkID09PSBmaWxlSWQpO1xuICAgICAgICAgIGNvbnN0IGZpbmFuY2lhbEZpbGUgPSBmaW5hbmNpYWxGaWxlcy5maW5kKChmaWxlOiBQcm9qZWN0RmlsZSkgPT4gZmlsZS5pZCA9PT0gZmlsZUlkKTtcbiAgICAgICAgICBjb25zdCBmaWxlID0gcHJvamVjdEZpbGUgfHwgZmluYW5jaWFsRmlsZTtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAoIWZpbGUpIHJldHVybjtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBHZW5lcmF0ZSBuZXcgZmlsZW5hbWUgd2l0aCBhcHByb3ByaWF0ZSBleHRlbnNpb25cbiAgICAgICAgICBjb25zdCBuZXdGaWxlTmFtZSA9IGAke25ld05hbWV9JHtnZXRGaWxlRXh0ZW5zaW9uKGZpbGUudHlwZSl9YDtcbiAgICAgICAgICBjb25zdCBiYXNlUGF0aCA9IGZpbGUuY2F0ZWdvcnkgPT09ICdmaW5hbmNpYWwnID8gJy9maW5hbmNpYWwtZGF0YScgOiAnL2VhYy1wcm9qZWN0cyc7XG4gICAgICAgICAgY29uc3QgbmV3RmlsZVBhdGggPSBgJHtiYXNlUGF0aH0vJHtuZXdGaWxlTmFtZX1gO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgZmlsZSBpbiBhcHByb3ByaWF0ZSBhcnJheVxuICAgICAgICAgIGNvbnN0IHVwZGF0ZWRQcm9qZWN0RmlsZXMgPSBwcm9qZWN0RmlsZXMubWFwKChmOiBQcm9qZWN0RmlsZSkgPT5cbiAgICAgICAgICAgIGYuaWQgPT09IGZpbGVJZFxuICAgICAgICAgICAgICA/IHsgLi4uZiwgbmFtZTogbmV3RmlsZU5hbWUsIGZpbGVQYXRoOiBuZXdGaWxlUGF0aCwgbW9kaWZpZWRBdDogbmV3IERhdGUoKSB9XG4gICAgICAgICAgICAgIDogZlxuICAgICAgICAgICk7XG5cbiAgICAgICAgICBjb25zdCB1cGRhdGVkRmluYW5jaWFsRmlsZXMgPSBmaW5hbmNpYWxGaWxlcy5tYXAoKGY6IFByb2plY3RGaWxlKSA9PlxuICAgICAgICAgICAgZi5pZCA9PT0gZmlsZUlkXG4gICAgICAgICAgICAgID8geyAuLi5mLCBuYW1lOiBuZXdGaWxlTmFtZSwgZmlsZVBhdGg6IG5ld0ZpbGVQYXRoLCBtb2RpZmllZEF0OiBuZXcgRGF0ZSgpIH1cbiAgICAgICAgICAgICAgOiBmXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIC8vIFVwZGF0ZSBvcGVuIHRhYnMgaWYgdGhlIGZpbGUgaXMgb3BlblxuICAgICAgICAgIGNvbnN0IHVwZGF0ZWRUYWJzID0gb3BlblRhYnMubWFwKCh0YWI6IEVkaXRvclRhYikgPT5cbiAgICAgICAgICAgIHRhYi5pZCA9PT0gZmlsZUlkXG4gICAgICAgICAgICAgID8geyAuLi50YWIsIG5hbWU6IG5ld0ZpbGVOYW1lLCBmaWxlUGF0aDogbmV3RmlsZVBhdGgsIG1vZGlmaWVkOiB0cnVlIH1cbiAgICAgICAgICAgICAgOiB0YWJcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgc2V0KHtcbiAgICAgICAgICAgIHByb2plY3RGaWxlczogdXBkYXRlZFByb2plY3RGaWxlcyxcbiAgICAgICAgICAgIGZpbmFuY2lhbEZpbGVzOiB1cGRhdGVkRmluYW5jaWFsRmlsZXMsXG4gICAgICAgICAgICBvcGVuVGFiczogdXBkYXRlZFRhYnMsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVuYW1lRm9sZGVyOiAoZm9sZGVySWQ6IHN0cmluZywgbmV3TmFtZTogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgY29uc3QgeyBwcm9qZWN0Rm9sZGVycywgZmluYW5jaWFsRm9sZGVycyB9ID0gZ2V0KCk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gVXBkYXRlIHRoZSBmb2xkZXIgaW4gYXBwcm9wcmlhdGUgYXJyYXlcbiAgICAgICAgICBjb25zdCB1cGRhdGVkUHJvamVjdEZvbGRlcnMgPSBwcm9qZWN0Rm9sZGVycy5tYXAoKGZvbGRlcjogUHJvamVjdEZvbGRlcikgPT5cbiAgICAgICAgICAgIGZvbGRlci5pZCA9PT0gZm9sZGVySWRcbiAgICAgICAgICAgICAgPyB7IC4uLmZvbGRlciwgbmFtZTogbmV3TmFtZSB9XG4gICAgICAgICAgICAgIDogZm9sZGVyXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIGNvbnN0IHVwZGF0ZWRGaW5hbmNpYWxGb2xkZXJzID0gZmluYW5jaWFsRm9sZGVycy5tYXAoKGZvbGRlcjogUHJvamVjdEZvbGRlcikgPT5cbiAgICAgICAgICAgIGZvbGRlci5pZCA9PT0gZm9sZGVySWRcbiAgICAgICAgICAgICAgPyB7IC4uLmZvbGRlciwgbmFtZTogbmV3TmFtZSB9XG4gICAgICAgICAgICAgIDogZm9sZGVyXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIHNldCh7XG4gICAgICAgICAgICBwcm9qZWN0Rm9sZGVyczogdXBkYXRlZFByb2plY3RGb2xkZXJzLFxuICAgICAgICAgICAgZmluYW5jaWFsRm9sZGVyczogdXBkYXRlZEZpbmFuY2lhbEZvbGRlcnMsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGVsZXRlRm9sZGVyOiAoZm9sZGVySWQ6IHN0cmluZykgPT4ge1xuICAgICAgICAgIGNvbnN0IHsgcHJvamVjdEZvbGRlcnMsIGZpbmFuY2lhbEZvbGRlcnMsIHByb2plY3RGaWxlcywgZmluYW5jaWFsRmlsZXMsIG9wZW5UYWJzIH0gPSBnZXQoKTtcblxuICAgICAgICAgIC8vIEZpbmQgYWxsIGZpbGVzIHRoYXQgd2VyZSBpbiB0aGlzIGZvbGRlclxuICAgICAgICAgIGNvbnN0IGZpbGVzVG9EZWxldGUgPSBbXG4gICAgICAgICAgICAuLi5wcm9qZWN0RmlsZXMuZmlsdGVyKChmaWxlOiBQcm9qZWN0RmlsZSkgPT4gZmlsZS5mb2xkZXJJZCA9PT0gZm9sZGVySWQpLFxuICAgICAgICAgICAgLi4uZmluYW5jaWFsRmlsZXMuZmlsdGVyKChmaWxlOiBQcm9qZWN0RmlsZSkgPT4gZmlsZS5mb2xkZXJJZCA9PT0gZm9sZGVySWQpXG4gICAgICAgICAgXTtcblxuICAgICAgICAgIC8vIENsb3NlIHRhYnMgZm9yIGFsbCBmaWxlcyBpbiB0aGlzIGZvbGRlclxuICAgICAgICAgIGZpbGVzVG9EZWxldGUuZm9yRWFjaCgoZmlsZTogUHJvamVjdEZpbGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRhYlRvQ2xvc2UgPSBvcGVuVGFicy5maW5kKCh0YWI6IEVkaXRvclRhYikgPT4gdGFiLmlkID09PSBmaWxlLmlkKTtcbiAgICAgICAgICAgIGlmICh0YWJUb0Nsb3NlKSB7XG4gICAgICAgICAgICAgIGdldCgpLmNsb3NlVGFiKGZpbGUuaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIFJlbW92ZSBmcm9tIGFwcHJvcHJpYXRlIGZvbGRlciBhcnJheVxuICAgICAgICAgIGNvbnN0IHVwZGF0ZWRQcm9qZWN0Rm9sZGVycyA9IHByb2plY3RGb2xkZXJzLmZpbHRlcigoZm9sZGVyOiBQcm9qZWN0Rm9sZGVyKSA9PiBmb2xkZXIuaWQgIT09IGZvbGRlcklkKTtcbiAgICAgICAgICBjb25zdCB1cGRhdGVkRmluYW5jaWFsRm9sZGVycyA9IGZpbmFuY2lhbEZvbGRlcnMuZmlsdGVyKChmb2xkZXI6IFByb2plY3RGb2xkZXIpID0+IGZvbGRlci5pZCAhPT0gZm9sZGVySWQpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIEFsc28gcmVtb3ZlIGFueSBmaWxlcyB0aGF0IHdlcmUgaW4gdGhpcyBmb2xkZXJcbiAgICAgICAgICBjb25zdCB1cGRhdGVkUHJvamVjdEZpbGVzID0gcHJvamVjdEZpbGVzLmZpbHRlcigoZmlsZTogUHJvamVjdEZpbGUpID0+IGZpbGUuZm9sZGVySWQgIT09IGZvbGRlcklkKTtcbiAgICAgICAgICBjb25zdCB1cGRhdGVkRmluYW5jaWFsRmlsZXMgPSBmaW5hbmNpYWxGaWxlcy5maWx0ZXIoKGZpbGU6IFByb2plY3RGaWxlKSA9PiBmaWxlLmZvbGRlcklkICE9PSBmb2xkZXJJZCk7XG4gICAgICAgICAgXG4gICAgICAgICAgc2V0KHsgXG4gICAgICAgICAgICBwcm9qZWN0Rm9sZGVyczogdXBkYXRlZFByb2plY3RGb2xkZXJzLFxuICAgICAgICAgICAgZmluYW5jaWFsRm9sZGVyczogdXBkYXRlZEZpbmFuY2lhbEZvbGRlcnMsXG4gICAgICAgICAgICBwcm9qZWN0RmlsZXM6IHVwZGF0ZWRQcm9qZWN0RmlsZXMsXG4gICAgICAgICAgICBmaW5hbmNpYWxGaWxlczogdXBkYXRlZEZpbmFuY2lhbEZpbGVzXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgbW92ZVRvVHJhc2g6IChpdGVtOiBQcm9qZWN0RmlsZSB8IFByb2plY3RGb2xkZXIsIHR5cGU6ICdmaWxlJyB8ICdmb2xkZXInKSA9PiB7XG4gICAgICAgICAgY29uc3QgeyB0cmFzaEl0ZW1zLCBwcm9qZWN0RmlsZXMsIGZpbmFuY2lhbEZpbGVzLCBwcm9qZWN0Rm9sZGVycywgZmluYW5jaWFsRm9sZGVycywgb3BlblRhYnMgfSA9IGdldCgpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIENyZWF0ZSB0cmFzaCBpdGVtXG4gICAgICAgICAgY29uc3QgdHJhc2hJdGVtOiBUcmFzaEl0ZW0gPSB7XG4gICAgICAgICAgICBpZDogYHRyYXNoXyR7aXRlbS5pZH1fJHtEYXRlLm5vdygpfWAsXG4gICAgICAgICAgICBuYW1lOiBpdGVtLm5hbWUsXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgb3JpZ2luYWxEYXRhOiBpdGVtLFxuICAgICAgICAgICAgZGVsZXRlZEF0OiBuZXcgRGF0ZSgpLFxuICAgICAgICAgICAgY2F0ZWdvcnk6IGl0ZW0uY2F0ZWdvcnlcbiAgICAgICAgICB9O1xuICAgICAgICAgIFxuICAgICAgICAgIGlmICh0eXBlID09PSAnZmlsZScpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpbGUgPSBpdGVtIGFzIFByb2plY3RGaWxlO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBDbG9zZSB0YWIgaWYgaXQncyBvcGVuXG4gICAgICAgICAgICBjb25zdCB0YWJUb0Nsb3NlID0gb3BlblRhYnMuZmluZCgodGFiOiBFZGl0b3JUYWIpID0+IHRhYi5pZCA9PT0gZmlsZS5pZCk7XG4gICAgICAgICAgICBpZiAodGFiVG9DbG9zZSkge1xuICAgICAgICAgICAgICBnZXQoKS5jbG9zZVRhYihmaWxlLmlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gUmVtb3ZlIGZyb20gYXBwcm9wcmlhdGUgZmlsZSBhcnJheVxuICAgICAgICAgICAgY29uc3QgdXBkYXRlZFByb2plY3RGaWxlcyA9IHByb2plY3RGaWxlcy5maWx0ZXIoKGY6IFByb2plY3RGaWxlKSA9PiBmLmlkICE9PSBmaWxlLmlkKTtcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRGaW5hbmNpYWxGaWxlcyA9IGZpbmFuY2lhbEZpbGVzLmZpbHRlcigoZjogUHJvamVjdEZpbGUpID0+IGYuaWQgIT09IGZpbGUuaWQpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBzZXQoe1xuICAgICAgICAgICAgICB0cmFzaEl0ZW1zOiBbLi4udHJhc2hJdGVtcywgdHJhc2hJdGVtXSxcbiAgICAgICAgICAgICAgcHJvamVjdEZpbGVzOiB1cGRhdGVkUHJvamVjdEZpbGVzLFxuICAgICAgICAgICAgICBmaW5hbmNpYWxGaWxlczogdXBkYXRlZEZpbmFuY2lhbEZpbGVzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgZm9sZGVyID0gaXRlbSBhcyBQcm9qZWN0Rm9sZGVyO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBGaW5kIGFsbCBmaWxlcyB0aGF0IHdlcmUgaW4gdGhpcyBmb2xkZXIgYW5kIG1vdmUgdGhlbSB0byB0cmFzaCB0b29cbiAgICAgICAgICAgIGNvbnN0IGZpbGVzVG9UcmFzaCA9IFtcbiAgICAgICAgICAgICAgLi4ucHJvamVjdEZpbGVzLmZpbHRlcigoZmlsZTogUHJvamVjdEZpbGUpID0+IGZpbGUuZm9sZGVySWQgPT09IGZvbGRlci5pZCksXG4gICAgICAgICAgICAgIC4uLmZpbmFuY2lhbEZpbGVzLmZpbHRlcigoZmlsZTogUHJvamVjdEZpbGUpID0+IGZpbGUuZm9sZGVySWQgPT09IGZvbGRlci5pZClcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIENsb3NlIHRhYnMgZm9yIGFsbCBmaWxlcyBpbiB0aGlzIGZvbGRlclxuICAgICAgICAgICAgZmlsZXNUb1RyYXNoLmZvckVhY2goKGZpbGU6IFByb2plY3RGaWxlKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IHRhYlRvQ2xvc2UgPSBvcGVuVGFicy5maW5kKCh0YWI6IEVkaXRvclRhYikgPT4gdGFiLmlkID09PSBmaWxlLmlkKTtcbiAgICAgICAgICAgICAgaWYgKHRhYlRvQ2xvc2UpIHtcbiAgICAgICAgICAgICAgICBnZXQoKS5jbG9zZVRhYihmaWxlLmlkKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIENyZWF0ZSB0cmFzaCBpdGVtcyBmb3IgYWxsIGZpbGVzIGluIHRoZSBmb2xkZXJcbiAgICAgICAgICAgIGNvbnN0IGZpbGVUcmFzaEl0ZW1zID0gZmlsZXNUb1RyYXNoLm1hcCgoZmlsZTogUHJvamVjdEZpbGUpID0+ICh7XG4gICAgICAgICAgICAgIGlkOiBgdHJhc2hfJHtmaWxlLmlkfV8ke0RhdGUubm93KCl9YCxcbiAgICAgICAgICAgICAgbmFtZTogZmlsZS5uYW1lLFxuICAgICAgICAgICAgICB0eXBlOiAnZmlsZScgYXMgY29uc3QsXG4gICAgICAgICAgICAgIG9yaWdpbmFsRGF0YTogZmlsZSxcbiAgICAgICAgICAgICAgZGVsZXRlZEF0OiBuZXcgRGF0ZSgpLFxuICAgICAgICAgICAgICBjYXRlZ29yeTogZmlsZS5jYXRlZ29yeVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBSZW1vdmUgZm9sZGVyIGFuZCBpdHMgZmlsZXMgZnJvbSBhcnJheXNcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRQcm9qZWN0Rm9sZGVycyA9IHByb2plY3RGb2xkZXJzLmZpbHRlcigoZjogUHJvamVjdEZvbGRlcikgPT4gZi5pZCAhPT0gZm9sZGVyLmlkKTtcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRGaW5hbmNpYWxGb2xkZXJzID0gZmluYW5jaWFsRm9sZGVycy5maWx0ZXIoKGY6IFByb2plY3RGb2xkZXIpID0+IGYuaWQgIT09IGZvbGRlci5pZCk7XG4gICAgICAgICAgICBjb25zdCB1cGRhdGVkUHJvamVjdEZpbGVzID0gcHJvamVjdEZpbGVzLmZpbHRlcigoZmlsZTogUHJvamVjdEZpbGUpID0+IGZpbGUuZm9sZGVySWQgIT09IGZvbGRlci5pZCk7XG4gICAgICAgICAgICBjb25zdCB1cGRhdGVkRmluYW5jaWFsRmlsZXMgPSBmaW5hbmNpYWxGaWxlcy5maWx0ZXIoKGZpbGU6IFByb2plY3RGaWxlKSA9PiBmaWxlLmZvbGRlcklkICE9PSBmb2xkZXIuaWQpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBzZXQoe1xuICAgICAgICAgICAgICB0cmFzaEl0ZW1zOiBbLi4udHJhc2hJdGVtcywgdHJhc2hJdGVtLCAuLi5maWxlVHJhc2hJdGVtc10sXG4gICAgICAgICAgICAgIHByb2plY3RGb2xkZXJzOiB1cGRhdGVkUHJvamVjdEZvbGRlcnMsXG4gICAgICAgICAgICAgIGZpbmFuY2lhbEZvbGRlcnM6IHVwZGF0ZWRGaW5hbmNpYWxGb2xkZXJzLFxuICAgICAgICAgICAgICBwcm9qZWN0RmlsZXM6IHVwZGF0ZWRQcm9qZWN0RmlsZXMsXG4gICAgICAgICAgICAgIGZpbmFuY2lhbEZpbGVzOiB1cGRhdGVkRmluYW5jaWFsRmlsZXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICByZXN0b3JlRnJvbVRyYXNoOiAodHJhc2hJdGVtSWQ6IHN0cmluZykgPT4ge1xuICAgICAgICAgIGNvbnN0IHsgdHJhc2hJdGVtcywgcHJvamVjdEZpbGVzLCBmaW5hbmNpYWxGaWxlcywgcHJvamVjdEZvbGRlcnMsIGZpbmFuY2lhbEZvbGRlcnMgfSA9IGdldCgpO1xuICAgICAgICAgIFxuICAgICAgICAgIGNvbnN0IHRyYXNoSXRlbSA9IHRyYXNoSXRlbXMuZmluZChpdGVtID0+IGl0ZW0uaWQgPT09IHRyYXNoSXRlbUlkKTtcbiAgICAgICAgICBpZiAoIXRyYXNoSXRlbSkgcmV0dXJuO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIFJlbW92ZSBmcm9tIHRyYXNoXG4gICAgICAgICAgY29uc3QgdXBkYXRlZFRyYXNoSXRlbXMgPSB0cmFzaEl0ZW1zLmZpbHRlcihpdGVtID0+IGl0ZW0uaWQgIT09IHRyYXNoSXRlbUlkKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBSZXN0b3JlIHRvIGFwcHJvcHJpYXRlIGFycmF5XG4gICAgICAgICAgaWYgKHRyYXNoSXRlbS50eXBlID09PSAnZmlsZScpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpbGUgPSB0cmFzaEl0ZW0ub3JpZ2luYWxEYXRhIGFzIFByb2plY3RGaWxlO1xuICAgICAgICAgICAgaWYgKGZpbGUuY2F0ZWdvcnkgPT09ICdwcm9qZWN0Jykge1xuICAgICAgICAgICAgICBzZXQoe1xuICAgICAgICAgICAgICAgIHRyYXNoSXRlbXM6IHVwZGF0ZWRUcmFzaEl0ZW1zLFxuICAgICAgICAgICAgICAgIHByb2plY3RGaWxlczogWy4uLnByb2plY3RGaWxlcywgeyAuLi5maWxlLCBtb2RpZmllZEF0OiBuZXcgRGF0ZSgpIH1dXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc2V0KHtcbiAgICAgICAgICAgICAgICB0cmFzaEl0ZW1zOiB1cGRhdGVkVHJhc2hJdGVtcyxcbiAgICAgICAgICAgICAgICBmaW5hbmNpYWxGaWxlczogWy4uLmZpbmFuY2lhbEZpbGVzLCB7IC4uLmZpbGUsIG1vZGlmaWVkQXQ6IG5ldyBEYXRlKCkgfV1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGZvbGRlciA9IHRyYXNoSXRlbS5vcmlnaW5hbERhdGEgYXMgUHJvamVjdEZvbGRlcjtcbiAgICAgICAgICAgIGlmIChmb2xkZXIuY2F0ZWdvcnkgPT09ICdwcm9qZWN0Jykge1xuICAgICAgICAgICAgICBzZXQoe1xuICAgICAgICAgICAgICAgIHRyYXNoSXRlbXM6IHVwZGF0ZWRUcmFzaEl0ZW1zLFxuICAgICAgICAgICAgICAgIHByb2plY3RGb2xkZXJzOiBbLi4ucHJvamVjdEZvbGRlcnMsIGZvbGRlcl1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzZXQoe1xuICAgICAgICAgICAgICAgIHRyYXNoSXRlbXM6IHVwZGF0ZWRUcmFzaEl0ZW1zLFxuICAgICAgICAgICAgICAgIGZpbmFuY2lhbEZvbGRlcnM6IFsuLi5maW5hbmNpYWxGb2xkZXJzLCBmb2xkZXJdXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBwZXJtYW5lbnRseURlbGV0ZTogKHRyYXNoSXRlbUlkOiBzdHJpbmcpID0+IHtcbiAgICAgICAgICBjb25zdCB7IHRyYXNoSXRlbXMgfSA9IGdldCgpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIFJlbW92ZSBmcm9tIHRyYXNoIHBlcm1hbmVudGx5XG4gICAgICAgICAgY29uc3QgdXBkYXRlZFRyYXNoSXRlbXMgPSB0cmFzaEl0ZW1zLmZpbHRlcihpdGVtID0+IGl0ZW0uaWQgIT09IHRyYXNoSXRlbUlkKTtcbiAgICAgICAgICBzZXQoeyB0cmFzaEl0ZW1zOiB1cGRhdGVkVHJhc2hJdGVtcyB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBlbXB0eVRyYXNoOiAoKSA9PiB7XG4gICAgICAgICAgc2V0KHsgdHJhc2hJdGVtczogW10gfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY2xlYXJQcm9qZWN0Q2F0ZWdvcnk6ICgpID0+IHtcbiAgICAgICAgICBjb25zdCB7IG9wZW5UYWJzIH0gPSBnZXQoKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBDbG9zZSBhbGwgcHJvamVjdC1yZWxhdGVkIHRhYnNcbiAgICAgICAgICBjb25zdCBwcm9qZWN0VGFiSWRzID0gb3BlblRhYnNcbiAgICAgICAgICAgIC5maWx0ZXIoKHRhYjogRWRpdG9yVGFiKSA9PiB7XG4gICAgICAgICAgICAgIC8vIEZpbmQgdGhlIGNvcnJlc3BvbmRpbmcgZmlsZSB0byBjaGVjayBpdHMgY2F0ZWdvcnlcbiAgICAgICAgICAgICAgY29uc3QgeyBwcm9qZWN0RmlsZXMgfSA9IGdldCgpO1xuICAgICAgICAgICAgICBjb25zdCBmaWxlID0gcHJvamVjdEZpbGVzLmZpbmQoKGY6IFByb2plY3RGaWxlKSA9PiBmLmlkID09PSB0YWIuaWQpO1xuICAgICAgICAgICAgICByZXR1cm4gZmlsZT8uY2F0ZWdvcnkgPT09ICdwcm9qZWN0JztcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAubWFwKCh0YWI6IEVkaXRvclRhYikgPT4gdGFiLmlkKTtcbiAgICAgICAgICBcbiAgICAgICAgICBwcm9qZWN0VGFiSWRzLmZvckVhY2goKHRhYklkOiBzdHJpbmcpID0+IGdldCgpLmNsb3NlVGFiKHRhYklkKSk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQ2xlYXIgYWxsIHByb2plY3QgZmlsZXMgYW5kIGZvbGRlcnNcbiAgICAgICAgICBzZXQoe1xuICAgICAgICAgICAgcHJvamVjdEZpbGVzOiBbXSxcbiAgICAgICAgICAgIHByb2plY3RGb2xkZXJzOiBbXSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBjbGVhckZpbmFuY2lhbENhdGVnb3J5OiAoKSA9PiB7XG4gICAgICAgICAgY29uc3QgeyBvcGVuVGFicyB9ID0gZ2V0KCk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQ2xvc2UgYWxsIGZpbmFuY2lhbC1yZWxhdGVkIHRhYnNcbiAgICAgICAgICBjb25zdCBmaW5hbmNpYWxUYWJJZHMgPSBvcGVuVGFic1xuICAgICAgICAgICAgLmZpbHRlcigodGFiOiBFZGl0b3JUYWIpID0+IHtcbiAgICAgICAgICAgICAgLy8gRmluZCB0aGUgY29ycmVzcG9uZGluZyBmaWxlIHRvIGNoZWNrIGl0cyBjYXRlZ29yeVxuICAgICAgICAgICAgICBjb25zdCB7IGZpbmFuY2lhbEZpbGVzIH0gPSBnZXQoKTtcbiAgICAgICAgICAgICAgY29uc3QgZmlsZSA9IGZpbmFuY2lhbEZpbGVzLmZpbmQoKGY6IFByb2plY3RGaWxlKSA9PiBmLmlkID09PSB0YWIuaWQpO1xuICAgICAgICAgICAgICByZXR1cm4gZmlsZT8uY2F0ZWdvcnkgPT09ICdmaW5hbmNpYWwnO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5tYXAoKHRhYjogRWRpdG9yVGFiKSA9PiB0YWIuaWQpO1xuICAgICAgICAgIFxuICAgICAgICAgIGZpbmFuY2lhbFRhYklkcy5mb3JFYWNoKCh0YWJJZDogc3RyaW5nKSA9PiBnZXQoKS5jbG9zZVRhYih0YWJJZCkpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIENsZWFyIGFsbCBmaW5hbmNpYWwgZmlsZXMgYW5kIGZvbGRlcnNcbiAgICAgICAgICBzZXQoe1xuICAgICAgICAgICAgZmluYW5jaWFsRmlsZXM6IFtdLFxuICAgICAgICAgICAgZmluYW5jaWFsRm9sZGVyczogW10sXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGVsZXRlUHJvamVjdHNDYXRlZ29yeTogKCkgPT4ge1xuICAgICAgICAgIGdldCgpLmNsZWFyUHJvamVjdENhdGVnb3J5KCk7XG4gICAgICAgICAgc2V0KHsgc2hvd1Byb2plY3RzQ2F0ZWdvcnk6IGZhbHNlIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIGRlbGV0ZUZpbmFuY2lhbENhdGVnb3J5OiAoKSA9PiB7XG4gICAgICAgICAgZ2V0KCkuY2xlYXJGaW5hbmNpYWxDYXRlZ29yeSgpO1xuICAgICAgICAgIHNldCh7IHNob3dGaW5hbmNpYWxDYXRlZ29yeTogZmFsc2UgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVvcmRlclByb2plY3RGb2xkZXJzOiAoZnJvbUluZGV4OiBudW1iZXIsIHRvSW5kZXg6IG51bWJlcikgPT4ge1xuICAgICAgICAgIGNvbnN0IHsgcHJvamVjdEZvbGRlcnMgfSA9IGdldCgpO1xuICAgICAgICAgIGNvbnN0IG5ld0ZvbGRlcnMgPSBbLi4ucHJvamVjdEZvbGRlcnNdO1xuICAgICAgICAgIGNvbnN0IFttb3ZlZEZvbGRlcl0gPSBuZXdGb2xkZXJzLnNwbGljZShmcm9tSW5kZXgsIDEpO1xuICAgICAgICAgIG5ld0ZvbGRlcnMuc3BsaWNlKHRvSW5kZXgsIDAsIG1vdmVkRm9sZGVyKTtcbiAgICAgICAgICBcbiAgICAgICAgICBzZXQoeyBwcm9qZWN0Rm9sZGVyczogbmV3Rm9sZGVycyB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICB1cGRhdGVQcm9qZWN0Rm9sZGVyczogKGZvbGRlcnM6IFByb2plY3RGb2xkZXJbXSkgPT4ge1xuICAgICAgICAgIHNldCh7IHByb2plY3RGb2xkZXJzOiBmb2xkZXJzIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlb3JkZXJGaWxlc0luRm9sZGVyOiAoZm9sZGVySWQ6IHN0cmluZywgZnJvbUluZGV4OiBudW1iZXIsIHRvSW5kZXg6IG51bWJlciwgY2F0ZWdvcnk6ICdwcm9qZWN0JyB8ICdmaW5hbmNpYWwnKSA9PiB7XG4gICAgICAgICAgY29uc3QgeyBwcm9qZWN0RmlsZXMsIGZpbmFuY2lhbEZpbGVzIH0gPSBnZXQoKTtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAoY2F0ZWdvcnkgPT09ICdwcm9qZWN0Jykge1xuICAgICAgICAgICAgLy8gRmlsdGVyIGZpbGVzIGluIHRoZSBzcGVjaWZpYyBmb2xkZXJcbiAgICAgICAgICAgIGNvbnN0IGZvbGRlckZpbGVzID0gcHJvamVjdEZpbGVzLmZpbHRlcihmaWxlID0+IGZpbGUuZm9sZGVySWQgPT09IGZvbGRlcklkKTtcbiAgICAgICAgICAgIGNvbnN0IG90aGVyRmlsZXMgPSBwcm9qZWN0RmlsZXMuZmlsdGVyKGZpbGUgPT4gZmlsZS5mb2xkZXJJZCAhPT0gZm9sZGVySWQpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBSZW9yZGVyIGZpbGVzIHdpdGhpbiB0aGUgZm9sZGVyXG4gICAgICAgICAgICBjb25zdCByZW9yZGVyZWRGb2xkZXJGaWxlcyA9IFsuLi5mb2xkZXJGaWxlc107XG4gICAgICAgICAgICBjb25zdCBbbW92ZWRGaWxlXSA9IHJlb3JkZXJlZEZvbGRlckZpbGVzLnNwbGljZShmcm9tSW5kZXgsIDEpO1xuICAgICAgICAgICAgcmVvcmRlcmVkRm9sZGVyRmlsZXMuc3BsaWNlKHRvSW5kZXgsIDAsIG1vdmVkRmlsZSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIENvbWJpbmUgd2l0aCBvdGhlciBmaWxlc1xuICAgICAgICAgICAgY29uc3QgbmV3UHJvamVjdEZpbGVzID0gWy4uLm90aGVyRmlsZXMsIC4uLnJlb3JkZXJlZEZvbGRlckZpbGVzXTtcbiAgICAgICAgICAgIHNldCh7IHByb2plY3RGaWxlczogbmV3UHJvamVjdEZpbGVzIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBTaW1pbGFyIGxvZ2ljIGZvciBmaW5hbmNpYWwgZmlsZXNcbiAgICAgICAgICAgIGNvbnN0IGZvbGRlckZpbGVzID0gZmluYW5jaWFsRmlsZXMuZmlsdGVyKGZpbGUgPT4gZmlsZS5mb2xkZXJJZCA9PT0gZm9sZGVySWQpO1xuICAgICAgICAgICAgY29uc3Qgb3RoZXJGaWxlcyA9IGZpbmFuY2lhbEZpbGVzLmZpbHRlcihmaWxlID0+IGZpbGUuZm9sZGVySWQgIT09IGZvbGRlcklkKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY29uc3QgcmVvcmRlcmVkRm9sZGVyRmlsZXMgPSBbLi4uZm9sZGVyRmlsZXNdO1xuICAgICAgICAgICAgY29uc3QgW21vdmVkRmlsZV0gPSByZW9yZGVyZWRGb2xkZXJGaWxlcy5zcGxpY2UoZnJvbUluZGV4LCAxKTtcbiAgICAgICAgICAgIHJlb3JkZXJlZEZvbGRlckZpbGVzLnNwbGljZSh0b0luZGV4LCAwLCBtb3ZlZEZpbGUpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBjb25zdCBuZXdGaW5hbmNpYWxGaWxlcyA9IFsuLi5vdGhlckZpbGVzLCAuLi5yZW9yZGVyZWRGb2xkZXJGaWxlc107XG4gICAgICAgICAgICBzZXQoeyBmaW5hbmNpYWxGaWxlczogbmV3RmluYW5jaWFsRmlsZXMgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHNhdmVGaWxlOiAodGFiSWQ6IHN0cmluZykgPT4ge1xuICAgICAgICAgIGNvbnN0IHsgb3BlblRhYnMsIHByb2plY3RGaWxlcywgZmluYW5jaWFsRmlsZXMgfSA9IGdldCgpO1xuICAgICAgICAgIGNvbnN0IHRhYiA9IG9wZW5UYWJzLmZpbmQoKHQ6IEVkaXRvclRhYikgPT4gdC5pZCA9PT0gdGFiSWQpO1xuICAgICAgICAgIFxuICAgICAgICAgIGlmICghdGFiKSByZXR1cm47XG5cbiAgICAgICAgICAvLyBVcGRhdGUgdGhlIGZpbGUgY29udGVudCBpbiBhcHByb3ByaWF0ZSBhcnJheVxuICAgICAgICAgIGNvbnN0IHVwZGF0ZWRQcm9qZWN0RmlsZXMgPSBwcm9qZWN0RmlsZXMubWFwKChmaWxlOiBQcm9qZWN0RmlsZSkgPT5cbiAgICAgICAgICAgIGZpbGUuaWQgPT09IHRhYklkXG4gICAgICAgICAgICAgID8geyAuLi5maWxlLCBjb250ZW50OiB0YWIuY29udGVudCwgbW9kaWZpZWRBdDogbmV3IERhdGUoKSB9XG4gICAgICAgICAgICAgIDogZmlsZVxuICAgICAgICAgICk7XG5cbiAgICAgICAgICBjb25zdCB1cGRhdGVkRmluYW5jaWFsRmlsZXMgPSBmaW5hbmNpYWxGaWxlcy5tYXAoKGZpbGU6IFByb2plY3RGaWxlKSA9PlxuICAgICAgICAgICAgZmlsZS5pZCA9PT0gdGFiSWRcbiAgICAgICAgICAgICAgPyB7IC4uLmZpbGUsIGNvbnRlbnQ6IHRhYi5jb250ZW50LCBtb2RpZmllZEF0OiBuZXcgRGF0ZSgpIH1cbiAgICAgICAgICAgICAgOiBmaWxlXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIGNvbnN0IHVwZGF0ZWRUYWJzID0gb3BlblRhYnMubWFwKCh0OiBFZGl0b3JUYWIpID0+XG4gICAgICAgICAgICB0LmlkID09PSB0YWJJZFxuICAgICAgICAgICAgICA/IHsgLi4udCwgbW9kaWZpZWQ6IGZhbHNlIH1cbiAgICAgICAgICAgICAgOiB0XG4gICAgICAgICAgKTtcblxuICAgICAgICAgIHNldCh7XG4gICAgICAgICAgICBwcm9qZWN0RmlsZXM6IHVwZGF0ZWRQcm9qZWN0RmlsZXMsXG4gICAgICAgICAgICBmaW5hbmNpYWxGaWxlczogdXBkYXRlZEZpbmFuY2lhbEZpbGVzLFxuICAgICAgICAgICAgb3BlblRhYnM6IHVwZGF0ZWRUYWJzLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldEVycm9yOiAoZXJyb3I6IHN0cmluZyB8IG51bGwpID0+IHtcbiAgICAgICAgICBzZXQoeyBlcnJvciB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBGaXggZmlsZXMgdGhhdCBkb24ndCBoYXZlIGNvbnRlbnRcbiAgICAgICAgcmVwYWlyRmlsZXNXaXRob3V0Q29udGVudDogKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHsgcHJvamVjdEZpbGVzLCBmaW5hbmNpYWxGaWxlcyB9ID0gZ2V0KCk7XG4gICAgICAgICAgXG4gICAgICAgICAgY29uc3QgcmVwYWlyZWRQcm9qZWN0RmlsZXMgPSBwcm9qZWN0RmlsZXMubWFwKGZpbGUgPT4ge1xuICAgICAgICAgICAgaWYgKCFmaWxlLmNvbnRlbnQgfHwgZmlsZS5jb250ZW50LnRyaW0oKSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAuLi5maWxlLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGdldERlZmF1bHRDb250ZW50KGZpbGUudHlwZSwgZmlsZS5uYW1lKSxcbiAgICAgICAgICAgICAgICBtb2RpZmllZEF0OiBuZXcgRGF0ZSgpXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmlsZTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBcbiAgICAgICAgICBjb25zdCByZXBhaXJlZEZpbmFuY2lhbEZpbGVzID0gZmluYW5jaWFsRmlsZXMubWFwKGZpbGUgPT4ge1xuICAgICAgICAgICAgaWYgKCFmaWxlLmNvbnRlbnQgfHwgZmlsZS5jb250ZW50LnRyaW0oKSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAuLi5maWxlLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGdldERlZmF1bHRDb250ZW50KGZpbGUudHlwZSwgZmlsZS5uYW1lKSxcbiAgICAgICAgICAgICAgICBtb2RpZmllZEF0OiBuZXcgRGF0ZSgpXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmlsZTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBcbiAgICAgICAgICBzZXQoe1xuICAgICAgICAgICAgcHJvamVjdEZpbGVzOiByZXBhaXJlZFByb2plY3RGaWxlcyxcbiAgICAgICAgICAgIGZpbmFuY2lhbEZpbGVzOiByZXBhaXJlZEZpbmFuY2lhbEZpbGVzXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVzZXQ6ICgpID0+IHtcbiAgICAgICAgICBzZXQoe1xuICAgICAgICAgICAgb3BlblRhYnM6IFtdLFxuICAgICAgICAgICAgYWN0aXZlVGFiOiAnJyxcbiAgICAgICAgICAgIHByb2plY3RGaWxlczogaW5pdGlhbFByb2plY3RGaWxlcyxcbiAgICAgICAgICAgIGZpbmFuY2lhbEZpbGVzOiBpbml0aWFsRmluYW5jaWFsRmlsZXMsXG4gICAgICAgICAgICBwcm9qZWN0Rm9sZGVyczogW10sXG4gICAgICAgICAgICBmaW5hbmNpYWxGb2xkZXJzOiBbXSxcbiAgICAgICAgICAgIHNob3dQcm9qZWN0c0NhdGVnb3J5OiB0cnVlLFxuICAgICAgICAgICAgc2hvd0ZpbmFuY2lhbENhdGVnb3J5OiBmYWxzZSwgLy8gRG9uJ3QgYXV0by1zaG93IGZpbmFuY2lhbCBjYXRlZ29yeSBvbiByZXNldFxuICAgICAgICAgICAgaXNMb2FkaW5nOiBmYWxzZSxcbiAgICAgICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIENsZWFyIHVzZXIgZGF0YSB3aGVuIHNpZ25pbmcgb3V0IChidXQga2VlcCBVSSBzdGF0ZSBsaWtlIHRoZW1lLCBldGMuKVxuICAgICAgICBjbGVhclVzZXJEYXRhOiAoKSA9PiB7XG4gICAgICAgICAgc2V0KHtcbiAgICAgICAgICAgIG9wZW5UYWJzOiBbXSxcbiAgICAgICAgICAgIGFjdGl2ZVRhYjogJycsXG4gICAgICAgICAgICBwcm9qZWN0RmlsZXM6IFtdLFxuICAgICAgICAgICAgZmluYW5jaWFsRmlsZXM6IFtdLFxuICAgICAgICAgICAgcHJvamVjdEZvbGRlcnM6IFtdLFxuICAgICAgICAgICAgZmluYW5jaWFsRm9sZGVyczogW10sXG4gICAgICAgICAgICB0cmFzaEl0ZW1zOiBbXSxcbiAgICAgICAgICAgIHNob3dQcm9qZWN0c0NhdGVnb3J5OiB0cnVlLFxuICAgICAgICAgICAgc2hvd0ZpbmFuY2lhbENhdGVnb3J5OiBmYWxzZSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBEZWJ1ZyBmdW5jdGlvbiB0byBoZWxwIHRyb3VibGVzaG9vdCBmaWxlIHBlcnNpc3RlbmNlIGlzc3Vlc1xuICAgICAgICBkZWJ1Z1N0b3JhZ2U6ICgpID0+IHtcbiAgICAgICAgICBjb25zdCBzdGF0ZSA9IGdldCgpO1xuICAgICAgICAgIGNvbnNvbGUubG9nKCfwn5SNIEN1cnJlbnQgc3RvcmUgc3RhdGU6Jywge1xuICAgICAgICAgICAgcHJvamVjdEZpbGVzOiBzdGF0ZS5wcm9qZWN0RmlsZXMubGVuZ3RoLFxuICAgICAgICAgICAgZmluYW5jaWFsRmlsZXM6IHN0YXRlLmZpbmFuY2lhbEZpbGVzLmxlbmd0aCxcbiAgICAgICAgICAgIHByb2plY3RGb2xkZXJzOiBzdGF0ZS5wcm9qZWN0Rm9sZGVycy5sZW5ndGgsXG4gICAgICAgICAgICBmaW5hbmNpYWxGb2xkZXJzOiBzdGF0ZS5maW5hbmNpYWxGb2xkZXJzLmxlbmd0aCxcbiAgICAgICAgICAgIHRyYXNoSXRlbXM6IHN0YXRlLnRyYXNoSXRlbXMubGVuZ3RoLFxuICAgICAgICAgICAgb3BlblRhYnM6IHN0YXRlLm9wZW5UYWJzLmxlbmd0aCxcbiAgICAgICAgICAgIGFjdGl2ZVRhYjogc3RhdGUuYWN0aXZlVGFiLFxuICAgICAgICAgICAgc2hvd1Byb2plY3RzQ2F0ZWdvcnk6IHN0YXRlLnNob3dQcm9qZWN0c0NhdGVnb3J5LFxuICAgICAgICAgICAgc2hvd0ZpbmFuY2lhbENhdGVnb3J5OiBzdGF0ZS5zaG93RmluYW5jaWFsQ2F0ZWdvcnlcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAoc3RhdGUucHJvamVjdEZpbGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCfwn5OBIFByb2plY3QgZmlsZXM6Jyk7XG4gICAgICAgICAgICBzdGF0ZS5wcm9qZWN0RmlsZXMuZm9yRWFjaCgoZmlsZSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coYCAgJHtpbmRleCArIDF9LiAke2ZpbGUubmFtZX0gKCR7ZmlsZS50eXBlfSkgLSBDcmVhdGVkOiAke2ZpbGUuY3JlYXRlZEF0fWApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIGlmIChzdGF0ZS5maW5hbmNpYWxGaWxlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygn8J+SsCBGaW5hbmNpYWwgZmlsZXM6Jyk7XG4gICAgICAgICAgICBzdGF0ZS5maW5hbmNpYWxGaWxlcy5mb3JFYWNoKChmaWxlLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgICAke2luZGV4ICsgMX0uICR7ZmlsZS5uYW1lfSAoJHtmaWxlLnR5cGV9KSAtIENyZWF0ZWQ6ICR7ZmlsZS5jcmVhdGVkQXR9YCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQ2hlY2sgbG9jYWxTdG9yYWdlXG4gICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5sb2NhbFN0b3JhZ2UpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0b3JlZCA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdlZGl0b3Itc3RvcmFnZScpO1xuICAgICAgICAgICAgaWYgKHN0b3JlZCkge1xuICAgICAgICAgICAgICBjb25zdCBwYXJzZWQgPSBKU09OLnBhcnNlKHN0b3JlZCk7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKCfwn5K+IFN0b3JlZCBzdGF0ZTonLCB7XG4gICAgICAgICAgICAgICAgcHJvamVjdEZpbGVzOiBwYXJzZWQuc3RhdGU/LnByb2plY3RGaWxlcz8ubGVuZ3RoIHx8IDAsXG4gICAgICAgICAgICAgICAgZmluYW5jaWFsRmlsZXM6IHBhcnNlZC5zdGF0ZT8uZmluYW5jaWFsRmlsZXM/Lmxlbmd0aCB8fCAwLFxuICAgICAgICAgICAgICAgIHZlcnNpb246IHBhcnNlZC52ZXJzaW9uXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coJ+KdjCBObyBkYXRhIGluIGxvY2FsU3RvcmFnZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvLyBFbWVyZ2VuY3kgZnVuY3Rpb24gdG8gY2xlYXIgYWxsIHN0b3JhZ2UgYW5kIHJlc2V0IHRvIGluaXRpYWwgc3RhdGVcbiAgICAgICAgY2xlYXJTdG9yYWdlOiAoKSA9PiB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ/Cfp7kgQ2xlYXJpbmcgYWxsIHN0b3JhZ2UgYW5kIHJlc2V0dGluZyB0byBpbml0aWFsIHN0YXRlLi4uJyk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQ2xlYXIgbG9jYWxTdG9yYWdlXG4gICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5sb2NhbFN0b3JhZ2UpIHtcbiAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCdlZGl0b3Itc3RvcmFnZScpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ+KchSBsb2NhbFN0b3JhZ2UgY2xlYXJlZCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBSZXNldCBzdG9yZSB0byBpbml0aWFsIHN0YXRlXG4gICAgICAgICAgc2V0KHtcbiAgICAgICAgICAgIG9wZW5UYWJzOiBbXSxcbiAgICAgICAgICAgIGFjdGl2ZVRhYjogJycsXG4gICAgICAgICAgICBwcm9qZWN0RmlsZXM6IFtdLFxuICAgICAgICAgICAgZmluYW5jaWFsRmlsZXM6IFtdLFxuICAgICAgICAgICAgcHJvamVjdEZvbGRlcnM6IFtdLFxuICAgICAgICAgICAgZmluYW5jaWFsRm9sZGVyczogW10sXG4gICAgICAgICAgICB0cmFzaEl0ZW1zOiBbXSxcbiAgICAgICAgICAgIHNob3dQcm9qZWN0c0NhdGVnb3J5OiB0cnVlLFxuICAgICAgICAgICAgc2hvd0ZpbmFuY2lhbENhdGVnb3J5OiBmYWxzZSxcbiAgICAgICAgICAgIGlzTG9hZGluZzogZmFsc2UsXG4gICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBcbiAgICAgICAgICBjb25zb2xlLmxvZygn4pyFIFN0b3JlIHJlc2V0IHRvIGluaXRpYWwgc3RhdGUnKTtcbiAgICAgICAgICBjb25zb2xlLmxvZygn8J+UhCBQbGVhc2UgcmVmcmVzaCB0aGUgcGFnZSB0byBjb21wbGV0ZSB0aGUgcmVzZXQnKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBSZXBsYWNlIHByb2plY3QgZmlsZXMgd2l0aCBkYXRhYmFzZSBmaWxlcyAoZm9yIGFnZ3Jlc3NpdmUgc3luYylcbiAgICAgICAgcmVwbGFjZVdpdGhEYXRhYmFzZUZpbGVzOiAoZGF0YWJhc2VGaWxlczogUHJvamVjdEZpbGVbXSkgPT4ge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCfwn5SEIFJlcGxhY2luZyBsb2NhbCBwcm9qZWN0IGZpbGVzIHdpdGggZGF0YWJhc2UgZmlsZXMuLi4nKTtcbiAgICAgICAgICBjb25zb2xlLmxvZyhg8J+TgSBSZXBsYWNpbmcgJHtnZXQoKS5wcm9qZWN0RmlsZXMubGVuZ3RofSBsb2NhbCBmaWxlcyB3aXRoICR7ZGF0YWJhc2VGaWxlcy5sZW5ndGh9IGRhdGFiYXNlIGZpbGVzYCk7XG4gICAgICAgICAgXG4gICAgICAgICAgc2V0KHsgXG4gICAgICAgICAgICBwcm9qZWN0RmlsZXM6IGRhdGFiYXNlRmlsZXMsXG4gICAgICAgICAgICBzaG93UHJvamVjdHNDYXRlZ29yeTogZGF0YWJhc2VGaWxlcy5sZW5ndGggPiAwIFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIFxuICAgICAgICAgIGNvbnNvbGUubG9nKCfinIUgUHJvamVjdCBmaWxlcyByZXBsYWNlZCB3aXRoIGRhdGFiYXNlIGZpbGVzJyk7XG4gICAgICAgIH0sXG4gICAgICB9KSxcbiAgICB7IG5hbWU6ICdlZGl0b3Itc3RvcmUnIH1cbiAgKVxuKTtcblxuLy8gTWFrZSBzdG9yZSBhdmFpbGFibGUgZ2xvYmFsbHkgZm9yIGRlYnVnZ2luZ1xuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICh3aW5kb3cgYXMgYW55KS51c2VFZGl0b3JTdG9yZSA9IHVzZUVkaXRvclN0b3JlO1xufSAiXSwibmFtZXMiOlsiQXRTaWduIiwiQnJhY2VzIiwiQ2FsZW5kYXIiLCJDYW1lcmEiLCJGaWxlQ29kZSIsIkZpbGVTcHJlYWRzaGVldCIsIkZpbGVUZXh0IiwiRmlsZVR5cGUiLCJIZWxwQ2lyY2xlIiwiTWVzc2FnZVNxdWFyZSIsImNyZWF0ZSIsImRldnRvb2xzIiwiZ2V0RmlsZUljb24iLCJ0eXBlIiwiZ2V0RmlsZUV4dGVuc2lvbiIsImdldERlZmF1bHRDb250ZW50IiwibmFtZSIsInJlcGxhY2UiLCJEYXRlIiwidG9JU09TdHJpbmciLCJ0b0xvY2FsZURhdGVTdHJpbmciLCJpbml0aWFsUHJvamVjdEZpbGVzIiwiaW5pdGlhbEZpbmFuY2lhbEZpbGVzIiwiaW5pdGlhbFByb2plY3RGb2xkZXJzIiwidXNlRWRpdG9yU3RvcmUiLCJzZXQiLCJnZXQiLCJvcGVuVGFicyIsImFjdGl2ZVRhYiIsInByb2plY3RGaWxlcyIsImZpbmFuY2lhbEZpbGVzIiwicHJvamVjdEZvbGRlcnMiLCJmaW5hbmNpYWxGb2xkZXJzIiwidHJhc2hJdGVtcyIsInNob3dQcm9qZWN0c0NhdGVnb3J5Iiwic2hvd0ZpbmFuY2lhbENhdGVnb3J5IiwiaXNMb2FkaW5nIiwiZXJyb3IiLCJvcGVuVGFiIiwiZmlsZSIsImNvbnNvbGUiLCJsb2ciLCJpZCIsImNvbnRlbnRMZW5ndGgiLCJjb250ZW50IiwibGVuZ3RoIiwiY29udGVudFByZXZpZXciLCJzdWJzdHJpbmciLCJwbGF0Zm9ybSIsInJhd0NvbnRlbnQiLCJleGlzdGluZ1RhYiIsImZpbmQiLCJ0YWIiLCJ1cGRhdGVkVGFicyIsIm1hcCIsImF1dG9QaW5GaWxlVHlwZXMiLCJzaG91bGRBdXRvUGlubiIsImluY2x1ZGVzIiwicGlubmVkT3JkZXIiLCJwaW5uZWRUYWJzIiwiZmlsdGVyIiwidCIsInBpbm5lZCIsIk1hdGgiLCJtYXgiLCJ0YWJDb250ZW50IiwiZmlsZUlkIiwiZmlsZU5hbWUiLCJoYXNDdXN0b21Db250ZW50IiwibmV3VGFiIiwibW9kaWZpZWQiLCJmaWxlUGF0aCIsInVuZGVmaW5lZCIsIm5ld1RhYnMiLCJvdGhlclRhYnMiLCJpbnNlcnRJbmRleCIsInNwbGljZSIsInVucGlubmVkVGFicyIsIm9wZW5TcGVjaWFsVGFiIiwiYXV0b1BpblR5cGVzIiwiY2xvc2VUYWIiLCJ0YWJJZCIsInRhYkluZGV4IiwiZmluZEluZGV4IiwibmV3QWN0aXZlVGFiIiwibmV4dEluZGV4IiwiY2xvc2VBbGxUYWJzIiwic2V0QWN0aXZlVGFiIiwiY3VycmVudEFjdGl2ZVRhYiIsInRhYkV4aXN0cyIsInNvbWUiLCJuZXdUYWJJZCIsIm9wZW5UYWJzQ291bnQiLCJhdmFpbGFibGVUYWJzIiwid2FybiIsInJlb3JkZXJUYWJzIiwiZnJvbVRhYklkIiwidG9UYWJJZCIsImZyb21JbmRleCIsInRvSW5kZXgiLCJtb3ZlZFRhYiIsInBpblRhYiIsIm5leHRQaW5uZWRPcmRlciIsInVwZGF0ZWRUYWIiLCJ1bnBpblRhYiIsInBpbm5lZENvdW50IiwidXBkYXRlVGFiQ29udGVudCIsInVwZGF0ZUZpbGVDb250ZW50IiwiY3VycmVudFRhYnNDb3VudCIsImN1cnJlbnRDb250ZW50TGVuZ3RoIiwibmV3Q29udGVudExlbmd0aCIsImNvbnRlbnRDaGFuZ2VkIiwidXBkYXRlZFRhYnNDb3VudCIsImhhc01hdGNoaW5nVGFiIiwidXBkYXRlRmlsZUNvbnRlbnRJblN0b3JlIiwiY3VycmVudFByb2plY3RGaWxlc0NvdW50IiwiY3VycmVudEZpbmFuY2lhbEZpbGVzQ291bnQiLCJjdXJyZW50T3BlblRhYnNDb3VudCIsImV4aXN0aW5nUHJvamVjdEZpbGUiLCJmIiwiZXhpc3RpbmdGaW5hbmNpYWxGaWxlIiwiZXhpc3RpbmdGaWxlIiwidXBkYXRlZFByb2plY3RGaWxlcyIsIm1vZGlmaWVkQXQiLCJ1cGRhdGVkRmluYW5jaWFsRmlsZXMiLCJ0YWJOYW1lIiwiY3VycmVudFRhYkNvbnRlbnRMZW5ndGgiLCJ0YWJDb250ZW50Q2hhbmdlZCIsInByb2plY3RGaWxlc1VwZGF0ZWQiLCJmaW5hbmNpYWxGaWxlc1VwZGF0ZWQiLCJ0YWJzVXBkYXRlZCIsInVwZGF0ZUZpbGVTdGF0dXMiLCJzdGF0dXMiLCJwcm9qZWN0RmlsZXNDb3VudCIsImFsbFByb2plY3RGaWxlSWRzIiwiY3VycmVudFN0YXR1cyIsInVwZGF0ZWRGaWxlIiwibmV3U3RhdHVzIiwiZm91bmRGaWxlIiwidXBkYXRlZEZpbGVTdGF0dXMiLCJ3YXNDaGFuZ2VkIiwibWF0Y2hlZEJ5TmFtZUluZGV4IiwiYnlOYW1lIiwidXBkYXRlRmlsZUNvbnZleElkIiwiY29udmV4SWQiLCJ1cGRhdGVGb2xkZXJDb252ZXhJZCIsImZvbGRlcklkIiwidXBkYXRlZFByb2plY3RGb2xkZXJzIiwiZm9sZGVyIiwidXBkYXRlZEZpbmFuY2lhbEZvbGRlcnMiLCJjcmVhdGVOZXdGaWxlIiwiY2F0ZWdvcnkiLCJjdXN0b21Db250ZW50Iiwic2tpcFN5bmMiLCJuZXdGaWxlIiwiY3VzdG9tQ29udGVudExlbmd0aCIsImN1c3RvbUNvbnRlbnRQcmV2aWV3IiwidG9Mb3dlckNhc2UiLCJub3ciLCJiYXNlUGF0aCIsImZpbGVDb250ZW50IiwiaXNDdXN0b20iLCJpY29uIiwiY3JlYXRlZEF0IiwiaGFzQ29udGVudCIsInNldFRpbWVvdXQiLCJjcmVhdGVGb2xkZXIiLCJleGlzdGluZ0ZvbGRlcnMiLCJleGlzdGluZ0ZvbGRlciIsInVuaXF1ZUlkIiwiY3J5cHRvIiwicmFuZG9tVVVJRCIsInRpbWVzdGFtcCIsInJhbmRvbSIsInRvU3RyaW5nIiwiY291bnRlciIsImZsb29yIiwiYWxsRm9sZGVycyIsInJhbmRvbVN1ZmZpeCIsIm5ld0ZvbGRlciIsImNsZWFudXBEdXBsaWNhdGVGb2xkZXJzIiwiY2xlYW51cEZvbGRlcnMiLCJmb2xkZXJzIiwic2VlbiIsIlNldCIsImNsZWFuZWQiLCJoYXMiLCJhZGQiLCJzdGFydHNXaXRoIiwibmV3SWQiLCJjbGVhbmVkUHJvamVjdEZvbGRlcnMiLCJjbGVhbmVkRmluYW5jaWFsRm9sZGVycyIsImRlbGV0ZUZpbGUiLCJ0YWJUb0Nsb3NlIiwicmVuYW1lRmlsZSIsIm5ld05hbWUiLCJwcm9qZWN0RmlsZSIsImZpbmFuY2lhbEZpbGUiLCJuZXdGaWxlTmFtZSIsIm5ld0ZpbGVQYXRoIiwicmVuYW1lRm9sZGVyIiwiZGVsZXRlRm9sZGVyIiwiZmlsZXNUb0RlbGV0ZSIsImZvckVhY2giLCJtb3ZlVG9UcmFzaCIsIml0ZW0iLCJ0cmFzaEl0ZW0iLCJvcmlnaW5hbERhdGEiLCJkZWxldGVkQXQiLCJmaWxlc1RvVHJhc2giLCJmaWxlVHJhc2hJdGVtcyIsInJlc3RvcmVGcm9tVHJhc2giLCJ0cmFzaEl0ZW1JZCIsInVwZGF0ZWRUcmFzaEl0ZW1zIiwicGVybWFuZW50bHlEZWxldGUiLCJlbXB0eVRyYXNoIiwiY2xlYXJQcm9qZWN0Q2F0ZWdvcnkiLCJwcm9qZWN0VGFiSWRzIiwiY2xlYXJGaW5hbmNpYWxDYXRlZ29yeSIsImZpbmFuY2lhbFRhYklkcyIsImRlbGV0ZVByb2plY3RzQ2F0ZWdvcnkiLCJkZWxldGVGaW5hbmNpYWxDYXRlZ29yeSIsInJlb3JkZXJQcm9qZWN0Rm9sZGVycyIsIm5ld0ZvbGRlcnMiLCJtb3ZlZEZvbGRlciIsInVwZGF0ZVByb2plY3RGb2xkZXJzIiwicmVvcmRlckZpbGVzSW5Gb2xkZXIiLCJmb2xkZXJGaWxlcyIsIm90aGVyRmlsZXMiLCJyZW9yZGVyZWRGb2xkZXJGaWxlcyIsIm1vdmVkRmlsZSIsIm5ld1Byb2plY3RGaWxlcyIsIm5ld0ZpbmFuY2lhbEZpbGVzIiwic2F2ZUZpbGUiLCJzZXRFcnJvciIsInJlcGFpckZpbGVzV2l0aG91dENvbnRlbnQiLCJyZXBhaXJlZFByb2plY3RGaWxlcyIsInRyaW0iLCJyZXBhaXJlZEZpbmFuY2lhbEZpbGVzIiwicmVzZXQiLCJjbGVhclVzZXJEYXRhIiwiZGVidWdTdG9yYWdlIiwic3RhdGUiLCJpbmRleCIsIndpbmRvdyIsImxvY2FsU3RvcmFnZSIsInN0b3JlZCIsImdldEl0ZW0iLCJwYXJzZWQiLCJKU09OIiwicGFyc2UiLCJ2ZXJzaW9uIiwiY2xlYXJTdG9yYWdlIiwicmVtb3ZlSXRlbSIsInJlcGxhY2VXaXRoRGF0YWJhc2VGaWxlcyIsImRhdGFiYXNlRmlsZXMiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./store/editor/index.ts\n"));

/***/ })

});