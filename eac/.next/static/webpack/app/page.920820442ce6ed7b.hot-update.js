"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./store/editor/index.ts":
/*!*******************************!*\
  !*** ./store/editor/index.ts ***!
  \*******************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useEditorStore: () => (/* binding */ useEditorStore)\n/* harmony export */ });\n/* harmony import */ var _barrel_optimize_names_AtSign_Braces_Calendar_Camera_FileCode_FileSpreadsheet_FileText_FileType_MessageSquare_lucide_react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! __barrel_optimize__?names=AtSign,Braces,Calendar,Camera,FileCode,FileSpreadsheet,FileText,FileType,MessageSquare!=!lucide-react */ \"(app-pages-browser)/../node_modules/.pnpm/lucide-react@0.525.0_react@18.3.1/node_modules/lucide-react/dist/esm/icons/file-code.js\");\n/* harmony import */ var _barrel_optimize_names_AtSign_Braces_Calendar_Camera_FileCode_FileSpreadsheet_FileText_FileType_MessageSquare_lucide_react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! __barrel_optimize__?names=AtSign,Braces,Calendar,Camera,FileCode,FileSpreadsheet,FileText,FileType,MessageSquare!=!lucide-react */ \"(app-pages-browser)/../node_modules/.pnpm/lucide-react@0.525.0_react@18.3.1/node_modules/lucide-react/dist/esm/icons/braces.js\");\n/* harmony import */ var _barrel_optimize_names_AtSign_Braces_Calendar_Camera_FileCode_FileSpreadsheet_FileText_FileType_MessageSquare_lucide_react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! __barrel_optimize__?names=AtSign,Braces,Calendar,Camera,FileCode,FileSpreadsheet,FileText,FileType,MessageSquare!=!lucide-react */ \"(app-pages-browser)/../node_modules/.pnpm/lucide-react@0.525.0_react@18.3.1/node_modules/lucide-react/dist/esm/icons/file-spreadsheet.js\");\n/* harmony import */ var _barrel_optimize_names_AtSign_Braces_Calendar_Camera_FileCode_FileSpreadsheet_FileText_FileType_MessageSquare_lucide_react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! __barrel_optimize__?names=AtSign,Braces,Calendar,Camera,FileCode,FileSpreadsheet,FileText,FileType,MessageSquare!=!lucide-react */ \"(app-pages-browser)/../node_modules/.pnpm/lucide-react@0.525.0_react@18.3.1/node_modules/lucide-react/dist/esm/icons/file-text.js\");\n/* harmony import */ var _barrel_optimize_names_AtSign_Braces_Calendar_Camera_FileCode_FileSpreadsheet_FileText_FileType_MessageSquare_lucide_react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! __barrel_optimize__?names=AtSign,Braces,Calendar,Camera,FileCode,FileSpreadsheet,FileText,FileType,MessageSquare!=!lucide-react */ \"(app-pages-browser)/../node_modules/.pnpm/lucide-react@0.525.0_react@18.3.1/node_modules/lucide-react/dist/esm/icons/file-type.js\");\n/* harmony import */ var _barrel_optimize_names_AtSign_Braces_Calendar_Camera_FileCode_FileSpreadsheet_FileText_FileType_MessageSquare_lucide_react__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! __barrel_optimize__?names=AtSign,Braces,Calendar,Camera,FileCode,FileSpreadsheet,FileText,FileType,MessageSquare!=!lucide-react */ \"(app-pages-browser)/../node_modules/.pnpm/lucide-react@0.525.0_react@18.3.1/node_modules/lucide-react/dist/esm/icons/message-square.js\");\n/* harmony import */ var _barrel_optimize_names_AtSign_Braces_Calendar_Camera_FileCode_FileSpreadsheet_FileText_FileType_MessageSquare_lucide_react__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! __barrel_optimize__?names=AtSign,Braces,Calendar,Camera,FileCode,FileSpreadsheet,FileText,FileType,MessageSquare!=!lucide-react */ \"(app-pages-browser)/../node_modules/.pnpm/lucide-react@0.525.0_react@18.3.1/node_modules/lucide-react/dist/esm/icons/camera.js\");\n/* harmony import */ var _barrel_optimize_names_AtSign_Braces_Calendar_Camera_FileCode_FileSpreadsheet_FileText_FileType_MessageSquare_lucide_react__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! __barrel_optimize__?names=AtSign,Braces,Calendar,Camera,FileCode,FileSpreadsheet,FileText,FileType,MessageSquare!=!lucide-react */ \"(app-pages-browser)/../node_modules/.pnpm/lucide-react@0.525.0_react@18.3.1/node_modules/lucide-react/dist/esm/icons/at-sign.js\");\n/* harmony import */ var _barrel_optimize_names_AtSign_Braces_Calendar_Camera_FileCode_FileSpreadsheet_FileText_FileType_MessageSquare_lucide_react__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! __barrel_optimize__?names=AtSign,Braces,Calendar,Camera,FileCode,FileSpreadsheet,FileText,FileType,MessageSquare!=!lucide-react */ \"(app-pages-browser)/../node_modules/.pnpm/lucide-react@0.525.0_react@18.3.1/node_modules/lucide-react/dist/esm/icons/calendar.js\");\n/* harmony import */ var zustand__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! zustand */ \"(app-pages-browser)/../node_modules/.pnpm/zustand@5.0.6_@types+react@19.1.9_react@18.3.1_use-sync-external-store@1.5.0_react@18.3.1_/node_modules/zustand/esm/react.mjs\");\n/* harmony import */ var zustand_middleware__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! zustand/middleware */ \"(app-pages-browser)/../node_modules/.pnpm/zustand@5.0.6_@types+react@19.1.9_react@18.3.1_use-sync-external-store@1.5.0_react@18.3.1_/node_modules/zustand/esm/middleware.mjs\");\n// Editor Store\n// /Users/matthewsimon/Projects/EAC/eac/store/editor/index.ts\n\n\n\n// Helper function to get icon based on file type\nconst getFileIcon = (type)=>{\n    switch(type){\n        case 'typescript':\n            return _barrel_optimize_names_AtSign_Braces_Calendar_Camera_FileCode_FileSpreadsheet_FileText_FileType_MessageSquare_lucide_react__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\n        case 'javascript':\n            return _barrel_optimize_names_AtSign_Braces_Calendar_Camera_FileCode_FileSpreadsheet_FileText_FileType_MessageSquare_lucide_react__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\n        case 'json':\n            return _barrel_optimize_names_AtSign_Braces_Calendar_Camera_FileCode_FileSpreadsheet_FileText_FileType_MessageSquare_lucide_react__WEBPACK_IMPORTED_MODULE_1__[\"default\"];\n        case 'excel':\n            return _barrel_optimize_names_AtSign_Braces_Calendar_Camera_FileCode_FileSpreadsheet_FileText_FileType_MessageSquare_lucide_react__WEBPACK_IMPORTED_MODULE_2__[\"default\"];\n        case 'markdown':\n            return _barrel_optimize_names_AtSign_Braces_Calendar_Camera_FileCode_FileSpreadsheet_FileText_FileType_MessageSquare_lucide_react__WEBPACK_IMPORTED_MODULE_3__[\"default\"];\n        case 'pdf':\n            return _barrel_optimize_names_AtSign_Braces_Calendar_Camera_FileCode_FileSpreadsheet_FileText_FileType_MessageSquare_lucide_react__WEBPACK_IMPORTED_MODULE_4__[\"default\"];\n        case 'generals':\n            return _barrel_optimize_names_AtSign_Braces_Calendar_Camera_FileCode_FileSpreadsheet_FileText_FileType_MessageSquare_lucide_react__WEBPACK_IMPORTED_MODULE_3__[\"default\"];\n        case 'percent-complete':\n            return _barrel_optimize_names_AtSign_Braces_Calendar_Camera_FileCode_FileSpreadsheet_FileText_FileType_MessageSquare_lucide_react__WEBPACK_IMPORTED_MODULE_2__[\"default\"];\n        case 'schedule':\n            return _barrel_optimize_names_AtSign_Braces_Calendar_Camera_FileCode_FileSpreadsheet_FileText_FileType_MessageSquare_lucide_react__WEBPACK_IMPORTED_MODULE_2__[\"default\"];\n        case 'materials':\n            return _barrel_optimize_names_AtSign_Braces_Calendar_Camera_FileCode_FileSpreadsheet_FileText_FileType_MessageSquare_lucide_react__WEBPACK_IMPORTED_MODULE_2__[\"default\"];\n        case 'facebook':\n            return _barrel_optimize_names_AtSign_Braces_Calendar_Camera_FileCode_FileSpreadsheet_FileText_FileType_MessageSquare_lucide_react__WEBPACK_IMPORTED_MODULE_5__[\"default\"];\n        case 'reddit':\n            return 'r/'; // Changed from Hash to r/ text\n        case 'instagram':\n            return _barrel_optimize_names_AtSign_Braces_Calendar_Camera_FileCode_FileSpreadsheet_FileText_FileType_MessageSquare_lucide_react__WEBPACK_IMPORTED_MODULE_6__[\"default\"];\n        case 'x':\n            return _barrel_optimize_names_AtSign_Braces_Calendar_Camera_FileCode_FileSpreadsheet_FileText_FileType_MessageSquare_lucide_react__WEBPACK_IMPORTED_MODULE_7__[\"default\"];\n        case 'calendar':\n            return _barrel_optimize_names_AtSign_Braces_Calendar_Camera_FileCode_FileSpreadsheet_FileText_FileType_MessageSquare_lucide_react__WEBPACK_IMPORTED_MODULE_8__[\"default\"];\n        default:\n            return _barrel_optimize_names_AtSign_Braces_Calendar_Camera_FileCode_FileSpreadsheet_FileText_FileType_MessageSquare_lucide_react__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\n    }\n};\n// Helper function to get file extension\n// Helper function to get file extension\nconst getFileExtension = (type)=>{\n    switch(type){\n        case 'typescript':\n            return '.ts';\n        case 'javascript':\n            return '.js';\n        case 'json':\n            return '.json';\n        case 'excel':\n            return '.xlsx';\n        case 'pdf':\n            return '.pdf';\n        case 'generals':\n            return '.generals';\n        case 'percent-complete':\n            return '.percent';\n        case 'schedule':\n            return '.schedule';\n        case 'materials':\n            return '.materials';\n        case 'facebook':\n            return '.facebook';\n        case 'reddit':\n            return '.reddit';\n        case 'instagram':\n            return '.instagram';\n        case 'x':\n            return '.x';\n        case 'markdown':\n            return '.md';\n        default:\n            return '.txt';\n    }\n};\n// Helper function to generate default content for new files\nconst getDefaultContent = (type, name)=>{\n    switch(type){\n        case 'typescript':\n            return \"// \".concat(name, \"\\n// Auto-generated TypeScript file\\n\\nimport React from 'react';\\n\\ninterface \").concat(name.replace(/[^a-zA-Z0-9]/g, ''), \"Props {\\n  // Define props here\\n}\\n\\nexport function \").concat(name.replace(/[^a-zA-Z0-9]/g, ''), \"({ }: \").concat(name.replace(/[^a-zA-Z0-9]/g, ''), 'Props) {\\n  return (\\n    <div className=\"p-4\">\\n      <h1 className=\"text-xl font-bold\">New Component: ').concat(name, '</h1>\\n      <p className=\"text-gray-600\">Start building your component here...</p>\\n    </div>\\n  );\\n}');\n        case 'javascript':\n            return \"// \".concat(name, \"\\n// Auto-generated JavaScript file\\n\\nexport function \").concat(name.replace(/[^a-zA-Z0-9]/g, ''), \"() {\\n  return {\\n    message: 'Hello from \").concat(name, \"!',\\n    data: []\\n  };\\n}\");\n        case 'json':\n            return '{\\n  \"name\": \"'.concat(name, '\",\\n  \"description\": \"Auto-generated JSON file\",\\n  \"version\": \"1.0.0\",\\n  \"data\": {}\\n}');\n        case 'markdown':\n            return \"Start writing your content here...\";\n        case 'generals':\n            return \"// \".concat(name, \" - Project General Information\\n// This file contains general project details and financial information\\n// Created on: \").concat(new Date().toISOString(), \"\\n\\nProject: \").concat(name, \"\\nStatus: Active\\nCreated: \").concat(new Date().toLocaleDateString(), \"\\n\\n// This file will display the project generals module interface\");\n        case 'percent-complete':\n            return \"// \".concat(name, \" - Percent Complete Tracker\\n// This file contains project completion tracking data\\n// Created on: \").concat(new Date().toISOString(), \"\\n\\nProject: \").concat(name, \"\\nType: Percent Complete Tracker\\nCreated: \").concat(new Date().toLocaleDateString(), \"\\n\\n// This file will display the percent complete tracking interface\");\n        case 'schedule':\n            return \"// \".concat(name, \" - Project Schedule\\n// This file contains project schedule and timeline data\\n// Created on: \").concat(new Date().toISOString(), \"\\n\\nProject: \").concat(name, \"\\nType: Project Schedule\\nCreated: \").concat(new Date().toLocaleDateString(), \"\\n\\n// This file will display the project schedule interface with Gantt chart\");\n        case 'materials':\n            return \"// \".concat(name, \" - Materials Management\\n// This file contains materials tracking and management data\\n// Created on: \").concat(new Date().toISOString(), \"\\n\\nProject: \").concat(name, \"\\nType: Materials Management\\nCreated: \").concat(new Date().toLocaleDateString(), \"\\n\\n// This file will display the materials management interface with manufactured and miscellaneous materials\");\n        case 'facebook':\n            return \"# \".concat(name, \" - Facebook Post\\nPlatform: Facebook\\nCreated: \").concat(new Date().toLocaleDateString(), \"\\n\\n## Post Content\\nWrite your Facebook post content here...\\n\\n## Settings\\n- Audience: Public\\n- Schedule: Now\\n- Hashtags: #example\\n\\n## Media\\n- Images: []\\n- Videos: []\\n\\n## Analytics\\n- Engagement: 0\\n- Reach: 0\\n- Clicks: 0\");\n        case 'reddit':\n            return \"# \".concat(name, \" - Reddit Post\\nPlatform: Reddit\\nCreated: \").concat(new Date().toLocaleDateString(), \"\\n\\n## Post Content\\nWrite your Reddit post content here...\\n\\n## Settings\\n- Subreddit: r/example\\n- Post Type: Text/Link/Image\\n- Flair: Discussion\\n- NSFW: No\\n\\n## Media\\n- Images: []\\n- Links: []\\n\\n## Analytics\\n- Upvotes: 0\\n- Comments: 0\\n- Awards: 0\");\n        case 'instagram':\n            return \"# \".concat(name, \" - Instagram Post\\nPlatform: Instagram\\nCreated: \").concat(new Date().toLocaleDateString(), \"\\n\\n## Post Content\\nWrite your Instagram post content here...\\n\\n## Settings\\n- Post Type: Feed/Story/Reel\\n- Location: City, Country\\n- Alt Text: Describe image\\n- Comment Settings: Public\\n\\n## Media\\n- Images: []\\n- Videos: []\\n\\n## Hashtags\\n#hashtag1 #hashtag2 #hashtag3\\n\\n## Analytics\\n- Likes: 0\\n- Comments: 0\\n- Shares: 0\\n- Reach: 0\");\n        case 'x':\n            return \"# \".concat(name, \" - X/Twitter Post\\nPlatform: X (Twitter)\\nCreated: \").concat(new Date().toLocaleDateString(), \"\\n\\n## Post Content\\nWrite your X post content here... (280 character limit)\\n\\n## Settings\\n- Reply Settings: Everyone\\n- Schedule: Now\\n- Thread: Single Tweet\\n\\n## Media\\n- Images: []\\n- Videos: []\\n- GIFs: []\\n\\n## Analytics\\n- Impressions: 0\\n- Engagements: 0\\n- Retweets: 0\\n- Likes: 0\\n- Replies: 0\");\n        default:\n            return \"# \".concat(name, \"\\n\\nThis is a new file created in the EAC Dashboard.\\nCreated on: \").concat(new Date().toISOString());\n    }\n};\n// Initial project files - empty by default, only created when needed\nconst initialProjectFiles = [];\n// Initial financial files - empty by default, only created when needed  \nconst initialFinancialFiles = [];\n// Initial project folders - only created when explicitly needed, not on storage clear\nconst initialProjectFolders = [];\nconst useEditorStore = (0,zustand__WEBPACK_IMPORTED_MODULE_9__.create)()((0,zustand_middleware__WEBPACK_IMPORTED_MODULE_10__.devtools)((0,zustand_middleware__WEBPACK_IMPORTED_MODULE_10__.persist)((set, get)=>({\n        // Initial state\n        openTabs: [],\n        activeTab: '',\n        projectFiles: initialProjectFiles,\n        financialFiles: initialFinancialFiles,\n        projectFolders: initialProjectFolders,\n        financialFolders: [],\n        trashItems: [],\n        showProjectsCategory: true,\n        showFinancialCategory: false,\n        isLoading: false,\n        error: null,\n        // Actions\n        openTab: (file)=>{\n            var _file_content, _file_content1;\n            const { openTabs } = get();\n            console.log('🔍 Opening tab for file:', {\n                id: file.id,\n                name: file.name,\n                contentLength: ((_file_content = file.content) === null || _file_content === void 0 ? void 0 : _file_content.length) || 0,\n                contentPreview: ((_file_content1 = file.content) === null || _file_content1 === void 0 ? void 0 : _file_content1.substring(0, 100)) || 'NO CONTENT'\n            });\n            // Check if tab is already open\n            const existingTab = openTabs.find((tab)=>tab.id === file.id);\n            if (existingTab) {\n                console.log('📂 Tab already exists, activating:', existingTab.id);\n                // Update the existing tab content with the current file content\n                const updatedTabs = openTabs.map((tab)=>tab.id === file.id ? {\n                        ...tab,\n                        content: file.content || getDefaultContent(file.type, file.name)\n                    } : tab);\n                set({\n                    openTabs: updatedTabs,\n                    activeTab: existingTab.id\n                });\n                return;\n            }\n            // Define which file types should be auto-pinned\n            // You can add more file types here if needed\n            const autoPinFileTypes = [\n                'calendar',\n                'social-connect',\n                'user-profile',\n                'post-creator'\n            ];\n            const shouldAutoPinn = autoPinFileTypes.includes(file.type);\n            let pinnedOrder;\n            if (shouldAutoPinn) {\n                // Get the highest pinned order for auto-pinned tabs\n                const pinnedTabs = openTabs.filter((t)=>t.pinned);\n                pinnedOrder = pinnedTabs.length > 0 ? Math.max(...pinnedTabs.map((t)=>t.pinnedOrder || 0)) + 1 : 1;\n            }\n            // Create new tab with content\n            const tabContent = file.content || getDefaultContent(file.type, file.name);\n            console.log('🆕 Creating new tab with content:', {\n                fileId: file.id,\n                fileName: file.name,\n                hasCustomContent: !!file.content,\n                contentLength: tabContent.length,\n                contentPreview: tabContent.substring(0, 100)\n            });\n            const newTab = {\n                id: file.id,\n                name: file.name,\n                modified: false,\n                content: tabContent,\n                filePath: file.filePath,\n                type: file.type,\n                pinned: shouldAutoPinn,\n                pinnedOrder: shouldAutoPinn ? pinnedOrder : undefined\n            };\n            let newTabs;\n            if (shouldAutoPinn) {\n                // For auto-pinned tabs, insert in correct pinned position\n                const otherTabs = [\n                    ...openTabs\n                ];\n                const insertIndex = otherTabs.filter((t)=>t.pinned && (t.pinnedOrder || 0) < (pinnedOrder || 0)).length;\n                otherTabs.splice(insertIndex, 0, newTab);\n                newTabs = otherTabs;\n            } else {\n                // For non-auto-pinned tabs, insert after all pinned tabs\n                const pinnedTabs = openTabs.filter((tab)=>tab.pinned);\n                const unpinnedTabs = openTabs.filter((tab)=>!tab.pinned);\n                newTabs = [\n                    ...pinnedTabs,\n                    ...unpinnedTabs,\n                    newTab\n                ];\n            }\n            set({\n                openTabs: newTabs,\n                activeTab: newTab.id\n            });\n        },\n        openSpecialTab: (id, name, type)=>{\n            const { openTabs } = get();\n            // Check if tab is already open\n            const existingTab = openTabs.find((tab)=>tab.id === id);\n            if (existingTab) {\n                set({\n                    activeTab: existingTab.id\n                });\n                return;\n            }\n            // Define which tab types should be auto-pinned\n            const autoPinTypes = [\n                'user-profile',\n                'calendar',\n                'social-connect',\n                'post-creator'\n            ];\n            const shouldAutoPinn = autoPinTypes.includes(type);\n            let pinnedOrder;\n            if (shouldAutoPinn) {\n                // Get the highest pinned order for auto-pinned tabs\n                const pinnedTabs = openTabs.filter((t)=>t.pinned);\n                pinnedOrder = pinnedTabs.length > 0 ? Math.max(...pinnedTabs.map((t)=>t.pinnedOrder || 0)) + 1 : 1;\n            }\n            // Create new special tab\n            const newTab = {\n                id,\n                name,\n                modified: false,\n                content: '',\n                filePath: \"/\".concat(type),\n                type,\n                pinned: shouldAutoPinn,\n                pinnedOrder: shouldAutoPinn ? pinnedOrder : undefined\n            };\n            let newTabs;\n            if (shouldAutoPinn) {\n                // For auto-pinned tabs, insert in correct pinned position\n                const otherTabs = [\n                    ...openTabs\n                ];\n                const insertIndex = otherTabs.filter((t)=>t.pinned && (t.pinnedOrder || 0) < (pinnedOrder || 0)).length;\n                otherTabs.splice(insertIndex, 0, newTab);\n                newTabs = otherTabs;\n            } else {\n                // For non-auto-pinned tabs, insert after all pinned tabs\n                const pinnedTabs = openTabs.filter((tab)=>tab.pinned);\n                const unpinnedTabs = openTabs.filter((tab)=>!tab.pinned);\n                newTabs = [\n                    ...pinnedTabs,\n                    ...unpinnedTabs,\n                    newTab\n                ];\n            }\n            set({\n                openTabs: newTabs,\n                activeTab: newTab.id\n            });\n        },\n        closeTab: (tabId)=>{\n            const { openTabs, activeTab } = get();\n            const tabIndex = openTabs.findIndex((tab)=>tab.id === tabId);\n            if (tabIndex === -1) return;\n            const newTabs = openTabs.filter((tab)=>tab.id !== tabId);\n            let newActiveTab = activeTab;\n            // If closing the active tab, switch to another tab\n            if (activeTab === tabId) {\n                if (newTabs.length > 0) {\n                    // Switch to the tab to the right, or the last tab if closing the last one\n                    const nextIndex = tabIndex < newTabs.length ? tabIndex : newTabs.length - 1;\n                    newActiveTab = newTabs[nextIndex].id;\n                } else {\n                    newActiveTab = '';\n                }\n            }\n            set({\n                openTabs: newTabs,\n                activeTab: newActiveTab\n            });\n        },\n        closeAllTabs: ()=>{\n            set({\n                openTabs: [],\n                activeTab: ''\n            });\n        },\n        setActiveTab: (tabId)=>{\n            const { openTabs } = get();\n            const tabExists = openTabs.some((tab)=>tab.id === tabId);\n            if (tabExists) {\n                set({\n                    activeTab: tabId\n                });\n            }\n        },\n        reorderTabs: (fromTabId, toTabId)=>{\n            const { openTabs } = get();\n            const fromIndex = openTabs.findIndex((tab)=>tab.id === fromTabId);\n            const toIndex = openTabs.findIndex((tab)=>tab.id === toTabId);\n            if (fromIndex !== -1 && toIndex !== -1 && fromIndex !== toIndex) {\n                const newTabs = [\n                    ...openTabs\n                ];\n                const [movedTab] = newTabs.splice(fromIndex, 1);\n                newTabs.splice(toIndex, 0, movedTab);\n                set({\n                    openTabs: newTabs\n                });\n            }\n        },\n        pinTab: (tabId)=>{\n            const { openTabs } = get();\n            const tabIndex = openTabs.findIndex((tab)=>tab.id === tabId);\n            if (tabIndex !== -1) {\n                const tab = openTabs[tabIndex];\n                // Don't pin if already pinned\n                if (tab.pinned) return;\n                // Get the highest pinned order\n                const pinnedTabs = openTabs.filter((t)=>t.pinned);\n                const nextPinnedOrder = pinnedTabs.length > 0 ? Math.max(...pinnedTabs.map((t)=>t.pinnedOrder || 0)) + 1 : 1;\n                // Update the tab to be pinned\n                const updatedTab = {\n                    ...tab,\n                    pinned: true,\n                    pinnedOrder: nextPinnedOrder\n                };\n                // Remove tab from current position and add to correct pinned position\n                const newTabs = [\n                    ...openTabs\n                ];\n                newTabs.splice(tabIndex, 1);\n                // Find the correct position among pinned tabs\n                const insertIndex = newTabs.filter((t)=>t.pinned && (t.pinnedOrder || 0) < nextPinnedOrder).length;\n                newTabs.splice(insertIndex, 0, updatedTab);\n                set({\n                    openTabs: newTabs\n                });\n            }\n        },\n        unpinTab: (tabId)=>{\n            const { openTabs } = get();\n            const tabIndex = openTabs.findIndex((tab)=>tab.id === tabId);\n            if (tabIndex !== -1) {\n                const tab = openTabs[tabIndex];\n                // Don't unpin if not pinned\n                if (!tab.pinned) return;\n                // Update the tab to be unpinned\n                const updatedTab = {\n                    ...tab,\n                    pinned: false,\n                    pinnedOrder: undefined\n                };\n                // Remove tab from current position\n                const newTabs = [\n                    ...openTabs\n                ];\n                newTabs.splice(tabIndex, 1);\n                // Find the position after all pinned tabs\n                const pinnedCount = newTabs.filter((t)=>t.pinned).length;\n                newTabs.splice(pinnedCount, 0, updatedTab);\n                set({\n                    openTabs: newTabs\n                });\n            }\n        },\n        updateTabContent: (tabId, content)=>{\n            const { openTabs } = get();\n            const updatedTabs = openTabs.map((tab)=>tab.id === tabId ? {\n                    ...tab,\n                    content,\n                    modified: true\n                } : tab);\n            set({\n                openTabs: updatedTabs\n            });\n        },\n        updateFileContent: (tabId, content)=>{\n            const { openTabs } = get();\n            const updatedTabs = openTabs.map((tab)=>tab.id === tabId ? {\n                    ...tab,\n                    content,\n                    modified: true\n                } : tab);\n            set({\n                openTabs: updatedTabs\n            });\n        },\n        updateFileContentInStore: (fileId, content)=>{\n            const { projectFiles, financialFiles, openTabs } = get();\n            // Update the file in the appropriate store\n            const updatedProjectFiles = projectFiles.map((file)=>file.id === fileId ? {\n                    ...file,\n                    content,\n                    modifiedAt: new Date()\n                } : file);\n            const updatedFinancialFiles = financialFiles.map((file)=>file.id === fileId ? {\n                    ...file,\n                    content,\n                    modifiedAt: new Date()\n                } : file);\n            // Also update the tab if it's open\n            const updatedTabs = openTabs.map((tab)=>tab.id === fileId ? {\n                    ...tab,\n                    content,\n                    modified: true\n                } : tab);\n            set({\n                projectFiles: updatedProjectFiles,\n                financialFiles: updatedFinancialFiles,\n                openTabs: updatedTabs\n            });\n        },\n        updateFileStatus: (fileId, status)=>{\n            const { projectFiles, financialFiles } = get();\n            // Update in project files\n            const updatedProjectFiles = projectFiles.map((file)=>file.id === fileId ? {\n                    ...file,\n                    status,\n                    modifiedAt: new Date()\n                } : file);\n            // Update in financial files\n            const updatedFinancialFiles = financialFiles.map((file)=>file.id === fileId ? {\n                    ...file,\n                    status,\n                    modifiedAt: new Date()\n                } : file);\n            set({\n                projectFiles: updatedProjectFiles,\n                financialFiles: updatedFinancialFiles\n            });\n        },\n        createNewFile: function(name, type) {\n            let category = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 'project', folderId = arguments.length > 3 ? arguments[3] : void 0, customContent = arguments.length > 4 ? arguments[4] : void 0;\n            const { projectFiles, financialFiles } = get();\n            console.log('🔧 createNewFile called with:', {\n                name,\n                type,\n                category,\n                folderId,\n                hasCustomContent: !!customContent,\n                customContentLength: (customContent === null || customContent === void 0 ? void 0 : customContent.length) || 0,\n                customContentPreview: (customContent === null || customContent === void 0 ? void 0 : customContent.substring(0, 100)) || 'NO CUSTOM CONTENT'\n            });\n            // Generate unique ID\n            const id = \"\".concat(name.toLowerCase().replace(/[^a-z0-9]/g, '-'), \"-\").concat(Date.now());\n            const fileName = \"\".concat(name).concat(getFileExtension(type));\n            const basePath = category === 'financial' ? '/financial-data' : '/eac-projects';\n            // Use custom content if provided, otherwise use default\n            const fileContent = customContent || getDefaultContent(type, name);\n            console.log('📄 Final file content:', {\n                fileName,\n                contentLength: fileContent.length,\n                contentPreview: fileContent.substring(0, 100),\n                isCustom: !!customContent\n            });\n            // Create new file\n            const newFile = {\n                id,\n                name: fileName,\n                icon: getFileIcon(type),\n                type,\n                category,\n                content: fileContent,\n                filePath: \"\".concat(basePath, \"/\").concat(fileName),\n                createdAt: new Date(),\n                modifiedAt: new Date(),\n                folderId,\n                status: [\n                    'facebook',\n                    'reddit',\n                    'instagram',\n                    'x'\n                ].includes(type) ? 'draft' : undefined\n            };\n            // Add to appropriate file array and ensure category is visible\n            if (category === 'financial') {\n                set({\n                    financialFiles: [\n                        ...financialFiles,\n                        newFile\n                    ],\n                    showFinancialCategory: true\n                });\n            } else {\n                set({\n                    projectFiles: [\n                        ...projectFiles,\n                        newFile\n                    ],\n                    showProjectsCategory: true\n                });\n            }\n            // Automatically open the new file\n            get().openTab(newFile);\n            // Save to Convex database (async - don't block UI)\n            try {\n                // We need to import the Convex hooks here, which isn't ideal\n                // Better to handle this in the component level\n                console.log('File created locally:', newFile);\n                // Dispatch custom event that components can listen to\n                if (true) {\n                    window.dispatchEvent(new CustomEvent('fileCreated', {\n                        detail: {\n                            file: newFile,\n                            projectId: folderId // Using folderId as projectId for now\n                        }\n                    }));\n                }\n            } catch (error) {\n                console.error('Failed to save file to database:', error);\n            }\n            // Return the file ID so caller can reference it\n            return id;\n        },\n        createFolder: (name, category, convexId)=>{\n            const { projectFolders, financialFolders } = get();\n            // Check if folder with this name already exists to prevent duplicates\n            const existingFolders = category === 'financial' ? financialFolders : projectFolders;\n            const folderExists = existingFolders.some((folder)=>folder.name.toLowerCase() === name.toLowerCase());\n            if (folderExists) {\n                console.log('Folder \"'.concat(name, '\" already exists in ').concat(category, \" category, skipping creation\"));\n                return;\n            }\n            // Generate truly unique ID using crypto if available, otherwise fallback to timestamp + random\n            let uniqueId;\n            if (typeof crypto !== 'undefined' && crypto.randomUUID) {\n                uniqueId = \"folder-\".concat(name.toLowerCase().replace(/[^a-z0-9]/g, '-'), \"-\").concat(crypto.randomUUID());\n            } else {\n                // Fallback for environments without crypto.randomUUID\n                const timestamp = Date.now();\n                const random = Math.random().toString(36).substring(2, 12);\n                const counter = Math.floor(Math.random() * 10000);\n                uniqueId = \"folder-\".concat(name.toLowerCase().replace(/[^a-z0-9]/g, '-'), \"-\").concat(timestamp, \"-\").concat(random, \"-\").concat(counter);\n            }\n            // Double-check uniqueness against all existing folder IDs\n            const allFolders = [\n                ...projectFolders,\n                ...financialFolders\n            ];\n            while(allFolders.some((folder)=>folder.id === uniqueId)){\n                const randomSuffix = Math.random().toString(36).substring(2, 8);\n                uniqueId = \"\".concat(uniqueId, \"-\").concat(randomSuffix);\n            }\n            // Create new folder\n            const newFolder = {\n                id: uniqueId,\n                name,\n                category,\n                createdAt: new Date(),\n                convexId\n            };\n            // Add to appropriate folder array and ensure category is visible\n            if (category === 'financial') {\n                set({\n                    financialFolders: [\n                        newFolder,\n                        ...financialFolders\n                    ],\n                    showFinancialCategory: true\n                });\n            } else {\n                set({\n                    projectFolders: [\n                        newFolder,\n                        ...projectFolders\n                    ],\n                    showProjectsCategory: true\n                });\n            }\n        },\n        // Emergency cleanup function for duplicate folder IDs\n        cleanupDuplicateFolders: ()=>{\n            const { projectFolders, financialFolders } = get();\n            // Function to remove duplicates and fix bad IDs\n            const cleanupFolders = (folders)=>{\n                const seen = new Set();\n                const cleaned = folders.filter((folder)=>{\n                    // Remove folders with the problematic key pattern\n                    if (folder.id.includes('folder-index-1753064508939')) {\n                        console.log(\"\\uD83E\\uDDF9 Removing problematic folder: \".concat(folder.id, \" (\").concat(folder.name, \")\"));\n                        return false;\n                    }\n                    // Remove duplicate IDs\n                    if (seen.has(folder.id)) {\n                        console.log(\"\\uD83E\\uDDF9 Removing duplicate folder: \".concat(folder.id, \" (\").concat(folder.name, \")\"));\n                        return false;\n                    }\n                    seen.add(folder.id);\n                    return true;\n                });\n                // Regenerate IDs for any remaining folders with old patterns\n                return cleaned.map((folder)=>{\n                    if (folder.id.startsWith('folder-index-') || folder.id.length < 20) {\n                        const newId = typeof crypto !== 'undefined' && crypto.randomUUID ? \"folder-\".concat(folder.name.toLowerCase().replace(/[^a-z0-9]/g, '-'), \"-\").concat(crypto.randomUUID()) : \"folder-\".concat(folder.name.toLowerCase().replace(/[^a-z0-9]/g, '-'), \"-\").concat(Date.now(), \"-\").concat(Math.random().toString(36).substring(2, 12));\n                        console.log(\"\\uD83D\\uDD04 Regenerating ID for folder: \".concat(folder.id, \" → \").concat(newId, \" (\").concat(folder.name, \")\"));\n                        return {\n                            ...folder,\n                            id: newId\n                        };\n                    }\n                    return folder;\n                });\n            };\n            const cleanedProjectFolders = cleanupFolders(projectFolders);\n            const cleanedFinancialFolders = cleanupFolders(financialFolders);\n            if (cleanedProjectFolders.length !== projectFolders.length || cleanedFinancialFolders.length !== financialFolders.length) {\n                console.log('🧹 Cleanup completed, updating store...');\n                set({\n                    projectFolders: cleanedProjectFolders,\n                    financialFolders: cleanedFinancialFolders\n                });\n            }\n        },\n        deleteFile: (fileId)=>{\n            const { projectFiles, financialFiles, openTabs } = get();\n            // Find and remove from appropriate array\n            const updatedProjectFiles = projectFiles.filter((file)=>file.id !== fileId);\n            const updatedFinancialFiles = financialFiles.filter((file)=>file.id !== fileId);\n            // Close tab if it's open\n            const tabToClose = openTabs.find((tab)=>tab.id === fileId);\n            if (tabToClose) {\n                get().closeTab(fileId);\n            }\n            set({\n                projectFiles: updatedProjectFiles,\n                financialFiles: updatedFinancialFiles\n            });\n        },\n        renameFile: (fileId, newName)=>{\n            const { projectFiles, financialFiles, openTabs } = get();\n            // Find the file to get its type and generate new filename with extension\n            const projectFile = projectFiles.find((file)=>file.id === fileId);\n            const financialFile = financialFiles.find((file)=>file.id === fileId);\n            const file = projectFile || financialFile;\n            if (!file) return;\n            // Generate new filename with appropriate extension\n            const newFileName = \"\".concat(newName).concat(getFileExtension(file.type));\n            const basePath = file.category === 'financial' ? '/financial-data' : '/eac-projects';\n            const newFilePath = \"\".concat(basePath, \"/\").concat(newFileName);\n            // Update the file in appropriate array\n            const updatedProjectFiles = projectFiles.map((f)=>f.id === fileId ? {\n                    ...f,\n                    name: newFileName,\n                    filePath: newFilePath,\n                    modifiedAt: new Date()\n                } : f);\n            const updatedFinancialFiles = financialFiles.map((f)=>f.id === fileId ? {\n                    ...f,\n                    name: newFileName,\n                    filePath: newFilePath,\n                    modifiedAt: new Date()\n                } : f);\n            // Update open tabs if the file is open\n            const updatedTabs = openTabs.map((tab)=>tab.id === fileId ? {\n                    ...tab,\n                    name: newFileName,\n                    filePath: newFilePath,\n                    modified: true\n                } : tab);\n            set({\n                projectFiles: updatedProjectFiles,\n                financialFiles: updatedFinancialFiles,\n                openTabs: updatedTabs\n            });\n        },\n        renameFolder: (folderId, newName)=>{\n            const { projectFolders, financialFolders } = get();\n            // Update the folder in appropriate array\n            const updatedProjectFolders = projectFolders.map((folder)=>folder.id === folderId ? {\n                    ...folder,\n                    name: newName\n                } : folder);\n            const updatedFinancialFolders = financialFolders.map((folder)=>folder.id === folderId ? {\n                    ...folder,\n                    name: newName\n                } : folder);\n            set({\n                projectFolders: updatedProjectFolders,\n                financialFolders: updatedFinancialFolders\n            });\n        },\n        deleteFolder: (folderId)=>{\n            const { projectFolders, financialFolders, projectFiles, financialFiles, openTabs } = get();\n            // Find all files that were in this folder\n            const filesToDelete = [\n                ...projectFiles.filter((file)=>file.folderId === folderId),\n                ...financialFiles.filter((file)=>file.folderId === folderId)\n            ];\n            // Close tabs for all files in this folder\n            filesToDelete.forEach((file)=>{\n                const tabToClose = openTabs.find((tab)=>tab.id === file.id);\n                if (tabToClose) {\n                    get().closeTab(file.id);\n                }\n            });\n            // Remove from appropriate folder array\n            const updatedProjectFolders = projectFolders.filter((folder)=>folder.id !== folderId);\n            const updatedFinancialFolders = financialFolders.filter((folder)=>folder.id !== folderId);\n            // Also remove any files that were in this folder\n            const updatedProjectFiles = projectFiles.filter((file)=>file.folderId !== folderId);\n            const updatedFinancialFiles = financialFiles.filter((file)=>file.folderId !== folderId);\n            set({\n                projectFolders: updatedProjectFolders,\n                financialFolders: updatedFinancialFolders,\n                projectFiles: updatedProjectFiles,\n                financialFiles: updatedFinancialFiles\n            });\n        },\n        moveToTrash: (item, type)=>{\n            const { trashItems, projectFiles, financialFiles, projectFolders, financialFolders, openTabs } = get();\n            // Create trash item\n            const trashItem = {\n                id: \"trash_\".concat(item.id, \"_\").concat(Date.now()),\n                name: item.name,\n                type,\n                originalData: item,\n                deletedAt: new Date(),\n                category: item.category\n            };\n            if (type === 'file') {\n                const file = item;\n                // Close tab if it's open\n                const tabToClose = openTabs.find((tab)=>tab.id === file.id);\n                if (tabToClose) {\n                    get().closeTab(file.id);\n                }\n                // Remove from appropriate file array\n                const updatedProjectFiles = projectFiles.filter((f)=>f.id !== file.id);\n                const updatedFinancialFiles = financialFiles.filter((f)=>f.id !== file.id);\n                set({\n                    trashItems: [\n                        ...trashItems,\n                        trashItem\n                    ],\n                    projectFiles: updatedProjectFiles,\n                    financialFiles: updatedFinancialFiles\n                });\n            } else {\n                const folder = item;\n                // Find all files that were in this folder and move them to trash too\n                const filesToTrash = [\n                    ...projectFiles.filter((file)=>file.folderId === folder.id),\n                    ...financialFiles.filter((file)=>file.folderId === folder.id)\n                ];\n                // Close tabs for all files in this folder\n                filesToTrash.forEach((file)=>{\n                    const tabToClose = openTabs.find((tab)=>tab.id === file.id);\n                    if (tabToClose) {\n                        get().closeTab(file.id);\n                    }\n                });\n                // Create trash items for all files in the folder\n                const fileTrashItems = filesToTrash.map((file)=>({\n                        id: \"trash_\".concat(file.id, \"_\").concat(Date.now()),\n                        name: file.name,\n                        type: 'file',\n                        originalData: file,\n                        deletedAt: new Date(),\n                        category: file.category\n                    }));\n                // Remove folder and its files from arrays\n                const updatedProjectFolders = projectFolders.filter((f)=>f.id !== folder.id);\n                const updatedFinancialFolders = financialFolders.filter((f)=>f.id !== folder.id);\n                const updatedProjectFiles = projectFiles.filter((file)=>file.folderId !== folder.id);\n                const updatedFinancialFiles = financialFiles.filter((file)=>file.folderId !== folder.id);\n                set({\n                    trashItems: [\n                        ...trashItems,\n                        trashItem,\n                        ...fileTrashItems\n                    ],\n                    projectFolders: updatedProjectFolders,\n                    financialFolders: updatedFinancialFolders,\n                    projectFiles: updatedProjectFiles,\n                    financialFiles: updatedFinancialFiles\n                });\n            }\n        },\n        restoreFromTrash: (trashItemId)=>{\n            const { trashItems, projectFiles, financialFiles, projectFolders, financialFolders } = get();\n            const trashItem = trashItems.find((item)=>item.id === trashItemId);\n            if (!trashItem) return;\n            // Remove from trash\n            const updatedTrashItems = trashItems.filter((item)=>item.id !== trashItemId);\n            // Restore to appropriate array\n            if (trashItem.type === 'file') {\n                const file = trashItem.originalData;\n                if (file.category === 'project') {\n                    set({\n                        trashItems: updatedTrashItems,\n                        projectFiles: [\n                            ...projectFiles,\n                            {\n                                ...file,\n                                modifiedAt: new Date()\n                            }\n                        ]\n                    });\n                } else {\n                    set({\n                        trashItems: updatedTrashItems,\n                        financialFiles: [\n                            ...financialFiles,\n                            {\n                                ...file,\n                                modifiedAt: new Date()\n                            }\n                        ]\n                    });\n                }\n            } else {\n                const folder = trashItem.originalData;\n                if (folder.category === 'project') {\n                    set({\n                        trashItems: updatedTrashItems,\n                        projectFolders: [\n                            ...projectFolders,\n                            folder\n                        ]\n                    });\n                } else {\n                    set({\n                        trashItems: updatedTrashItems,\n                        financialFolders: [\n                            ...financialFolders,\n                            folder\n                        ]\n                    });\n                }\n            }\n        },\n        permanentlyDelete: (trashItemId)=>{\n            const { trashItems } = get();\n            // Remove from trash permanently\n            const updatedTrashItems = trashItems.filter((item)=>item.id !== trashItemId);\n            set({\n                trashItems: updatedTrashItems\n            });\n        },\n        emptyTrash: ()=>{\n            set({\n                trashItems: []\n            });\n        },\n        clearProjectCategory: ()=>{\n            const { openTabs } = get();\n            // Close all project-related tabs\n            const projectTabIds = openTabs.filter((tab)=>{\n                // Find the corresponding file to check its category\n                const { projectFiles } = get();\n                const file = projectFiles.find((f)=>f.id === tab.id);\n                return (file === null || file === void 0 ? void 0 : file.category) === 'project';\n            }).map((tab)=>tab.id);\n            projectTabIds.forEach((tabId)=>get().closeTab(tabId));\n            // Clear all project files and folders\n            set({\n                projectFiles: [],\n                projectFolders: []\n            });\n        },\n        clearFinancialCategory: ()=>{\n            const { openTabs } = get();\n            // Close all financial-related tabs\n            const financialTabIds = openTabs.filter((tab)=>{\n                // Find the corresponding file to check its category\n                const { financialFiles } = get();\n                const file = financialFiles.find((f)=>f.id === tab.id);\n                return (file === null || file === void 0 ? void 0 : file.category) === 'financial';\n            }).map((tab)=>tab.id);\n            financialTabIds.forEach((tabId)=>get().closeTab(tabId));\n            // Clear all financial files and folders\n            set({\n                financialFiles: [],\n                financialFolders: []\n            });\n        },\n        deleteProjectsCategory: ()=>{\n            get().clearProjectCategory();\n            set({\n                showProjectsCategory: false\n            });\n        },\n        deleteFinancialCategory: ()=>{\n            get().clearFinancialCategory();\n            set({\n                showFinancialCategory: false\n            });\n        },\n        reorderProjectFolders: (fromIndex, toIndex)=>{\n            const { projectFolders } = get();\n            const newFolders = [\n                ...projectFolders\n            ];\n            const [movedFolder] = newFolders.splice(fromIndex, 1);\n            newFolders.splice(toIndex, 0, movedFolder);\n            set({\n                projectFolders: newFolders\n            });\n        },\n        updateProjectFolders: (folders)=>{\n            set({\n                projectFolders: folders\n            });\n        },\n        reorderFilesInFolder: (folderId, fromIndex, toIndex, category)=>{\n            const { projectFiles, financialFiles } = get();\n            if (category === 'project') {\n                // Filter files in the specific folder\n                const folderFiles = projectFiles.filter((file)=>file.folderId === folderId);\n                const otherFiles = projectFiles.filter((file)=>file.folderId !== folderId);\n                // Reorder files within the folder\n                const reorderedFolderFiles = [\n                    ...folderFiles\n                ];\n                const [movedFile] = reorderedFolderFiles.splice(fromIndex, 1);\n                reorderedFolderFiles.splice(toIndex, 0, movedFile);\n                // Combine with other files\n                const newProjectFiles = [\n                    ...otherFiles,\n                    ...reorderedFolderFiles\n                ];\n                set({\n                    projectFiles: newProjectFiles\n                });\n            } else {\n                // Similar logic for financial files\n                const folderFiles = financialFiles.filter((file)=>file.folderId === folderId);\n                const otherFiles = financialFiles.filter((file)=>file.folderId !== folderId);\n                const reorderedFolderFiles = [\n                    ...folderFiles\n                ];\n                const [movedFile] = reorderedFolderFiles.splice(fromIndex, 1);\n                reorderedFolderFiles.splice(toIndex, 0, movedFile);\n                const newFinancialFiles = [\n                    ...otherFiles,\n                    ...reorderedFolderFiles\n                ];\n                set({\n                    financialFiles: newFinancialFiles\n                });\n            }\n        },\n        saveFile: (tabId)=>{\n            const { openTabs, projectFiles, financialFiles } = get();\n            const tab = openTabs.find((t)=>t.id === tabId);\n            if (!tab) return;\n            // Update the file content in appropriate array\n            const updatedProjectFiles = projectFiles.map((file)=>file.id === tabId ? {\n                    ...file,\n                    content: tab.content,\n                    modifiedAt: new Date()\n                } : file);\n            const updatedFinancialFiles = financialFiles.map((file)=>file.id === tabId ? {\n                    ...file,\n                    content: tab.content,\n                    modifiedAt: new Date()\n                } : file);\n            const updatedTabs = openTabs.map((t)=>t.id === tabId ? {\n                    ...t,\n                    modified: false\n                } : t);\n            set({\n                projectFiles: updatedProjectFiles,\n                financialFiles: updatedFinancialFiles,\n                openTabs: updatedTabs\n            });\n        },\n        setError: (error)=>{\n            set({\n                error\n            });\n        },\n        // Fix files that don't have content\n        repairFilesWithoutContent: ()=>{\n            const { projectFiles, financialFiles } = get();\n            const repairedProjectFiles = projectFiles.map((file)=>{\n                if (!file.content || file.content.trim() === '') {\n                    return {\n                        ...file,\n                        content: getDefaultContent(file.type, file.name),\n                        modifiedAt: new Date()\n                    };\n                }\n                return file;\n            });\n            const repairedFinancialFiles = financialFiles.map((file)=>{\n                if (!file.content || file.content.trim() === '') {\n                    return {\n                        ...file,\n                        content: getDefaultContent(file.type, file.name),\n                        modifiedAt: new Date()\n                    };\n                }\n                return file;\n            });\n            set({\n                projectFiles: repairedProjectFiles,\n                financialFiles: repairedFinancialFiles\n            });\n        },\n        reset: ()=>{\n            set({\n                openTabs: [],\n                activeTab: '',\n                projectFiles: initialProjectFiles,\n                financialFiles: initialFinancialFiles,\n                projectFolders: [],\n                financialFolders: [],\n                showProjectsCategory: true,\n                showFinancialCategory: false,\n                isLoading: false,\n                error: null\n            });\n        },\n        // Clear user data when signing out (but keep UI state like theme, etc.)\n        clearUserData: ()=>{\n            set({\n                openTabs: [],\n                activeTab: '',\n                projectFiles: [],\n                financialFiles: [],\n                projectFolders: [],\n                financialFolders: [],\n                trashItems: [],\n                showProjectsCategory: true,\n                showFinancialCategory: false\n            });\n        }\n    }), {\n    name: 'editor-storage',\n    version: 1,\n    // Only persist specific fields\n    partialize: (state)=>({\n            openTabs: state.openTabs.map((tab)=>({\n                    id: tab.id,\n                    name: tab.name,\n                    modified: tab.modified,\n                    content: tab.content,\n                    filePath: tab.filePath,\n                    type: tab.type,\n                    pinned: tab.pinned,\n                    pinnedOrder: tab.pinnedOrder\n                })),\n            activeTab: state.activeTab,\n            projectFiles: state.projectFiles,\n            financialFiles: state.financialFiles,\n            projectFolders: state.projectFolders,\n            financialFolders: state.financialFolders,\n            showProjectsCategory: state.showProjectsCategory,\n            showFinancialCategory: state.showFinancialCategory\n        }),\n    // Custom storage to handle icon restoration\n    storage: {\n        getItem: (name)=>{\n            const str = localStorage.getItem(name);\n            if (!str) return null;\n            const { state } = JSON.parse(str);\n            // Restore icons based on file type\n            const restoredTabs = (state.openTabs || []).map((tab)=>{\n                let icon = _barrel_optimize_names_AtSign_Braces_Calendar_Camera_FileCode_FileSpreadsheet_FileText_FileType_MessageSquare_lucide_react__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\n                switch(tab.type){\n                    case 'typescript':\n                    case 'javascript':\n                        icon = _barrel_optimize_names_AtSign_Braces_Calendar_Camera_FileCode_FileSpreadsheet_FileText_FileType_MessageSquare_lucide_react__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\n                        break;\n                    case 'json':\n                        icon = _barrel_optimize_names_AtSign_Braces_Calendar_Camera_FileCode_FileSpreadsheet_FileText_FileType_MessageSquare_lucide_react__WEBPACK_IMPORTED_MODULE_1__[\"default\"];\n                        break;\n                    case 'excel':\n                        icon = _barrel_optimize_names_AtSign_Braces_Calendar_Camera_FileCode_FileSpreadsheet_FileText_FileType_MessageSquare_lucide_react__WEBPACK_IMPORTED_MODULE_2__[\"default\"];\n                        break;\n                    case 'markdown':\n                        icon = _barrel_optimize_names_AtSign_Braces_Calendar_Camera_FileCode_FileSpreadsheet_FileText_FileType_MessageSquare_lucide_react__WEBPACK_IMPORTED_MODULE_3__[\"default\"];\n                        break;\n                    case 'pdf':\n                        icon = _barrel_optimize_names_AtSign_Braces_Calendar_Camera_FileCode_FileSpreadsheet_FileText_FileType_MessageSquare_lucide_react__WEBPACK_IMPORTED_MODULE_4__[\"default\"];\n                        break;\n                }\n                return {\n                    ...tab,\n                    icon\n                };\n            });\n            return {\n                state: {\n                    ...state,\n                    openTabs: restoredTabs\n                }\n            };\n        },\n        setItem: (name, value)=>{\n            if ( true && localStorage) {\n                localStorage.setItem(name, JSON.stringify(value));\n            }\n        },\n        removeItem: (name)=>{\n            if ( true && localStorage) {\n                localStorage.removeItem(name);\n            }\n        }\n    },\n    onRehydrateStorage: ()=>(state)=>{\n            if (state) {\n                // Repair any files that don't have content\n                if (state.projectFiles) {\n                    state.projectFiles = state.projectFiles.map((file)=>{\n                        if (!file.content || file.content.trim() === '') {\n                            return {\n                                ...file,\n                                content: getDefaultContent(file.type, file.name),\n                                modifiedAt: new Date()\n                            };\n                        }\n                        return file;\n                    });\n                }\n                if (state.financialFiles) {\n                    state.financialFiles = state.financialFiles.map((file)=>{\n                        if (!file.content || file.content.trim() === '') {\n                            return {\n                                ...file,\n                                content: getDefaultContent(file.type, file.name),\n                                modifiedAt: new Date()\n                            };\n                        }\n                        return file;\n                    });\n                }\n                // Ensure system folders exist if there are project folders\n                if (state.projectFolders && state.projectFolders.length > 0) {\n                    // Only ensure the system folders if there are already some project folders\n                    // This prevents auto-creation when storage is intentionally cleared\n                    const hasInstructionsFolder = state.projectFolders.some((folder)=>folder.id === 'instructions-folder' && folder.pinned);\n                    const hasContentCreationFolder = state.projectFolders.some((folder)=>folder.id === 'content-creation-folder' && folder.pinned);\n                    const systemFolders = [];\n                    if (!hasInstructionsFolder) {\n                        systemFolders.push({\n                            id: 'instructions-folder',\n                            name: 'Instructions',\n                            category: 'project',\n                            createdAt: new Date(),\n                            pinned: true\n                        });\n                    }\n                    if (!hasContentCreationFolder) {\n                        systemFolders.push({\n                            id: 'content-creation-folder',\n                            name: 'Content Creation',\n                            category: 'project',\n                            createdAt: new Date(),\n                            pinned: true\n                        });\n                    }\n                    if (systemFolders.length > 0) {\n                        state.projectFolders = [\n                            ...systemFolders,\n                            ...state.projectFolders\n                        ];\n                    }\n                }\n            }\n        // If projectFolders is empty, respect that (don't auto-create anything)\n        }\n}), {\n    name: 'editor-store'\n}));\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3N0b3JlL2VkaXRvci9pbmRleC50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBQSxlQUFlO0FBQ2YsNkRBQTZEO0FBRWlFO0FBQzdGO0FBQ3NCO0FBR3ZELGlEQUFpRDtBQUNqRCxNQUFNWSxjQUFjLENBQUNDO0lBQ25CLE9BQVFBO1FBQ04sS0FBSztZQUNILE9BQU9ULGtLQUFRQTtRQUNqQixLQUFLO1lBQ0gsT0FBT0Esa0tBQVFBO1FBQ2pCLEtBQUs7WUFDSCxPQUFPSCxrS0FBTUE7UUFDZixLQUFLO1lBQ0gsT0FBT0ksa0tBQWVBO1FBQ3hCLEtBQUs7WUFDSCxPQUFPQyxrS0FBUUE7UUFDakIsS0FBSztZQUNILE9BQU9DLGtLQUFRQTtRQUNqQixLQUFLO1lBQ0gsT0FBT0Qsa0tBQVFBO1FBQ2pCLEtBQUs7WUFDSCxPQUFPRCxrS0FBZUE7UUFDeEIsS0FBSztZQUNILE9BQU9BLGtLQUFlQTtRQUN4QixLQUFLO1lBQ0gsT0FBT0Esa0tBQWVBO1FBQ3hCLEtBQUs7WUFDSCxPQUFPRyxrS0FBYUE7UUFDdEIsS0FBSztZQUNILE9BQU8sTUFBTSwrQkFBK0I7UUFDOUMsS0FBSztZQUNILE9BQU9MLGtLQUFNQTtRQUNmLEtBQUs7WUFDSCxPQUFPSCxrS0FBTUE7UUFDZixLQUFLO1lBQ0gsT0FBT0Usa0tBQVFBO1FBQ2pCO1lBQ0UsT0FBT0Usa0tBQVFBO0lBQ25CO0FBQ0Y7QUFFQSx3Q0FBd0M7QUFDeEMsd0NBQXdDO0FBQ3hDLE1BQU1VLG1CQUFtQixDQUFDRDtJQUN4QixPQUFRQTtRQUNOLEtBQUs7WUFDSCxPQUFPO1FBQ1QsS0FBSztZQUNILE9BQU87UUFDVCxLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7WUFDSCxPQUFPO1FBQ1QsS0FBSztZQUNILE9BQU87UUFDVCxLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7WUFDSCxPQUFPO1FBQ1QsS0FBSztZQUNILE9BQU87UUFDVCxLQUFLO1lBQ0gsT0FBTztRQUNULEtB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LGNBQWMsQ0FBQ3dELElBQUksQ0FBQzJDLENBQUFBLFNBQ3pEQSxPQUFPeEYsRUFBRSxLQUFLLDZCQUE2QndGLE9BQU90RSxNQUFNO29CQUcxRCxNQUFNbUssZ0JBQWlDLEVBQUU7b0JBRXpDLElBQUksQ0FBQ0YsdUJBQXVCO3dCQUMxQkUsY0FBY0MsSUFBSSxDQUFDOzRCQUNqQnRMLElBQUk7NEJBQ0oxQixNQUFNOzRCQUNONEYsVUFBVTs0QkFDVlksV0FBVyxJQUFJdEc7NEJBQ2YwQyxRQUFRO3dCQUNWO29CQUNGO29CQUVBLElBQUksQ0FBQ2tLLDBCQUEwQjt3QkFDN0JDLGNBQWNDLElBQUksQ0FBQzs0QkFDakJ0TCxJQUFJOzRCQUNKMUIsTUFBTTs0QkFDTjRGLFVBQVU7NEJBQ1ZZLFdBQVcsSUFBSXRHOzRCQUNmMEMsUUFBUTt3QkFDVjtvQkFDRjtvQkFFQSxJQUFJbUssY0FBY2xMLE1BQU0sR0FBRyxHQUFHO3dCQUM1Qm1LLE1BQU1qTCxjQUFjLEdBQUc7K0JBQ2xCZ007K0JBQ0FmLE1BQU1qTCxjQUFjO3lCQUN4QjtvQkFDSDtnQkFDRjtZQUNGO1FBQ0Esd0VBQXdFO1FBQzFFO0FBQ0YsSUFFRjtJQUFFZixNQUFNO0FBQWUsSUFFekIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYXR0aGV3c2ltb24vUHJvamVjdHMvZWFjL2VhYy9zdG9yZS9lZGl0b3IvaW5kZXgudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gRWRpdG9yIFN0b3JlXG4vLyAvVXNlcnMvbWF0dGhld3NpbW9uL1Byb2plY3RzL0VBQy9lYWMvc3RvcmUvZWRpdG9yL2luZGV4LnRzXG5cbmltcG9ydCB7IEF0U2lnbiwgQnJhY2VzLCBDYWxlbmRhciwgQ2FtZXJhLCBGaWxlQ29kZSwgRmlsZVNwcmVhZHNoZWV0LCBGaWxlVGV4dCwgRmlsZVR5cGUsIE1lc3NhZ2VTcXVhcmUgfSBmcm9tICdsdWNpZGUtcmVhY3QnO1xuaW1wb3J0IHsgY3JlYXRlIH0gZnJvbSAnenVzdGFuZCc7XG5pbXBvcnQgeyBkZXZ0b29scywgcGVyc2lzdCB9IGZyb20gJ3p1c3RhbmQvbWlkZGxld2FyZSc7XG5pbXBvcnQgeyBFZGl0b3JTdGF0ZSwgRWRpdG9yVGFiLCBQcm9qZWN0RmlsZSwgUHJvamVjdEZvbGRlciwgVHJhc2hJdGVtIH0gZnJvbSAnLi90eXBlcyc7XG5cbi8vIEhlbHBlciBmdW5jdGlvbiB0byBnZXQgaWNvbiBiYXNlZCBvbiBmaWxlIHR5cGVcbmNvbnN0IGdldEZpbGVJY29uID0gKHR5cGU6IFByb2plY3RGaWxlWyd0eXBlJ10pID0+IHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAndHlwZXNjcmlwdCc6XG4gICAgICByZXR1cm4gRmlsZUNvZGU7XG4gICAgY2FzZSAnamF2YXNjcmlwdCc6XG4gICAgICByZXR1cm4gRmlsZUNvZGU7XG4gICAgY2FzZSAnanNvbic6XG4gICAgICByZXR1cm4gQnJhY2VzO1xuICAgIGNhc2UgJ2V4Y2VsJzpcbiAgICAgIHJldHVybiBGaWxlU3ByZWFkc2hlZXQ7XG4gICAgY2FzZSAnbWFya2Rvd24nOlxuICAgICAgcmV0dXJuIEZpbGVUZXh0O1xuICAgIGNhc2UgJ3BkZic6XG4gICAgICByZXR1cm4gRmlsZVR5cGU7XG4gICAgY2FzZSAnZ2VuZXJhbHMnOlxuICAgICAgcmV0dXJuIEZpbGVUZXh0O1xuICAgIGNhc2UgJ3BlcmNlbnQtY29tcGxldGUnOlxuICAgICAgcmV0dXJuIEZpbGVTcHJlYWRzaGVldDtcbiAgICBjYXNlICdzY2hlZHVsZSc6XG4gICAgICByZXR1cm4gRmlsZVNwcmVhZHNoZWV0O1xuICAgIGNhc2UgJ21hdGVyaWFscyc6XG4gICAgICByZXR1cm4gRmlsZVNwcmVhZHNoZWV0O1xuICAgIGNhc2UgJ2ZhY2Vib29rJzpcbiAgICAgIHJldHVybiBNZXNzYWdlU3F1YXJlO1xuICAgIGNhc2UgJ3JlZGRpdCc6XG4gICAgICByZXR1cm4gJ3IvJzsgLy8gQ2hhbmdlZCBmcm9tIEhhc2ggdG8gci8gdGV4dFxuICAgIGNhc2UgJ2luc3RhZ3JhbSc6XG4gICAgICByZXR1cm4gQ2FtZXJhO1xuICAgIGNhc2UgJ3gnOlxuICAgICAgcmV0dXJuIEF0U2lnbjtcbiAgICBjYXNlICdjYWxlbmRhcic6XG4gICAgICByZXR1cm4gQ2FsZW5kYXI7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBGaWxlQ29kZTtcbiAgfVxufTtcblxuLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGdldCBmaWxlIGV4dGVuc2lvblxuLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGdldCBmaWxlIGV4dGVuc2lvblxuY29uc3QgZ2V0RmlsZUV4dGVuc2lvbiA9ICh0eXBlOiBQcm9qZWN0RmlsZVsndHlwZSddKTogc3RyaW5nID0+IHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAndHlwZXNjcmlwdCc6XG4gICAgICByZXR1cm4gJy50cyc7XG4gICAgY2FzZSAnamF2YXNjcmlwdCc6XG4gICAgICByZXR1cm4gJy5qcyc7XG4gICAgY2FzZSAnanNvbic6XG4gICAgICByZXR1cm4gJy5qc29uJztcbiAgICBjYXNlICdleGNlbCc6XG4gICAgICByZXR1cm4gJy54bHN4JztcbiAgICBjYXNlICdwZGYnOlxuICAgICAgcmV0dXJuICcucGRmJztcbiAgICBjYXNlICdnZW5lcmFscyc6XG4gICAgICByZXR1cm4gJy5nZW5lcmFscyc7XG4gICAgY2FzZSAncGVyY2VudC1jb21wbGV0ZSc6XG4gICAgICByZXR1cm4gJy5wZXJjZW50JztcbiAgICBjYXNlICdzY2hlZHVsZSc6XG4gICAgICByZXR1cm4gJy5zY2hlZHVsZSc7XG4gICAgY2FzZSAnbWF0ZXJpYWxzJzpcbiAgICAgIHJldHVybiAnLm1hdGVyaWFscyc7XG4gICAgY2FzZSAnZmFjZWJvb2snOlxuICAgICAgcmV0dXJuICcuZmFjZWJvb2snO1xuICAgIGNhc2UgJ3JlZGRpdCc6XG4gICAgICByZXR1cm4gJy5yZWRkaXQnO1xuICAgIGNhc2UgJ2luc3RhZ3JhbSc6XG4gICAgICByZXR1cm4gJy5pbnN0YWdyYW0nO1xuICAgIGNhc2UgJ3gnOlxuICAgICAgcmV0dXJuICcueCc7XG4gICAgY2FzZSAnbWFya2Rvd24nOlxuICAgICAgcmV0dXJuICcubWQnO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gJy50eHQnO1xuICB9XG59O1xuXG4vLyBIZWxwZXIgZnVuY3Rpb24gdG8gZ2VuZXJhdGUgZGVmYXVsdCBjb250ZW50IGZvciBuZXcgZmlsZXNcbmNvbnN0IGdldERlZmF1bHRDb250ZW50ID0gKHR5cGU6IFByb2plY3RGaWxlWyd0eXBlJ10sIG5hbWU6IHN0cmluZykgPT4ge1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICd0eXBlc2NyaXB0JzpcbiAgICAgIHJldHVybiBgLy8gJHtuYW1lfVxuLy8gQXV0by1nZW5lcmF0ZWQgVHlwZVNjcmlwdCBmaWxlXG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbmludGVyZmFjZSAke25hbWUucmVwbGFjZSgvW15hLXpBLVowLTldL2csICcnKX1Qcm9wcyB7XG4gIC8vIERlZmluZSBwcm9wcyBoZXJlXG59XG5cbmV4cG9ydCBmdW5jdGlvbiAke25hbWUucmVwbGFjZSgvW15hLXpBLVowLTldL2csICcnKX0oeyB9OiAke25hbWUucmVwbGFjZSgvW15hLXpBLVowLTldL2csICcnKX1Qcm9wcykge1xuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPVwicC00XCI+XG4gICAgICA8aDEgY2xhc3NOYW1lPVwidGV4dC14bCBmb250LWJvbGRcIj5OZXcgQ29tcG9uZW50OiAke25hbWV9PC9oMT5cbiAgICAgIDxwIGNsYXNzTmFtZT1cInRleHQtZ3JheS02MDBcIj5TdGFydCBidWlsZGluZyB5b3VyIGNvbXBvbmVudCBoZXJlLi4uPC9wPlxuICAgIDwvZGl2PlxuICApO1xufWA7XG4gICAgY2FzZSAnamF2YXNjcmlwdCc6XG4gICAgICByZXR1cm4gYC8vICR7bmFtZX1cbi8vIEF1dG8tZ2VuZXJhdGVkIEphdmFTY3JpcHQgZmlsZVxuXG5leHBvcnQgZnVuY3Rpb24gJHtuYW1lLnJlcGxhY2UoL1teYS16QS1aMC05XS9nLCAnJyl9KCkge1xuICByZXR1cm4ge1xuICAgIG1lc3NhZ2U6ICdIZWxsbyBmcm9tICR7bmFtZX0hJyxcbiAgICBkYXRhOiBbXVxuICB9O1xufWA7XG4gICAgY2FzZSAnanNvbic6XG4gICAgICByZXR1cm4gYHtcbiAgXCJuYW1lXCI6IFwiJHtuYW1lfVwiLFxuICBcImRlc2NyaXB0aW9uXCI6IFwiQXV0by1nZW5lcmF0ZWQgSlNPTiBmaWxlXCIsXG4gIFwidmVyc2lvblwiOiBcIjEuMC4wXCIsXG4gIFwiZGF0YVwiOiB7fVxufWA7XG4gICAgY2FzZSAnbWFya2Rvd24nOlxuICAgICAgcmV0dXJuIGBTdGFydCB3cml0aW5nIHlvdXIgY29udGVudCBoZXJlLi4uYDtcbiAgICBjYXNlICdnZW5lcmFscyc6XG4gICAgICByZXR1cm4gYC8vICR7bmFtZX0gLSBQcm9qZWN0IEdlbmVyYWwgSW5mb3JtYXRpb25cbi8vIFRoaXMgZmlsZSBjb250YWlucyBnZW5lcmFsIHByb2plY3QgZGV0YWlscyBhbmQgZmluYW5jaWFsIGluZm9ybWF0aW9uXG4vLyBDcmVhdGVkIG9uOiAke25ldyBEYXRlKCkudG9JU09TdHJpbmcoKX1cblxuUHJvamVjdDogJHtuYW1lfVxuU3RhdHVzOiBBY3RpdmVcbkNyZWF0ZWQ6ICR7bmV3IERhdGUoKS50b0xvY2FsZURhdGVTdHJpbmcoKX1cblxuLy8gVGhpcyBmaWxlIHdpbGwgZGlzcGxheSB0aGUgcHJvamVjdCBnZW5lcmFscyBtb2R1bGUgaW50ZXJmYWNlYDtcbiAgICBjYXNlICdwZXJjZW50LWNvbXBsZXRlJzpcbiAgICAgIHJldHVybiBgLy8gJHtuYW1lfSAtIFBlcmNlbnQgQ29tcGxldGUgVHJhY2tlclxuLy8gVGhpcyBmaWxlIGNvbnRhaW5zIHByb2plY3QgY29tcGxldGlvbiB0cmFja2luZyBkYXRhXG4vLyBDcmVhdGVkIG9uOiAke25ldyBEYXRlKCkudG9JU09TdHJpbmcoKX1cblxuUHJvamVjdDogJHtuYW1lfVxuVHlwZTogUGVyY2VudCBDb21wbGV0ZSBUcmFja2VyXG5DcmVhdGVkOiAke25ldyBEYXRlKCkudG9Mb2NhbGVEYXRlU3RyaW5nKCl9XG5cbi8vIFRoaXMgZmlsZSB3aWxsIGRpc3BsYXkgdGhlIHBlcmNlbnQgY29tcGxldGUgdHJhY2tpbmcgaW50ZXJmYWNlYDtcbiAgICBjYXNlICdzY2hlZHVsZSc6XG4gICAgICByZXR1cm4gYC8vICR7bmFtZX0gLSBQcm9qZWN0IFNjaGVkdWxlXG4vLyBUaGlzIGZpbGUgY29udGFpbnMgcHJvamVjdCBzY2hlZHVsZSBhbmQgdGltZWxpbmUgZGF0YVxuLy8gQ3JlYXRlZCBvbjogJHtuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCl9XG5cblByb2plY3Q6ICR7bmFtZX1cblR5cGU6IFByb2plY3QgU2NoZWR1bGVcbkNyZWF0ZWQ6ICR7bmV3IERhdGUoKS50b0xvY2FsZURhdGVTdHJpbmcoKX1cblxuLy8gVGhpcyBmaWxlIHdpbGwgZGlzcGxheSB0aGUgcHJvamVjdCBzY2hlZHVsZSBpbnRlcmZhY2Ugd2l0aCBHYW50dCBjaGFydGA7XG4gICAgY2FzZSAnbWF0ZXJpYWxzJzpcbiAgICAgIHJldHVybiBgLy8gJHtuYW1lfSAtIE1hdGVyaWFscyBNYW5hZ2VtZW50XG4vLyBUaGlzIGZpbGUgY29udGFpbnMgbWF0ZXJpYWxzIHRyYWNraW5nIGFuZCBtYW5hZ2VtZW50IGRhdGFcbi8vIENyZWF0ZWQgb246ICR7bmV3IERhdGUoKS50b0lTT1N0cmluZygpfVxuXG5Qcm9qZWN0OiAke25hbWV9XG5UeXBlOiBNYXRlcmlhbHMgTWFuYWdlbWVudFxuQ3JlYXRlZDogJHtuZXcgRGF0ZSgpLnRvTG9jYWxlRGF0ZVN0cmluZygpfVxuXG4vLyBUaGlzIGZpbGUgd2lsbCBkaXNwbGF5IHRoZSBtYXRlcmlhbHMgbWFuYWdlbWVudCBpbnRlcmZhY2Ugd2l0aCBtYW51ZmFjdHVyZWQgYW5kIG1pc2NlbGxhbmVvdXMgbWF0ZXJpYWxzYDtcbiAgICBjYXNlICdmYWNlYm9vayc6XG4gICAgICByZXR1cm4gYCMgJHtuYW1lfSAtIEZhY2Vib29rIFBvc3RcblBsYXRmb3JtOiBGYWNlYm9va1xuQ3JlYXRlZDogJHtuZXcgRGF0ZSgpLnRvTG9jYWxlRGF0ZVN0cmluZygpfVxuXG4jIyBQb3N0IENvbnRlbnRcbldyaXRlIHlvdXIgRmFjZWJvb2sgcG9zdCBjb250ZW50IGhlcmUuLi5cblxuIyMgU2V0dGluZ3Ncbi0gQXVkaWVuY2U6IFB1YmxpY1xuLSBTY2hlZHVsZTogTm93XG4tIEhhc2h0YWdzOiAjZXhhbXBsZVxuXG4jIyBNZWRpYVxuLSBJbWFnZXM6IFtdXG4tIFZpZGVvczogW11cblxuIyMgQW5hbHl0aWNzXG4tIEVuZ2FnZW1lbnQ6IDBcbi0gUmVhY2g6IDBcbi0gQ2xpY2tzOiAwYDtcbiAgICBjYXNlICdyZWRkaXQnOlxuICAgICAgcmV0dXJuIGAjICR7bmFtZX0gLSBSZWRkaXQgUG9zdFxuUGxhdGZvcm06IFJlZGRpdFxuQ3JlYXRlZDogJHtuZXcgRGF0ZSgpLnRvTG9jYWxlRGF0ZVN0cmluZygpfVxuXG4jIyBQb3N0IENvbnRlbnRcbldyaXRlIHlvdXIgUmVkZGl0IHBvc3QgY29udGVudCBoZXJlLi4uXG5cbiMjIFNldHRpbmdzXG4tIFN1YnJlZGRpdDogci9leGFtcGxlXG4tIFBvc3QgVHlwZTogVGV4dC9MaW5rL0ltYWdlXG4tIEZsYWlyOiBEaXNjdXNzaW9uXG4tIE5TRlc6IE5vXG5cbiMjIE1lZGlhXG4tIEltYWdlczogW11cbi0gTGlua3M6IFtdXG5cbiMjIEFuYWx5dGljc1xuLSBVcHZvdGVzOiAwXG4tIENvbW1lbnRzOiAwXG4tIEF3YXJkczogMGA7XG4gICAgY2FzZSAnaW5zdGFncmFtJzpcbiAgICAgIHJldHVybiBgIyAke25hbWV9IC0gSW5zdGFncmFtIFBvc3RcblBsYXRmb3JtOiBJbnN0YWdyYW1cbkNyZWF0ZWQ6ICR7bmV3IERhdGUoKS50b0xvY2FsZURhdGVTdHJpbmcoKX1cblxuIyMgUG9zdCBDb250ZW50XG5Xcml0ZSB5b3VyIEluc3RhZ3JhbSBwb3N0IGNvbnRlbnQgaGVyZS4uLlxuXG4jIyBTZXR0aW5nc1xuLSBQb3N0IFR5cGU6IEZlZWQvU3RvcnkvUmVlbFxuLSBMb2NhdGlvbjogQ2l0eSwgQ291bnRyeVxuLSBBbHQgVGV4dDogRGVzY3JpYmUgaW1hZ2Vcbi0gQ29tbWVudCBTZXR0aW5nczogUHVibGljXG5cbiMjIE1lZGlhXG4tIEltYWdlczogW11cbi0gVmlkZW9zOiBbXVxuXG4jIyBIYXNodGFnc1xuI2hhc2h0YWcxICNoYXNodGFnMiAjaGFzaHRhZzNcblxuIyMgQW5hbHl0aWNzXG4tIExpa2VzOiAwXG4tIENvbW1lbnRzOiAwXG4tIFNoYXJlczogMFxuLSBSZWFjaDogMGA7XG4gICAgY2FzZSAneCc6XG4gICAgICByZXR1cm4gYCMgJHtuYW1lfSAtIFgvVHdpdHRlciBQb3N0XG5QbGF0Zm9ybTogWCAoVHdpdHRlcilcbkNyZWF0ZWQ6ICR7bmV3IERhdGUoKS50b0xvY2FsZURhdGVTdHJpbmcoKX1cblxuIyMgUG9zdCBDb250ZW50XG5Xcml0ZSB5b3VyIFggcG9zdCBjb250ZW50IGhlcmUuLi4gKDI4MCBjaGFyYWN0ZXIgbGltaXQpXG5cbiMjIFNldHRpbmdzXG4tIFJlcGx5IFNldHRpbmdzOiBFdmVyeW9uZVxuLSBTY2hlZHVsZTogTm93XG4tIFRocmVhZDogU2luZ2xlIFR3ZWV0XG5cbiMjIE1lZGlhXG4tIEltYWdlczogW11cbi0gVmlkZW9zOiBbXVxuLSBHSUZzOiBbXVxuXG4jIyBBbmFseXRpY3Ncbi0gSW1wcmVzc2lvbnM6IDBcbi0gRW5nYWdlbWVudHM6IDBcbi0gUmV0d2VldHM6IDBcbi0gTGlrZXM6IDBcbi0gUmVwbGllczogMGA7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBgIyAke25hbWV9XG5cblRoaXMgaXMgYSBuZXcgZmlsZSBjcmVhdGVkIGluIHRoZSBFQUMgRGFzaGJvYXJkLlxuQ3JlYXRlZCBvbjogJHtuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCl9YDtcbiAgfVxufTtcblxuLy8gSW5pdGlhbCBwcm9qZWN0IGZpbGVzIC0gZW1wdHkgYnkgZGVmYXVsdCwgb25seSBjcmVhdGVkIHdoZW4gbmVlZGVkXG5jb25zdCBpbml0aWFsUHJvamVjdEZpbGVzOiBQcm9qZWN0RmlsZVtdID0gW107XG5cbi8vIEluaXRpYWwgZmluYW5jaWFsIGZpbGVzIC0gZW1wdHkgYnkgZGVmYXVsdCwgb25seSBjcmVhdGVkIHdoZW4gbmVlZGVkICBcbmNvbnN0IGluaXRpYWxGaW5hbmNpYWxGaWxlczogUHJvamVjdEZpbGVbXSA9IFtdO1xuXG4vLyBJbml0aWFsIHByb2plY3QgZm9sZGVycyAtIG9ubHkgY3JlYXRlZCB3aGVuIGV4cGxpY2l0bHkgbmVlZGVkLCBub3Qgb24gc3RvcmFnZSBjbGVhclxuY29uc3QgaW5pdGlhbFByb2plY3RGb2xkZXJzOiBQcm9qZWN0Rm9sZGVyW10gPSBbXTtcblxuZXhwb3J0IGNvbnN0IHVzZUVkaXRvclN0b3JlID0gY3JlYXRlPEVkaXRvclN0YXRlPigpKFxuICBkZXZ0b29scyhcbiAgICBwZXJzaXN0KFxuICAgICAgKHNldCwgZ2V0KSA9PiAoe1xuICAgICAgICAvLyBJbml0aWFsIHN0YXRlXG4gICAgICAgIG9wZW5UYWJzOiBbXSxcbiAgICAgICAgYWN0aXZlVGFiOiAnJyxcbiAgICAgICAgcHJvamVjdEZpbGVzOiBpbml0aWFsUHJvamVjdEZpbGVzLFxuICAgICAgICBmaW5hbmNpYWxGaWxlczogaW5pdGlhbEZpbmFuY2lhbEZpbGVzLFxuICAgICAgICBwcm9qZWN0Rm9sZGVyczogaW5pdGlhbFByb2plY3RGb2xkZXJzLFxuICAgICAgICBmaW5hbmNpYWxGb2xkZXJzOiBbXSxcbiAgICAgICAgdHJhc2hJdGVtczogW10sXG4gICAgICAgIHNob3dQcm9qZWN0c0NhdGVnb3J5OiB0cnVlLFxuICAgICAgICBzaG93RmluYW5jaWFsQ2F0ZWdvcnk6IGZhbHNlLCAvLyBEb24ndCBzaG93IGJ5IGRlZmF1bHQgLSBvbmx5IHNob3cgd2hlbiB1c2VyIGNyZWF0ZXMgZmluYW5jaWFsIGNvbnRlbnRcbiAgICAgICAgaXNMb2FkaW5nOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6IG51bGwsXG5cbiAgICAgICAgLy8gQWN0aW9uc1xuICAgICAgICBvcGVuVGFiOiAoZmlsZTogUHJvamVjdEZpbGUpID0+IHtcbiAgICAgICAgICBjb25zdCB7IG9wZW5UYWJzIH0gPSBnZXQoKTtcbiAgICAgICAgICBcbiAgICAgICAgICBjb25zb2xlLmxvZygn8J+UjSBPcGVuaW5nIHRhYiBmb3IgZmlsZTonLCB7XG4gICAgICAgICAgICBpZDogZmlsZS5pZCxcbiAgICAgICAgICAgIG5hbWU6IGZpbGUubmFtZSxcbiAgICAgICAgICAgIGNvbnRlbnRMZW5ndGg6IGZpbGUuY29udGVudD8ubGVuZ3RoIHx8IDAsXG4gICAgICAgICAgICBjb250ZW50UHJldmlldzogZmlsZS5jb250ZW50Py5zdWJzdHJpbmcoMCwgMTAwKSB8fCAnTk8gQ09OVEVOVCdcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBDaGVjayBpZiB0YWIgaXMgYWxyZWFkeSBvcGVuXG4gICAgICAgICAgY29uc3QgZXhpc3RpbmdUYWIgPSBvcGVuVGFicy5maW5kKHRhYiA9PiB0YWIuaWQgPT09IGZpbGUuaWQpO1xuICAgICAgICAgIGlmIChleGlzdGluZ1RhYikge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ/Cfk4IgVGFiIGFscmVhZHkgZXhpc3RzLCBhY3RpdmF0aW5nOicsIGV4aXN0aW5nVGFiLmlkKTtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgZXhpc3RpbmcgdGFiIGNvbnRlbnQgd2l0aCB0aGUgY3VycmVudCBmaWxlIGNvbnRlbnRcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRUYWJzID0gb3BlblRhYnMubWFwKHRhYiA9PiBcbiAgICAgICAgICAgICAgdGFiLmlkID09PSBmaWxlLmlkIFxuICAgICAgICAgICAgICAgID8geyAuLi50YWIsIGNvbnRlbnQ6IGZpbGUuY29udGVudCB8fCBnZXREZWZhdWx0Q29udGVudChmaWxlLnR5cGUsIGZpbGUubmFtZSkgfVxuICAgICAgICAgICAgICAgIDogdGFiXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgc2V0KHsgXG4gICAgICAgICAgICAgIG9wZW5UYWJzOiB1cGRhdGVkVGFicyxcbiAgICAgICAgICAgICAgYWN0aXZlVGFiOiBleGlzdGluZ1RhYi5pZCBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIERlZmluZSB3aGljaCBmaWxlIHR5cGVzIHNob3VsZCBiZSBhdXRvLXBpbm5lZFxuICAgICAgICAgIC8vIFlvdSBjYW4gYWRkIG1vcmUgZmlsZSB0eXBlcyBoZXJlIGlmIG5lZWRlZFxuICAgICAgICAgIGNvbnN0IGF1dG9QaW5GaWxlVHlwZXMgPSBbJ2NhbGVuZGFyJywgJ3NvY2lhbC1jb25uZWN0JywgJ3VzZXItcHJvZmlsZScsICdwb3N0LWNyZWF0b3InXTtcbiAgICAgICAgICBjb25zdCBzaG91bGRBdXRvUGlubiA9IGF1dG9QaW5GaWxlVHlwZXMuaW5jbHVkZXMoZmlsZS50eXBlKTtcbiAgICAgICAgICBcbiAgICAgICAgICBsZXQgcGlubmVkT3JkZXI6IG51bWJlciB8IHVuZGVmaW5lZDtcbiAgICAgICAgICBpZiAoc2hvdWxkQXV0b1Bpbm4pIHtcbiAgICAgICAgICAgIC8vIEdldCB0aGUgaGlnaGVzdCBwaW5uZWQgb3JkZXIgZm9yIGF1dG8tcGlubmVkIHRhYnNcbiAgICAgICAgICAgIGNvbnN0IHBpbm5lZFRhYnMgPSBvcGVuVGFicy5maWx0ZXIodCA9PiB0LnBpbm5lZCk7XG4gICAgICAgICAgICBwaW5uZWRPcmRlciA9IHBpbm5lZFRhYnMubGVuZ3RoID4gMCA/IE1hdGgubWF4KC4uLnBpbm5lZFRhYnMubWFwKHQgPT4gdC5waW5uZWRPcmRlciB8fCAwKSkgKyAxIDogMTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBDcmVhdGUgbmV3IHRhYiB3aXRoIGNvbnRlbnRcbiAgICAgICAgICBjb25zdCB0YWJDb250ZW50ID0gZmlsZS5jb250ZW50IHx8IGdldERlZmF1bHRDb250ZW50KGZpbGUudHlwZSwgZmlsZS5uYW1lKTtcbiAgICAgICAgICBjb25zb2xlLmxvZygn8J+GlSBDcmVhdGluZyBuZXcgdGFiIHdpdGggY29udGVudDonLCB7XG4gICAgICAgICAgICBmaWxlSWQ6IGZpbGUuaWQsXG4gICAgICAgICAgICBmaWxlTmFtZTogZmlsZS5uYW1lLFxuICAgICAgICAgICAgaGFzQ3VzdG9tQ29udGVudDogISFmaWxlLmNvbnRlbnQsXG4gICAgICAgICAgICBjb250ZW50TGVuZ3RoOiB0YWJDb250ZW50Lmxlbmd0aCxcbiAgICAgICAgICAgIGNvbnRlbnRQcmV2aWV3OiB0YWJDb250ZW50LnN1YnN0cmluZygwLCAxMDApXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgXG4gICAgICAgICAgY29uc3QgbmV3VGFiOiBFZGl0b3JUYWIgPSB7XG4gICAgICAgICAgICBpZDogZmlsZS5pZCxcbiAgICAgICAgICAgIG5hbWU6IGZpbGUubmFtZSxcbiAgICAgICAgICAgIG1vZGlmaWVkOiBmYWxzZSxcbiAgICAgICAgICAgIGNvbnRlbnQ6IHRhYkNvbnRlbnQsXG4gICAgICAgICAgICBmaWxlUGF0aDogZmlsZS5maWxlUGF0aCxcbiAgICAgICAgICAgIHR5cGU6IGZpbGUudHlwZSxcbiAgICAgICAgICAgIHBpbm5lZDogc2hvdWxkQXV0b1Bpbm4sXG4gICAgICAgICAgICBwaW5uZWRPcmRlcjogc2hvdWxkQXV0b1Bpbm4gPyBwaW5uZWRPcmRlciA6IHVuZGVmaW5lZCxcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgbGV0IG5ld1RhYnM6IEVkaXRvclRhYltdO1xuICAgICAgICAgIGlmIChzaG91bGRBdXRvUGlubikge1xuICAgICAgICAgICAgLy8gRm9yIGF1dG8tcGlubmVkIHRhYnMsIGluc2VydCBpbiBjb3JyZWN0IHBpbm5lZCBwb3NpdGlvblxuICAgICAgICAgICAgY29uc3Qgb3RoZXJUYWJzID0gWy4uLm9wZW5UYWJzXTtcbiAgICAgICAgICAgIGNvbnN0IGluc2VydEluZGV4ID0gb3RoZXJUYWJzLmZpbHRlcih0ID0+IHQucGlubmVkICYmICh0LnBpbm5lZE9yZGVyIHx8IDApIDwgKHBpbm5lZE9yZGVyIHx8IDApKS5sZW5ndGg7XG4gICAgICAgICAgICBvdGhlclRhYnMuc3BsaWNlKGluc2VydEluZGV4LCAwLCBuZXdUYWIpO1xuICAgICAgICAgICAgbmV3VGFicyA9IG90aGVyVGFicztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gRm9yIG5vbi1hdXRvLXBpbm5lZCB0YWJzLCBpbnNlcnQgYWZ0ZXIgYWxsIHBpbm5lZCB0YWJzXG4gICAgICAgICAgICBjb25zdCBwaW5uZWRUYWJzID0gb3BlblRhYnMuZmlsdGVyKHRhYiA9PiB0YWIucGlubmVkKTtcbiAgICAgICAgICAgIGNvbnN0IHVucGlubmVkVGFicyA9IG9wZW5UYWJzLmZpbHRlcih0YWIgPT4gIXRhYi5waW5uZWQpO1xuICAgICAgICAgICAgbmV3VGFicyA9IFsuLi5waW5uZWRUYWJzLCAuLi51bnBpbm5lZFRhYnMsIG5ld1RhYl07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2V0KHtcbiAgICAgICAgICAgIG9wZW5UYWJzOiBuZXdUYWJzLFxuICAgICAgICAgICAgYWN0aXZlVGFiOiBuZXdUYWIuaWQsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb3BlblNwZWNpYWxUYWI6IChpZDogc3RyaW5nLCBuYW1lOiBzdHJpbmcsIHR5cGU6ICdzb2NpYWwtY29ubmVjdCcgfCAncG9zdC1jcmVhdG9yJyB8ICdjYWxlbmRhcicgfCAndXNlci1wcm9maWxlJyB8ICdzaWduLWluJykgPT4ge1xuICAgICAgICAgIGNvbnN0IHsgb3BlblRhYnMgfSA9IGdldCgpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIENoZWNrIGlmIHRhYiBpcyBhbHJlYWR5IG9wZW5cbiAgICAgICAgICBjb25zdCBleGlzdGluZ1RhYiA9IG9wZW5UYWJzLmZpbmQodGFiID0+IHRhYi5pZCA9PT0gaWQpO1xuICAgICAgICAgIGlmIChleGlzdGluZ1RhYikge1xuICAgICAgICAgICAgc2V0KHsgYWN0aXZlVGFiOiBleGlzdGluZ1RhYi5pZCB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBEZWZpbmUgd2hpY2ggdGFiIHR5cGVzIHNob3VsZCBiZSBhdXRvLXBpbm5lZFxuICAgICAgICAgIGNvbnN0IGF1dG9QaW5UeXBlcyA9IFsndXNlci1wcm9maWxlJywgJ2NhbGVuZGFyJywgJ3NvY2lhbC1jb25uZWN0JywgJ3Bvc3QtY3JlYXRvciddO1xuICAgICAgICAgIGNvbnN0IHNob3VsZEF1dG9QaW5uID0gYXV0b1BpblR5cGVzLmluY2x1ZGVzKHR5cGUpO1xuICAgICAgICAgIFxuICAgICAgICAgIGxldCBwaW5uZWRPcmRlcjogbnVtYmVyIHwgdW5kZWZpbmVkO1xuICAgICAgICAgIGlmIChzaG91bGRBdXRvUGlubikge1xuICAgICAgICAgICAgLy8gR2V0IHRoZSBoaWdoZXN0IHBpbm5lZCBvcmRlciBmb3IgYXV0by1waW5uZWQgdGFic1xuICAgICAgICAgICAgY29uc3QgcGlubmVkVGFicyA9IG9wZW5UYWJzLmZpbHRlcih0ID0+IHQucGlubmVkKTtcbiAgICAgICAgICAgIHBpbm5lZE9yZGVyID0gcGlubmVkVGFicy5sZW5ndGggPiAwID8gTWF0aC5tYXgoLi4ucGlubmVkVGFicy5tYXAodCA9PiB0LnBpbm5lZE9yZGVyIHx8IDApKSArIDEgOiAxO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIENyZWF0ZSBuZXcgc3BlY2lhbCB0YWJcbiAgICAgICAgICBjb25zdCBuZXdUYWI6IEVkaXRvclRhYiA9IHtcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIG1vZGlmaWVkOiBmYWxzZSxcbiAgICAgICAgICAgIGNvbnRlbnQ6ICcnLFxuICAgICAgICAgICAgZmlsZVBhdGg6IGAvJHt0eXBlfWAsXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgcGlubmVkOiBzaG91bGRBdXRvUGlubixcbiAgICAgICAgICAgIHBpbm5lZE9yZGVyOiBzaG91bGRBdXRvUGlubiA/IHBpbm5lZE9yZGVyIDogdW5kZWZpbmVkLFxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBsZXQgbmV3VGFiczogRWRpdG9yVGFiW107XG4gICAgICAgICAgaWYgKHNob3VsZEF1dG9QaW5uKSB7XG4gICAgICAgICAgICAvLyBGb3IgYXV0by1waW5uZWQgdGFicywgaW5zZXJ0IGluIGNvcnJlY3QgcGlubmVkIHBvc2l0aW9uXG4gICAgICAgICAgICBjb25zdCBvdGhlclRhYnMgPSBbLi4ub3BlblRhYnNdO1xuICAgICAgICAgICAgY29uc3QgaW5zZXJ0SW5kZXggPSBvdGhlclRhYnMuZmlsdGVyKHQgPT4gdC5waW5uZWQgJiYgKHQucGlubmVkT3JkZXIgfHwgMCkgPCAocGlubmVkT3JkZXIgfHwgMCkpLmxlbmd0aDtcbiAgICAgICAgICAgIG90aGVyVGFicy5zcGxpY2UoaW5zZXJ0SW5kZXgsIDAsIG5ld1RhYik7XG4gICAgICAgICAgICBuZXdUYWJzID0gb3RoZXJUYWJzO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBGb3Igbm9uLWF1dG8tcGlubmVkIHRhYnMsIGluc2VydCBhZnRlciBhbGwgcGlubmVkIHRhYnNcbiAgICAgICAgICAgIGNvbnN0IHBpbm5lZFRhYnMgPSBvcGVuVGFicy5maWx0ZXIodGFiID0+IHRhYi5waW5uZWQpO1xuICAgICAgICAgICAgY29uc3QgdW5waW5uZWRUYWJzID0gb3BlblRhYnMuZmlsdGVyKHRhYiA9PiAhdGFiLnBpbm5lZCk7XG4gICAgICAgICAgICBuZXdUYWJzID0gWy4uLnBpbm5lZFRhYnMsIC4uLnVucGlubmVkVGFicywgbmV3VGFiXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzZXQoe1xuICAgICAgICAgICAgb3BlblRhYnM6IG5ld1RhYnMsXG4gICAgICAgICAgICBhY3RpdmVUYWI6IG5ld1RhYi5pZCxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBjbG9zZVRhYjogKHRhYklkOiBzdHJpbmcpID0+IHtcbiAgICAgICAgICBjb25zdCB7IG9wZW5UYWJzLCBhY3RpdmVUYWIgfSA9IGdldCgpO1xuICAgICAgICAgIGNvbnN0IHRhYkluZGV4ID0gb3BlblRhYnMuZmluZEluZGV4KHRhYiA9PiB0YWIuaWQgPT09IHRhYklkKTtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAodGFiSW5kZXggPT09IC0xKSByZXR1cm47XG5cbiAgICAgICAgICBjb25zdCBuZXdUYWJzID0gb3BlblRhYnMuZmlsdGVyKHRhYiA9PiB0YWIuaWQgIT09IHRhYklkKTtcbiAgICAgICAgICBsZXQgbmV3QWN0aXZlVGFiID0gYWN0aXZlVGFiO1xuXG4gICAgICAgICAgLy8gSWYgY2xvc2luZyB0aGUgYWN0aXZlIHRhYiwgc3dpdGNoIHRvIGFub3RoZXIgdGFiXG4gICAgICAgICAgaWYgKGFjdGl2ZVRhYiA9PT0gdGFiSWQpIHtcbiAgICAgICAgICAgIGlmIChuZXdUYWJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgLy8gU3dpdGNoIHRvIHRoZSB0YWIgdG8gdGhlIHJpZ2h0LCBvciB0aGUgbGFzdCB0YWIgaWYgY2xvc2luZyB0aGUgbGFzdCBvbmVcbiAgICAgICAgICAgICAgY29uc3QgbmV4dEluZGV4ID0gdGFiSW5kZXggPCBuZXdUYWJzLmxlbmd0aCA/IHRhYkluZGV4IDogbmV3VGFicy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICBuZXdBY3RpdmVUYWIgPSBuZXdUYWJzW25leHRJbmRleF0uaWQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBuZXdBY3RpdmVUYWIgPSAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzZXQoe1xuICAgICAgICAgICAgb3BlblRhYnM6IG5ld1RhYnMsXG4gICAgICAgICAgICBhY3RpdmVUYWI6IG5ld0FjdGl2ZVRhYixcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBjbG9zZUFsbFRhYnM6ICgpID0+IHtcbiAgICAgICAgICBzZXQoe1xuICAgICAgICAgICAgb3BlblRhYnM6IFtdLFxuICAgICAgICAgICAgYWN0aXZlVGFiOiAnJyxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXRBY3RpdmVUYWI6ICh0YWJJZDogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgY29uc3QgeyBvcGVuVGFicyB9ID0gZ2V0KCk7XG4gICAgICAgICAgY29uc3QgdGFiRXhpc3RzID0gb3BlblRhYnMuc29tZSh0YWIgPT4gdGFiLmlkID09PSB0YWJJZCk7XG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKHRhYkV4aXN0cykge1xuICAgICAgICAgICAgc2V0KHsgYWN0aXZlVGFiOiB0YWJJZCB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVvcmRlclRhYnM6IChmcm9tVGFiSWQ6IHN0cmluZywgdG9UYWJJZDogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgY29uc3QgeyBvcGVuVGFicyB9ID0gZ2V0KCk7XG4gICAgICAgICAgY29uc3QgZnJvbUluZGV4ID0gb3BlblRhYnMuZmluZEluZGV4KHRhYiA9PiB0YWIuaWQgPT09IGZyb21UYWJJZCk7XG4gICAgICAgICAgY29uc3QgdG9JbmRleCA9IG9wZW5UYWJzLmZpbmRJbmRleCh0YWIgPT4gdGFiLmlkID09PSB0b1RhYklkKTtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAoZnJvbUluZGV4ICE9PSAtMSAmJiB0b0luZGV4ICE9PSAtMSAmJiBmcm9tSW5kZXggIT09IHRvSW5kZXgpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld1RhYnMgPSBbLi4ub3BlblRhYnNdO1xuICAgICAgICAgICAgY29uc3QgW21vdmVkVGFiXSA9IG5ld1RhYnMuc3BsaWNlKGZyb21JbmRleCwgMSk7XG4gICAgICAgICAgICBuZXdUYWJzLnNwbGljZSh0b0luZGV4LCAwLCBtb3ZlZFRhYik7XG4gICAgICAgICAgICBzZXQoeyBvcGVuVGFiczogbmV3VGFicyB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgcGluVGFiOiAodGFiSWQ6IHN0cmluZykgPT4ge1xuICAgICAgICAgIGNvbnN0IHsgb3BlblRhYnMgfSA9IGdldCgpO1xuICAgICAgICAgIGNvbnN0IHRhYkluZGV4ID0gb3BlblRhYnMuZmluZEluZGV4KHRhYiA9PiB0YWIuaWQgPT09IHRhYklkKTtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAodGFiSW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICBjb25zdCB0YWIgPSBvcGVuVGFic1t0YWJJbmRleF07XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIERvbid0IHBpbiBpZiBhbHJlYWR5IHBpbm5lZFxuICAgICAgICAgICAgaWYgKHRhYi5waW5uZWQpIHJldHVybjtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gR2V0IHRoZSBoaWdoZXN0IHBpbm5lZCBvcmRlclxuICAgICAgICAgICAgY29uc3QgcGlubmVkVGFicyA9IG9wZW5UYWJzLmZpbHRlcih0ID0+IHQucGlubmVkKTtcbiAgICAgICAgICAgIGNvbnN0IG5leHRQaW5uZWRPcmRlciA9IHBpbm5lZFRhYnMubGVuZ3RoID4gMCA/IE1hdGgubWF4KC4uLnBpbm5lZFRhYnMubWFwKHQgPT4gdC5waW5uZWRPcmRlciB8fCAwKSkgKyAxIDogMTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSB0YWIgdG8gYmUgcGlubmVkXG4gICAgICAgICAgICBjb25zdCB1cGRhdGVkVGFiID0geyAuLi50YWIsIHBpbm5lZDogdHJ1ZSwgcGlubmVkT3JkZXI6IG5leHRQaW5uZWRPcmRlciB9O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBSZW1vdmUgdGFiIGZyb20gY3VycmVudCBwb3NpdGlvbiBhbmQgYWRkIHRvIGNvcnJlY3QgcGlubmVkIHBvc2l0aW9uXG4gICAgICAgICAgICBjb25zdCBuZXdUYWJzID0gWy4uLm9wZW5UYWJzXTtcbiAgICAgICAgICAgIG5ld1RhYnMuc3BsaWNlKHRhYkluZGV4LCAxKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gRmluZCB0aGUgY29ycmVjdCBwb3NpdGlvbiBhbW9uZyBwaW5uZWQgdGFic1xuICAgICAgICAgICAgY29uc3QgaW5zZXJ0SW5kZXggPSBuZXdUYWJzLmZpbHRlcih0ID0+IHQucGlubmVkICYmICh0LnBpbm5lZE9yZGVyIHx8IDApIDwgbmV4dFBpbm5lZE9yZGVyKS5sZW5ndGg7XG4gICAgICAgICAgICBuZXdUYWJzLnNwbGljZShpbnNlcnRJbmRleCwgMCwgdXBkYXRlZFRhYik7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHNldCh7IG9wZW5UYWJzOiBuZXdUYWJzIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICB1bnBpblRhYjogKHRhYklkOiBzdHJpbmcpID0+IHtcbiAgICAgICAgICBjb25zdCB7IG9wZW5UYWJzIH0gPSBnZXQoKTtcbiAgICAgICAgICBjb25zdCB0YWJJbmRleCA9IG9wZW5UYWJzLmZpbmRJbmRleCh0YWIgPT4gdGFiLmlkID09PSB0YWJJZCk7XG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKHRhYkluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgY29uc3QgdGFiID0gb3BlblRhYnNbdGFiSW5kZXhdO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBEb24ndCB1bnBpbiBpZiBub3QgcGlubmVkXG4gICAgICAgICAgICBpZiAoIXRhYi5waW5uZWQpIHJldHVybjtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSB0YWIgdG8gYmUgdW5waW5uZWRcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRUYWIgPSB7IC4uLnRhYiwgcGlubmVkOiBmYWxzZSwgcGlubmVkT3JkZXI6IHVuZGVmaW5lZCB9O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBSZW1vdmUgdGFiIGZyb20gY3VycmVudCBwb3NpdGlvblxuICAgICAgICAgICAgY29uc3QgbmV3VGFicyA9IFsuLi5vcGVuVGFic107XG4gICAgICAgICAgICBuZXdUYWJzLnNwbGljZSh0YWJJbmRleCwgMSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIEZpbmQgdGhlIHBvc2l0aW9uIGFmdGVyIGFsbCBwaW5uZWQgdGFic1xuICAgICAgICAgICAgY29uc3QgcGlubmVkQ291bnQgPSBuZXdUYWJzLmZpbHRlcih0ID0+IHQucGlubmVkKS5sZW5ndGg7XG4gICAgICAgICAgICBuZXdUYWJzLnNwbGljZShwaW5uZWRDb3VudCwgMCwgdXBkYXRlZFRhYik7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHNldCh7IG9wZW5UYWJzOiBuZXdUYWJzIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICB1cGRhdGVUYWJDb250ZW50OiAodGFiSWQ6IHN0cmluZywgY29udGVudDogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgY29uc3QgeyBvcGVuVGFicyB9ID0gZ2V0KCk7XG4gICAgICAgICAgY29uc3QgdXBkYXRlZFRhYnMgPSBvcGVuVGFicy5tYXAoKHRhYjogRWRpdG9yVGFiKSA9PiBcbiAgICAgICAgICAgIHRhYi5pZCA9PT0gdGFiSWQgXG4gICAgICAgICAgICAgID8geyAuLi50YWIsIGNvbnRlbnQsIG1vZGlmaWVkOiB0cnVlIH1cbiAgICAgICAgICAgICAgOiB0YWJcbiAgICAgICAgICApO1xuICAgICAgICAgIFxuICAgICAgICAgIHNldCh7IG9wZW5UYWJzOiB1cGRhdGVkVGFicyB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICB1cGRhdGVGaWxlQ29udGVudDogKHRhYklkOiBzdHJpbmcsIGNvbnRlbnQ6IHN0cmluZykgPT4ge1xuICAgICAgICAgIGNvbnN0IHsgb3BlblRhYnMgfSA9IGdldCgpO1xuICAgICAgICAgIGNvbnN0IHVwZGF0ZWRUYWJzID0gb3BlblRhYnMubWFwKCh0YWI6IEVkaXRvclRhYikgPT4gXG4gICAgICAgICAgICB0YWIuaWQgPT09IHRhYklkIFxuICAgICAgICAgICAgICA/IHsgLi4udGFiLCBjb250ZW50LCBtb2RpZmllZDogdHJ1ZSB9XG4gICAgICAgICAgICAgIDogdGFiXG4gICAgICAgICAgKTtcbiAgICAgICAgICBcbiAgICAgICAgICBzZXQoeyBvcGVuVGFiczogdXBkYXRlZFRhYnMgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdXBkYXRlRmlsZUNvbnRlbnRJblN0b3JlOiAoZmlsZUlkOiBzdHJpbmcsIGNvbnRlbnQ6IHN0cmluZykgPT4ge1xuICAgICAgICAgIGNvbnN0IHsgcHJvamVjdEZpbGVzLCBmaW5hbmNpYWxGaWxlcywgb3BlblRhYnMgfSA9IGdldCgpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgZmlsZSBpbiB0aGUgYXBwcm9wcmlhdGUgc3RvcmVcbiAgICAgICAgICBjb25zdCB1cGRhdGVkUHJvamVjdEZpbGVzID0gcHJvamVjdEZpbGVzLm1hcChmaWxlID0+XG4gICAgICAgICAgICBmaWxlLmlkID09PSBmaWxlSWQgPyB7IC4uLmZpbGUsIGNvbnRlbnQsIG1vZGlmaWVkQXQ6IG5ldyBEYXRlKCkgfSA6IGZpbGVcbiAgICAgICAgICApO1xuICAgICAgICAgIFxuICAgICAgICAgIGNvbnN0IHVwZGF0ZWRGaW5hbmNpYWxGaWxlcyA9IGZpbmFuY2lhbEZpbGVzLm1hcChmaWxlID0+XG4gICAgICAgICAgICBmaWxlLmlkID09PSBmaWxlSWQgPyB7IC4uLmZpbGUsIGNvbnRlbnQsIG1vZGlmaWVkQXQ6IG5ldyBEYXRlKCkgfSA6IGZpbGVcbiAgICAgICAgICApO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIEFsc28gdXBkYXRlIHRoZSB0YWIgaWYgaXQncyBvcGVuXG4gICAgICAgICAgY29uc3QgdXBkYXRlZFRhYnMgPSBvcGVuVGFicy5tYXAoKHRhYjogRWRpdG9yVGFiKSA9PiBcbiAgICAgICAgICAgIHRhYi5pZCA9PT0gZmlsZUlkIFxuICAgICAgICAgICAgICA/IHsgLi4udGFiLCBjb250ZW50LCBtb2RpZmllZDogdHJ1ZSB9XG4gICAgICAgICAgICAgIDogdGFiXG4gICAgICAgICAgKTtcbiAgICAgICAgICBcbiAgICAgICAgICBzZXQoeyBcbiAgICAgICAgICAgIHByb2plY3RGaWxlczogdXBkYXRlZFByb2plY3RGaWxlcyxcbiAgICAgICAgICAgIGZpbmFuY2lhbEZpbGVzOiB1cGRhdGVkRmluYW5jaWFsRmlsZXMsXG4gICAgICAgICAgICBvcGVuVGFiczogdXBkYXRlZFRhYnNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICB1cGRhdGVGaWxlU3RhdHVzOiAoZmlsZUlkOiBzdHJpbmcsIHN0YXR1czogJ2RyYWZ0JyB8ICdzY2hlZHVsZWQnIHwgJ2NvbXBsZXRlJykgPT4ge1xuICAgICAgICAgIGNvbnN0IHsgcHJvamVjdEZpbGVzLCBmaW5hbmNpYWxGaWxlcyB9ID0gZ2V0KCk7XG5cbiAgICAgICAgICAvLyBVcGRhdGUgaW4gcHJvamVjdCBmaWxlc1xuICAgICAgICAgIGNvbnN0IHVwZGF0ZWRQcm9qZWN0RmlsZXMgPSBwcm9qZWN0RmlsZXMubWFwKGZpbGUgPT5cbiAgICAgICAgICAgIGZpbGUuaWQgPT09IGZpbGVJZCA/IHsgLi4uZmlsZSwgc3RhdHVzLCBtb2RpZmllZEF0OiBuZXcgRGF0ZSgpIH0gOiBmaWxlXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIC8vIFVwZGF0ZSBpbiBmaW5hbmNpYWwgZmlsZXNcbiAgICAgICAgICBjb25zdCB1cGRhdGVkRmluYW5jaWFsRmlsZXMgPSBmaW5hbmNpYWxGaWxlcy5tYXAoZmlsZSA9PlxuICAgICAgICAgICAgZmlsZS5pZCA9PT0gZmlsZUlkID8geyAuLi5maWxlLCBzdGF0dXMsIG1vZGlmaWVkQXQ6IG5ldyBEYXRlKCkgfSA6IGZpbGVcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgc2V0KHtcbiAgICAgICAgICAgIHByb2plY3RGaWxlczogdXBkYXRlZFByb2plY3RGaWxlcyxcbiAgICAgICAgICAgIGZpbmFuY2lhbEZpbGVzOiB1cGRhdGVkRmluYW5jaWFsRmlsZXNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBjcmVhdGVOZXdGaWxlOiAobmFtZTogc3RyaW5nLCB0eXBlOiBQcm9qZWN0RmlsZVsndHlwZSddLCBjYXRlZ29yeTogUHJvamVjdEZpbGVbJ2NhdGVnb3J5J10gPSAncHJvamVjdCcsIGZvbGRlcklkPzogc3RyaW5nLCBjdXN0b21Db250ZW50Pzogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgY29uc3QgeyBwcm9qZWN0RmlsZXMsIGZpbmFuY2lhbEZpbGVzIH0gPSBnZXQoKTtcbiAgICAgICAgICBcbiAgICAgICAgICBjb25zb2xlLmxvZygn8J+UpyBjcmVhdGVOZXdGaWxlIGNhbGxlZCB3aXRoOicsIHtcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgY2F0ZWdvcnksXG4gICAgICAgICAgICBmb2xkZXJJZCxcbiAgICAgICAgICAgIGhhc0N1c3RvbUNvbnRlbnQ6ICEhY3VzdG9tQ29udGVudCxcbiAgICAgICAgICAgIGN1c3RvbUNvbnRlbnRMZW5ndGg6IGN1c3RvbUNvbnRlbnQ/Lmxlbmd0aCB8fCAwLFxuICAgICAgICAgICAgY3VzdG9tQ29udGVudFByZXZpZXc6IGN1c3RvbUNvbnRlbnQ/LnN1YnN0cmluZygwLCAxMDApIHx8ICdOTyBDVVNUT00gQ09OVEVOVCdcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBHZW5lcmF0ZSB1bmlxdWUgSURcbiAgICAgICAgICBjb25zdCBpZCA9IGAke25hbWUudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9bXmEtejAtOV0vZywgJy0nKX0tJHtEYXRlLm5vdygpfWA7XG4gICAgICAgICAgY29uc3QgZmlsZU5hbWUgPSBgJHtuYW1lfSR7Z2V0RmlsZUV4dGVuc2lvbih0eXBlKX1gO1xuICAgICAgICAgIGNvbnN0IGJhc2VQYXRoID0gY2F0ZWdvcnkgPT09ICdmaW5hbmNpYWwnID8gJy9maW5hbmNpYWwtZGF0YScgOiAnL2VhYy1wcm9qZWN0cyc7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gVXNlIGN1c3RvbSBjb250ZW50IGlmIHByb3ZpZGVkLCBvdGhlcndpc2UgdXNlIGRlZmF1bHRcbiAgICAgICAgICBjb25zdCBmaWxlQ29udGVudCA9IGN1c3RvbUNvbnRlbnQgfHwgZ2V0RGVmYXVsdENvbnRlbnQodHlwZSwgbmFtZSk7XG4gICAgICAgICAgXG4gICAgICAgICAgY29uc29sZS5sb2coJ/Cfk4QgRmluYWwgZmlsZSBjb250ZW50OicsIHtcbiAgICAgICAgICAgIGZpbGVOYW1lLFxuICAgICAgICAgICAgY29udGVudExlbmd0aDogZmlsZUNvbnRlbnQubGVuZ3RoLFxuICAgICAgICAgICAgY29udGVudFByZXZpZXc6IGZpbGVDb250ZW50LnN1YnN0cmluZygwLCAxMDApLFxuICAgICAgICAgICAgaXNDdXN0b206ICEhY3VzdG9tQ29udGVudFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIENyZWF0ZSBuZXcgZmlsZVxuICAgICAgICAgIGNvbnN0IG5ld0ZpbGU6IFByb2plY3RGaWxlID0ge1xuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBuYW1lOiBmaWxlTmFtZSxcbiAgICAgICAgICAgIGljb246IGdldEZpbGVJY29uKHR5cGUpLFxuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgIGNhdGVnb3J5LFxuICAgICAgICAgICAgY29udGVudDogZmlsZUNvbnRlbnQsXG4gICAgICAgICAgICBmaWxlUGF0aDogYCR7YmFzZVBhdGh9LyR7ZmlsZU5hbWV9YCxcbiAgICAgICAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKSxcbiAgICAgICAgICAgIG1vZGlmaWVkQXQ6IG5ldyBEYXRlKCksXG4gICAgICAgICAgICBmb2xkZXJJZCwgLy8gQWRkIGZvbGRlciBhc3NpZ25tZW50XG4gICAgICAgICAgICBzdGF0dXM6IFsnZmFjZWJvb2snLCAncmVkZGl0JywgJ2luc3RhZ3JhbScsICd4J10uaW5jbHVkZXModHlwZSkgPyAnZHJhZnQnIDogdW5kZWZpbmVkLCAvLyBEZWZhdWx0IHNvY2lhbCBtZWRpYSBmaWxlcyB0byBkcmFmdFxuICAgICAgICAgIH07XG5cbiAgICAgICAgICAvLyBBZGQgdG8gYXBwcm9wcmlhdGUgZmlsZSBhcnJheSBhbmQgZW5zdXJlIGNhdGVnb3J5IGlzIHZpc2libGVcbiAgICAgICAgICBpZiAoY2F0ZWdvcnkgPT09ICdmaW5hbmNpYWwnKSB7XG4gICAgICAgICAgICBzZXQoe1xuICAgICAgICAgICAgICBmaW5hbmNpYWxGaWxlczogWy4uLmZpbmFuY2lhbEZpbGVzLCBuZXdGaWxlXSxcbiAgICAgICAgICAgICAgc2hvd0ZpbmFuY2lhbENhdGVnb3J5OiB0cnVlLCAvLyBFbnN1cmUgZmluYW5jaWFsIGNhdGVnb3J5IGlzIHZpc2libGVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZXQoe1xuICAgICAgICAgICAgICBwcm9qZWN0RmlsZXM6IFsuLi5wcm9qZWN0RmlsZXMsIG5ld0ZpbGVdLFxuICAgICAgICAgICAgICBzaG93UHJvamVjdHNDYXRlZ29yeTogdHJ1ZSwgLy8gRW5zdXJlIHByb2plY3RzIGNhdGVnb3J5IGlzIHZpc2libGVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIEF1dG9tYXRpY2FsbHkgb3BlbiB0aGUgbmV3IGZpbGVcbiAgICAgICAgICBnZXQoKS5vcGVuVGFiKG5ld0ZpbGUpO1xuXG4gICAgICAgICAgLy8gU2F2ZSB0byBDb252ZXggZGF0YWJhc2UgKGFzeW5jIC0gZG9uJ3QgYmxvY2sgVUkpXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gaW1wb3J0IHRoZSBDb252ZXggaG9va3MgaGVyZSwgd2hpY2ggaXNuJ3QgaWRlYWxcbiAgICAgICAgICAgIC8vIEJldHRlciB0byBoYW5kbGUgdGhpcyBpbiB0aGUgY29tcG9uZW50IGxldmVsXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnRmlsZSBjcmVhdGVkIGxvY2FsbHk6JywgbmV3RmlsZSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIERpc3BhdGNoIGN1c3RvbSBldmVudCB0aGF0IGNvbXBvbmVudHMgY2FuIGxpc3RlbiB0b1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgIHdpbmRvdy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgnZmlsZUNyZWF0ZWQnLCB7IFxuICAgICAgICAgICAgICAgIGRldGFpbDogeyBcbiAgICAgICAgICAgICAgICAgIGZpbGU6IG5ld0ZpbGUsXG4gICAgICAgICAgICAgICAgICBwcm9qZWN0SWQ6IGZvbGRlcklkIC8vIFVzaW5nIGZvbGRlcklkIGFzIHByb2plY3RJZCBmb3Igbm93XG4gICAgICAgICAgICAgICAgfSBcbiAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBzYXZlIGZpbGUgdG8gZGF0YWJhc2U6JywgZXJyb3IpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFJldHVybiB0aGUgZmlsZSBJRCBzbyBjYWxsZXIgY2FuIHJlZmVyZW5jZSBpdFxuICAgICAgICAgIHJldHVybiBpZDtcbiAgICAgICAgfSxcblxuICAgICAgICBjcmVhdGVGb2xkZXI6IChuYW1lOiBzdHJpbmcsIGNhdGVnb3J5OiAncHJvamVjdCcgfCAnZmluYW5jaWFsJywgY29udmV4SWQ/OiBzdHJpbmcpID0+IHtcbiAgICAgICAgICBjb25zdCB7IHByb2plY3RGb2xkZXJzLCBmaW5hbmNpYWxGb2xkZXJzIH0gPSBnZXQoKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBDaGVjayBpZiBmb2xkZXIgd2l0aCB0aGlzIG5hbWUgYWxyZWFkeSBleGlzdHMgdG8gcHJldmVudCBkdXBsaWNhdGVzXG4gICAgICAgICAgY29uc3QgZXhpc3RpbmdGb2xkZXJzID0gY2F0ZWdvcnkgPT09ICdmaW5hbmNpYWwnID8gZmluYW5jaWFsRm9sZGVycyA6IHByb2plY3RGb2xkZXJzO1xuICAgICAgICAgIGNvbnN0IGZvbGRlckV4aXN0cyA9IGV4aXN0aW5nRm9sZGVycy5zb21lKGZvbGRlciA9PiBcbiAgICAgICAgICAgIGZvbGRlci5uYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUudG9Mb3dlckNhc2UoKVxuICAgICAgICAgICk7XG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKGZvbGRlckV4aXN0cykge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYEZvbGRlciBcIiR7bmFtZX1cIiBhbHJlYWR5IGV4aXN0cyBpbiAke2NhdGVnb3J5fSBjYXRlZ29yeSwgc2tpcHBpbmcgY3JlYXRpb25gKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gR2VuZXJhdGUgdHJ1bHkgdW5pcXVlIElEIHVzaW5nIGNyeXB0byBpZiBhdmFpbGFibGUsIG90aGVyd2lzZSBmYWxsYmFjayB0byB0aW1lc3RhbXAgKyByYW5kb21cbiAgICAgICAgICBsZXQgdW5pcXVlSWQ6IHN0cmluZztcbiAgICAgICAgICBpZiAodHlwZW9mIGNyeXB0byAhPT0gJ3VuZGVmaW5lZCcgJiYgY3J5cHRvLnJhbmRvbVVVSUQpIHtcbiAgICAgICAgICAgIHVuaXF1ZUlkID0gYGZvbGRlci0ke25hbWUudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9bXmEtejAtOV0vZywgJy0nKX0tJHtjcnlwdG8ucmFuZG9tVVVJRCgpfWA7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEZhbGxiYWNrIGZvciBlbnZpcm9ubWVudHMgd2l0aG91dCBjcnlwdG8ucmFuZG9tVVVJRFxuICAgICAgICAgICAgY29uc3QgdGltZXN0YW1wID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgIGNvbnN0IHJhbmRvbSA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygyLCAxMik7XG4gICAgICAgICAgICBjb25zdCBjb3VudGVyID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMDApO1xuICAgICAgICAgICAgdW5pcXVlSWQgPSBgZm9sZGVyLSR7bmFtZS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1teYS16MC05XS9nLCAnLScpfS0ke3RpbWVzdGFtcH0tJHtyYW5kb219LSR7Y291bnRlcn1gO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBEb3VibGUtY2hlY2sgdW5pcXVlbmVzcyBhZ2FpbnN0IGFsbCBleGlzdGluZyBmb2xkZXIgSURzXG4gICAgICAgICAgY29uc3QgYWxsRm9sZGVycyA9IFsuLi5wcm9qZWN0Rm9sZGVycywgLi4uZmluYW5jaWFsRm9sZGVyc107XG4gICAgICAgICAgd2hpbGUgKGFsbEZvbGRlcnMuc29tZShmb2xkZXIgPT4gZm9sZGVyLmlkID09PSB1bmlxdWVJZCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHJhbmRvbVN1ZmZpeCA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygyLCA4KTtcbiAgICAgICAgICAgIHVuaXF1ZUlkID0gYCR7dW5pcXVlSWR9LSR7cmFuZG9tU3VmZml4fWA7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIENyZWF0ZSBuZXcgZm9sZGVyXG4gICAgICAgICAgY29uc3QgbmV3Rm9sZGVyOiBQcm9qZWN0Rm9sZGVyID0ge1xuICAgICAgICAgICAgaWQ6IHVuaXF1ZUlkLFxuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIGNhdGVnb3J5LFxuICAgICAgICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLFxuICAgICAgICAgICAgY29udmV4SWQsIC8vIFN0b3JlIHRoZSBDb252ZXggcHJvamVjdCBJRFxuICAgICAgICAgIH07XG5cbiAgICAgICAgICAvLyBBZGQgdG8gYXBwcm9wcmlhdGUgZm9sZGVyIGFycmF5IGFuZCBlbnN1cmUgY2F0ZWdvcnkgaXMgdmlzaWJsZVxuICAgICAgICAgIGlmIChjYXRlZ29yeSA9PT0gJ2ZpbmFuY2lhbCcpIHtcbiAgICAgICAgICAgIHNldCh7XG4gICAgICAgICAgICAgIGZpbmFuY2lhbEZvbGRlcnM6IFtuZXdGb2xkZXIsIC4uLmZpbmFuY2lhbEZvbGRlcnNdLFxuICAgICAgICAgICAgICBzaG93RmluYW5jaWFsQ2F0ZWdvcnk6IHRydWUsIC8vIEVuc3VyZSBmaW5hbmNpYWwgY2F0ZWdvcnkgaXMgdmlzaWJsZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNldCh7XG4gICAgICAgICAgICAgIHByb2plY3RGb2xkZXJzOiBbbmV3Rm9sZGVyLCAuLi5wcm9qZWN0Rm9sZGVyc10sXG4gICAgICAgICAgICAgIHNob3dQcm9qZWN0c0NhdGVnb3J5OiB0cnVlLCAvLyBFbnN1cmUgcHJvamVjdHMgY2F0ZWdvcnkgaXMgdmlzaWJsZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIEVtZXJnZW5jeSBjbGVhbnVwIGZ1bmN0aW9uIGZvciBkdXBsaWNhdGUgZm9sZGVyIElEc1xuICAgICAgICBjbGVhbnVwRHVwbGljYXRlRm9sZGVyczogKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHsgcHJvamVjdEZvbGRlcnMsIGZpbmFuY2lhbEZvbGRlcnMgfSA9IGdldCgpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIEZ1bmN0aW9uIHRvIHJlbW92ZSBkdXBsaWNhdGVzIGFuZCBmaXggYmFkIElEc1xuICAgICAgICAgIGNvbnN0IGNsZWFudXBGb2xkZXJzID0gKGZvbGRlcnM6IFByb2plY3RGb2xkZXJbXSkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc2VlbiA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICAgICAgICAgICAgY29uc3QgY2xlYW5lZCA9IGZvbGRlcnMuZmlsdGVyKGZvbGRlciA9PiB7XG4gICAgICAgICAgICAgIC8vIFJlbW92ZSBmb2xkZXJzIHdpdGggdGhlIHByb2JsZW1hdGljIGtleSBwYXR0ZXJuXG4gICAgICAgICAgICAgIGlmIChmb2xkZXIuaWQuaW5jbHVkZXMoJ2ZvbGRlci1pbmRleC0xNzUzMDY0NTA4OTM5JykpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhg8J+nuSBSZW1vdmluZyBwcm9ibGVtYXRpYyBmb2xkZXI6ICR7Zm9sZGVyLmlkfSAoJHtmb2xkZXIubmFtZX0pYCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAvLyBSZW1vdmUgZHVwbGljYXRlIElEc1xuICAgICAgICAgICAgICBpZiAoc2Vlbi5oYXMoZm9sZGVyLmlkKSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGDwn6e5IFJlbW92aW5nIGR1cGxpY2F0ZSBmb2xkZXI6ICR7Zm9sZGVyLmlkfSAoJHtmb2xkZXIubmFtZX0pYCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICBzZWVuLmFkZChmb2xkZXIuaWQpO1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBSZWdlbmVyYXRlIElEcyBmb3IgYW55IHJlbWFpbmluZyBmb2xkZXJzIHdpdGggb2xkIHBhdHRlcm5zXG4gICAgICAgICAgICByZXR1cm4gY2xlYW5lZC5tYXAoZm9sZGVyID0+IHtcbiAgICAgICAgICAgICAgaWYgKGZvbGRlci5pZC5zdGFydHNXaXRoKCdmb2xkZXItaW5kZXgtJykgfHwgZm9sZGVyLmlkLmxlbmd0aCA8IDIwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3SWQgPSB0eXBlb2YgY3J5cHRvICE9PSAndW5kZWZpbmVkJyAmJiBjcnlwdG8ucmFuZG9tVVVJRFxuICAgICAgICAgICAgICAgICAgPyBgZm9sZGVyLSR7Zm9sZGVyLm5hbWUudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9bXmEtejAtOV0vZywgJy0nKX0tJHtjcnlwdG8ucmFuZG9tVVVJRCgpfWBcbiAgICAgICAgICAgICAgICAgIDogYGZvbGRlci0ke2ZvbGRlci5uYW1lLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvW15hLXowLTldL2csICctJyl9LSR7RGF0ZS5ub3coKX0tJHtNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMiwgMTIpfWA7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYPCflIQgUmVnZW5lcmF0aW5nIElEIGZvciBmb2xkZXI6ICR7Zm9sZGVyLmlkfSDihpIgJHtuZXdJZH0gKCR7Zm9sZGVyLm5hbWV9KWApO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHJldHVybiB7IC4uLmZvbGRlciwgaWQ6IG5ld0lkIH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGZvbGRlcjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH07XG4gICAgICAgICAgXG4gICAgICAgICAgY29uc3QgY2xlYW5lZFByb2plY3RGb2xkZXJzID0gY2xlYW51cEZvbGRlcnMocHJvamVjdEZvbGRlcnMpO1xuICAgICAgICAgIGNvbnN0IGNsZWFuZWRGaW5hbmNpYWxGb2xkZXJzID0gY2xlYW51cEZvbGRlcnMoZmluYW5jaWFsRm9sZGVycyk7XG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKGNsZWFuZWRQcm9qZWN0Rm9sZGVycy5sZW5ndGggIT09IHByb2plY3RGb2xkZXJzLmxlbmd0aCB8fCBcbiAgICAgICAgICAgICAgY2xlYW5lZEZpbmFuY2lhbEZvbGRlcnMubGVuZ3RoICE9PSBmaW5hbmNpYWxGb2xkZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ/Cfp7kgQ2xlYW51cCBjb21wbGV0ZWQsIHVwZGF0aW5nIHN0b3JlLi4uJyk7XG4gICAgICAgICAgICBzZXQoe1xuICAgICAgICAgICAgICBwcm9qZWN0Rm9sZGVyczogY2xlYW5lZFByb2plY3RGb2xkZXJzLFxuICAgICAgICAgICAgICBmaW5hbmNpYWxGb2xkZXJzOiBjbGVhbmVkRmluYW5jaWFsRm9sZGVyc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGRlbGV0ZUZpbGU6IChmaWxlSWQ6IHN0cmluZykgPT4ge1xuICAgICAgICAgIGNvbnN0IHsgcHJvamVjdEZpbGVzLCBmaW5hbmNpYWxGaWxlcywgb3BlblRhYnMgfSA9IGdldCgpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIEZpbmQgYW5kIHJlbW92ZSBmcm9tIGFwcHJvcHJpYXRlIGFycmF5XG4gICAgICAgICAgY29uc3QgdXBkYXRlZFByb2plY3RGaWxlcyA9IHByb2plY3RGaWxlcy5maWx0ZXIoKGZpbGU6IFByb2plY3RGaWxlKSA9PiBmaWxlLmlkICE9PSBmaWxlSWQpO1xuICAgICAgICAgIGNvbnN0IHVwZGF0ZWRGaW5hbmNpYWxGaWxlcyA9IGZpbmFuY2lhbEZpbGVzLmZpbHRlcigoZmlsZTogUHJvamVjdEZpbGUpID0+IGZpbGUuaWQgIT09IGZpbGVJZCk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQ2xvc2UgdGFiIGlmIGl0J3Mgb3BlblxuICAgICAgICAgIGNvbnN0IHRhYlRvQ2xvc2UgPSBvcGVuVGFicy5maW5kKCh0YWI6IEVkaXRvclRhYikgPT4gdGFiLmlkID09PSBmaWxlSWQpO1xuICAgICAgICAgIGlmICh0YWJUb0Nsb3NlKSB7XG4gICAgICAgICAgICBnZXQoKS5jbG9zZVRhYihmaWxlSWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICBzZXQoeyBcbiAgICAgICAgICAgIHByb2plY3RGaWxlczogdXBkYXRlZFByb2plY3RGaWxlcyxcbiAgICAgICAgICAgIGZpbmFuY2lhbEZpbGVzOiB1cGRhdGVkRmluYW5jaWFsRmlsZXMgXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVuYW1lRmlsZTogKGZpbGVJZDogc3RyaW5nLCBuZXdOYW1lOiBzdHJpbmcpID0+IHtcbiAgICAgICAgICBjb25zdCB7IHByb2plY3RGaWxlcywgZmluYW5jaWFsRmlsZXMsIG9wZW5UYWJzIH0gPSBnZXQoKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBGaW5kIHRoZSBmaWxlIHRvIGdldCBpdHMgdHlwZSBhbmQgZ2VuZXJhdGUgbmV3IGZpbGVuYW1lIHdpdGggZXh0ZW5zaW9uXG4gICAgICAgICAgY29uc3QgcHJvamVjdEZpbGUgPSBwcm9qZWN0RmlsZXMuZmluZCgoZmlsZTogUHJvamVjdEZpbGUpID0+IGZpbGUuaWQgPT09IGZpbGVJZCk7XG4gICAgICAgICAgY29uc3QgZmluYW5jaWFsRmlsZSA9IGZpbmFuY2lhbEZpbGVzLmZpbmQoKGZpbGU6IFByb2plY3RGaWxlKSA9PiBmaWxlLmlkID09PSBmaWxlSWQpO1xuICAgICAgICAgIGNvbnN0IGZpbGUgPSBwcm9qZWN0RmlsZSB8fCBmaW5hbmNpYWxGaWxlO1xuICAgICAgICAgIFxuICAgICAgICAgIGlmICghZmlsZSkgcmV0dXJuO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIEdlbmVyYXRlIG5ldyBmaWxlbmFtZSB3aXRoIGFwcHJvcHJpYXRlIGV4dGVuc2lvblxuICAgICAgICAgIGNvbnN0IG5ld0ZpbGVOYW1lID0gYCR7bmV3TmFtZX0ke2dldEZpbGVFeHRlbnNpb24oZmlsZS50eXBlKX1gO1xuICAgICAgICAgIGNvbnN0IGJhc2VQYXRoID0gZmlsZS5jYXRlZ29yeSA9PT0gJ2ZpbmFuY2lhbCcgPyAnL2ZpbmFuY2lhbC1kYXRhJyA6ICcvZWFjLXByb2plY3RzJztcbiAgICAgICAgICBjb25zdCBuZXdGaWxlUGF0aCA9IGAke2Jhc2VQYXRofS8ke25ld0ZpbGVOYW1lfWA7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gVXBkYXRlIHRoZSBmaWxlIGluIGFwcHJvcHJpYXRlIGFycmF5XG4gICAgICAgICAgY29uc3QgdXBkYXRlZFByb2plY3RGaWxlcyA9IHByb2plY3RGaWxlcy5tYXAoKGY6IFByb2plY3RGaWxlKSA9PlxuICAgICAgICAgICAgZi5pZCA9PT0gZmlsZUlkXG4gICAgICAgICAgICAgID8geyAuLi5mLCBuYW1lOiBuZXdGaWxlTmFtZSwgZmlsZVBhdGg6IG5ld0ZpbGVQYXRoLCBtb2RpZmllZEF0OiBuZXcgRGF0ZSgpIH1cbiAgICAgICAgICAgICAgOiBmXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIGNvbnN0IHVwZGF0ZWRGaW5hbmNpYWxGaWxlcyA9IGZpbmFuY2lhbEZpbGVzLm1hcCgoZjogUHJvamVjdEZpbGUpID0+XG4gICAgICAgICAgICBmLmlkID09PSBmaWxlSWRcbiAgICAgICAgICAgICAgPyB7IC4uLmYsIG5hbWU6IG5ld0ZpbGVOYW1lLCBmaWxlUGF0aDogbmV3RmlsZVBhdGgsIG1vZGlmaWVkQXQ6IG5ldyBEYXRlKCkgfVxuICAgICAgICAgICAgICA6IGZcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgLy8gVXBkYXRlIG9wZW4gdGFicyBpZiB0aGUgZmlsZSBpcyBvcGVuXG4gICAgICAgICAgY29uc3QgdXBkYXRlZFRhYnMgPSBvcGVuVGFicy5tYXAoKHRhYjogRWRpdG9yVGFiKSA9PlxuICAgICAgICAgICAgdGFiLmlkID09PSBmaWxlSWRcbiAgICAgICAgICAgICAgPyB7IC4uLnRhYiwgbmFtZTogbmV3RmlsZU5hbWUsIGZpbGVQYXRoOiBuZXdGaWxlUGF0aCwgbW9kaWZpZWQ6IHRydWUgfVxuICAgICAgICAgICAgICA6IHRhYlxuICAgICAgICAgICk7XG5cbiAgICAgICAgICBzZXQoe1xuICAgICAgICAgICAgcHJvamVjdEZpbGVzOiB1cGRhdGVkUHJvamVjdEZpbGVzLFxuICAgICAgICAgICAgZmluYW5jaWFsRmlsZXM6IHVwZGF0ZWRGaW5hbmNpYWxGaWxlcyxcbiAgICAgICAgICAgIG9wZW5UYWJzOiB1cGRhdGVkVGFicyxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICByZW5hbWVGb2xkZXI6IChmb2xkZXJJZDogc3RyaW5nLCBuZXdOYW1lOiBzdHJpbmcpID0+IHtcbiAgICAgICAgICBjb25zdCB7IHByb2plY3RGb2xkZXJzLCBmaW5hbmNpYWxGb2xkZXJzIH0gPSBnZXQoKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBVcGRhdGUgdGhlIGZvbGRlciBpbiBhcHByb3ByaWF0ZSBhcnJheVxuICAgICAgICAgIGNvbnN0IHVwZGF0ZWRQcm9qZWN0Rm9sZGVycyA9IHByb2plY3RGb2xkZXJzLm1hcCgoZm9sZGVyOiBQcm9qZWN0Rm9sZGVyKSA9PlxuICAgICAgICAgICAgZm9sZGVyLmlkID09PSBmb2xkZXJJZFxuICAgICAgICAgICAgICA/IHsgLi4uZm9sZGVyLCBuYW1lOiBuZXdOYW1lIH1cbiAgICAgICAgICAgICAgOiBmb2xkZXJcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgY29uc3QgdXBkYXRlZEZpbmFuY2lhbEZvbGRlcnMgPSBmaW5hbmNpYWxGb2xkZXJzLm1hcCgoZm9sZGVyOiBQcm9qZWN0Rm9sZGVyKSA9PlxuICAgICAgICAgICAgZm9sZGVyLmlkID09PSBmb2xkZXJJZFxuICAgICAgICAgICAgICA/IHsgLi4uZm9sZGVyLCBuYW1lOiBuZXdOYW1lIH1cbiAgICAgICAgICAgICAgOiBmb2xkZXJcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgc2V0KHtcbiAgICAgICAgICAgIHByb2plY3RGb2xkZXJzOiB1cGRhdGVkUHJvamVjdEZvbGRlcnMsXG4gICAgICAgICAgICBmaW5hbmNpYWxGb2xkZXJzOiB1cGRhdGVkRmluYW5jaWFsRm9sZGVycyxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBkZWxldGVGb2xkZXI6IChmb2xkZXJJZDogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgY29uc3QgeyBwcm9qZWN0Rm9sZGVycywgZmluYW5jaWFsRm9sZGVycywgcHJvamVjdEZpbGVzLCBmaW5hbmNpYWxGaWxlcywgb3BlblRhYnMgfSA9IGdldCgpO1xuXG4gICAgICAgICAgLy8gRmluZCBhbGwgZmlsZXMgdGhhdCB3ZXJlIGluIHRoaXMgZm9sZGVyXG4gICAgICAgICAgY29uc3QgZmlsZXNUb0RlbGV0ZSA9IFtcbiAgICAgICAgICAgIC4uLnByb2plY3RGaWxlcy5maWx0ZXIoKGZpbGU6IFByb2plY3RGaWxlKSA9PiBmaWxlLmZvbGRlcklkID09PSBmb2xkZXJJZCksXG4gICAgICAgICAgICAuLi5maW5hbmNpYWxGaWxlcy5maWx0ZXIoKGZpbGU6IFByb2plY3RGaWxlKSA9PiBmaWxlLmZvbGRlcklkID09PSBmb2xkZXJJZClcbiAgICAgICAgICBdO1xuXG4gICAgICAgICAgLy8gQ2xvc2UgdGFicyBmb3IgYWxsIGZpbGVzIGluIHRoaXMgZm9sZGVyXG4gICAgICAgICAgZmlsZXNUb0RlbGV0ZS5mb3JFYWNoKChmaWxlOiBQcm9qZWN0RmlsZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdGFiVG9DbG9zZSA9IG9wZW5UYWJzLmZpbmQoKHRhYjogRWRpdG9yVGFiKSA9PiB0YWIuaWQgPT09IGZpbGUuaWQpO1xuICAgICAgICAgICAgaWYgKHRhYlRvQ2xvc2UpIHtcbiAgICAgICAgICAgICAgZ2V0KCkuY2xvc2VUYWIoZmlsZS5pZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gUmVtb3ZlIGZyb20gYXBwcm9wcmlhdGUgZm9sZGVyIGFycmF5XG4gICAgICAgICAgY29uc3QgdXBkYXRlZFByb2plY3RGb2xkZXJzID0gcHJvamVjdEZvbGRlcnMuZmlsdGVyKChmb2xkZXI6IFByb2plY3RGb2xkZXIpID0+IGZvbGRlci5pZCAhPT0gZm9sZGVySWQpO1xuICAgICAgICAgIGNvbnN0IHVwZGF0ZWRGaW5hbmNpYWxGb2xkZXJzID0gZmluYW5jaWFsRm9sZGVycy5maWx0ZXIoKGZvbGRlcjogUHJvamVjdEZvbGRlcikgPT4gZm9sZGVyLmlkICE9PSBmb2xkZXJJZCk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQWxzbyByZW1vdmUgYW55IGZpbGVzIHRoYXQgd2VyZSBpbiB0aGlzIGZvbGRlclxuICAgICAgICAgIGNvbnN0IHVwZGF0ZWRQcm9qZWN0RmlsZXMgPSBwcm9qZWN0RmlsZXMuZmlsdGVyKChmaWxlOiBQcm9qZWN0RmlsZSkgPT4gZmlsZS5mb2xkZXJJZCAhPT0gZm9sZGVySWQpO1xuICAgICAgICAgIGNvbnN0IHVwZGF0ZWRGaW5hbmNpYWxGaWxlcyA9IGZpbmFuY2lhbEZpbGVzLmZpbHRlcigoZmlsZTogUHJvamVjdEZpbGUpID0+IGZpbGUuZm9sZGVySWQgIT09IGZvbGRlcklkKTtcbiAgICAgICAgICBcbiAgICAgICAgICBzZXQoeyBcbiAgICAgICAgICAgIHByb2plY3RGb2xkZXJzOiB1cGRhdGVkUHJvamVjdEZvbGRlcnMsXG4gICAgICAgICAgICBmaW5hbmNpYWxGb2xkZXJzOiB1cGRhdGVkRmluYW5jaWFsRm9sZGVycyxcbiAgICAgICAgICAgIHByb2plY3RGaWxlczogdXBkYXRlZFByb2plY3RGaWxlcyxcbiAgICAgICAgICAgIGZpbmFuY2lhbEZpbGVzOiB1cGRhdGVkRmluYW5jaWFsRmlsZXNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBtb3ZlVG9UcmFzaDogKGl0ZW06IFByb2plY3RGaWxlIHwgUHJvamVjdEZvbGRlciwgdHlwZTogJ2ZpbGUnIHwgJ2ZvbGRlcicpID0+IHtcbiAgICAgICAgICBjb25zdCB7IHRyYXNoSXRlbXMsIHByb2plY3RGaWxlcywgZmluYW5jaWFsRmlsZXMsIHByb2plY3RGb2xkZXJzLCBmaW5hbmNpYWxGb2xkZXJzLCBvcGVuVGFicyB9ID0gZ2V0KCk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQ3JlYXRlIHRyYXNoIGl0ZW1cbiAgICAgICAgICBjb25zdCB0cmFzaEl0ZW06IFRyYXNoSXRlbSA9IHtcbiAgICAgICAgICAgIGlkOiBgdHJhc2hfJHtpdGVtLmlkfV8ke0RhdGUubm93KCl9YCxcbiAgICAgICAgICAgIG5hbWU6IGl0ZW0ubmFtZSxcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICBvcmlnaW5hbERhdGE6IGl0ZW0sXG4gICAgICAgICAgICBkZWxldGVkQXQ6IG5ldyBEYXRlKCksXG4gICAgICAgICAgICBjYXRlZ29yeTogaXRlbS5jYXRlZ29yeVxuICAgICAgICAgIH07XG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKHR5cGUgPT09ICdmaWxlJykge1xuICAgICAgICAgICAgY29uc3QgZmlsZSA9IGl0ZW0gYXMgUHJvamVjdEZpbGU7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIENsb3NlIHRhYiBpZiBpdCdzIG9wZW5cbiAgICAgICAgICAgIGNvbnN0IHRhYlRvQ2xvc2UgPSBvcGVuVGFicy5maW5kKCh0YWI6IEVkaXRvclRhYikgPT4gdGFiLmlkID09PSBmaWxlLmlkKTtcbiAgICAgICAgICAgIGlmICh0YWJUb0Nsb3NlKSB7XG4gICAgICAgICAgICAgIGdldCgpLmNsb3NlVGFiKGZpbGUuaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBSZW1vdmUgZnJvbSBhcHByb3ByaWF0ZSBmaWxlIGFycmF5XG4gICAgICAgICAgICBjb25zdCB1cGRhdGVkUHJvamVjdEZpbGVzID0gcHJvamVjdEZpbGVzLmZpbHRlcigoZjogUHJvamVjdEZpbGUpID0+IGYuaWQgIT09IGZpbGUuaWQpO1xuICAgICAgICAgICAgY29uc3QgdXBkYXRlZEZpbmFuY2lhbEZpbGVzID0gZmluYW5jaWFsRmlsZXMuZmlsdGVyKChmOiBQcm9qZWN0RmlsZSkgPT4gZi5pZCAhPT0gZmlsZS5pZCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHNldCh7XG4gICAgICAgICAgICAgIHRyYXNoSXRlbXM6IFsuLi50cmFzaEl0ZW1zLCB0cmFzaEl0ZW1dLFxuICAgICAgICAgICAgICBwcm9qZWN0RmlsZXM6IHVwZGF0ZWRQcm9qZWN0RmlsZXMsXG4gICAgICAgICAgICAgIGZpbmFuY2lhbEZpbGVzOiB1cGRhdGVkRmluYW5jaWFsRmlsZXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBmb2xkZXIgPSBpdGVtIGFzIFByb2plY3RGb2xkZXI7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIEZpbmQgYWxsIGZpbGVzIHRoYXQgd2VyZSBpbiB0aGlzIGZvbGRlciBhbmQgbW92ZSB0aGVtIHRvIHRyYXNoIHRvb1xuICAgICAgICAgICAgY29uc3QgZmlsZXNUb1RyYXNoID0gW1xuICAgICAgICAgICAgICAuLi5wcm9qZWN0RmlsZXMuZmlsdGVyKChmaWxlOiBQcm9qZWN0RmlsZSkgPT4gZmlsZS5mb2xkZXJJZCA9PT0gZm9sZGVyLmlkKSxcbiAgICAgICAgICAgICAgLi4uZmluYW5jaWFsRmlsZXMuZmlsdGVyKChmaWxlOiBQcm9qZWN0RmlsZSkgPT4gZmlsZS5mb2xkZXJJZCA9PT0gZm9sZGVyLmlkKVxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gQ2xvc2UgdGFicyBmb3IgYWxsIGZpbGVzIGluIHRoaXMgZm9sZGVyXG4gICAgICAgICAgICBmaWxlc1RvVHJhc2guZm9yRWFjaCgoZmlsZTogUHJvamVjdEZpbGUpID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgdGFiVG9DbG9zZSA9IG9wZW5UYWJzLmZpbmQoKHRhYjogRWRpdG9yVGFiKSA9PiB0YWIuaWQgPT09IGZpbGUuaWQpO1xuICAgICAgICAgICAgICBpZiAodGFiVG9DbG9zZSkge1xuICAgICAgICAgICAgICAgIGdldCgpLmNsb3NlVGFiKGZpbGUuaWQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gQ3JlYXRlIHRyYXNoIGl0ZW1zIGZvciBhbGwgZmlsZXMgaW4gdGhlIGZvbGRlclxuICAgICAgICAgICAgY29uc3QgZmlsZVRyYXNoSXRlbXMgPSBmaWxlc1RvVHJhc2gubWFwKChmaWxlOiBQcm9qZWN0RmlsZSkgPT4gKHtcbiAgICAgICAgICAgICAgaWQ6IGB0cmFzaF8ke2ZpbGUuaWR9XyR7RGF0ZS5ub3coKX1gLFxuICAgICAgICAgICAgICBuYW1lOiBmaWxlLm5hbWUsXG4gICAgICAgICAgICAgIHR5cGU6ICdmaWxlJyBhcyBjb25zdCxcbiAgICAgICAgICAgICAgb3JpZ2luYWxEYXRhOiBmaWxlLFxuICAgICAgICAgICAgICBkZWxldGVkQXQ6IG5ldyBEYXRlKCksXG4gICAgICAgICAgICAgIGNhdGVnb3J5OiBmaWxlLmNhdGVnb3J5XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIFJlbW92ZSBmb2xkZXIgYW5kIGl0cyBmaWxlcyBmcm9tIGFycmF5c1xuICAgICAgICAgICAgY29uc3QgdXBkYXRlZFByb2plY3RGb2xkZXJzID0gcHJvamVjdEZvbGRlcnMuZmlsdGVyKChmOiBQcm9qZWN0Rm9sZGVyKSA9PiBmLmlkICE9PSBmb2xkZXIuaWQpO1xuICAgICAgICAgICAgY29uc3QgdXBkYXRlZEZpbmFuY2lhbEZvbGRlcnMgPSBmaW5hbmNpYWxGb2xkZXJzLmZpbHRlcigoZjogUHJvamVjdEZvbGRlcikgPT4gZi5pZCAhPT0gZm9sZGVyLmlkKTtcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRQcm9qZWN0RmlsZXMgPSBwcm9qZWN0RmlsZXMuZmlsdGVyKChmaWxlOiBQcm9qZWN0RmlsZSkgPT4gZmlsZS5mb2xkZXJJZCAhPT0gZm9sZGVyLmlkKTtcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRGaW5hbmNpYWxGaWxlcyA9IGZpbmFuY2lhbEZpbGVzLmZpbHRlcigoZmlsZTogUHJvamVjdEZpbGUpID0+IGZpbGUuZm9sZGVySWQgIT09IGZvbGRlci5pZCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHNldCh7XG4gICAgICAgICAgICAgIHRyYXNoSXRlbXM6IFsuLi50cmFzaEl0ZW1zLCB0cmFzaEl0ZW0sIC4uLmZpbGVUcmFzaEl0ZW1zXSxcbiAgICAgICAgICAgICAgcHJvamVjdEZvbGRlcnM6IHVwZGF0ZWRQcm9qZWN0Rm9sZGVycyxcbiAgICAgICAgICAgICAgZmluYW5jaWFsRm9sZGVyczogdXBkYXRlZEZpbmFuY2lhbEZvbGRlcnMsXG4gICAgICAgICAgICAgIHByb2plY3RGaWxlczogdXBkYXRlZFByb2plY3RGaWxlcyxcbiAgICAgICAgICAgICAgZmluYW5jaWFsRmlsZXM6IHVwZGF0ZWRGaW5hbmNpYWxGaWxlc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHJlc3RvcmVGcm9tVHJhc2g6ICh0cmFzaEl0ZW1JZDogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgY29uc3QgeyB0cmFzaEl0ZW1zLCBwcm9qZWN0RmlsZXMsIGZpbmFuY2lhbEZpbGVzLCBwcm9qZWN0Rm9sZGVycywgZmluYW5jaWFsRm9sZGVycyB9ID0gZ2V0KCk7XG4gICAgICAgICAgXG4gICAgICAgICAgY29uc3QgdHJhc2hJdGVtID0gdHJhc2hJdGVtcy5maW5kKGl0ZW0gPT4gaXRlbS5pZCA9PT0gdHJhc2hJdGVtSWQpO1xuICAgICAgICAgIGlmICghdHJhc2hJdGVtKSByZXR1cm47XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gUmVtb3ZlIGZyb20gdHJhc2hcbiAgICAgICAgICBjb25zdCB1cGRhdGVkVHJhc2hJdGVtcyA9IHRyYXNoSXRlbXMuZmlsdGVyKGl0ZW0gPT4gaXRlbS5pZCAhPT0gdHJhc2hJdGVtSWQpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIFJlc3RvcmUgdG8gYXBwcm9wcmlhdGUgYXJyYXlcbiAgICAgICAgICBpZiAodHJhc2hJdGVtLnR5cGUgPT09ICdmaWxlJykge1xuICAgICAgICAgICAgY29uc3QgZmlsZSA9IHRyYXNoSXRlbS5vcmlnaW5hbERhdGEgYXMgUHJvamVjdEZpbGU7XG4gICAgICAgICAgICBpZiAoZmlsZS5jYXRlZ29yeSA9PT0gJ3Byb2plY3QnKSB7XG4gICAgICAgICAgICAgIHNldCh7XG4gICAgICAgICAgICAgICAgdHJhc2hJdGVtczogdXBkYXRlZFRyYXNoSXRlbXMsXG4gICAgICAgICAgICAgICAgcHJvamVjdEZpbGVzOiBbLi4ucHJvamVjdEZpbGVzLCB7IC4uLmZpbGUsIG1vZGlmaWVkQXQ6IG5ldyBEYXRlKCkgfV1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzZXQoe1xuICAgICAgICAgICAgICAgIHRyYXNoSXRlbXM6IHVwZGF0ZWRUcmFzaEl0ZW1zLFxuICAgICAgICAgICAgICAgIGZpbmFuY2lhbEZpbGVzOiBbLi4uZmluYW5jaWFsRmlsZXMsIHsgLi4uZmlsZSwgbW9kaWZpZWRBdDogbmV3IERhdGUoKSB9XVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgZm9sZGVyID0gdHJhc2hJdGVtLm9yaWdpbmFsRGF0YSBhcyBQcm9qZWN0Rm9sZGVyO1xuICAgICAgICAgICAgaWYgKGZvbGRlci5jYXRlZ29yeSA9PT0gJ3Byb2plY3QnKSB7XG4gICAgICAgICAgICAgIHNldCh7XG4gICAgICAgICAgICAgICAgdHJhc2hJdGVtczogdXBkYXRlZFRyYXNoSXRlbXMsXG4gICAgICAgICAgICAgICAgcHJvamVjdEZvbGRlcnM6IFsuLi5wcm9qZWN0Rm9sZGVycywgZm9sZGVyXVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHNldCh7XG4gICAgICAgICAgICAgICAgdHJhc2hJdGVtczogdXBkYXRlZFRyYXNoSXRlbXMsXG4gICAgICAgICAgICAgICAgZmluYW5jaWFsRm9sZGVyczogWy4uLmZpbmFuY2lhbEZvbGRlcnMsIGZvbGRlcl1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHBlcm1hbmVudGx5RGVsZXRlOiAodHJhc2hJdGVtSWQ6IHN0cmluZykgPT4ge1xuICAgICAgICAgIGNvbnN0IHsgdHJhc2hJdGVtcyB9ID0gZ2V0KCk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gUmVtb3ZlIGZyb20gdHJhc2ggcGVybWFuZW50bHlcbiAgICAgICAgICBjb25zdCB1cGRhdGVkVHJhc2hJdGVtcyA9IHRyYXNoSXRlbXMuZmlsdGVyKGl0ZW0gPT4gaXRlbS5pZCAhPT0gdHJhc2hJdGVtSWQpO1xuICAgICAgICAgIHNldCh7IHRyYXNoSXRlbXM6IHVwZGF0ZWRUcmFzaEl0ZW1zIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIGVtcHR5VHJhc2g6ICgpID0+IHtcbiAgICAgICAgICBzZXQoeyB0cmFzaEl0ZW1zOiBbXSB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBjbGVhclByb2plY3RDYXRlZ29yeTogKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHsgb3BlblRhYnMgfSA9IGdldCgpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIENsb3NlIGFsbCBwcm9qZWN0LXJlbGF0ZWQgdGFic1xuICAgICAgICAgIGNvbnN0IHByb2plY3RUYWJJZHMgPSBvcGVuVGFic1xuICAgICAgICAgICAgLmZpbHRlcigodGFiOiBFZGl0b3JUYWIpID0+IHtcbiAgICAgICAgICAgICAgLy8gRmluZCB0aGUgY29ycmVzcG9uZGluZyBmaWxlIHRvIGNoZWNrIGl0cyBjYXRlZ29yeVxuICAgICAgICAgICAgICBjb25zdCB7IHByb2plY3RGaWxlcyB9ID0gZ2V0KCk7XG4gICAgICAgICAgICAgIGNvbnN0IGZpbGUgPSBwcm9qZWN0RmlsZXMuZmluZCgoZjogUHJvamVjdEZpbGUpID0+IGYuaWQgPT09IHRhYi5pZCk7XG4gICAgICAgICAgICAgIHJldHVybiBmaWxlPy5jYXRlZ29yeSA9PT0gJ3Byb2plY3QnO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5tYXAoKHRhYjogRWRpdG9yVGFiKSA9PiB0YWIuaWQpO1xuICAgICAgICAgIFxuICAgICAgICAgIHByb2plY3RUYWJJZHMuZm9yRWFjaCgodGFiSWQ6IHN0cmluZykgPT4gZ2V0KCkuY2xvc2VUYWIodGFiSWQpKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBDbGVhciBhbGwgcHJvamVjdCBmaWxlcyBhbmQgZm9sZGVyc1xuICAgICAgICAgIHNldCh7XG4gICAgICAgICAgICBwcm9qZWN0RmlsZXM6IFtdLFxuICAgICAgICAgICAgcHJvamVjdEZvbGRlcnM6IFtdLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNsZWFyRmluYW5jaWFsQ2F0ZWdvcnk6ICgpID0+IHtcbiAgICAgICAgICBjb25zdCB7IG9wZW5UYWJzIH0gPSBnZXQoKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBDbG9zZSBhbGwgZmluYW5jaWFsLXJlbGF0ZWQgdGFic1xuICAgICAgICAgIGNvbnN0IGZpbmFuY2lhbFRhYklkcyA9IG9wZW5UYWJzXG4gICAgICAgICAgICAuZmlsdGVyKCh0YWI6IEVkaXRvclRhYikgPT4ge1xuICAgICAgICAgICAgICAvLyBGaW5kIHRoZSBjb3JyZXNwb25kaW5nIGZpbGUgdG8gY2hlY2sgaXRzIGNhdGVnb3J5XG4gICAgICAgICAgICAgIGNvbnN0IHsgZmluYW5jaWFsRmlsZXMgfSA9IGdldCgpO1xuICAgICAgICAgICAgICBjb25zdCBmaWxlID0gZmluYW5jaWFsRmlsZXMuZmluZCgoZjogUHJvamVjdEZpbGUpID0+IGYuaWQgPT09IHRhYi5pZCk7XG4gICAgICAgICAgICAgIHJldHVybiBmaWxlPy5jYXRlZ29yeSA9PT0gJ2ZpbmFuY2lhbCc7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLm1hcCgodGFiOiBFZGl0b3JUYWIpID0+IHRhYi5pZCk7XG4gICAgICAgICAgXG4gICAgICAgICAgZmluYW5jaWFsVGFiSWRzLmZvckVhY2goKHRhYklkOiBzdHJpbmcpID0+IGdldCgpLmNsb3NlVGFiKHRhYklkKSk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQ2xlYXIgYWxsIGZpbmFuY2lhbCBmaWxlcyBhbmQgZm9sZGVyc1xuICAgICAgICAgIHNldCh7XG4gICAgICAgICAgICBmaW5hbmNpYWxGaWxlczogW10sXG4gICAgICAgICAgICBmaW5hbmNpYWxGb2xkZXJzOiBbXSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBkZWxldGVQcm9qZWN0c0NhdGVnb3J5OiAoKSA9PiB7XG4gICAgICAgICAgZ2V0KCkuY2xlYXJQcm9qZWN0Q2F0ZWdvcnkoKTtcbiAgICAgICAgICBzZXQoeyBzaG93UHJvamVjdHNDYXRlZ29yeTogZmFsc2UgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGVsZXRlRmluYW5jaWFsQ2F0ZWdvcnk6ICgpID0+IHtcbiAgICAgICAgICBnZXQoKS5jbGVhckZpbmFuY2lhbENhdGVnb3J5KCk7XG4gICAgICAgICAgc2V0KHsgc2hvd0ZpbmFuY2lhbENhdGVnb3J5OiBmYWxzZSB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICByZW9yZGVyUHJvamVjdEZvbGRlcnM6IChmcm9tSW5kZXg6IG51bWJlciwgdG9JbmRleDogbnVtYmVyKSA9PiB7XG4gICAgICAgICAgY29uc3QgeyBwcm9qZWN0Rm9sZGVycyB9ID0gZ2V0KCk7XG4gICAgICAgICAgY29uc3QgbmV3Rm9sZGVycyA9IFsuLi5wcm9qZWN0Rm9sZGVyc107XG4gICAgICAgICAgY29uc3QgW21vdmVkRm9sZGVyXSA9IG5ld0ZvbGRlcnMuc3BsaWNlKGZyb21JbmRleCwgMSk7XG4gICAgICAgICAgbmV3Rm9sZGVycy5zcGxpY2UodG9JbmRleCwgMCwgbW92ZWRGb2xkZXIpO1xuICAgICAgICAgIFxuICAgICAgICAgIHNldCh7IHByb2plY3RGb2xkZXJzOiBuZXdGb2xkZXJzIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIHVwZGF0ZVByb2plY3RGb2xkZXJzOiAoZm9sZGVyczogUHJvamVjdEZvbGRlcltdKSA9PiB7XG4gICAgICAgICAgc2V0KHsgcHJvamVjdEZvbGRlcnM6IGZvbGRlcnMgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVvcmRlckZpbGVzSW5Gb2xkZXI6IChmb2xkZXJJZDogc3RyaW5nLCBmcm9tSW5kZXg6IG51bWJlciwgdG9JbmRleDogbnVtYmVyLCBjYXRlZ29yeTogJ3Byb2plY3QnIHwgJ2ZpbmFuY2lhbCcpID0+IHtcbiAgICAgICAgICBjb25zdCB7IHByb2plY3RGaWxlcywgZmluYW5jaWFsRmlsZXMgfSA9IGdldCgpO1xuICAgICAgICAgIFxuICAgICAgICAgIGlmIChjYXRlZ29yeSA9PT0gJ3Byb2plY3QnKSB7XG4gICAgICAgICAgICAvLyBGaWx0ZXIgZmlsZXMgaW4gdGhlIHNwZWNpZmljIGZvbGRlclxuICAgICAgICAgICAgY29uc3QgZm9sZGVyRmlsZXMgPSBwcm9qZWN0RmlsZXMuZmlsdGVyKGZpbGUgPT4gZmlsZS5mb2xkZXJJZCA9PT0gZm9sZGVySWQpO1xuICAgICAgICAgICAgY29uc3Qgb3RoZXJGaWxlcyA9IHByb2plY3RGaWxlcy5maWx0ZXIoZmlsZSA9PiBmaWxlLmZvbGRlcklkICE9PSBmb2xkZXJJZCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIFJlb3JkZXIgZmlsZXMgd2l0aGluIHRoZSBmb2xkZXJcbiAgICAgICAgICAgIGNvbnN0IHJlb3JkZXJlZEZvbGRlckZpbGVzID0gWy4uLmZvbGRlckZpbGVzXTtcbiAgICAgICAgICAgIGNvbnN0IFttb3ZlZEZpbGVdID0gcmVvcmRlcmVkRm9sZGVyRmlsZXMuc3BsaWNlKGZyb21JbmRleCwgMSk7XG4gICAgICAgICAgICByZW9yZGVyZWRGb2xkZXJGaWxlcy5zcGxpY2UodG9JbmRleCwgMCwgbW92ZWRGaWxlKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gQ29tYmluZSB3aXRoIG90aGVyIGZpbGVzXG4gICAgICAgICAgICBjb25zdCBuZXdQcm9qZWN0RmlsZXMgPSBbLi4ub3RoZXJGaWxlcywgLi4ucmVvcmRlcmVkRm9sZGVyRmlsZXNdO1xuICAgICAgICAgICAgc2V0KHsgcHJvamVjdEZpbGVzOiBuZXdQcm9qZWN0RmlsZXMgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFNpbWlsYXIgbG9naWMgZm9yIGZpbmFuY2lhbCBmaWxlc1xuICAgICAgICAgICAgY29uc3QgZm9sZGVyRmlsZXMgPSBmaW5hbmNpYWxGaWxlcy5maWx0ZXIoZmlsZSA9PiBmaWxlLmZvbGRlcklkID09PSBmb2xkZXJJZCk7XG4gICAgICAgICAgICBjb25zdCBvdGhlckZpbGVzID0gZmluYW5jaWFsRmlsZXMuZmlsdGVyKGZpbGUgPT4gZmlsZS5mb2xkZXJJZCAhPT0gZm9sZGVySWQpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBjb25zdCByZW9yZGVyZWRGb2xkZXJGaWxlcyA9IFsuLi5mb2xkZXJGaWxlc107XG4gICAgICAgICAgICBjb25zdCBbbW92ZWRGaWxlXSA9IHJlb3JkZXJlZEZvbGRlckZpbGVzLnNwbGljZShmcm9tSW5kZXgsIDEpO1xuICAgICAgICAgICAgcmVvcmRlcmVkRm9sZGVyRmlsZXMuc3BsaWNlKHRvSW5kZXgsIDAsIG1vdmVkRmlsZSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNvbnN0IG5ld0ZpbmFuY2lhbEZpbGVzID0gWy4uLm90aGVyRmlsZXMsIC4uLnJlb3JkZXJlZEZvbGRlckZpbGVzXTtcbiAgICAgICAgICAgIHNldCh7IGZpbmFuY2lhbEZpbGVzOiBuZXdGaW5hbmNpYWxGaWxlcyB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2F2ZUZpbGU6ICh0YWJJZDogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgY29uc3QgeyBvcGVuVGFicywgcHJvamVjdEZpbGVzLCBmaW5hbmNpYWxGaWxlcyB9ID0gZ2V0KCk7XG4gICAgICAgICAgY29uc3QgdGFiID0gb3BlblRhYnMuZmluZCgodDogRWRpdG9yVGFiKSA9PiB0LmlkID09PSB0YWJJZCk7XG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKCF0YWIpIHJldHVybjtcblxuICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgZmlsZSBjb250ZW50IGluIGFwcHJvcHJpYXRlIGFycmF5XG4gICAgICAgICAgY29uc3QgdXBkYXRlZFByb2plY3RGaWxlcyA9IHByb2plY3RGaWxlcy5tYXAoKGZpbGU6IFByb2plY3RGaWxlKSA9PlxuICAgICAgICAgICAgZmlsZS5pZCA9PT0gdGFiSWRcbiAgICAgICAgICAgICAgPyB7IC4uLmZpbGUsIGNvbnRlbnQ6IHRhYi5jb250ZW50LCBtb2RpZmllZEF0OiBuZXcgRGF0ZSgpIH1cbiAgICAgICAgICAgICAgOiBmaWxlXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIGNvbnN0IHVwZGF0ZWRGaW5hbmNpYWxGaWxlcyA9IGZpbmFuY2lhbEZpbGVzLm1hcCgoZmlsZTogUHJvamVjdEZpbGUpID0+XG4gICAgICAgICAgICBmaWxlLmlkID09PSB0YWJJZFxuICAgICAgICAgICAgICA/IHsgLi4uZmlsZSwgY29udGVudDogdGFiLmNvbnRlbnQsIG1vZGlmaWVkQXQ6IG5ldyBEYXRlKCkgfVxuICAgICAgICAgICAgICA6IGZpbGVcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgY29uc3QgdXBkYXRlZFRhYnMgPSBvcGVuVGFicy5tYXAoKHQ6IEVkaXRvclRhYikgPT5cbiAgICAgICAgICAgIHQuaWQgPT09IHRhYklkXG4gICAgICAgICAgICAgID8geyAuLi50LCBtb2RpZmllZDogZmFsc2UgfVxuICAgICAgICAgICAgICA6IHRcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgc2V0KHtcbiAgICAgICAgICAgIHByb2plY3RGaWxlczogdXBkYXRlZFByb2plY3RGaWxlcyxcbiAgICAgICAgICAgIGZpbmFuY2lhbEZpbGVzOiB1cGRhdGVkRmluYW5jaWFsRmlsZXMsXG4gICAgICAgICAgICBvcGVuVGFiczogdXBkYXRlZFRhYnMsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0RXJyb3I6IChlcnJvcjogc3RyaW5nIHwgbnVsbCkgPT4ge1xuICAgICAgICAgIHNldCh7IGVycm9yIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIEZpeCBmaWxlcyB0aGF0IGRvbid0IGhhdmUgY29udGVudFxuICAgICAgICByZXBhaXJGaWxlc1dpdGhvdXRDb250ZW50OiAoKSA9PiB7XG4gICAgICAgICAgY29uc3QgeyBwcm9qZWN0RmlsZXMsIGZpbmFuY2lhbEZpbGVzIH0gPSBnZXQoKTtcbiAgICAgICAgICBcbiAgICAgICAgICBjb25zdCByZXBhaXJlZFByb2plY3RGaWxlcyA9IHByb2plY3RGaWxlcy5tYXAoZmlsZSA9PiB7XG4gICAgICAgICAgICBpZiAoIWZpbGUuY29udGVudCB8fCBmaWxlLmNvbnRlbnQudHJpbSgpID09PSAnJykge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIC4uLmZpbGUsXG4gICAgICAgICAgICAgICAgY29udGVudDogZ2V0RGVmYXVsdENvbnRlbnQoZmlsZS50eXBlLCBmaWxlLm5hbWUpLFxuICAgICAgICAgICAgICAgIG1vZGlmaWVkQXQ6IG5ldyBEYXRlKClcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmaWxlO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIFxuICAgICAgICAgIGNvbnN0IHJlcGFpcmVkRmluYW5jaWFsRmlsZXMgPSBmaW5hbmNpYWxGaWxlcy5tYXAoZmlsZSA9PiB7XG4gICAgICAgICAgICBpZiAoIWZpbGUuY29udGVudCB8fCBmaWxlLmNvbnRlbnQudHJpbSgpID09PSAnJykge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIC4uLmZpbGUsXG4gICAgICAgICAgICAgICAgY29udGVudDogZ2V0RGVmYXVsdENvbnRlbnQoZmlsZS50eXBlLCBmaWxlLm5hbWUpLFxuICAgICAgICAgICAgICAgIG1vZGlmaWVkQXQ6IG5ldyBEYXRlKClcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmaWxlO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIFxuICAgICAgICAgIHNldCh7XG4gICAgICAgICAgICBwcm9qZWN0RmlsZXM6IHJlcGFpcmVkUHJvamVjdEZpbGVzLFxuICAgICAgICAgICAgZmluYW5jaWFsRmlsZXM6IHJlcGFpcmVkRmluYW5jaWFsRmlsZXNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICByZXNldDogKCkgPT4ge1xuICAgICAgICAgIHNldCh7XG4gICAgICAgICAgICBvcGVuVGFiczogW10sXG4gICAgICAgICAgICBhY3RpdmVUYWI6ICcnLFxuICAgICAgICAgICAgcHJvamVjdEZpbGVzOiBpbml0aWFsUHJvamVjdEZpbGVzLFxuICAgICAgICAgICAgZmluYW5jaWFsRmlsZXM6IGluaXRpYWxGaW5hbmNpYWxGaWxlcyxcbiAgICAgICAgICAgIHByb2plY3RGb2xkZXJzOiBbXSxcbiAgICAgICAgICAgIGZpbmFuY2lhbEZvbGRlcnM6IFtdLFxuICAgICAgICAgICAgc2hvd1Byb2plY3RzQ2F0ZWdvcnk6IHRydWUsXG4gICAgICAgICAgICBzaG93RmluYW5jaWFsQ2F0ZWdvcnk6IGZhbHNlLCAvLyBEb24ndCBhdXRvLXNob3cgZmluYW5jaWFsIGNhdGVnb3J5IG9uIHJlc2V0XG4gICAgICAgICAgICBpc0xvYWRpbmc6IGZhbHNlLFxuICAgICAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gQ2xlYXIgdXNlciBkYXRhIHdoZW4gc2lnbmluZyBvdXQgKGJ1dCBrZWVwIFVJIHN0YXRlIGxpa2UgdGhlbWUsIGV0Yy4pXG4gICAgICAgIGNsZWFyVXNlckRhdGE6ICgpID0+IHtcbiAgICAgICAgICBzZXQoe1xuICAgICAgICAgICAgb3BlblRhYnM6IFtdLFxuICAgICAgICAgICAgYWN0aXZlVGFiOiAnJyxcbiAgICAgICAgICAgIHByb2plY3RGaWxlczogW10sXG4gICAgICAgICAgICBmaW5hbmNpYWxGaWxlczogW10sXG4gICAgICAgICAgICBwcm9qZWN0Rm9sZGVyczogW10sXG4gICAgICAgICAgICBmaW5hbmNpYWxGb2xkZXJzOiBbXSxcbiAgICAgICAgICAgIHRyYXNoSXRlbXM6IFtdLFxuICAgICAgICAgICAgc2hvd1Byb2plY3RzQ2F0ZWdvcnk6IHRydWUsXG4gICAgICAgICAgICBzaG93RmluYW5jaWFsQ2F0ZWdvcnk6IGZhbHNlLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgfSksXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdlZGl0b3Itc3RvcmFnZScsXG4gICAgICAgIHZlcnNpb246IDEsIC8vIEFkZCB2ZXJzaW9uIGZvciB0YWIgcGlubmluZyBwZXJzaXN0ZW5jZVxuICAgICAgICAvLyBPbmx5IHBlcnNpc3Qgc3BlY2lmaWMgZmllbGRzXG4gICAgICAgIHBhcnRpYWxpemU6IChzdGF0ZSkgPT4gKHsgXG4gICAgICAgICAgb3BlblRhYnM6IHN0YXRlLm9wZW5UYWJzLm1hcCh0YWIgPT4gKHtcbiAgICAgICAgICAgIGlkOiB0YWIuaWQsXG4gICAgICAgICAgICBuYW1lOiB0YWIubmFtZSxcbiAgICAgICAgICAgIG1vZGlmaWVkOiB0YWIubW9kaWZpZWQsXG4gICAgICAgICAgICBjb250ZW50OiB0YWIuY29udGVudCxcbiAgICAgICAgICAgIGZpbGVQYXRoOiB0YWIuZmlsZVBhdGgsXG4gICAgICAgICAgICB0eXBlOiB0YWIudHlwZSxcbiAgICAgICAgICAgIHBpbm5lZDogdGFiLnBpbm5lZCwgLy8gUGVyc2lzdCBwaW5uZWQgc3RhdGVcbiAgICAgICAgICAgIHBpbm5lZE9yZGVyOiB0YWIucGlubmVkT3JkZXIsIC8vIFBlcnNpc3QgcGlubmVkIG9yZGVyXG4gICAgICAgICAgICAvLyBXZSdsbCBuZWVkIHRvIHJlc3RvcmUgdGhlIGljb24gYmFzZWQgb24gZmlsZSB0eXBlXG4gICAgICAgICAgfSkpLFxuICAgICAgICAgIGFjdGl2ZVRhYjogc3RhdGUuYWN0aXZlVGFiLFxuICAgICAgICAgIHByb2plY3RGaWxlczogc3RhdGUucHJvamVjdEZpbGVzLFxuICAgICAgICAgIGZpbmFuY2lhbEZpbGVzOiBzdGF0ZS5maW5hbmNpYWxGaWxlcyxcbiAgICAgICAgICBwcm9qZWN0Rm9sZGVyczogc3RhdGUucHJvamVjdEZvbGRlcnMsXG4gICAgICAgICAgZmluYW5jaWFsRm9sZGVyczogc3RhdGUuZmluYW5jaWFsRm9sZGVycyxcbiAgICAgICAgICBzaG93UHJvamVjdHNDYXRlZ29yeTogc3RhdGUuc2hvd1Byb2plY3RzQ2F0ZWdvcnksXG4gICAgICAgICAgc2hvd0ZpbmFuY2lhbENhdGVnb3J5OiBzdGF0ZS5zaG93RmluYW5jaWFsQ2F0ZWdvcnksXG4gICAgICAgIH0pLFxuICAgICAgICAvLyBDdXN0b20gc3RvcmFnZSB0byBoYW5kbGUgaWNvbiByZXN0b3JhdGlvblxuICAgICAgICBzdG9yYWdlOiB7XG4gICAgICAgICAgZ2V0SXRlbTogKG5hbWUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHN0ciA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKG5hbWUpO1xuICAgICAgICAgICAgaWYgKCFzdHIpIHJldHVybiBudWxsO1xuICAgICAgICAgICAgY29uc3QgeyBzdGF0ZSB9ID0gSlNPTi5wYXJzZShzdHIpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBSZXN0b3JlIGljb25zIGJhc2VkIG9uIGZpbGUgdHlwZVxuICAgICAgICAgICAgY29uc3QgcmVzdG9yZWRUYWJzID0gKHN0YXRlLm9wZW5UYWJzIHx8IFtdKS5tYXAoKHRhYjogT21pdDxFZGl0b3JUYWIsICdpY29uJz4pID0+IHtcbiAgICAgICAgICAgICAgbGV0IGljb24gPSBGaWxlQ29kZTtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIHN3aXRjaCAodGFiLnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICd0eXBlc2NyaXB0JzpcbiAgICAgICAgICAgICAgICBjYXNlICdqYXZhc2NyaXB0JzpcbiAgICAgICAgICAgICAgICAgIGljb24gPSBGaWxlQ29kZTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2pzb24nOlxuICAgICAgICAgICAgICAgICAgaWNvbiA9IEJyYWNlcztcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2V4Y2VsJzpcbiAgICAgICAgICAgICAgICAgIGljb24gPSBGaWxlU3ByZWFkc2hlZXQ7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdtYXJrZG93bic6XG4gICAgICAgICAgICAgICAgICBpY29uID0gRmlsZVRleHQ7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdwZGYnOlxuICAgICAgICAgICAgICAgICAgaWNvbiA9IEZpbGVUeXBlO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgLi4udGFiLFxuICAgICAgICAgICAgICAgIGljb24sXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgc3RhdGU6IHtcbiAgICAgICAgICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgICAgICAgICBvcGVuVGFiczogcmVzdG9yZWRUYWJzLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNldEl0ZW06IChuYW1lLCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIGxvY2FsU3RvcmFnZSkge1xuICAgICAgICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShuYW1lLCBKU09OLnN0cmluZ2lmeSh2YWx1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVtb3ZlSXRlbTogKG5hbWUpID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiBsb2NhbFN0b3JhZ2UpIHtcbiAgICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0obmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgb25SZWh5ZHJhdGVTdG9yYWdlOiAoKSA9PiAoc3RhdGUpID0+IHtcbiAgICAgICAgICBpZiAoc3RhdGUpIHtcbiAgICAgICAgICAgIC8vIFJlcGFpciBhbnkgZmlsZXMgdGhhdCBkb24ndCBoYXZlIGNvbnRlbnRcbiAgICAgICAgICAgIGlmIChzdGF0ZS5wcm9qZWN0RmlsZXMpIHtcbiAgICAgICAgICAgICAgc3RhdGUucHJvamVjdEZpbGVzID0gc3RhdGUucHJvamVjdEZpbGVzLm1hcChmaWxlID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIWZpbGUuY29udGVudCB8fCBmaWxlLmNvbnRlbnQudHJpbSgpID09PSAnJykge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgLi4uZmlsZSxcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDogZ2V0RGVmYXVsdENvbnRlbnQoZmlsZS50eXBlLCBmaWxlLm5hbWUpLFxuICAgICAgICAgICAgICAgICAgICBtb2RpZmllZEF0OiBuZXcgRGF0ZSgpXG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmlsZTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmIChzdGF0ZS5maW5hbmNpYWxGaWxlcykge1xuICAgICAgICAgICAgICBzdGF0ZS5maW5hbmNpYWxGaWxlcyA9IHN0YXRlLmZpbmFuY2lhbEZpbGVzLm1hcChmaWxlID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIWZpbGUuY29udGVudCB8fCBmaWxlLmNvbnRlbnQudHJpbSgpID09PSAnJykge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgLi4uZmlsZSxcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDogZ2V0RGVmYXVsdENvbnRlbnQoZmlsZS50eXBlLCBmaWxlLm5hbWUpLFxuICAgICAgICAgICAgICAgICAgICBtb2RpZmllZEF0OiBuZXcgRGF0ZSgpXG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmlsZTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIEVuc3VyZSBzeXN0ZW0gZm9sZGVycyBleGlzdCBpZiB0aGVyZSBhcmUgcHJvamVjdCBmb2xkZXJzXG4gICAgICAgICAgICBpZiAoc3RhdGUucHJvamVjdEZvbGRlcnMgJiYgc3RhdGUucHJvamVjdEZvbGRlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAvLyBPbmx5IGVuc3VyZSB0aGUgc3lzdGVtIGZvbGRlcnMgaWYgdGhlcmUgYXJlIGFscmVhZHkgc29tZSBwcm9qZWN0IGZvbGRlcnNcbiAgICAgICAgICAgICAgLy8gVGhpcyBwcmV2ZW50cyBhdXRvLWNyZWF0aW9uIHdoZW4gc3RvcmFnZSBpcyBpbnRlbnRpb25hbGx5IGNsZWFyZWRcbiAgICAgICAgICAgICAgY29uc3QgaGFzSW5zdHJ1Y3Rpb25zRm9sZGVyID0gc3RhdGUucHJvamVjdEZvbGRlcnMuc29tZShmb2xkZXIgPT5cbiAgICAgICAgICAgICAgICBmb2xkZXIuaWQgPT09ICdpbnN0cnVjdGlvbnMtZm9sZGVyJyAmJiBmb2xkZXIucGlubmVkXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICBjb25zdCBoYXNDb250ZW50Q3JlYXRpb25Gb2xkZXIgPSBzdGF0ZS5wcm9qZWN0Rm9sZGVycy5zb21lKGZvbGRlciA9PlxuICAgICAgICAgICAgICAgIGZvbGRlci5pZCA9PT0gJ2NvbnRlbnQtY3JlYXRpb24tZm9sZGVyJyAmJiBmb2xkZXIucGlubmVkXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICBjb25zdCBzeXN0ZW1Gb2xkZXJzOiBQcm9qZWN0Rm9sZGVyW10gPSBbXTtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIGlmICghaGFzSW5zdHJ1Y3Rpb25zRm9sZGVyKSB7XG4gICAgICAgICAgICAgICAgc3lzdGVtRm9sZGVycy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgIGlkOiAnaW5zdHJ1Y3Rpb25zLWZvbGRlcicsXG4gICAgICAgICAgICAgICAgICBuYW1lOiAnSW5zdHJ1Y3Rpb25zJyxcbiAgICAgICAgICAgICAgICAgIGNhdGVnb3J5OiAncHJvamVjdCcgYXMgY29uc3QsXG4gICAgICAgICAgICAgICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCksXG4gICAgICAgICAgICAgICAgICBwaW5uZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIGlmICghaGFzQ29udGVudENyZWF0aW9uRm9sZGVyKSB7XG4gICAgICAgICAgICAgICAgc3lzdGVtRm9sZGVycy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgIGlkOiAnY29udGVudC1jcmVhdGlvbi1mb2xkZXInLFxuICAgICAgICAgICAgICAgICAgbmFtZTogJ0NvbnRlbnQgQ3JlYXRpb24nLFxuICAgICAgICAgICAgICAgICAgY2F0ZWdvcnk6ICdwcm9qZWN0JyBhcyBjb25zdCxcbiAgICAgICAgICAgICAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKSxcbiAgICAgICAgICAgICAgICAgIHBpbm5lZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgaWYgKHN5c3RlbUZvbGRlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHN0YXRlLnByb2plY3RGb2xkZXJzID0gW1xuICAgICAgICAgICAgICAgICAgLi4uc3lzdGVtRm9sZGVycyxcbiAgICAgICAgICAgICAgICAgIC4uLnN0YXRlLnByb2plY3RGb2xkZXJzXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBJZiBwcm9qZWN0Rm9sZGVycyBpcyBlbXB0eSwgcmVzcGVjdCB0aGF0IChkb24ndCBhdXRvLWNyZWF0ZSBhbnl0aGluZylcbiAgICAgICAgfSxcbiAgICAgIH1cbiAgICApLFxuICAgIHsgbmFtZTogJ2VkaXRvci1zdG9yZScgfVxuICApXG4pOyAiXSwibmFtZXMiOlsiQXRTaWduIiwiQnJhY2VzIiwiQ2FsZW5kYXIiLCJDYW1lcmEiLCJGaWxlQ29kZSIsIkZpbGVTcHJlYWRzaGVldCIsIkZpbGVUZXh0IiwiRmlsZVR5cGUiLCJNZXNzYWdlU3F1YXJlIiwiY3JlYXRlIiwiZGV2dG9vbHMiLCJwZXJzaXN0IiwiZ2V0RmlsZUljb24iLCJ0eXBlIiwiZ2V0RmlsZUV4dGVuc2lvbiIsImdldERlZmF1bHRDb250ZW50IiwibmFtZSIsInJlcGxhY2UiLCJEYXRlIiwidG9JU09TdHJpbmciLCJ0b0xvY2FsZURhdGVTdHJpbmciLCJpbml0aWFsUHJvamVjdEZpbGVzIiwiaW5pdGlhbEZpbmFuY2lhbEZpbGVzIiwiaW5pdGlhbFByb2plY3RGb2xkZXJzIiwidXNlRWRpdG9yU3RvcmUiLCJzZXQiLCJnZXQiLCJvcGVuVGFicyIsImFjdGl2ZVRhYiIsInByb2plY3RGaWxlcyIsImZpbmFuY2lhbEZpbGVzIiwicHJvamVjdEZvbGRlcnMiLCJmaW5hbmNpYWxGb2xkZXJzIiwidHJhc2hJdGVtcyIsInNob3dQcm9qZWN0c0NhdGVnb3J5Iiwic2hvd0ZpbmFuY2lhbENhdGVnb3J5IiwiaXNMb2FkaW5nIiwiZXJyb3IiLCJvcGVuVGFiIiwiZmlsZSIsImNvbnNvbGUiLCJsb2ciLCJpZCIsImNvbnRlbnRMZW5ndGgiLCJjb250ZW50IiwibGVuZ3RoIiwiY29udGVudFByZXZpZXciLCJzdWJzdHJpbmciLCJleGlzdGluZ1RhYiIsImZpbmQiLCJ0YWIiLCJ1cGRhdGVkVGFicyIsIm1hcCIsImF1dG9QaW5GaWxlVHlwZXMiLCJzaG91bGRBdXRvUGlubiIsImluY2x1ZGVzIiwicGlubmVkT3JkZXIiLCJwaW5uZWRUYWJzIiwiZmlsdGVyIiwidCIsInBpbm5lZCIsIk1hdGgiLCJtYXgiLCJ0YWJDb250ZW50IiwiZmlsZUlkIiwiZmlsZU5hbWUiLCJoYXNDdXN0b21Db250ZW50IiwibmV3VGFiIiwibW9kaWZpZWQiLCJmaWxlUGF0aCIsInVuZGVmaW5lZCIsIm5ld1RhYnMiLCJvdGhlclRhYnMiLCJpbnNlcnRJbmRleCIsInNwbGljZSIsInVucGlubmVkVGFicyIsIm9wZW5TcGVjaWFsVGFiIiwiYXV0b1BpblR5cGVzIiwiY2xvc2VUYWIiLCJ0YWJJZCIsInRhYkluZGV4IiwiZmluZEluZGV4IiwibmV3QWN0aXZlVGFiIiwibmV4dEluZGV4IiwiY2xvc2VBbGxUYWJzIiwic2V0QWN0aXZlVGFiIiwidGFiRXhpc3RzIiwic29tZSIsInJlb3JkZXJUYWJzIiwiZnJvbVRhYklkIiwidG9UYWJJZCIsImZyb21JbmRleCIsInRvSW5kZXgiLCJtb3ZlZFRhYiIsInBpblRhYiIsIm5leHRQaW5uZWRPcmRlciIsInVwZGF0ZWRUYWIiLCJ1bnBpblRhYiIsInBpbm5lZENvdW50IiwidXBkYXRlVGFiQ29udGVudCIsInVwZGF0ZUZpbGVDb250ZW50IiwidXBkYXRlRmlsZUNvbnRlbnRJblN0b3JlIiwidXBkYXRlZFByb2plY3RGaWxlcyIsIm1vZGlmaWVkQXQiLCJ1cGRhdGVkRmluYW5jaWFsRmlsZXMiLCJ1cGRhdGVGaWxlU3RhdHVzIiwic3RhdHVzIiwiY3JlYXRlTmV3RmlsZSIsImNhdGVnb3J5IiwiZm9sZGVySWQiLCJjdXN0b21Db250ZW50IiwiY3VzdG9tQ29udGVudExlbmd0aCIsImN1c3RvbUNvbnRlbnRQcmV2aWV3IiwidG9Mb3dlckNhc2UiLCJub3ciLCJiYXNlUGF0aCIsImZpbGVDb250ZW50IiwiaXNDdXN0b20iLCJuZXdGaWxlIiwiaWNvbiIsImNyZWF0ZWRBdCIsIndpbmRvdyIsImRpc3BhdGNoRXZlbnQiLCJDdXN0b21FdmVudCIsImRldGFpbCIsInByb2plY3RJZCIsImNyZWF0ZUZvbGRlciIsImNvbnZleElkIiwiZXhpc3RpbmdGb2xkZXJzIiwiZm9sZGVyRXhpc3RzIiwiZm9sZGVyIiwidW5pcXVlSWQiLCJjcnlwdG8iLCJyYW5kb21VVUlEIiwidGltZXN0YW1wIiwicmFuZG9tIiwidG9TdHJpbmciLCJjb3VudGVyIiwiZmxvb3IiLCJhbGxGb2xkZXJzIiwicmFuZG9tU3VmZml4IiwibmV3Rm9sZGVyIiwiY2xlYW51cER1cGxpY2F0ZUZvbGRlcnMiLCJjbGVhbnVwRm9sZGVycyIsImZvbGRlcnMiLCJzZWVuIiwiU2V0IiwiY2xlYW5lZCIsImhhcyIsImFkZCIsInN0YXJ0c1dpdGgiLCJuZXdJZCIsImNsZWFuZWRQcm9qZWN0Rm9sZGVycyIsImNsZWFuZWRGaW5hbmNpYWxGb2xkZXJzIiwiZGVsZXRlRmlsZSIsInRhYlRvQ2xvc2UiLCJyZW5hbWVGaWxlIiwibmV3TmFtZSIsInByb2plY3RGaWxlIiwiZmluYW5jaWFsRmlsZSIsIm5ld0ZpbGVOYW1lIiwibmV3RmlsZVBhdGgiLCJmIiwicmVuYW1lRm9sZGVyIiwidXBkYXRlZFByb2plY3RGb2xkZXJzIiwidXBkYXRlZEZpbmFuY2lhbEZvbGRlcnMiLCJkZWxldGVGb2xkZXIiLCJmaWxlc1RvRGVsZXRlIiwiZm9yRWFjaCIsIm1vdmVUb1RyYXNoIiwiaXRlbSIsInRyYXNoSXRlbSIsIm9yaWdpbmFsRGF0YSIsImRlbGV0ZWRBdCIsImZpbGVzVG9UcmFzaCIsImZpbGVUcmFzaEl0ZW1zIiwicmVzdG9yZUZyb21UcmFzaCIsInRyYXNoSXRlbUlkIiwidXBkYXRlZFRyYXNoSXRlbXMiLCJwZXJtYW5lbnRseURlbGV0ZSIsImVtcHR5VHJhc2giLCJjbGVhclByb2plY3RDYXRlZ29yeSIsInByb2plY3RUYWJJZHMiLCJjbGVhckZpbmFuY2lhbENhdGVnb3J5IiwiZmluYW5jaWFsVGFiSWRzIiwiZGVsZXRlUHJvamVjdHNDYXRlZ29yeSIsImRlbGV0ZUZpbmFuY2lhbENhdGVnb3J5IiwicmVvcmRlclByb2plY3RGb2xkZXJzIiwibmV3Rm9sZGVycyIsIm1vdmVkRm9sZGVyIiwidXBkYXRlUHJvamVjdEZvbGRlcnMiLCJyZW9yZGVyRmlsZXNJbkZvbGRlciIsImZvbGRlckZpbGVzIiwib3RoZXJGaWxlcyIsInJlb3JkZXJlZEZvbGRlckZpbGVzIiwibW92ZWRGaWxlIiwibmV3UHJvamVjdEZpbGVzIiwibmV3RmluYW5jaWFsRmlsZXMiLCJzYXZlRmlsZSIsInNldEVycm9yIiwicmVwYWlyRmlsZXNXaXRob3V0Q29udGVudCIsInJlcGFpcmVkUHJvamVjdEZpbGVzIiwidHJpbSIsInJlcGFpcmVkRmluYW5jaWFsRmlsZXMiLCJyZXNldCIsImNsZWFyVXNlckRhdGEiLCJ2ZXJzaW9uIiwicGFydGlhbGl6ZSIsInN0YXRlIiwic3RvcmFnZSIsImdldEl0ZW0iLCJzdHIiLCJsb2NhbFN0b3JhZ2UiLCJKU09OIiwicGFyc2UiLCJyZXN0b3JlZFRhYnMiLCJzZXRJdGVtIiwidmFsdWUiLCJzdHJpbmdpZnkiLCJyZW1vdmVJdGVtIiwib25SZWh5ZHJhdGVTdG9yYWdlIiwiaGFzSW5zdHJ1Y3Rpb25zRm9sZGVyIiwiaGFzQ29udGVudENyZWF0aW9uRm9sZGVyIiwic3lzdGVtRm9sZGVycyIsInB1c2giXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./store/editor/index.ts\n"));

/***/ })

});