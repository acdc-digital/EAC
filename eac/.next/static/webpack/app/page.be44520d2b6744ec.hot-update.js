"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./store/agents/fileCreatorAgent.ts":
/*!******************************************!*\
  !*** ./store/agents/fileCreatorAgent.ts ***!
  \******************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FileCreatorAgent: () => (/* binding */ FileCreatorAgent),\n/* harmony export */   fileCreatorAgent: () => (/* binding */ fileCreatorAgent)\n/* harmony export */ });\n/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ \"(app-pages-browser)/./store/agents/base.ts\");\n// File Creator Agent\n// Creates files in existing projects using natural language input with project selection\n\nclass FileCreatorAgent extends _base__WEBPACK_IMPORTED_MODULE_0__.BaseAgent {\n    async execute(tool, input, convexMutations) {\n        console.log('üöÄ FileCreatorAgent executing with input:', input);\n        try {\n            return await this.processFileCreationRequest(input, convexMutations);\n        } catch (error) {\n            console.error('‚ùå FileCreatorAgent error:', error);\n            return \"‚ùå Failed to process request: \".concat(error instanceof Error ? error.message : 'Unknown error');\n        }\n    }\n    /**\n   * Process natural language requests to create files\n   */ async processFileCreationRequest(input, convexMutations) {\n        const normalizedInput = input.toLowerCase().trim();\n        console.log('üîç Processing file creation input:', normalizedInput);\n        // Check for pending file creation (project selection response)\n        if (FileCreatorAgent.pendingFileCreation) {\n            const pendingAge = Date.now() - FileCreatorAgent.pendingFileCreation.timestamp;\n            // If pending request is less than 5 minutes old, try to handle as project selection\n            if (pendingAge < 5 * 60 * 1000) {\n                const projectSelectionResult = await this.handleProjectSelection(input, convexMutations);\n                if (projectSelectionResult) {\n                    return projectSelectionResult;\n                }\n            } else {\n                // Clear expired pending request\n                FileCreatorAgent.pendingFileCreation = null;\n            }\n        }\n        // Check if this is a help request\n        if (this.isHelpRequest(normalizedInput)) {\n            return this.getHelpMessage();\n        }\n        // Check if this is a file type listing request\n        if (this.isFileTypeListRequest(normalizedInput)) {\n            return this.getFileTypeOptions();\n        }\n        // Extract file creation details\n        const fileDetails = this.extractFileDetails(input);\n        // If we couldn't extract enough details, provide guidance\n        if (!fileDetails.fileName && !fileDetails.fileType) {\n            return this.getCreationGuidance();\n        }\n        // If no project specified, ask for project selection\n        if (!fileDetails.projectName) {\n            return await this.getProjectSelectionPrompt(fileDetails, convexMutations);\n        }\n        // Create the file\n        return await this.createFile(fileDetails, convexMutations);\n    }\n    /**\n   * Handle project selection response\n   */ async handleProjectSelection(input, convexMutations) {\n        if (!FileCreatorAgent.pendingFileCreation) {\n            return null;\n        }\n        const { fileDetails, projects } = FileCreatorAgent.pendingFileCreation;\n        const normalizedInput = input.toLowerCase().trim();\n        let selectedProject = null;\n        // Try to match by number (e.g., \"1\", \"2\", \"3\")\n        const numberMatch = input.match(/^\\d+$/);\n        if (numberMatch) {\n            const index = parseInt(numberMatch[0]) - 1;\n            if (index >= 0 && index < projects.length) {\n                selectedProject = projects[index];\n            }\n        }\n        // Try to match by project name patterns\n        if (!selectedProject) {\n            const projectSelectionPatterns = [\n                /(?:add.*to|put.*in|create.*for|use|select)\\s+[\\\"\\']?([^\\\"\\']+?)[\\\"\\']?$/i,\n                /^[\\\"\\']?([^\\\"\\']+?)[\\\"\\']?$/i // Just the project name\n            ];\n            for (const pattern of projectSelectionPatterns){\n                const match = input.match(pattern);\n                if (match && match[1]) {\n                    const projectName = match[1].trim().toLowerCase();\n                    selectedProject = projects.find((p)=>p.name.toLowerCase().includes(projectName) || projectName.includes(p.name.toLowerCase()));\n                    if (selectedProject) break;\n                }\n            }\n        }\n        if (!selectedProject) {\n            var _projects_, _projects_1;\n            // Re-show project selection with error message\n            let result = \"‚ùå **Project not found.** Please select from the available projects:\\n\\n\";\n            result += \"**\\uD83D\\uDCC1 Available Projects:**\\n\";\n            projects.forEach((project, index)=>{\n                result += \"\".concat(index + 1, \". **\").concat(project.name, \"**\\n\");\n            });\n            result += \"\\n**\\uD83D\\uDCA1 You can:**\\n\";\n            result += '‚Ä¢ Type a number (e.g., \"1\", \"2\")\\n';\n            result += '‚Ä¢ Type the project name (e.g., \"'.concat((_projects_ = projects[0]) === null || _projects_ === void 0 ? void 0 : _projects_.name, '\")\\n');\n            result += '‚Ä¢ Or say \"add it to '.concat((_projects_1 = projects[0]) === null || _projects_1 === void 0 ? void 0 : _projects_1.name, '\"\\n');\n            return result;\n        }\n        // Clear pending state\n        FileCreatorAgent.pendingFileCreation = null;\n        // Create the file with selected project\n        const updatedFileDetails = {\n            ...fileDetails,\n            projectName: selectedProject.name\n        };\n        return await this.createFile(updatedFileDetails, convexMutations);\n    }\n    /**\n   * Check if input is requesting help\n   */ isHelpRequest(input) {\n        const helpPatterns = [\n            /help/,\n            /how.*work/,\n            /what.*do/,\n            /commands/,\n            /options/\n        ];\n        return helpPatterns.some((pattern)=>pattern.test(input));\n    }\n    /**\n   * Check if input is requesting file type list\n   */ isFileTypeListRequest(input) {\n        const listPatterns = [\n            /file.*types?/,\n            /what.*files?/,\n            /list.*files?/,\n            /show.*options/,\n            /available.*types?/\n        ];\n        return listPatterns.some((pattern)=>pattern.test(input));\n    }\n    /**\n   * Extract file creation details from natural language input\n   */ extractFileDetails(input) {\n        const normalizedInput = input.toLowerCase();\n        let fileName = '';\n        let fileType = '';\n        let extension = '.md'; // default\n        let projectName = '';\n        // Extract file name patterns\n        const fileNamePatterns = [\n            /(?:create|make|add|generate)\\s+(?:a\\s+)?(?:new\\s+)?(?:file\\s+)?(?:called\\s+)?[\\\"\\']?([^\\\"\\']+?)[\\\"\\']?(?:\\s+(?:for|in|to|as)|\\s*$)/i,\n            /(?:file\\s+)?[\\\"\\']([^\\\"\\']+)[\\\"\\']?/i\n        ];\n        for (const pattern of fileNamePatterns){\n            const match = input.match(pattern);\n            if (match && match[1]) {\n                fileName = match[1].trim();\n                break;\n            }\n        }\n        // Clean up fileName by removing file type words\n        fileName = fileName.replace(/\\b(file|document|spreadsheet|presentation|notes?|plan|brief|checklist)\\b/gi, '').trim();\n        // Detect file type from input\n        for (const option of this.fileTypeOptions){\n            const typePatterns = [\n                new RegExp(\"\\\\b\".concat(option.type, \"\\\\b\"), 'i'),\n                new RegExp(\"\\\\b\".concat(option.description.split(' ')[0], \"\\\\b\"), 'i')\n            ];\n            if (option.type === 'spreadsheet' && /\\b(excel|xlsx?|budget|financial|calculation)\\b/i.test(normalizedInput)) {\n                fileType = option.type;\n                extension = option.extension;\n                break;\n            } else if (option.type === 'document' && /\\b(document|docx?|report|proposal|word)\\b/i.test(normalizedInput)) {\n                fileType = option.type;\n                extension = option.extension;\n                break;\n            } else if (option.type === 'presentation' && /\\b(presentation|pptx?|slides?|powerpoint)\\b/i.test(normalizedInput)) {\n                fileType = option.type;\n                extension = option.extension;\n                break;\n            } else if (option.type === 'plan' && /\\b(plan|planning|strategy|roadmap)\\b/i.test(normalizedInput)) {\n                fileType = option.type;\n                extension = option.extension;\n                break;\n            } else if (option.type === 'notes' && /\\b(notes?|meeting|minutes)\\b/i.test(normalizedInput)) {\n                fileType = option.type;\n                extension = option.extension;\n                break;\n            } else if (option.type === 'brief' && /\\b(brief|overview|summary)\\b/i.test(normalizedInput)) {\n                fileType = option.type;\n                extension = option.extension;\n                break;\n            } else if (option.type === 'checklist' && /\\b(checklist|tasks?|todo|list)\\b/i.test(normalizedInput)) {\n                fileType = option.type;\n                extension = option.extension;\n                break;\n            } else if (typePatterns.some((pattern)=>pattern.test(normalizedInput))) {\n                fileType = option.type;\n                extension = option.extension;\n                break;\n            }\n        }\n        // If no specific type detected, default to markdown\n        if (!fileType) {\n            fileType = 'markdown';\n            extension = '.md';\n        }\n        // Extract project name (only very explicit project mentions)\n        const projectPatterns = [\n            /(?:for|in|to)\\s+(?:the\\s+)?project\\s+[\\\"\\']?([^\\\"\\']+?)[\\\"\\']?(?:\\s*$)/i,\n            /project\\s+[\\\"\\']([^\\\"\\']+)[\\\"\\']?/i,\n            /in\\s+[\\\"\\']([^\\\"\\']+)[\\\"\\']?\\s+project/i\n        ];\n        for (const pattern of projectPatterns){\n            const match = input.match(pattern);\n            if (match && match[1]) {\n                projectName = match[1].trim();\n                break;\n            }\n        }\n        // Generate default file name if not provided\n        if (!fileName) {\n            const typeWords = fileType.split(/(?=[A-Z])/).join(' ').toLowerCase();\n            fileName = \"new-\".concat(typeWords);\n        }\n        // Ensure fileName has extension\n        if (!fileName.includes('.')) {\n            fileName += extension;\n        }\n        return {\n            fileName,\n            fileType,\n            projectName,\n            extension,\n            content: ''\n        };\n    }\n    /**\n   * Create the file in the specified project\n   */ async createFile(fileDetails, convexMutations) {\n        try {\n            if (!convexMutations.createFile) {\n                return '‚ùå File creation is not available. Please check system configuration.';\n            }\n            if (!convexMutations.getProjects) {\n                return '‚ùå Project lookup is not available. Please check system configuration.';\n            }\n            // Look up the actual project ID by name\n            const projects = await convexMutations.getProjects();\n            const targetProject = projects.find((p)=>{\n                var _fileDetails_projectName;\n                return p.name.toLowerCase() === ((_fileDetails_projectName = fileDetails.projectName) === null || _fileDetails_projectName === void 0 ? void 0 : _fileDetails_projectName.toLowerCase());\n            });\n            if (!targetProject) {\n                return '‚ùå **Project Not Found**\\n\\nCould not find a project named \"'.concat(fileDetails.projectName, '\". Please check the project name and try again.\\n\\n**Available projects:**\\n').concat(projects.map((p)=>\"‚Ä¢ \".concat(p.name)).join('\\n'));\n            }\n            // Find the file type option for content template\n            const fileTypeOption = this.fileTypeOptions.find((option)=>option.type === fileDetails.fileType);\n            // Generate content from template\n            const content = this.generateFileContent(fileDetails, fileTypeOption);\n            // Create the file with the actual project ID\n            const newFile = await convexMutations.createFile({\n                name: fileDetails.fileName,\n                content: content,\n                type: this.mapToConvexFileType(fileDetails.fileType),\n                projectId: targetProject._id // Use the actual project ID\n            });\n            let result = \"‚úÖ **File Created Successfully!**\\n\\n\";\n            result += \"\\uD83D\\uDCC4 **File Name:** \".concat(fileDetails.fileName, \"\\n\");\n            result += \"\\uD83D\\uDCC1 **Project:** \".concat(fileDetails.projectName, \"\\n\");\n            result += \"\\uD83C\\uDFF7Ô∏è **Type:** \".concat(fileDetails.fileType, \"\\n\");\n            if (fileTypeOption) {\n                result += \"\\uD83D\\uDCDD **Description:** \".concat(fileTypeOption.description, \"\\n\");\n            }\n            result += \"\\uD83D\\uDCC5 **Created:** \".concat(new Date().toLocaleDateString(), \"\\n\\n\");\n            result += \"\\uD83D\\uDCA1 You can now find and edit this file in the sidebar!\\n\\n\";\n            result += \"\\uD83D\\uDD27 **Next Steps:**\\n\";\n            result += \"‚Ä¢ Open the file to customize the content\\n\";\n            result += \"‚Ä¢ Share with team members if needed\\n\";\n            result += \"‚Ä¢ Add to your workflow or calendar\";\n            return result;\n        } catch (error) {\n            console.error('‚ùå File creation failed:', error);\n            return \"‚ùå **File creation failed:** \".concat(error instanceof Error ? error.message : 'Unknown error');\n        }\n    }\n    /**\n   * Generate file content based on template\n   */ generateFileContent(fileDetails, fileTypeOption) {\n        if (!fileTypeOption) {\n            // Default content if no template found\n            return \"# \".concat(fileDetails.fileName.replace(/\\.[^/.]+$/, \"\"), \"\\n\\nCreated: \").concat(new Date().toLocaleDateString(), \"\\n\\nContent goes here...\");\n        }\n        // Replace template variables\n        let content = fileTypeOption.contentTemplate;\n        content = content.replace(/\\{fileName\\}/g, fileDetails.fileName.replace(/\\.[^/.]+$/, \"\"));\n        content = content.replace(/\\{date\\}/g, new Date().toLocaleDateString());\n        return content;\n    }\n    /**\n   * Map file type to Convex expected type\n   */ mapToConvexFileType(fileType) {\n        const typeMap = {\n            markdown: 'note',\n            notes: 'note',\n            plan: 'note',\n            brief: 'note',\n            checklist: 'note',\n            spreadsheet: 'document',\n            document: 'document',\n            presentation: 'document'\n        };\n        return typeMap[fileType] || 'note';\n    }\n    /**\n   * Get creation guidance when details are insufficient\n   */ getCreationGuidance() {\n        return '\\uD83E\\uDD16 **File Creator - Let\\'s Get Started!**\\n\\nI need a bit more information to create your file. Here are some examples:\\n\\n**\\uD83D\\uDCC4 Quick Examples:**\\n‚Ä¢ \"Create a budget spreadsheet for Marketing Project\"\\n‚Ä¢ \"Make meeting notes for Development Team\"\\n‚Ä¢ \"Add a project plan for Q1 Campaign\"\\n‚Ä¢ \"Generate a presentation for Client Review\"\\n\\n**\\uD83C\\uDFAF What I need:**\\n1. **File type** (spreadsheet, notes, plan, etc.)\\n2. **File name** (optional - I\\'ll suggest one)\\n3. **Project name** (which project to add it to)\\n\\n**\\uD83D\\uDCA1 Pro tip:** Just describe what you want! \\nExample: \"I need a checklist for the product launch project\"\\n\\nType your request or say \"**file types**\" to see all available options! \\uD83D\\uDE80';\n    }\n    /**\n   * Get project selection prompt when project is not specified\n   */ async getProjectSelectionPrompt(fileDetails, convexMutations) {\n        try {\n            if (!convexMutations.getProjects) {\n                return \"\\uD83E\\uDD16 **Almost There! Which Project?**\\n\\nI'm ready to create your **\".concat(fileDetails.fileType, \"** file: `\").concat(fileDetails.fileName, '`\\n\\n**\\uD83D\\uDCC1 Please specify which project to add it to.**\\n\\n**\\uD83D\\uDCA1 Tip:** You can say something like:\\n\"Create ').concat(fileDetails.fileName, ' for [Your Project Name]\"');\n            }\n            // Fetch available projects\n            const projects = await convexMutations.getProjects();\n            let result = \"\\uD83E\\uDD16 **Almost There! Which Project?**\\n\\n\";\n            result += \"I'm ready to create your **\".concat(fileDetails.fileType, \"** file: `\").concat(fileDetails.fileName, \"`\\n\\n\");\n            result += \"**\\uD83D\\uDCC1 Available Projects:**\\n\";\n            if (projects && projects.length > 0) {\n                var _projects_, _projects_1;\n                // Store pending file creation state\n                FileCreatorAgent.pendingFileCreation = {\n                    fileDetails,\n                    projects,\n                    timestamp: Date.now()\n                };\n                projects.forEach((project, index)=>{\n                    result += \"\".concat(index + 1, \". **\").concat(project.name, \"**\\n\");\n                });\n                result += \"\\n**\\uD83C\\uDFAF Select a project:**\\n\";\n                result += \"‚Ä¢ Type a number: **1**, **2**, **3**, etc.\\n\";\n                result += \"‚Ä¢ Type the name: **\".concat((_projects_ = projects[0]) === null || _projects_ === void 0 ? void 0 : _projects_.name, \"**\\n\");\n                result += '‚Ä¢ Or say: \"**add it to '.concat((_projects_1 = projects[0]) === null || _projects_1 === void 0 ? void 0 : _projects_1.name, '**\"\\n\\n');\n                result += \"\\uD83D\\uDCA1 **Next message:** Just type your selection!\";\n            } else {\n                result += \"No projects found. Please create a project first or specify a project name.\\n\";\n            }\n            return result;\n        } catch (error) {\n            console.error('Error fetching projects for selection:', error);\n            return \"\\uD83E\\uDD16 **Almost There! Which Project?**\\n\\nI'm ready to create your **\".concat(fileDetails.fileType, \"** file: `\").concat(fileDetails.fileName, '`\\n\\n**\\uD83D\\uDCC1 Please specify which project to add it to.**\\n\\n**\\uD83D\\uDCA1 Tip:** You can say something like:\\n\"Create ').concat(fileDetails.fileName, ' for [Your Project Name]\"');\n        }\n    }\n    /**\n   * Get available file type options\n   */ getFileTypeOptions() {\n        let result = \"\\uD83E\\uDD16 **Available File Types**\\n\\n\";\n        this.fileTypeOptions.forEach((option, index)=>{\n            result += \"**\".concat(index + 1, \". \").concat(option.type.charAt(0).toUpperCase() + option.type.slice(1), \"** (\").concat(option.extension, \")\\n\");\n            result += \"   \".concat(option.description, \"\\n\\n\");\n        });\n        result += \"**\\uD83D\\uDCA1 Usage Examples:**\\n\";\n        result += '‚Ä¢ \"Create a spreadsheet for Budget Planning\"\\n';\n        result += '‚Ä¢ \"Make meeting notes for Development Team\"\\n';\n        result += '‚Ä¢ \"Add a project plan for Marketing Campaign\"\\n';\n        result += '‚Ä¢ \"Generate a brief for Client Presentation\"\\n\\n';\n        result += \"**\\uD83D\\uDE80 Just describe what you need and I'll handle the rest!**\";\n        return result;\n    }\n    /**\n   * Get help message for the agent\n   */ getHelpMessage() {\n        return '\\uD83E\\uDD16 **File Creator Agent Help**\\n\\nI specialize in creating files for your existing projects! Here\\'s how I work:\\n\\n**\\uD83D\\uDCC4 Supported File Types:**\\n‚Ä¢ **Spreadsheets** - Budgets, calculations, data tracking\\n‚Ä¢ **Documents** - Reports, proposals, formal documents  \\n‚Ä¢ **Presentations** - Meeting slides, proposals\\n‚Ä¢ **Notes** - Meeting notes, general notes\\n‚Ä¢ **Plans** - Project plans, strategies, roadmaps\\n‚Ä¢ **Briefs** - Creative briefs, project overviews\\n‚Ä¢ **Checklists** - Task lists, process checklists\\n‚Ä¢ **Markdown** - General documentation\\n\\n**\\uD83C\\uDFAF How to Use:**\\n1. **Tell me what file you want:** \"Create a budget spreadsheet\"\\n2. **Specify the project:** \"for Marketing Campaign\"\\n3. **I\\'ll create it with a template!**\\n\\n**‚ú® Quick Examples:**\\n‚Ä¢ \"Create a meeting notes file for Development Team\"\\n‚Ä¢ \"Make a project plan for Q1 Launch\"\\n‚Ä¢ \"Add a budget spreadsheet to Marketing Project\" \\n‚Ä¢ \"Generate a presentation for Client Review\"\\n\\n**\\uD83D\\uDD27 Special Commands:**\\n‚Ä¢ Type \"**file types**\" to see all available options\\n‚Ä¢ Type \"**help**\" to see this message again\\n\\n**\\uD83D\\uDCA1 Pro Tips:**\\n‚Ä¢ I\\'ll suggest file names if you don\\'t provide one\\n‚Ä¢ All files come with helpful templates\\n‚Ä¢ Just describe what you need in plain English!\\n\\nReady to create some files? \\uD83D\\uDE80';\n    }\n    constructor(...args){\n        super(...args), this.id = 'file-creator', this.name = 'File Creator', this.description = 'Creates files in existing projects using natural language with project selection', this.icon = 'FilePlus', // Predefined file type options\n        this.fileTypeOptions = [\n            {\n                type: 'markdown',\n                extension: '.md',\n                description: 'Markdown document for notes, documentation, or content',\n                contentTemplate: '# {fileName}\\n\\nCreated: {date}\\n\\n## Overview\\n\\n## Details\\n\\n## Notes\\n'\n            },\n            {\n                type: 'spreadsheet',\n                extension: '.xlsx',\n                description: 'Excel spreadsheet for budgets, calculations, or data',\n                contentTemplate: '# {fileName}\\n\\n| Item | Value | Notes |\\n|------|-------|-------|\\n| Example | 0 | Add your data here |\\n| Total | 0 | |\\n'\n            },\n            {\n                type: 'document',\n                extension: '.docx',\n                description: 'Word document for reports, proposals, or formal documents',\n                contentTemplate: '# {fileName}\\n\\nDocument created: {date}\\n\\n## Executive Summary\\n\\n## Main Content\\n\\n## Conclusion\\n'\n            },\n            {\n                type: 'presentation',\n                extension: '.pptx',\n                description: 'PowerPoint presentation for meetings or proposals',\n                contentTemplate: '# {fileName}\\n\\nPresentation Outline\\n\\n## Slide 1: Title\\n- {fileName}\\n- Date: {date}\\n\\n## Slide 2: Agenda\\n- Topic 1\\n- Topic 2\\n- Topic 3\\n\\n## Slide 3: Content\\n- Main points\\n'\n            },\n            {\n                type: 'plan',\n                extension: '.md',\n                description: 'Project plan or strategy document',\n                contentTemplate: '# {fileName}\\n\\nProject Plan - {date}\\n\\n## Objectives\\n- Primary goal\\n- Secondary goals\\n\\n## Timeline\\n- Phase 1:\\n- Phase 2:\\n- Phase 3:\\n\\n## Resources\\n- Team members\\n- Budget\\n- Tools\\n\\n## Milestones\\n- Milestone 1:\\n- Milestone 2:\\n- Final delivery:\\n'\n            },\n            {\n                type: 'notes',\n                extension: '.md',\n                description: 'Meeting notes or general notes',\n                contentTemplate: '# {fileName}\\n\\nMeeting Notes - {date}\\n\\n## Attendees\\n- \\n\\n## Agenda\\n- \\n\\n## Discussion Points\\n- \\n\\n## Action Items\\n- [ ] \\n\\n## Next Steps\\n- \\n'\n            },\n            {\n                type: 'brief',\n                extension: '.md',\n                description: 'Creative brief or project brief',\n                contentTemplate: '# {fileName}\\n\\nProject Brief - {date}\\n\\n## Project Overview\\n\\n## Objectives\\n- Primary:\\n- Secondary:\\n\\n## Target Audience\\n\\n## Key Messages\\n\\n## Deliverables\\n- \\n\\n## Timeline\\n- Start:\\n- End:\\n\\n## Budget\\n$\\n\\n## Success Metrics\\n- \\n'\n            },\n            {\n                type: 'checklist',\n                extension: '.md',\n                description: 'Task checklist or process checklist',\n                contentTemplate: '# {fileName}\\n\\nChecklist - {date}\\n\\n## Pre-Launch\\n- [ ] Task 1\\n- [ ] Task 2\\n- [ ] Task 3\\n\\n## Launch\\n- [ ] Task 1\\n- [ ] Task 2\\n\\n## Post-Launch\\n- [ ] Task 1\\n- [ ] Task 2\\n\\n## Notes\\n- \\n'\n            }\n        ], this.tools = [\n            {\n                id: 'natural-language-file-creator',\n                name: 'Natural Language File Creator',\n                command: 'create-file',\n                description: 'Create files in existing projects using natural language with guided project selection',\n                parameters: []\n            }\n        ];\n    }\n}\n// State to track pending file creation\nFileCreatorAgent.pendingFileCreation = null;\n// Export an instance of the agent for use in the registry\nconst fileCreatorAgent = new FileCreatorAgent();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3N0b3JlL2FnZW50cy9maWxlQ3JlYXRvckFnZW50LnRzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLHFCQUFxQjtBQUNyQix5RkFBeUY7QUFFM0M7QUFrQnZDLE1BQU1DLHlCQUF5QkQsNENBQVNBO0lBMkU3QyxNQUFNRSxRQUNKQyxJQUFlLEVBQ2ZDLEtBQWEsRUFDYkMsZUFBZ0MsRUFDZjtRQUNqQkMsUUFBUUMsR0FBRyxDQUFDLDZDQUE2Q0g7UUFFekQsSUFBSTtZQUNGLE9BQU8sTUFBTSxJQUFJLENBQUNJLDBCQUEwQixDQUFDSixPQUFPQztRQUN0RCxFQUFFLE9BQU9JLE9BQU87WUFDZEgsUUFBUUcsS0FBSyxDQUFDLDZCQUE2QkE7WUFDM0MsT0FBTyxnQ0FBeUYsT0FBekRBLGlCQUFpQkMsUUFBUUQsTUFBTUUsT0FBTyxHQUFHO1FBQ2xGO0lBQ0Y7SUFFQTs7R0FFQyxHQUNELE1BQWNILDJCQUNaSixLQUFhLEVBQ2JDLGVBQWdDLEVBQ2Y7UUFDakIsTUFBTU8sa0JBQWtCUixNQUFNUyxXQUFXLEdBQUdDLElBQUk7UUFDaERSLFFBQVFDLEdBQUcsQ0FBQyxzQ0FBc0NLO1FBRWxELCtEQUErRDtRQUMvRCxJQUFJWCxpQkFBaUJjLG1CQUFtQixFQUFFO1lBQ3hDLE1BQU1DLGFBQWFDLEtBQUtDLEdBQUcsS0FBS2pCLGlCQUFpQmMsbUJBQW1CLENBQUNJLFNBQVM7WUFFOUUsb0ZBQW9GO1lBQ3BGLElBQUlILGFBQWEsSUFBSSxLQUFLLE1BQU07Z0JBQzlCLE1BQU1JLHlCQUF5QixNQUFNLElBQUksQ0FBQ0Msc0JBQXNCLENBQUNqQixPQUFPQztnQkFDeEUsSUFBSWUsd0JBQXdCO29CQUMxQixPQUFPQTtnQkFDVDtZQUNGLE9BQU87Z0JBQ0wsZ0NBQWdDO2dCQUNoQ25CLGlCQUFpQmMsbUJBQW1CLEdBQUc7WUFDekM7UUFDRjtRQUVBLGtDQUFrQztRQUNsQyxJQUFJLElBQUksQ0FBQ08sYUFBYSxDQUFDVixrQkFBa0I7WUFD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Z0JBQ2JnQixpQkFBaUI7WUFDbkI7WUFDQTtnQkFDRWpCLE1BQU07Z0JBQ05QLFdBQVc7Z0JBQ1hRLGFBQWE7Z0JBQ2JnQixpQkFBaUI7WUFDbkI7WUFDQTtnQkFDRWpCLE1BQU07Z0JBQ05QLFdBQVc7Z0JBQ1hRLGFBQWE7Z0JBQ2JnQixpQkFBaUI7WUFDbkI7U0FDRCxPQUVEZSxRQUFxQjtZQUNuQjtnQkFDRUYsSUFBSTtnQkFDSi9DLE1BQU07Z0JBQ05rRCxTQUFTO2dCQUNUaEMsYUFBYTtnQkFDYmlDLFlBQVksRUFBRTtZQUNoQjtTQUNEOztBQXdnQkg7QUEza0JFLHVDQUF1QztBQU41Qi9GLGlCQU9JYyxzQkFJSjtBQXdrQmIsMERBQTBEO0FBQ25ELE1BQU1rRixtQkFBbUIsSUFBSWhHLG1CQUFtQiIsInNvdXJjZXMiOlsiL1VzZXJzL21hdHRoZXdzaW1vbi9Qcm9qZWN0cy9lYWMvZWFjL3N0b3JlL2FnZW50cy9maWxlQ3JlYXRvckFnZW50LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEZpbGUgQ3JlYXRvciBBZ2VudFxuLy8gQ3JlYXRlcyBmaWxlcyBpbiBleGlzdGluZyBwcm9qZWN0cyB1c2luZyBuYXR1cmFsIGxhbmd1YWdlIGlucHV0IHdpdGggcHJvamVjdCBzZWxlY3Rpb25cblxuaW1wb3J0IHsgQWdlbnRUb29sLCBCYXNlQWdlbnQgfSBmcm9tICcuL2Jhc2UnO1xuaW1wb3J0IHsgQ29udmV4TXV0YXRpb25zIH0gZnJvbSAnLi90eXBlcyc7XG5cbmludGVyZmFjZSBGaWxlQ3JlYXRpb25EZXRhaWxzIHtcbiAgZmlsZU5hbWU6IHN0cmluZztcbiAgZmlsZVR5cGU6IHN0cmluZztcbiAgcHJvamVjdE5hbWU/OiBzdHJpbmc7XG4gIGNvbnRlbnQ/OiBzdHJpbmc7XG4gIGV4dGVuc2lvbjogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgRmlsZVR5cGVPcHRpb24ge1xuICB0eXBlOiBzdHJpbmc7XG4gIGV4dGVuc2lvbjogc3RyaW5nO1xuICBkZXNjcmlwdGlvbjogc3RyaW5nO1xuICBjb250ZW50VGVtcGxhdGU6IHN0cmluZztcbn1cblxuZXhwb3J0IGNsYXNzIEZpbGVDcmVhdG9yQWdlbnQgZXh0ZW5kcyBCYXNlQWdlbnQge1xuICBpZCA9ICdmaWxlLWNyZWF0b3InO1xuICBuYW1lID0gJ0ZpbGUgQ3JlYXRvcic7XG4gIGRlc2NyaXB0aW9uID0gJ0NyZWF0ZXMgZmlsZXMgaW4gZXhpc3RpbmcgcHJvamVjdHMgdXNpbmcgbmF0dXJhbCBsYW5ndWFnZSB3aXRoIHByb2plY3Qgc2VsZWN0aW9uJztcbiAgaWNvbiA9ICdGaWxlUGx1cyc7XG5cbiAgLy8gU3RhdGUgdG8gdHJhY2sgcGVuZGluZyBmaWxlIGNyZWF0aW9uXG4gIHByaXZhdGUgc3RhdGljIHBlbmRpbmdGaWxlQ3JlYXRpb246IHtcbiAgICBmaWxlRGV0YWlsczogRmlsZUNyZWF0aW9uRGV0YWlscztcbiAgICBwcm9qZWN0czogYW55W107XG4gICAgdGltZXN0YW1wOiBudW1iZXI7XG4gIH0gfCBudWxsID0gbnVsbDtcblxuICAvLyBQcmVkZWZpbmVkIGZpbGUgdHlwZSBvcHRpb25zXG4gIHByaXZhdGUgZmlsZVR5cGVPcHRpb25zOiBGaWxlVHlwZU9wdGlvbltdID0gW1xuICAgIHtcbiAgICAgIHR5cGU6ICdtYXJrZG93bicsXG4gICAgICBleHRlbnNpb246ICcubWQnLFxuICAgICAgZGVzY3JpcHRpb246ICdNYXJrZG93biBkb2N1bWVudCBmb3Igbm90ZXMsIGRvY3VtZW50YXRpb24sIG9yIGNvbnRlbnQnLFxuICAgICAgY29udGVudFRlbXBsYXRlOiAnIyB7ZmlsZU5hbWV9XFxuXFxuQ3JlYXRlZDoge2RhdGV9XFxuXFxuIyMgT3ZlcnZpZXdcXG5cXG4jIyBEZXRhaWxzXFxuXFxuIyMgTm90ZXNcXG4nXG4gICAgfSxcbiAgICB7XG4gICAgICB0eXBlOiAnc3ByZWFkc2hlZXQnLFxuICAgICAgZXh0ZW5zaW9uOiAnLnhsc3gnLFxuICAgICAgZGVzY3JpcHRpb246ICdFeGNlbCBzcHJlYWRzaGVldCBmb3IgYnVkZ2V0cywgY2FsY3VsYXRpb25zLCBvciBkYXRhJyxcbiAgICAgIGNvbnRlbnRUZW1wbGF0ZTogJyMge2ZpbGVOYW1lfVxcblxcbnwgSXRlbSB8IFZhbHVlIHwgTm90ZXMgfFxcbnwtLS0tLS18LS0tLS0tLXwtLS0tLS0tfFxcbnwgRXhhbXBsZSB8IDAgfCBBZGQgeW91ciBkYXRhIGhlcmUgfFxcbnwgVG90YWwgfCAwIHwgfFxcbidcbiAgICB9LFxuICAgIHtcbiAgICAgIHR5cGU6ICdkb2N1bWVudCcsXG4gICAgICBleHRlbnNpb246ICcuZG9jeCcsXG4gICAgICBkZXNjcmlwdGlvbjogJ1dvcmQgZG9jdW1lbnQgZm9yIHJlcG9ydHMsIHByb3Bvc2Fscywgb3IgZm9ybWFsIGRvY3VtZW50cycsXG4gICAgICBjb250ZW50VGVtcGxhdGU6ICcjIHtmaWxlTmFtZX1cXG5cXG5Eb2N1bWVudCBjcmVhdGVkOiB7ZGF0ZX1cXG5cXG4jIyBFeGVjdXRpdmUgU3VtbWFyeVxcblxcbiMjIE1haW4gQ29udGVudFxcblxcbiMjIENvbmNsdXNpb25cXG4nXG4gICAgfSxcbiAgICB7XG4gICAgICB0eXBlOiAncHJlc2VudGF0aW9uJyxcbiAgICAgIGV4dGVuc2lvbjogJy5wcHR4JyxcbiAgICAgIGRlc2NyaXB0aW9uOiAnUG93ZXJQb2ludCBwcmVzZW50YXRpb24gZm9yIG1lZXRpbmdzIG9yIHByb3Bvc2FscycsXG4gICAgICBjb250ZW50VGVtcGxhdGU6ICcjIHtmaWxlTmFtZX1cXG5cXG5QcmVzZW50YXRpb24gT3V0bGluZVxcblxcbiMjIFNsaWRlIDE6IFRpdGxlXFxuLSB7ZmlsZU5hbWV9XFxuLSBEYXRlOiB7ZGF0ZX1cXG5cXG4jIyBTbGlkZSAyOiBBZ2VuZGFcXG4tIFRvcGljIDFcXG4tIFRvcGljIDJcXG4tIFRvcGljIDNcXG5cXG4jIyBTbGlkZSAzOiBDb250ZW50XFxuLSBNYWluIHBvaW50c1xcbidcbiAgICB9LFxuICAgIHtcbiAgICAgIHR5cGU6ICdwbGFuJyxcbiAgICAgIGV4dGVuc2lvbjogJy5tZCcsXG4gICAgICBkZXNjcmlwdGlvbjogJ1Byb2plY3QgcGxhbiBvciBzdHJhdGVneSBkb2N1bWVudCcsXG4gICAgICBjb250ZW50VGVtcGxhdGU6ICcjIHtmaWxlTmFtZX1cXG5cXG5Qcm9qZWN0IFBsYW4gLSB7ZGF0ZX1cXG5cXG4jIyBPYmplY3RpdmVzXFxuLSBQcmltYXJ5IGdvYWxcXG4tIFNlY29uZGFyeSBnb2Fsc1xcblxcbiMjIFRpbWVsaW5lXFxuLSBQaGFzZSAxOlxcbi0gUGhhc2UgMjpcXG4tIFBoYXNlIDM6XFxuXFxuIyMgUmVzb3VyY2VzXFxuLSBUZWFtIG1lbWJlcnNcXG4tIEJ1ZGdldFxcbi0gVG9vbHNcXG5cXG4jIyBNaWxlc3RvbmVzXFxuLSBNaWxlc3RvbmUgMTpcXG4tIE1pbGVzdG9uZSAyOlxcbi0gRmluYWwgZGVsaXZlcnk6XFxuJ1xuICAgIH0sXG4gICAge1xuICAgICAgdHlwZTogJ25vdGVzJyxcbiAgICAgIGV4dGVuc2lvbjogJy5tZCcsXG4gICAgICBkZXNjcmlwdGlvbjogJ01lZXRpbmcgbm90ZXMgb3IgZ2VuZXJhbCBub3RlcycsXG4gICAgICBjb250ZW50VGVtcGxhdGU6ICcjIHtmaWxlTmFtZX1cXG5cXG5NZWV0aW5nIE5vdGVzIC0ge2RhdGV9XFxuXFxuIyMgQXR0ZW5kZWVzXFxuLSBcXG5cXG4jIyBBZ2VuZGFcXG4tIFxcblxcbiMjIERpc2N1c3Npb24gUG9pbnRzXFxuLSBcXG5cXG4jIyBBY3Rpb24gSXRlbXNcXG4tIFsgXSBcXG5cXG4jIyBOZXh0IFN0ZXBzXFxuLSBcXG4nXG4gICAgfSxcbiAgICB7XG4gICAgICB0eXBlOiAnYnJpZWYnLFxuICAgICAgZXh0ZW5zaW9uOiAnLm1kJyxcbiAgICAgIGRlc2NyaXB0aW9uOiAnQ3JlYXRpdmUgYnJpZWYgb3IgcHJvamVjdCBicmllZicsXG4gICAgICBjb250ZW50VGVtcGxhdGU6ICcjIHtmaWxlTmFtZX1cXG5cXG5Qcm9qZWN0IEJyaWVmIC0ge2RhdGV9XFxuXFxuIyMgUHJvamVjdCBPdmVydmlld1xcblxcbiMjIE9iamVjdGl2ZXNcXG4tIFByaW1hcnk6XFxuLSBTZWNvbmRhcnk6XFxuXFxuIyMgVGFyZ2V0IEF1ZGllbmNlXFxuXFxuIyMgS2V5IE1lc3NhZ2VzXFxuXFxuIyMgRGVsaXZlcmFibGVzXFxuLSBcXG5cXG4jIyBUaW1lbGluZVxcbi0gU3RhcnQ6XFxuLSBFbmQ6XFxuXFxuIyMgQnVkZ2V0XFxuJFxcblxcbiMjIFN1Y2Nlc3MgTWV0cmljc1xcbi0gXFxuJ1xuICAgIH0sXG4gICAge1xuICAgICAgdHlwZTogJ2NoZWNrbGlzdCcsXG4gICAgICBleHRlbnNpb246ICcubWQnLFxuICAgICAgZGVzY3JpcHRpb246ICdUYXNrIGNoZWNrbGlzdCBvciBwcm9jZXNzIGNoZWNrbGlzdCcsXG4gICAgICBjb250ZW50VGVtcGxhdGU6ICcjIHtmaWxlTmFtZX1cXG5cXG5DaGVja2xpc3QgLSB7ZGF0ZX1cXG5cXG4jIyBQcmUtTGF1bmNoXFxuLSBbIF0gVGFzayAxXFxuLSBbIF0gVGFzayAyXFxuLSBbIF0gVGFzayAzXFxuXFxuIyMgTGF1bmNoXFxuLSBbIF0gVGFzayAxXFxuLSBbIF0gVGFzayAyXFxuXFxuIyMgUG9zdC1MYXVuY2hcXG4tIFsgXSBUYXNrIDFcXG4tIFsgXSBUYXNrIDJcXG5cXG4jIyBOb3Rlc1xcbi0gXFxuJ1xuICAgIH1cbiAgXTtcblxuICB0b29sczogQWdlbnRUb29sW10gPSBbXG4gICAge1xuICAgICAgaWQ6ICduYXR1cmFsLWxhbmd1YWdlLWZpbGUtY3JlYXRvcicsXG4gICAgICBuYW1lOiAnTmF0dXJhbCBMYW5ndWFnZSBGaWxlIENyZWF0b3InLFxuICAgICAgY29tbWFuZDogJ2NyZWF0ZS1maWxlJyxcbiAgICAgIGRlc2NyaXB0aW9uOiAnQ3JlYXRlIGZpbGVzIGluIGV4aXN0aW5nIHByb2plY3RzIHVzaW5nIG5hdHVyYWwgbGFuZ3VhZ2Ugd2l0aCBndWlkZWQgcHJvamVjdCBzZWxlY3Rpb24nLFxuICAgICAgcGFyYW1ldGVyczogW11cbiAgICB9XG4gIF07XG5cbiAgYXN5bmMgZXhlY3V0ZShcbiAgICB0b29sOiBBZ2VudFRvb2wsXG4gICAgaW5wdXQ6IHN0cmluZyxcbiAgICBjb252ZXhNdXRhdGlvbnM6IENvbnZleE11dGF0aW9uc1xuICApOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIGNvbnNvbGUubG9nKCfwn5qAIEZpbGVDcmVhdG9yQWdlbnQgZXhlY3V0aW5nIHdpdGggaW5wdXQ6JywgaW5wdXQpO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5wcm9jZXNzRmlsZUNyZWF0aW9uUmVxdWVzdChpbnB1dCwgY29udmV4TXV0YXRpb25zKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcign4p2MIEZpbGVDcmVhdG9yQWdlbnQgZXJyb3I6JywgZXJyb3IpO1xuICAgICAgcmV0dXJuIGDinYwgRmFpbGVkIHRvIHByb2Nlc3MgcmVxdWVzdDogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJ31gO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBQcm9jZXNzIG5hdHVyYWwgbGFuZ3VhZ2UgcmVxdWVzdHMgdG8gY3JlYXRlIGZpbGVzXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIHByb2Nlc3NGaWxlQ3JlYXRpb25SZXF1ZXN0KFxuICAgIGlucHV0OiBzdHJpbmcsXG4gICAgY29udmV4TXV0YXRpb25zOiBDb252ZXhNdXRhdGlvbnNcbiAgKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICBjb25zdCBub3JtYWxpemVkSW5wdXQgPSBpbnB1dC50b0xvd2VyQ2FzZSgpLnRyaW0oKTtcbiAgICBjb25zb2xlLmxvZygn8J+UjSBQcm9jZXNzaW5nIGZpbGUgY3JlYXRpb24gaW5wdXQ6Jywgbm9ybWFsaXplZElucHV0KTtcblxuICAgIC8vIENoZWNrIGZvciBwZW5kaW5nIGZpbGUgY3JlYXRpb24gKHByb2plY3Qgc2VsZWN0aW9uIHJlc3BvbnNlKVxuICAgIGlmIChGaWxlQ3JlYXRvckFnZW50LnBlbmRpbmdGaWxlQ3JlYXRpb24pIHtcbiAgICAgIGNvbnN0IHBlbmRpbmdBZ2UgPSBEYXRlLm5vdygpIC0gRmlsZUNyZWF0b3JBZ2VudC5wZW5kaW5nRmlsZUNyZWF0aW9uLnRpbWVzdGFtcDtcbiAgICAgIFxuICAgICAgLy8gSWYgcGVuZGluZyByZXF1ZXN0IGlzIGxlc3MgdGhhbiA1IG1pbnV0ZXMgb2xkLCB0cnkgdG8gaGFuZGxlIGFzIHByb2plY3Qgc2VsZWN0aW9uXG4gICAgICBpZiAocGVuZGluZ0FnZSA8IDUgKiA2MCAqIDEwMDApIHtcbiAgICAgICAgY29uc3QgcHJvamVjdFNlbGVjdGlvblJlc3VsdCA9IGF3YWl0IHRoaXMuaGFuZGxlUHJvamVjdFNlbGVjdGlvbihpbnB1dCwgY29udmV4TXV0YXRpb25zKTtcbiAgICAgICAgaWYgKHByb2plY3RTZWxlY3Rpb25SZXN1bHQpIHtcbiAgICAgICAgICByZXR1cm4gcHJvamVjdFNlbGVjdGlvblJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQ2xlYXIgZXhwaXJlZCBwZW5kaW5nIHJlcXVlc3RcbiAgICAgICAgRmlsZUNyZWF0b3JBZ2VudC5wZW5kaW5nRmlsZUNyZWF0aW9uID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiB0aGlzIGlzIGEgaGVscCByZXF1ZXN0XG4gICAgaWYgKHRoaXMuaXNIZWxwUmVxdWVzdChub3JtYWxpemVkSW5wdXQpKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRIZWxwTWVzc2FnZSgpO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIHRoaXMgaXMgYSBmaWxlIHR5cGUgbGlzdGluZyByZXF1ZXN0XG4gICAgaWYgKHRoaXMuaXNGaWxlVHlwZUxpc3RSZXF1ZXN0KG5vcm1hbGl6ZWRJbnB1dCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldEZpbGVUeXBlT3B0aW9ucygpO1xuICAgIH1cblxuICAgIC8vIEV4dHJhY3QgZmlsZSBjcmVhdGlvbiBkZXRhaWxzXG4gICAgY29uc3QgZmlsZURldGFpbHMgPSB0aGlzLmV4dHJhY3RGaWxlRGV0YWlscyhpbnB1dCk7XG4gICAgXG4gICAgLy8gSWYgd2UgY291bGRuJ3QgZXh0cmFjdCBlbm91Z2ggZGV0YWlscywgcHJvdmlkZSBndWlkYW5jZVxuICAgIGlmICghZmlsZURldGFpbHMuZmlsZU5hbWUgJiYgIWZpbGVEZXRhaWxzLmZpbGVUeXBlKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRDcmVhdGlvbkd1aWRhbmNlKCk7XG4gICAgfVxuXG4gICAgLy8gSWYgbm8gcHJvamVjdCBzcGVjaWZpZWQsIGFzayBmb3IgcHJvamVjdCBzZWxlY3Rpb25cbiAgICBpZiAoIWZpbGVEZXRhaWxzLnByb2plY3ROYW1lKSB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5nZXRQcm9qZWN0U2VsZWN0aW9uUHJvbXB0KGZpbGVEZXRhaWxzLCBjb252ZXhNdXRhdGlvbnMpO1xuICAgIH1cblxuICAgIC8vIENyZWF0ZSB0aGUgZmlsZVxuICAgIHJldHVybiBhd2FpdCB0aGlzLmNyZWF0ZUZpbGUoZmlsZURldGFpbHMsIGNvbnZleE11dGF0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIHByb2plY3Qgc2VsZWN0aW9uIHJlc3BvbnNlXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGhhbmRsZVByb2plY3RTZWxlY3Rpb24oaW5wdXQ6IHN0cmluZywgY29udmV4TXV0YXRpb25zOiBDb252ZXhNdXRhdGlvbnMpOiBQcm9taXNlPHN0cmluZyB8IG51bGw+IHtcbiAgICBpZiAoIUZpbGVDcmVhdG9yQWdlbnQucGVuZGluZ0ZpbGVDcmVhdGlvbikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QgeyBmaWxlRGV0YWlscywgcHJvamVjdHMgfSA9IEZpbGVDcmVhdG9yQWdlbnQucGVuZGluZ0ZpbGVDcmVhdGlvbjtcbiAgICBjb25zdCBub3JtYWxpemVkSW5wdXQgPSBpbnB1dC50b0xvd2VyQ2FzZSgpLnRyaW0oKTtcblxuICAgIGxldCBzZWxlY3RlZFByb2plY3Q6IGFueSA9IG51bGw7XG5cbiAgICAvLyBUcnkgdG8gbWF0Y2ggYnkgbnVtYmVyIChlLmcuLCBcIjFcIiwgXCIyXCIsIFwiM1wiKVxuICAgIGNvbnN0IG51bWJlck1hdGNoID0gaW5wdXQubWF0Y2goL15cXGQrJC8pO1xuICAgIGlmIChudW1iZXJNYXRjaCkge1xuICAgICAgY29uc3QgaW5kZXggPSBwYXJzZUludChudW1iZXJNYXRjaFswXSkgLSAxO1xuICAgICAgaWYgKGluZGV4ID49IDAgJiYgaW5kZXggPCBwcm9qZWN0cy5sZW5ndGgpIHtcbiAgICAgICAgc2VsZWN0ZWRQcm9qZWN0ID0gcHJvamVjdHNbaW5kZXhdO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRyeSB0byBtYXRjaCBieSBwcm9qZWN0IG5hbWUgcGF0dGVybnNcbiAgICBpZiAoIXNlbGVjdGVkUHJvamVjdCkge1xuICAgICAgY29uc3QgcHJvamVjdFNlbGVjdGlvblBhdHRlcm5zID0gW1xuICAgICAgICAvKD86YWRkLip0b3xwdXQuKmlufGNyZWF0ZS4qZm9yfHVzZXxzZWxlY3QpXFxzK1tcXFwiXFwnXT8oW15cXFwiXFwnXSs/KVtcXFwiXFwnXT8kL2ksXG4gICAgICAgIC9eW1xcXCJcXCddPyhbXlxcXCJcXCddKz8pW1xcXCJcXCddPyQvaSAvLyBKdXN0IHRoZSBwcm9qZWN0IG5hbWVcbiAgICAgIF07XG5cbiAgICAgIGZvciAoY29uc3QgcGF0dGVybiBvZiBwcm9qZWN0U2VsZWN0aW9uUGF0dGVybnMpIHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSBpbnB1dC5tYXRjaChwYXR0ZXJuKTtcbiAgICAgICAgaWYgKG1hdGNoICYmIG1hdGNoWzFdKSB7XG4gICAgICAgICAgY29uc3QgcHJvamVjdE5hbWUgPSBtYXRjaFsxXS50cmltKCkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICBzZWxlY3RlZFByb2plY3QgPSBwcm9qZWN0cy5maW5kKChwOiBhbnkpID0+IFxuICAgICAgICAgICAgcC5uYW1lLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMocHJvamVjdE5hbWUpIHx8IFxuICAgICAgICAgICAgcHJvamVjdE5hbWUuaW5jbHVkZXMocC5uYW1lLnRvTG93ZXJDYXNlKCkpXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAoc2VsZWN0ZWRQcm9qZWN0KSBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghc2VsZWN0ZWRQcm9qZWN0KSB7XG4gICAgICAvLyBSZS1zaG93IHByb2plY3Qgc2VsZWN0aW9uIHdpdGggZXJyb3IgbWVzc2FnZVxuICAgICAgbGV0IHJlc3VsdCA9IGDinYwgKipQcm9qZWN0IG5vdCBmb3VuZC4qKiBQbGVhc2Ugc2VsZWN0IGZyb20gdGhlIGF2YWlsYWJsZSBwcm9qZWN0czpcXG5cXG5gO1xuICAgICAgcmVzdWx0ICs9IGAqKvCfk4EgQXZhaWxhYmxlIFByb2plY3RzOioqXFxuYDtcbiAgICAgIHByb2plY3RzLmZvckVhY2goKHByb2plY3Q6IGFueSwgaW5kZXg6IG51bWJlcikgPT4ge1xuICAgICAgICByZXN1bHQgKz0gYCR7aW5kZXggKyAxfS4gKioke3Byb2plY3QubmFtZX0qKlxcbmA7XG4gICAgICB9KTtcbiAgICAgIHJlc3VsdCArPSBgXFxuKirwn5KhIFlvdSBjYW46KipcXG5gO1xuICAgICAgcmVzdWx0ICs9IGDigKIgVHlwZSBhIG51bWJlciAoZS5nLiwgXCIxXCIsIFwiMlwiKVxcbmA7XG4gICAgICByZXN1bHQgKz0gYOKAoiBUeXBlIHRoZSBwcm9qZWN0IG5hbWUgKGUuZy4sIFwiJHtwcm9qZWN0c1swXT8ubmFtZX1cIilcXG5gO1xuICAgICAgcmVzdWx0ICs9IGDigKIgT3Igc2F5IFwiYWRkIGl0IHRvICR7cHJvamVjdHNbMF0/Lm5hbWV9XCJcXG5gO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvLyBDbGVhciBwZW5kaW5nIHN0YXRlXG4gICAgRmlsZUNyZWF0b3JBZ2VudC5wZW5kaW5nRmlsZUNyZWF0aW9uID0gbnVsbDtcblxuICAgIC8vIENyZWF0ZSB0aGUgZmlsZSB3aXRoIHNlbGVjdGVkIHByb2plY3RcbiAgICBjb25zdCB1cGRhdGVkRmlsZURldGFpbHMgPSB7XG4gICAgICAuLi5maWxlRGV0YWlscyxcbiAgICAgIHByb2plY3ROYW1lOiBzZWxlY3RlZFByb2plY3QubmFtZVxuICAgIH07XG5cbiAgICByZXR1cm4gYXdhaXQgdGhpcy5jcmVhdGVGaWxlKHVwZGF0ZWRGaWxlRGV0YWlscywgY29udmV4TXV0YXRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBpbnB1dCBpcyByZXF1ZXN0aW5nIGhlbHBcbiAgICovXG4gIHByaXZhdGUgaXNIZWxwUmVxdWVzdChpbnB1dDogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgY29uc3QgaGVscFBhdHRlcm5zID0gW1xuICAgICAgL2hlbHAvLFxuICAgICAgL2hvdy4qd29yay8sXG4gICAgICAvd2hhdC4qZG8vLFxuICAgICAgL2NvbW1hbmRzLyxcbiAgICAgIC9vcHRpb25zL1xuICAgIF07XG4gICAgcmV0dXJuIGhlbHBQYXR0ZXJucy5zb21lKHBhdHRlcm4gPT4gcGF0dGVybi50ZXN0KGlucHV0KSk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgaW5wdXQgaXMgcmVxdWVzdGluZyBmaWxlIHR5cGUgbGlzdFxuICAgKi9cbiAgcHJpdmF0ZSBpc0ZpbGVUeXBlTGlzdFJlcXVlc3QoaW5wdXQ6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IGxpc3RQYXR0ZXJucyA9IFtcbiAgICAgIC9maWxlLip0eXBlcz8vLFxuICAgICAgL3doYXQuKmZpbGVzPy8sXG4gICAgICAvbGlzdC4qZmlsZXM/LyxcbiAgICAgIC9zaG93LipvcHRpb25zLyxcbiAgICAgIC9hdmFpbGFibGUuKnR5cGVzPy9cbiAgICBdO1xuICAgIHJldHVybiBsaXN0UGF0dGVybnMuc29tZShwYXR0ZXJuID0+IHBhdHRlcm4udGVzdChpbnB1dCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4dHJhY3QgZmlsZSBjcmVhdGlvbiBkZXRhaWxzIGZyb20gbmF0dXJhbCBsYW5ndWFnZSBpbnB1dFxuICAgKi9cbiAgcHJpdmF0ZSBleHRyYWN0RmlsZURldGFpbHMoaW5wdXQ6IHN0cmluZyk6IEZpbGVDcmVhdGlvbkRldGFpbHMge1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRJbnB1dCA9IGlucHV0LnRvTG93ZXJDYXNlKCk7XG4gICAgXG4gICAgbGV0IGZpbGVOYW1lID0gJyc7XG4gICAgbGV0IGZpbGVUeXBlID0gJyc7XG4gICAgbGV0IGV4dGVuc2lvbiA9ICcubWQnOyAvLyBkZWZhdWx0XG4gICAgbGV0IHByb2plY3ROYW1lID0gJyc7XG5cbiAgICAvLyBFeHRyYWN0IGZpbGUgbmFtZSBwYXR0ZXJuc1xuICAgIGNvbnN0IGZpbGVOYW1lUGF0dGVybnMgPSBbXG4gICAgICAvKD86Y3JlYXRlfG1ha2V8YWRkfGdlbmVyYXRlKVxccysoPzphXFxzKyk/KD86bmV3XFxzKyk/KD86ZmlsZVxccyspPyg/OmNhbGxlZFxccyspP1tcXFwiXFwnXT8oW15cXFwiXFwnXSs/KVtcXFwiXFwnXT8oPzpcXHMrKD86Zm9yfGlufHRvfGFzKXxcXHMqJCkvaSxcbiAgICAgIC8oPzpmaWxlXFxzKyk/W1xcXCJcXCddKFteXFxcIlxcJ10rKVtcXFwiXFwnXT8vaVxuICAgIF07XG5cbiAgICBmb3IgKGNvbnN0IHBhdHRlcm4gb2YgZmlsZU5hbWVQYXR0ZXJucykge1xuICAgICAgY29uc3QgbWF0Y2ggPSBpbnB1dC5tYXRjaChwYXR0ZXJuKTtcbiAgICAgIGlmIChtYXRjaCAmJiBtYXRjaFsxXSkge1xuICAgICAgICBmaWxlTmFtZSA9IG1hdGNoWzFdLnRyaW0oKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ2xlYW4gdXAgZmlsZU5hbWUgYnkgcmVtb3ZpbmcgZmlsZSB0eXBlIHdvcmRzXG4gICAgZmlsZU5hbWUgPSBmaWxlTmFtZS5yZXBsYWNlKC9cXGIoZmlsZXxkb2N1bWVudHxzcHJlYWRzaGVldHxwcmVzZW50YXRpb258bm90ZXM/fHBsYW58YnJpZWZ8Y2hlY2tsaXN0KVxcYi9naSwgJycpLnRyaW0oKTtcblxuICAgIC8vIERldGVjdCBmaWxlIHR5cGUgZnJvbSBpbnB1dFxuICAgIGZvciAoY29uc3Qgb3B0aW9uIG9mIHRoaXMuZmlsZVR5cGVPcHRpb25zKSB7XG4gICAgICBjb25zdCB0eXBlUGF0dGVybnMgPSBbXG4gICAgICAgIG5ldyBSZWdFeHAoYFxcXFxiJHtvcHRpb24udHlwZX1cXFxcYmAsICdpJyksXG4gICAgICAgIG5ldyBSZWdFeHAoYFxcXFxiJHtvcHRpb24uZGVzY3JpcHRpb24uc3BsaXQoJyAnKVswXX1cXFxcYmAsICdpJylcbiAgICAgIF07XG4gICAgICBcbiAgICAgIGlmIChvcHRpb24udHlwZSA9PT0gJ3NwcmVhZHNoZWV0JyAmJiAvXFxiKGV4Y2VsfHhsc3g/fGJ1ZGdldHxmaW5hbmNpYWx8Y2FsY3VsYXRpb24pXFxiL2kudGVzdChub3JtYWxpemVkSW5wdXQpKSB7XG4gICAgICAgIGZpbGVUeXBlID0gb3B0aW9uLnR5cGU7XG4gICAgICAgIGV4dGVuc2lvbiA9IG9wdGlvbi5leHRlbnNpb247XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIGlmIChvcHRpb24udHlwZSA9PT0gJ2RvY3VtZW50JyAmJiAvXFxiKGRvY3VtZW50fGRvY3g/fHJlcG9ydHxwcm9wb3NhbHx3b3JkKVxcYi9pLnRlc3Qobm9ybWFsaXplZElucHV0KSkge1xuICAgICAgICBmaWxlVHlwZSA9IG9wdGlvbi50eXBlO1xuICAgICAgICBleHRlbnNpb24gPSBvcHRpb24uZXh0ZW5zaW9uO1xuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSBpZiAob3B0aW9uLnR5cGUgPT09ICdwcmVzZW50YXRpb24nICYmIC9cXGIocHJlc2VudGF0aW9ufHBwdHg/fHNsaWRlcz98cG93ZXJwb2ludClcXGIvaS50ZXN0KG5vcm1hbGl6ZWRJbnB1dCkpIHtcbiAgICAgICAgZmlsZVR5cGUgPSBvcHRpb24udHlwZTtcbiAgICAgICAgZXh0ZW5zaW9uID0gb3B0aW9uLmV4dGVuc2lvbjtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2UgaWYgKG9wdGlvbi50eXBlID09PSAncGxhbicgJiYgL1xcYihwbGFufHBsYW5uaW5nfHN0cmF0ZWd5fHJvYWRtYXApXFxiL2kudGVzdChub3JtYWxpemVkSW5wdXQpKSB7XG4gICAgICAgIGZpbGVUeXBlID0gb3B0aW9uLnR5cGU7XG4gICAgICAgIGV4dGVuc2lvbiA9IG9wdGlvbi5leHRlbnNpb247XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIGlmIChvcHRpb24udHlwZSA9PT0gJ25vdGVzJyAmJiAvXFxiKG5vdGVzP3xtZWV0aW5nfG1pbnV0ZXMpXFxiL2kudGVzdChub3JtYWxpemVkSW5wdXQpKSB7XG4gICAgICAgIGZpbGVUeXBlID0gb3B0aW9uLnR5cGU7XG4gICAgICAgIGV4dGVuc2lvbiA9IG9wdGlvbi5leHRlbnNpb247XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIGlmIChvcHRpb24udHlwZSA9PT0gJ2JyaWVmJyAmJiAvXFxiKGJyaWVmfG92ZXJ2aWV3fHN1bW1hcnkpXFxiL2kudGVzdChub3JtYWxpemVkSW5wdXQpKSB7XG4gICAgICAgIGZpbGVUeXBlID0gb3B0aW9uLnR5cGU7XG4gICAgICAgIGV4dGVuc2lvbiA9IG9wdGlvbi5leHRlbnNpb247XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIGlmIChvcHRpb24udHlwZSA9PT0gJ2NoZWNrbGlzdCcgJiYgL1xcYihjaGVja2xpc3R8dGFza3M/fHRvZG98bGlzdClcXGIvaS50ZXN0KG5vcm1hbGl6ZWRJbnB1dCkpIHtcbiAgICAgICAgZmlsZVR5cGUgPSBvcHRpb24udHlwZTtcbiAgICAgICAgZXh0ZW5zaW9uID0gb3B0aW9uLmV4dGVuc2lvbjtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVQYXR0ZXJucy5zb21lKHBhdHRlcm4gPT4gcGF0dGVybi50ZXN0KG5vcm1hbGl6ZWRJbnB1dCkpKSB7XG4gICAgICAgIGZpbGVUeXBlID0gb3B0aW9uLnR5cGU7XG4gICAgICAgIGV4dGVuc2lvbiA9IG9wdGlvbi5leHRlbnNpb247XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIG5vIHNwZWNpZmljIHR5cGUgZGV0ZWN0ZWQsIGRlZmF1bHQgdG8gbWFya2Rvd25cbiAgICBpZiAoIWZpbGVUeXBlKSB7XG4gICAgICBmaWxlVHlwZSA9ICdtYXJrZG93bic7XG4gICAgICBleHRlbnNpb24gPSAnLm1kJztcbiAgICB9XG5cbiAgICAvLyBFeHRyYWN0IHByb2plY3QgbmFtZSAob25seSB2ZXJ5IGV4cGxpY2l0IHByb2plY3QgbWVudGlvbnMpXG4gICAgY29uc3QgcHJvamVjdFBhdHRlcm5zID0gW1xuICAgICAgLyg/OmZvcnxpbnx0bylcXHMrKD86dGhlXFxzKyk/cHJvamVjdFxccytbXFxcIlxcJ10/KFteXFxcIlxcJ10rPylbXFxcIlxcJ10/KD86XFxzKiQpL2ksXG4gICAgICAvcHJvamVjdFxccytbXFxcIlxcJ10oW15cXFwiXFwnXSspW1xcXCJcXCddPy9pLFxuICAgICAgL2luXFxzK1tcXFwiXFwnXShbXlxcXCJcXCddKylbXFxcIlxcJ10/XFxzK3Byb2plY3QvaVxuICAgIF07XG5cbiAgICBmb3IgKGNvbnN0IHBhdHRlcm4gb2YgcHJvamVjdFBhdHRlcm5zKSB7XG4gICAgICBjb25zdCBtYXRjaCA9IGlucHV0Lm1hdGNoKHBhdHRlcm4pO1xuICAgICAgaWYgKG1hdGNoICYmIG1hdGNoWzFdKSB7XG4gICAgICAgIHByb2plY3ROYW1lID0gbWF0Y2hbMV0udHJpbSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBHZW5lcmF0ZSBkZWZhdWx0IGZpbGUgbmFtZSBpZiBub3QgcHJvdmlkZWRcbiAgICBpZiAoIWZpbGVOYW1lKSB7XG4gICAgICBjb25zdCB0eXBlV29yZHMgPSBmaWxlVHlwZS5zcGxpdCgvKD89W0EtWl0pLykuam9pbignICcpLnRvTG93ZXJDYXNlKCk7XG4gICAgICBmaWxlTmFtZSA9IGBuZXctJHt0eXBlV29yZHN9YDtcbiAgICB9XG5cbiAgICAvLyBFbnN1cmUgZmlsZU5hbWUgaGFzIGV4dGVuc2lvblxuICAgIGlmICghZmlsZU5hbWUuaW5jbHVkZXMoJy4nKSkge1xuICAgICAgZmlsZU5hbWUgKz0gZXh0ZW5zaW9uO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBmaWxlTmFtZSxcbiAgICAgIGZpbGVUeXBlLFxuICAgICAgcHJvamVjdE5hbWUsXG4gICAgICBleHRlbnNpb24sXG4gICAgICBjb250ZW50OiAnJ1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSBmaWxlIGluIHRoZSBzcGVjaWZpZWQgcHJvamVjdFxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBjcmVhdGVGaWxlKFxuICAgIGZpbGVEZXRhaWxzOiBGaWxlQ3JlYXRpb25EZXRhaWxzLFxuICAgIGNvbnZleE11dGF0aW9uczogQ29udmV4TXV0YXRpb25zXG4gICk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghY29udmV4TXV0YXRpb25zLmNyZWF0ZUZpbGUpIHtcbiAgICAgICAgcmV0dXJuICfinYwgRmlsZSBjcmVhdGlvbiBpcyBub3QgYXZhaWxhYmxlLiBQbGVhc2UgY2hlY2sgc3lzdGVtIGNvbmZpZ3VyYXRpb24uJztcbiAgICAgIH1cblxuICAgICAgaWYgKCFjb252ZXhNdXRhdGlvbnMuZ2V0UHJvamVjdHMpIHtcbiAgICAgICAgcmV0dXJuICfinYwgUHJvamVjdCBsb29rdXAgaXMgbm90IGF2YWlsYWJsZS4gUGxlYXNlIGNoZWNrIHN5c3RlbSBjb25maWd1cmF0aW9uLic7XG4gICAgICB9XG5cbiAgICAgIC8vIExvb2sgdXAgdGhlIGFjdHVhbCBwcm9qZWN0IElEIGJ5IG5hbWVcbiAgICAgIGNvbnN0IHByb2plY3RzID0gYXdhaXQgY29udmV4TXV0YXRpb25zLmdldFByb2plY3RzKCk7XG4gICAgICBjb25zdCB0YXJnZXRQcm9qZWN0ID0gcHJvamVjdHMuZmluZCgocDogYW55KSA9PiBcbiAgICAgICAgcC5uYW1lLnRvTG93ZXJDYXNlKCkgPT09IGZpbGVEZXRhaWxzLnByb2plY3ROYW1lPy50b0xvd2VyQ2FzZSgpXG4gICAgICApO1xuXG4gICAgICBpZiAoIXRhcmdldFByb2plY3QpIHtcbiAgICAgICAgcmV0dXJuIGDinYwgKipQcm9qZWN0IE5vdCBGb3VuZCoqXFxuXFxuQ291bGQgbm90IGZpbmQgYSBwcm9qZWN0IG5hbWVkIFwiJHtmaWxlRGV0YWlscy5wcm9qZWN0TmFtZX1cIi4gUGxlYXNlIGNoZWNrIHRoZSBwcm9qZWN0IG5hbWUgYW5kIHRyeSBhZ2Fpbi5cXG5cXG4qKkF2YWlsYWJsZSBwcm9qZWN0czoqKlxcbiR7cHJvamVjdHMubWFwKChwOiBhbnkpID0+IGDigKIgJHtwLm5hbWV9YCkuam9pbignXFxuJyl9YDtcbiAgICAgIH1cblxuICAgICAgLy8gRmluZCB0aGUgZmlsZSB0eXBlIG9wdGlvbiBmb3IgY29udGVudCB0ZW1wbGF0ZVxuICAgICAgY29uc3QgZmlsZVR5cGVPcHRpb24gPSB0aGlzLmZpbGVUeXBlT3B0aW9ucy5maW5kKG9wdGlvbiA9PiBvcHRpb24udHlwZSA9PT0gZmlsZURldGFpbHMuZmlsZVR5cGUpO1xuICAgICAgXG4gICAgICAvLyBHZW5lcmF0ZSBjb250ZW50IGZyb20gdGVtcGxhdGVcbiAgICAgIGNvbnN0IGNvbnRlbnQgPSB0aGlzLmdlbmVyYXRlRmlsZUNvbnRlbnQoZmlsZURldGFpbHMsIGZpbGVUeXBlT3B0aW9uKTtcblxuICAgICAgLy8gQ3JlYXRlIHRoZSBmaWxlIHdpdGggdGhlIGFjdHVhbCBwcm9qZWN0IElEXG4gICAgICBjb25zdCBuZXdGaWxlID0gYXdhaXQgY29udmV4TXV0YXRpb25zLmNyZWF0ZUZpbGUoe1xuICAgICAgICBuYW1lOiBmaWxlRGV0YWlscy5maWxlTmFtZSxcbiAgICAgICAgY29udGVudDogY29udGVudCxcbiAgICAgICAgdHlwZTogdGhpcy5tYXBUb0NvbnZleEZpbGVUeXBlKGZpbGVEZXRhaWxzLmZpbGVUeXBlKSxcbiAgICAgICAgcHJvamVjdElkOiB0YXJnZXRQcm9qZWN0Ll9pZCAvLyBVc2UgdGhlIGFjdHVhbCBwcm9qZWN0IElEXG4gICAgICB9KTtcblxuICAgICAgbGV0IHJlc3VsdCA9IGDinIUgKipGaWxlIENyZWF0ZWQgU3VjY2Vzc2Z1bGx5ISoqXFxuXFxuYDtcbiAgICAgIHJlc3VsdCArPSBg8J+ThCAqKkZpbGUgTmFtZToqKiAke2ZpbGVEZXRhaWxzLmZpbGVOYW1lfVxcbmA7XG4gICAgICByZXN1bHQgKz0gYPCfk4EgKipQcm9qZWN0OioqICR7ZmlsZURldGFpbHMucHJvamVjdE5hbWV9XFxuYDtcbiAgICAgIHJlc3VsdCArPSBg8J+Pt++4jyAqKlR5cGU6KiogJHtmaWxlRGV0YWlscy5maWxlVHlwZX1cXG5gO1xuICAgICAgXG4gICAgICBpZiAoZmlsZVR5cGVPcHRpb24pIHtcbiAgICAgICAgcmVzdWx0ICs9IGDwn5OdICoqRGVzY3JpcHRpb246KiogJHtmaWxlVHlwZU9wdGlvbi5kZXNjcmlwdGlvbn1cXG5gO1xuICAgICAgfVxuICAgICAgXG4gICAgICByZXN1bHQgKz0gYPCfk4UgKipDcmVhdGVkOioqICR7bmV3IERhdGUoKS50b0xvY2FsZURhdGVTdHJpbmcoKX1cXG5cXG5gO1xuICAgICAgcmVzdWx0ICs9IGDwn5KhIFlvdSBjYW4gbm93IGZpbmQgYW5kIGVkaXQgdGhpcyBmaWxlIGluIHRoZSBzaWRlYmFyIVxcblxcbmA7XG4gICAgICByZXN1bHQgKz0gYPCflKcgKipOZXh0IFN0ZXBzOioqXFxuYDtcbiAgICAgIHJlc3VsdCArPSBg4oCiIE9wZW4gdGhlIGZpbGUgdG8gY3VzdG9taXplIHRoZSBjb250ZW50XFxuYDtcbiAgICAgIHJlc3VsdCArPSBg4oCiIFNoYXJlIHdpdGggdGVhbSBtZW1iZXJzIGlmIG5lZWRlZFxcbmA7XG4gICAgICByZXN1bHQgKz0gYOKAoiBBZGQgdG8geW91ciB3b3JrZmxvdyBvciBjYWxlbmRhcmA7XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBGaWxlIGNyZWF0aW9uIGZhaWxlZDonLCBlcnJvcik7XG4gICAgICByZXR1cm4gYOKdjCAqKkZpbGUgY3JlYXRpb24gZmFpbGVkOioqICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcid9YDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgZmlsZSBjb250ZW50IGJhc2VkIG9uIHRlbXBsYXRlXG4gICAqL1xuICBwcml2YXRlIGdlbmVyYXRlRmlsZUNvbnRlbnQoZmlsZURldGFpbHM6IEZpbGVDcmVhdGlvbkRldGFpbHMsIGZpbGVUeXBlT3B0aW9uPzogRmlsZVR5cGVPcHRpb24pOiBzdHJpbmcge1xuICAgIGlmICghZmlsZVR5cGVPcHRpb24pIHtcbiAgICAgIC8vIERlZmF1bHQgY29udGVudCBpZiBubyB0ZW1wbGF0ZSBmb3VuZFxuICAgICAgcmV0dXJuIGAjICR7ZmlsZURldGFpbHMuZmlsZU5hbWUucmVwbGFjZSgvXFwuW14vLl0rJC8sIFwiXCIpfVxcblxcbkNyZWF0ZWQ6ICR7bmV3IERhdGUoKS50b0xvY2FsZURhdGVTdHJpbmcoKX1cXG5cXG5Db250ZW50IGdvZXMgaGVyZS4uLmA7XG4gICAgfVxuXG4gICAgLy8gUmVwbGFjZSB0ZW1wbGF0ZSB2YXJpYWJsZXNcbiAgICBsZXQgY29udGVudCA9IGZpbGVUeXBlT3B0aW9uLmNvbnRlbnRUZW1wbGF0ZTtcbiAgICBjb250ZW50ID0gY29udGVudC5yZXBsYWNlKC9cXHtmaWxlTmFtZVxcfS9nLCBmaWxlRGV0YWlscy5maWxlTmFtZS5yZXBsYWNlKC9cXC5bXi8uXSskLywgXCJcIikpO1xuICAgIGNvbnRlbnQgPSBjb250ZW50LnJlcGxhY2UoL1xce2RhdGVcXH0vZywgbmV3IERhdGUoKS50b0xvY2FsZURhdGVTdHJpbmcoKSk7XG4gICAgXG4gICAgcmV0dXJuIGNvbnRlbnQ7XG4gIH1cblxuICAvKipcbiAgICogTWFwIGZpbGUgdHlwZSB0byBDb252ZXggZXhwZWN0ZWQgdHlwZVxuICAgKi9cbiAgcHJpdmF0ZSBtYXBUb0NvbnZleEZpbGVUeXBlKGZpbGVUeXBlOiBzdHJpbmcpOiAncG9zdCcgfCAnY2FtcGFpZ24nIHwgJ25vdGUnIHwgJ2RvY3VtZW50JyB8ICdpbWFnZScgfCAndmlkZW8nIHwgJ290aGVyJyB7XG4gICAgY29uc3QgdHlwZU1hcDogUmVjb3JkPHN0cmluZywgJ3Bvc3QnIHwgJ2NhbXBhaWduJyB8ICdub3RlJyB8ICdkb2N1bWVudCcgfCAnaW1hZ2UnIHwgJ3ZpZGVvJyB8ICdvdGhlcic+ID0ge1xuICAgICAgbWFya2Rvd246ICdub3RlJyxcbiAgICAgIG5vdGVzOiAnbm90ZScsXG4gICAgICBwbGFuOiAnbm90ZScsXG4gICAgICBicmllZjogJ25vdGUnLFxuICAgICAgY2hlY2tsaXN0OiAnbm90ZScsXG4gICAgICBzcHJlYWRzaGVldDogJ2RvY3VtZW50JyxcbiAgICAgIGRvY3VtZW50OiAnZG9jdW1lbnQnLFxuICAgICAgcHJlc2VudGF0aW9uOiAnZG9jdW1lbnQnXG4gICAgfTtcbiAgICByZXR1cm4gdHlwZU1hcFtmaWxlVHlwZV0gfHwgJ25vdGUnO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBjcmVhdGlvbiBndWlkYW5jZSB3aGVuIGRldGFpbHMgYXJlIGluc3VmZmljaWVudFxuICAgKi9cbiAgcHJpdmF0ZSBnZXRDcmVhdGlvbkd1aWRhbmNlKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGDwn6SWICoqRmlsZSBDcmVhdG9yIC0gTGV0J3MgR2V0IFN0YXJ0ZWQhKipcblxuSSBuZWVkIGEgYml0IG1vcmUgaW5mb3JtYXRpb24gdG8gY3JlYXRlIHlvdXIgZmlsZS4gSGVyZSBhcmUgc29tZSBleGFtcGxlczpcblxuKirwn5OEIFF1aWNrIEV4YW1wbGVzOioqXG7igKIgXCJDcmVhdGUgYSBidWRnZXQgc3ByZWFkc2hlZXQgZm9yIE1hcmtldGluZyBQcm9qZWN0XCJcbuKAoiBcIk1ha2UgbWVldGluZyBub3RlcyBmb3IgRGV2ZWxvcG1lbnQgVGVhbVwiXG7igKIgXCJBZGQgYSBwcm9qZWN0IHBsYW4gZm9yIFExIENhbXBhaWduXCJcbuKAoiBcIkdlbmVyYXRlIGEgcHJlc2VudGF0aW9uIGZvciBDbGllbnQgUmV2aWV3XCJcblxuKirwn46vIFdoYXQgSSBuZWVkOioqXG4xLiAqKkZpbGUgdHlwZSoqIChzcHJlYWRzaGVldCwgbm90ZXMsIHBsYW4sIGV0Yy4pXG4yLiAqKkZpbGUgbmFtZSoqIChvcHRpb25hbCAtIEknbGwgc3VnZ2VzdCBvbmUpXG4zLiAqKlByb2plY3QgbmFtZSoqICh3aGljaCBwcm9qZWN0IHRvIGFkZCBpdCB0bylcblxuKirwn5KhIFBybyB0aXA6KiogSnVzdCBkZXNjcmliZSB3aGF0IHlvdSB3YW50ISBcbkV4YW1wbGU6IFwiSSBuZWVkIGEgY2hlY2tsaXN0IGZvciB0aGUgcHJvZHVjdCBsYXVuY2ggcHJvamVjdFwiXG5cblR5cGUgeW91ciByZXF1ZXN0IG9yIHNheSBcIioqZmlsZSB0eXBlcyoqXCIgdG8gc2VlIGFsbCBhdmFpbGFibGUgb3B0aW9ucyEg8J+agGA7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHByb2plY3Qgc2VsZWN0aW9uIHByb21wdCB3aGVuIHByb2plY3QgaXMgbm90IHNwZWNpZmllZFxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBnZXRQcm9qZWN0U2VsZWN0aW9uUHJvbXB0KGZpbGVEZXRhaWxzOiBGaWxlQ3JlYXRpb25EZXRhaWxzLCBjb252ZXhNdXRhdGlvbnM6IENvbnZleE11dGF0aW9ucyk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghY29udmV4TXV0YXRpb25zLmdldFByb2plY3RzKSB7XG4gICAgICAgIHJldHVybiBg8J+kliAqKkFsbW9zdCBUaGVyZSEgV2hpY2ggUHJvamVjdD8qKlxuXG5JJ20gcmVhZHkgdG8gY3JlYXRlIHlvdXIgKioke2ZpbGVEZXRhaWxzLmZpbGVUeXBlfSoqIGZpbGU6IFxcYCR7ZmlsZURldGFpbHMuZmlsZU5hbWV9XFxgXG5cbioq8J+TgSBQbGVhc2Ugc3BlY2lmeSB3aGljaCBwcm9qZWN0IHRvIGFkZCBpdCB0by4qKlxuXG4qKvCfkqEgVGlwOioqIFlvdSBjYW4gc2F5IHNvbWV0aGluZyBsaWtlOlxuXCJDcmVhdGUgJHtmaWxlRGV0YWlscy5maWxlTmFtZX0gZm9yIFtZb3VyIFByb2plY3QgTmFtZV1cImA7XG4gICAgICB9XG5cbiAgICAgIC8vIEZldGNoIGF2YWlsYWJsZSBwcm9qZWN0c1xuICAgICAgY29uc3QgcHJvamVjdHMgPSBhd2FpdCBjb252ZXhNdXRhdGlvbnMuZ2V0UHJvamVjdHMoKTtcbiAgICAgIFxuICAgICAgbGV0IHJlc3VsdCA9IGDwn6SWICoqQWxtb3N0IFRoZXJlISBXaGljaCBQcm9qZWN0PyoqXFxuXFxuYDtcbiAgICAgIHJlc3VsdCArPSBgSSdtIHJlYWR5IHRvIGNyZWF0ZSB5b3VyICoqJHtmaWxlRGV0YWlscy5maWxlVHlwZX0qKiBmaWxlOiBcXGAke2ZpbGVEZXRhaWxzLmZpbGVOYW1lfVxcYFxcblxcbmA7XG4gICAgICByZXN1bHQgKz0gYCoq8J+TgSBBdmFpbGFibGUgUHJvamVjdHM6KipcXG5gO1xuICAgICAgXG4gICAgICBpZiAocHJvamVjdHMgJiYgcHJvamVjdHMubGVuZ3RoID4gMCkge1xuICAgICAgICAvLyBTdG9yZSBwZW5kaW5nIGZpbGUgY3JlYXRpb24gc3RhdGVcbiAgICAgICAgRmlsZUNyZWF0b3JBZ2VudC5wZW5kaW5nRmlsZUNyZWF0aW9uID0ge1xuICAgICAgICAgIGZpbGVEZXRhaWxzLFxuICAgICAgICAgIHByb2plY3RzLFxuICAgICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKVxuICAgICAgICB9O1xuXG4gICAgICAgIHByb2plY3RzLmZvckVhY2goKHByb2plY3Q6IGFueSwgaW5kZXg6IG51bWJlcikgPT4ge1xuICAgICAgICAgIHJlc3VsdCArPSBgJHtpbmRleCArIDF9LiAqKiR7cHJvamVjdC5uYW1lfSoqXFxuYDtcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICByZXN1bHQgKz0gYFxcbioq8J+OryBTZWxlY3QgYSBwcm9qZWN0OioqXFxuYDtcbiAgICAgICAgcmVzdWx0ICs9IGDigKIgVHlwZSBhIG51bWJlcjogKioxKiosICoqMioqLCAqKjMqKiwgZXRjLlxcbmA7XG4gICAgICAgIHJlc3VsdCArPSBg4oCiIFR5cGUgdGhlIG5hbWU6ICoqJHtwcm9qZWN0c1swXT8ubmFtZX0qKlxcbmA7XG4gICAgICAgIHJlc3VsdCArPSBg4oCiIE9yIHNheTogXCIqKmFkZCBpdCB0byAke3Byb2plY3RzWzBdPy5uYW1lfSoqXCJcXG5cXG5gO1xuICAgICAgICByZXN1bHQgKz0gYPCfkqEgKipOZXh0IG1lc3NhZ2U6KiogSnVzdCB0eXBlIHlvdXIgc2VsZWN0aW9uIWA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgKz0gYE5vIHByb2plY3RzIGZvdW5kLiBQbGVhc2UgY3JlYXRlIGEgcHJvamVjdCBmaXJzdCBvciBzcGVjaWZ5IGEgcHJvamVjdCBuYW1lLlxcbmA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICBcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgcHJvamVjdHMgZm9yIHNlbGVjdGlvbjonLCBlcnJvcik7XG4gICAgICByZXR1cm4gYPCfpJYgKipBbG1vc3QgVGhlcmUhIFdoaWNoIFByb2plY3Q/KipcblxuSSdtIHJlYWR5IHRvIGNyZWF0ZSB5b3VyICoqJHtmaWxlRGV0YWlscy5maWxlVHlwZX0qKiBmaWxlOiBcXGAke2ZpbGVEZXRhaWxzLmZpbGVOYW1lfVxcYFxuXG4qKvCfk4EgUGxlYXNlIHNwZWNpZnkgd2hpY2ggcHJvamVjdCB0byBhZGQgaXQgdG8uKipcblxuKirwn5KhIFRpcDoqKiBZb3UgY2FuIHNheSBzb21ldGhpbmcgbGlrZTpcblwiQ3JlYXRlICR7ZmlsZURldGFpbHMuZmlsZU5hbWV9IGZvciBbWW91ciBQcm9qZWN0IE5hbWVdXCJgO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYXZhaWxhYmxlIGZpbGUgdHlwZSBvcHRpb25zXG4gICAqL1xuICBwcml2YXRlIGdldEZpbGVUeXBlT3B0aW9ucygpOiBzdHJpbmcge1xuICAgIGxldCByZXN1bHQgPSBg8J+kliAqKkF2YWlsYWJsZSBGaWxlIFR5cGVzKipcXG5cXG5gO1xuICAgIFxuICAgIHRoaXMuZmlsZVR5cGVPcHRpb25zLmZvckVhY2goKG9wdGlvbiwgaW5kZXgpID0+IHtcbiAgICAgIHJlc3VsdCArPSBgKioke2luZGV4ICsgMX0uICR7b3B0aW9uLnR5cGUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBvcHRpb24udHlwZS5zbGljZSgxKX0qKiAoJHtvcHRpb24uZXh0ZW5zaW9ufSlcXG5gO1xuICAgICAgcmVzdWx0ICs9IGAgICAke29wdGlvbi5kZXNjcmlwdGlvbn1cXG5cXG5gO1xuICAgIH0pO1xuXG4gICAgcmVzdWx0ICs9IGAqKvCfkqEgVXNhZ2UgRXhhbXBsZXM6KipcXG5gO1xuICAgIHJlc3VsdCArPSBg4oCiIFwiQ3JlYXRlIGEgc3ByZWFkc2hlZXQgZm9yIEJ1ZGdldCBQbGFubmluZ1wiXFxuYDtcbiAgICByZXN1bHQgKz0gYOKAoiBcIk1ha2UgbWVldGluZyBub3RlcyBmb3IgRGV2ZWxvcG1lbnQgVGVhbVwiXFxuYDtcbiAgICByZXN1bHQgKz0gYOKAoiBcIkFkZCBhIHByb2plY3QgcGxhbiBmb3IgTWFya2V0aW5nIENhbXBhaWduXCJcXG5gO1xuICAgIHJlc3VsdCArPSBg4oCiIFwiR2VuZXJhdGUgYSBicmllZiBmb3IgQ2xpZW50IFByZXNlbnRhdGlvblwiXFxuXFxuYDtcbiAgICBcbiAgICByZXN1bHQgKz0gYCoq8J+agCBKdXN0IGRlc2NyaWJlIHdoYXQgeW91IG5lZWQgYW5kIEknbGwgaGFuZGxlIHRoZSByZXN0ISoqYDtcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGhlbHAgbWVzc2FnZSBmb3IgdGhlIGFnZW50XG4gICAqL1xuICBwcml2YXRlIGdldEhlbHBNZXNzYWdlKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGDwn6SWICoqRmlsZSBDcmVhdG9yIEFnZW50IEhlbHAqKlxuXG5JIHNwZWNpYWxpemUgaW4gY3JlYXRpbmcgZmlsZXMgZm9yIHlvdXIgZXhpc3RpbmcgcHJvamVjdHMhIEhlcmUncyBob3cgSSB3b3JrOlxuXG4qKvCfk4QgU3VwcG9ydGVkIEZpbGUgVHlwZXM6KipcbuKAoiAqKlNwcmVhZHNoZWV0cyoqIC0gQnVkZ2V0cywgY2FsY3VsYXRpb25zLCBkYXRhIHRyYWNraW5nXG7igKIgKipEb2N1bWVudHMqKiAtIFJlcG9ydHMsIHByb3Bvc2FscywgZm9ybWFsIGRvY3VtZW50cyAgXG7igKIgKipQcmVzZW50YXRpb25zKiogLSBNZWV0aW5nIHNsaWRlcywgcHJvcG9zYWxzXG7igKIgKipOb3RlcyoqIC0gTWVldGluZyBub3RlcywgZ2VuZXJhbCBub3Rlc1xu4oCiICoqUGxhbnMqKiAtIFByb2plY3QgcGxhbnMsIHN0cmF0ZWdpZXMsIHJvYWRtYXBzXG7igKIgKipCcmllZnMqKiAtIENyZWF0aXZlIGJyaWVmcywgcHJvamVjdCBvdmVydmlld3NcbuKAoiAqKkNoZWNrbGlzdHMqKiAtIFRhc2sgbGlzdHMsIHByb2Nlc3MgY2hlY2tsaXN0c1xu4oCiICoqTWFya2Rvd24qKiAtIEdlbmVyYWwgZG9jdW1lbnRhdGlvblxuXG4qKvCfjq8gSG93IHRvIFVzZToqKlxuMS4gKipUZWxsIG1lIHdoYXQgZmlsZSB5b3Ugd2FudDoqKiBcIkNyZWF0ZSBhIGJ1ZGdldCBzcHJlYWRzaGVldFwiXG4yLiAqKlNwZWNpZnkgdGhlIHByb2plY3Q6KiogXCJmb3IgTWFya2V0aW5nIENhbXBhaWduXCJcbjMuICoqSSdsbCBjcmVhdGUgaXQgd2l0aCBhIHRlbXBsYXRlISoqXG5cbioq4pyoIFF1aWNrIEV4YW1wbGVzOioqXG7igKIgXCJDcmVhdGUgYSBtZWV0aW5nIG5vdGVzIGZpbGUgZm9yIERldmVsb3BtZW50IFRlYW1cIlxu4oCiIFwiTWFrZSBhIHByb2plY3QgcGxhbiBmb3IgUTEgTGF1bmNoXCJcbuKAoiBcIkFkZCBhIGJ1ZGdldCBzcHJlYWRzaGVldCB0byBNYXJrZXRpbmcgUHJvamVjdFwiIFxu4oCiIFwiR2VuZXJhdGUgYSBwcmVzZW50YXRpb24gZm9yIENsaWVudCBSZXZpZXdcIlxuXG4qKvCflKcgU3BlY2lhbCBDb21tYW5kczoqKlxu4oCiIFR5cGUgXCIqKmZpbGUgdHlwZXMqKlwiIHRvIHNlZSBhbGwgYXZhaWxhYmxlIG9wdGlvbnNcbuKAoiBUeXBlIFwiKipoZWxwKipcIiB0byBzZWUgdGhpcyBtZXNzYWdlIGFnYWluXG5cbioq8J+SoSBQcm8gVGlwczoqKlxu4oCiIEknbGwgc3VnZ2VzdCBmaWxlIG5hbWVzIGlmIHlvdSBkb24ndCBwcm92aWRlIG9uZVxu4oCiIEFsbCBmaWxlcyBjb21lIHdpdGggaGVscGZ1bCB0ZW1wbGF0ZXNcbuKAoiBKdXN0IGRlc2NyaWJlIHdoYXQgeW91IG5lZWQgaW4gcGxhaW4gRW5nbGlzaCFcblxuUmVhZHkgdG8gY3JlYXRlIHNvbWUgZmlsZXM/IPCfmoBgO1xuICB9XG59XG5cbi8vIEV4cG9ydCBhbiBpbnN0YW5jZSBvZiB0aGUgYWdlbnQgZm9yIHVzZSBpbiB0aGUgcmVnaXN0cnlcbmV4cG9ydCBjb25zdCBmaWxlQ3JlYXRvckFnZW50ID0gbmV3IEZpbGVDcmVhdG9yQWdlbnQoKTtcbiJdLCJuYW1lcyI6WyJCYXNlQWdlbnQiLCJGaWxlQ3JlYXRvckFnZW50IiwiZXhlY3V0ZSIsInRvb2wiLCJpbnB1dCIsImNvbnZleE11dGF0aW9ucyIsImNvbnNvbGUiLCJsb2ciLCJwcm9jZXNzRmlsZUNyZWF0aW9uUmVxdWVzdCIsImVycm9yIiwiRXJyb3IiLCJtZXNzYWdlIiwibm9ybWFsaXplZElucHV0IiwidG9Mb3dlckNhc2UiLCJ0cmltIiwicGVuZGluZ0ZpbGVDcmVhdGlvbiIsInBlbmRpbmdBZ2UiLCJEYXRlIiwibm93IiwidGltZXN0YW1wIiwicHJvamVjdFNlbGVjdGlvblJlc3VsdCIsImhhbmRsZVByb2plY3RTZWxlY3Rpb24iLCJpc0hlbHBSZXF1ZXN0IiwiZ2V0SGVscE1lc3NhZ2UiLCJpc0ZpbGVUeXBlTGlzdFJlcXVlc3QiLCJnZXRGaWxlVHlwZU9wdGlvbnMiLCJmaWxlRGV0YWlscyIsImV4dHJhY3RGaWxlRGV0YWlscyIsImZpbGVOYW1lIiwiZmlsZVR5cGUiLCJnZXRDcmVhdGlvbkd1aWRhbmNlIiwicHJvamVjdE5hbWUiLCJnZXRQcm9qZWN0U2VsZWN0aW9uUHJvbXB0IiwiY3JlYXRlRmlsZSIsInByb2plY3RzIiwic2VsZWN0ZWRQcm9qZWN0IiwibnVtYmVyTWF0Y2giLCJtYXRjaCIsImluZGV4IiwicGFyc2VJbnQiLCJsZW5ndGgiLCJwcm9qZWN0U2VsZWN0aW9uUGF0dGVybnMiLCJwYXR0ZXJuIiwiZmluZCIsInAiLCJuYW1lIiwiaW5jbHVkZXMiLCJyZXN1bHQiLCJmb3JFYWNoIiwicHJvamVjdCIsInVwZGF0ZWRGaWxlRGV0YWlscyIsImhlbHBQYXR0ZXJucyIsInNvbWUiLCJ0ZXN0IiwibGlzdFBhdHRlcm5zIiwiZXh0ZW5zaW9uIiwiZmlsZU5hbWVQYXR0ZXJucyIsInJlcGxhY2UiLCJvcHRpb24iLCJmaWxlVHlwZU9wdGlvbnMiLCJ0eXBlUGF0dGVybnMiLCJSZWdFeHAiLCJ0eXBlIiwiZGVzY3JpcHRpb24iLCJzcGxpdCIsInByb2plY3RQYXR0ZXJucyIsInR5cGVXb3JkcyIsImpvaW4iLCJjb250ZW50IiwiZ2V0UHJvamVjdHMiLCJ0YXJnZXRQcm9qZWN0IiwibWFwIiwiZmlsZVR5cGVPcHRpb24iLCJnZW5lcmF0ZUZpbGVDb250ZW50IiwibmV3RmlsZSIsIm1hcFRvQ29udmV4RmlsZVR5cGUiLCJwcm9qZWN0SWQiLCJfaWQiLCJ0b0xvY2FsZURhdGVTdHJpbmciLCJjb250ZW50VGVtcGxhdGUiLCJ0eXBlTWFwIiwibWFya2Rvd24iLCJub3RlcyIsInBsYW4iLCJicmllZiIsImNoZWNrbGlzdCIsInNwcmVhZHNoZWV0IiwiZG9jdW1lbnQiLCJwcmVzZW50YXRpb24iLCJjaGFyQXQiLCJ0b1VwcGVyQ2FzZSIsInNsaWNlIiwiaWQiLCJpY29uIiwidG9vbHMiLCJjb21tYW5kIiwicGFyYW1ldGVycyIsImZpbGVDcmVhdG9yQWdlbnQiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./store/agents/fileCreatorAgent.ts\n"));

/***/ })

});