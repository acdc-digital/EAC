"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./store/agents/projectCreatorAgent.ts":
/*!*********************************************!*\
  !*** ./store/agents/projectCreatorAgent.ts ***!
  \*********************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ProjectCreatorAgent: () => (/* binding */ ProjectCreatorAgent),\n/* harmony export */   projectCreatorAgent: () => (/* binding */ projectCreatorAgent)\n/* harmony export */ });\n/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ \"(app-pages-browser)/./store/agents/base.ts\");\n// Project Creator Agent\n// Creates projects and files on behalf of users using natural language input\n\nclass ProjectCreatorAgent extends _base__WEBPACK_IMPORTED_MODULE_0__.BaseAgent {\n    async execute(tool, input, convexMutations) {\n        console.log('üöÄ ProjectCreatorAgent executing with input:', input);\n        try {\n            return await this.processNaturalLanguageRequest(input, convexMutations);\n        } catch (error) {\n            console.error('‚ùå ProjectCreatorAgent error:', error);\n            return \"‚ùå Failed to process request: \".concat(error instanceof Error ? error.message : 'Unknown error');\n        }\n    }\n    /**\n   * Process natural language requests to create projects and files\n   */ async processNaturalLanguageRequest(input, convexMutations) {\n        const normalizedInput = input.toLowerCase().trim();\n        console.log('üîç Processing natural language input:', normalizedInput);\n        console.log('üîç Has pending project creation:', !!ProjectCreatorAgent.pendingProjectCreation);\n        // Check for pending project creation (project name input response)\n        if (ProjectCreatorAgent.pendingProjectCreation) {\n            const pendingAge = Date.now() - ProjectCreatorAgent.pendingProjectCreation.timestamp;\n            console.log('‚è∞ Pending project creation age (ms):', pendingAge);\n            // If pending request is less than 5 minutes old, try to handle as project name input\n            if (pendingAge < 5 * 60 * 1000) {\n                console.log('üîÑ Trying to handle as project name input...');\n                const projectNameResult = await this.handleProjectNameInput(input, convexMutations);\n                console.log('üìã Project name input result:', projectNameResult);\n                if (projectNameResult) {\n                    console.log('‚úÖ Returning project name input result');\n                    return projectNameResult;\n                } else {\n                    console.log('‚ùå Project name input returned null');\n                    // Don't continue with normal processing - remind user to use the input\n                    return \"‚ö†Ô∏è **Please use the project name input above** to specify the project name.\\n\\nI'm still waiting for you to enter a project name.\\n\\n_To start a new project creation, wait for the current one to complete or cancel it first._\";\n                }\n            } else {\n                // Clear expired pending request\n                console.log('‚è∞ Clearing expired pending request');\n                ProjectCreatorAgent.pendingProjectCreation = null;\n            }\n        }\n        // Detect if this is a project creation request\n        if (this.isProjectCreationRequest(normalizedInput)) {\n            return await this.handleProjectCreation(input, convexMutations);\n        }\n        // Detect if this is a file creation request\n        if (this.isFileCreationRequest(normalizedInput)) {\n            return await this.handleFileCreation(input, convexMutations);\n        }\n        // Detect if this is a template setup request\n        if (this.isTemplateRequest(normalizedInput)) {\n            return await this.handleTemplateSetup(input, convexMutations);\n        }\n        // If we can't determine the intent, provide helpful guidance\n        return this.getHelpMessage();\n    }\n    /**\n   * Check if input is requesting project creation\n   */ isProjectCreationRequest(input) {\n        const projectPatterns = [\n            /create.*project/,\n            /new.*project/,\n            /make.*project/,\n            /start.*project/,\n            /build.*project/,\n            /setup.*project/\n        ];\n        return projectPatterns.some((pattern)=>pattern.test(input));\n    }\n    /**\n   * Check if input is requesting file creation\n   */ isFileCreationRequest(input) {\n        const filePatterns = [\n            /create.*file/,\n            /new.*file/,\n            /make.*file/,\n            /add.*file/,\n            /generate.*file/\n        ];\n        return filePatterns.some((pattern)=>pattern.test(input));\n    }\n    /**\n   * Check if input is requesting template setup\n   */ isTemplateRequest(input) {\n        const templatePatterns = [\n            /template/,\n            /scaffold/,\n            /boilerplate/,\n            /starter/,\n            /preset/\n        ];\n        return templatePatterns.some((pattern)=>pattern.test(input));\n    }\n    /**\n   * Handle project creation from natural language\n   */ async handleProjectCreation(input, convexMutations) {\n        try {\n            // Extract project details from natural language\n            const projectDetails = this.extractProjectDetails(input);\n            console.log('üìä Extracted project details:', projectDetails);\n            // If no specific project name was extracted or it's generic, show the input component\n            if (!projectDetails.name || projectDetails.name === '' || projectDetails.name === 'New Project' || projectDetails.name.length < 3) {\n                return await this.getProjectNameInputPrompt(projectDetails, convexMutations);\n            }\n            if (!convexMutations.createProject) {\n                return '‚ùå Project creation is not available. Please check system configuration.';\n            }\n            // Create the project\n            const newProject = await convexMutations.createProject({\n                name: projectDetails.name,\n                description: projectDetails.description,\n                status: 'active',\n                budget: projectDetails.budget\n            });\n            let result = \"‚úÖ **Project Created Successfully!**\\n\\n\";\n            result += \"\\uD83D\\uDCC1 **Project Name:** \".concat((newProject === null || newProject === void 0 ? void 0 : newProject.name) || projectDetails.name, \"\\n\");\n            if (newProject === null || newProject === void 0 ? void 0 : newProject.projectNumber) {\n                result += \"\\uD83D\\uDD22 **Project Number:** #\".concat(newProject.projectNumber, \"\\n\");\n            }\n            if (projectDetails.description) {\n                result += \"\\uD83D\\uDCDD **Description:** \".concat(projectDetails.description, \"\\n\");\n            }\n            result += \"\\uD83D\\uDCC5 **Created:** \".concat(new Date().toLocaleDateString(), \"\\n\");\n            result += \"\\uD83D\\uDCCA **Status:** Active\\n\\n\";\n            // Create initial files if requested\n            if (projectDetails.createFiles && convexMutations.createFile) {\n                const fileResults = await this.createInitialFiles(newProject, convexMutations);\n                result += \"\\n\\uD83D\\uDCC4 **Initial Files Created:**\\n\".concat(fileResults);\n            }\n            result += \"\\n\\uD83C\\uDF89 Your project is ready! You can now start adding files and managing your project.\";\n            return result;\n        } catch (error) {\n            console.error('‚ùå Project creation failed:', error);\n            return \"‚ùå **Project creation failed:** \".concat(error instanceof Error ? error.message : 'Unknown error');\n        }\n    }\n    /**\n   * Handle project name input response\n   */ async handleProjectNameInput(input, convexMutations) {\n        console.log('üéØ Handling project name input with input:', input);\n        console.log('üìÅ Pending project creation:', ProjectCreatorAgent.pendingProjectCreation);\n        if (!ProjectCreatorAgent.pendingProjectCreation) {\n            console.log('‚ùå No pending project creation found');\n            return null;\n        }\n        const { projectDetails } = ProjectCreatorAgent.pendingProjectCreation;\n        const projectName = input.trim();\n        console.log('üîç Project name input:', projectName);\n        if (!projectName || projectName.length < 2) {\n            return '‚ùå **Please enter a valid project name**\\n\\nProject names should be at least 2 characters long.\\n\\n**Examples:**\\n‚Ä¢ \"Marketing Campaign\"\\n‚Ä¢ \"Website Redesign\"\\n‚Ä¢ \"Q1 Budget Planning\"';\n        }\n        // Clear pending state\n        ProjectCreatorAgent.pendingProjectCreation = null;\n        console.log('‚úÖ Cleared pending project creation');\n        // Create the project with the provided name\n        const updatedProjectDetails = {\n            ...projectDetails,\n            name: projectName\n        };\n        console.log('üìÑ Creating project with details:', updatedProjectDetails);\n        if (!convexMutations.createProject) {\n            return '‚ùå Project creation is not available. Please check system configuration.';\n        }\n        try {\n            // Create the project\n            const newProject = await convexMutations.createProject({\n                name: updatedProjectDetails.name,\n                description: updatedProjectDetails.description,\n                status: 'active',\n                budget: updatedProjectDetails.budget\n            });\n            let result = \"‚úÖ **Project Created Successfully!**\\n\\n\";\n            result += \"\\uD83D\\uDCC1 **Project Name:** \".concat((newProject === null || newProject === void 0 ? void 0 : newProject.name) || updatedProjectDetails.name, \"\\n\");\n            if (newProject === null || newProject === void 0 ? void 0 : newProject.projectNumber) {\n                result += \"\\uD83D\\uDD22 **Project Number:** #\".concat(newProject.projectNumber, \"\\n\");\n            }\n            if (updatedProjectDetails.description) {\n                result += \"\\uD83D\\uDCDD **Description:** \".concat(updatedProjectDetails.description, \"\\n\");\n            }\n            result += \"\\uD83D\\uDCC5 **Created:** \".concat(new Date().toLocaleDateString(), \"\\n\");\n            result += \"\\uD83D\\uDCCA **Status:** Active\\n\\n\";\n            // Create initial files if requested\n            if (updatedProjectDetails.createFiles && convexMutations.createFile) {\n                const fileResults = await this.createInitialFiles(newProject, convexMutations);\n                result += \"\\n\\uD83D\\uDCC4 **Initial Files Created:**\\n\".concat(fileResults);\n            }\n            result += \"\\n\\uD83C\\uDF89 Your project is ready! You can now start adding files and managing your project.\";\n            console.log('üìù Create project result:', result);\n            return result;\n        } catch (error) {\n            console.error('‚ùå Project creation failed:', error);\n            return \"‚ùå **Project creation failed:** \".concat(error instanceof Error ? error.message : 'Unknown error');\n        }\n    }\n    /**\n   * Handle file creation from natural language\n   */ async handleFileCreation(input, convexMutations) {\n        try {\n            const fileDetails = this.extractFileDetails(input);\n            if (!fileDetails.fileName) {\n                return '‚ùå **Could not determine file name**\\n\\nPlease specify what file you want to create.\\n\\n**Examples:**\\n‚Ä¢ \"Create a budget spreadsheet\"\\n‚Ä¢ \"Add a meeting notes file\"\\n‚Ä¢ \"Make a project plan document\"';\n            }\n            if (!fileDetails.projectName) {\n                return '‚ùå **Could not determine project**\\n\\nPlease specify which project to add the file to.\\n\\n**Examples:**\\n‚Ä¢ \"Create a budget file for Marketing Campaign\"\\n‚Ä¢ \"Add notes to the Development Project\"';\n            }\n            if (!convexMutations.createFile) {\n                return '‚ùå File creation is not available. Please check system configuration.';\n            }\n            const content = this.generateFileContent(fileDetails.fileType, fileDetails.fileName);\n            // TODO: Need to look up project by name to get the projectId\n            // For now, this functionality is incomplete without project lookup\n            throw new Error('File creation requires a valid project. Project \"'.concat(fileDetails.projectName, '\" lookup not implemented yet.'));\n            let result = \"‚úÖ **File Created Successfully!**\\n\\n\";\n            result += \"\\uD83D\\uDCC4 **File Name:** \".concat(fileDetails.fileName, \"\\n\");\n            result += \"\\uD83D\\uDCC1 **Project:** \".concat(fileDetails.projectName, \"\\n\");\n            result += \"\\uD83C\\uDFF7Ô∏è **Type:** \".concat(fileDetails.fileType, \"\\n\");\n            result += \"\\uD83D\\uDCC5 **Created:** \".concat(new Date().toLocaleDateString(), \"\\n\\n\");\n            result += \"\\uD83D\\uDCA1 You can now find and edit this file in the sidebar!\";\n            return result;\n        } catch (error) {\n            console.error('‚ùå File creation failed:', error);\n            return \"‚ùå **File creation failed:** \".concat(error instanceof Error ? error.message : 'Unknown error');\n        }\n    }\n    /**\n   * Handle template setup from natural language\n   */ async handleTemplateSetup(input, convexMutations) {\n        try {\n            const templateDetails = this.extractTemplateDetails(input);\n            if (!convexMutations.createProject) {\n                return '‚ùå Project creation is not available. Please check system configuration.';\n            }\n            const projectName = templateDetails.name || \"\".concat(templateDetails.type.charAt(0).toUpperCase() + templateDetails.type.slice(1), \" Project\");\n            const newProject = await convexMutations.createProject({\n                name: projectName,\n                description: this.getTemplateDescription(templateDetails.type),\n                status: 'active',\n                budget: this.getTemplateBudget(templateDetails.type)\n            });\n            // Create template-specific files\n            let templateFiles = '';\n            if (convexMutations.createFile) {\n                templateFiles = await this.createTemplateFiles(newProject, templateDetails.type, convexMutations);\n            }\n            let result = \"‚úÖ **Template Applied Successfully!**\\n\\n\";\n            result += \"\\uD83D\\uDCC1 **Project Name:** \".concat((newProject === null || newProject === void 0 ? void 0 : newProject.name) || projectName, \"\\n\");\n            result += \"\\uD83C\\uDFA8 **Template Type:** \".concat(templateDetails.type.charAt(0).toUpperCase() + templateDetails.type.slice(1), \"\\n\");\n            if (newProject === null || newProject === void 0 ? void 0 : newProject.projectNumber) {\n                result += \"\\uD83D\\uDD22 **Project Number:** #\".concat(newProject.projectNumber, \"\\n\");\n            }\n            if (templateFiles) {\n                result += \"\\n\\uD83D\\uDCC4 **Template Files:**\\n\".concat(templateFiles, \"\\n\");\n            } else {\n                result += \"\\n\";\n            }\n            result += \"\\uD83C\\uDF89 Your template project is ready to use!\";\n            return result;\n        } catch (error) {\n            console.error('‚ùå Template setup failed:', error);\n            return \"‚ùå **Template setup failed:** \".concat(error instanceof Error ? error.message : 'Unknown error');\n        }\n    }\n    /**\n   * Extract project details from natural language input\n   */ extractProjectDetails(input) {\n        const normalizedInput = input.toLowerCase();\n        // Extract project name - more specific patterns that capture actual project names\n        const namePatterns = [\n            // Pattern for \"create project called [name]\" or \"create project named [name]\"\n            /(?:create|new|make|start|build|setup)\\s+(?:a\\s+)?project\\s+(?:called|named)\\s+[\\\"\\']?([^\\\"\\']+?)[\\\"\\']?(?:\\s+for|\\s+with|$)/i,\n            // Pattern for quoted names: \"project name\" or 'project name'\n            /[\\\"\\']([^\\\"\\']{2,})[\\\"\\']/,\n            // Pattern for specific project names after \"create\" (but not generic words)\n            /(?:create|new|make|start|build|setup)\\s+(?:a\\s+)?(?:project\\s+)?[\\\"\\']?([a-zA-Z][a-zA-Z0-9\\s\\-_]{2,})[\\\"\\']?(?:\\s+for|\\s+with|$)/i\n        ];\n        let name = '';\n        for (const pattern of namePatterns){\n            const match = input.match(pattern);\n            if (match && match[1]) {\n                const extractedName = match[1].trim();\n                // Reject generic/vague names that should trigger input prompt\n                const genericNames = [\n                    'project',\n                    'new project',\n                    'a project',\n                    'new',\n                    'it',\n                    'this',\n                    'that',\n                    'one'\n                ];\n                if (!genericNames.includes(extractedName.toLowerCase()) && extractedName.length > 2) {\n                    name = extractedName;\n                    break;\n                }\n            }\n        }\n        // If no specific name found, return empty string to trigger input component\n        if (!name) {\n            name = '';\n        }\n        // Extract description (words after \"for\", \"about\", \"to\")\n        const descriptionMatch = input.match(/(?:for|about|to)\\s+(.+)/i);\n        const description = descriptionMatch ? descriptionMatch[1].trim() : undefined;\n        // Detect project type from keywords\n        const typeKeywords = {\n            marketing: [\n                'marketing',\n                'campaign',\n                'promotion',\n                'advertising',\n                'brand'\n            ],\n            development: [\n                'development',\n                'dev',\n                'app',\n                'website',\n                'software',\n                'code'\n            ],\n            content: [\n                'content',\n                'blog',\n                'article',\n                'writing',\n                'editorial'\n            ],\n            financial: [\n                'financial',\n                'budget',\n                'finance',\n                'accounting',\n                'money'\n            ],\n            social: [\n                'social',\n                'instagram',\n                'twitter',\n                'facebook',\n                'media'\n            ]\n        };\n        let type;\n        for (const [projectType, keywords] of Object.entries(typeKeywords)){\n            if (keywords.some((keyword)=>normalizedInput.includes(keyword))) {\n                type = projectType;\n                break;\n            }\n        }\n        // Extract budget if mentioned\n        const budgetMatch = input.match(/\\$?([\\d,]+)/);\n        const budget = budgetMatch ? parseInt(budgetMatch[1].replace(/,/g, '')) : this.getDefaultBudget(type);\n        // Check if user wants initial files\n        const createFiles = /(?:with|include)\\s+(?:files|documents|templates)/i.test(input);\n        return {\n            name,\n            description,\n            type,\n            budget,\n            createFiles\n        };\n    }\n    /**\n   * Extract file details from natural language input\n   */ extractFileDetails(input) {\n        const normalizedInput = input.toLowerCase();\n        // Extract file name and type\n        let fileName = '';\n        let fileType = 'text';\n        // Common file patterns\n        const filePatterns = [\n            {\n                pattern: /(?:spreadsheet|excel|\\.xlsx?)/,\n                type: 'spreadsheet',\n                extension: '.xlsx'\n            },\n            {\n                pattern: /(?:document|doc|\\.docx?)/,\n                type: 'document',\n                extension: '.docx'\n            },\n            {\n                pattern: /(?:notes|\\.md|markdown)/,\n                type: 'markdown',\n                extension: '.md'\n            },\n            {\n                pattern: /(?:plan|planning)/,\n                type: 'document',\n                extension: '.md'\n            },\n            {\n                pattern: /(?:budget|financial)/,\n                type: 'spreadsheet',\n                extension: '.xlsx'\n            },\n            {\n                pattern: /(?:presentation|\\.pptx?)/,\n                type: 'presentation',\n                extension: '.pptx'\n            }\n        ];\n        for (const { pattern, type, extension } of filePatterns){\n            if (pattern.test(normalizedInput)) {\n                fileType = type;\n                // Extract specific file name if mentioned\n                const nameMatch = input.match(/(?:create|add|make)\\s+(?:a\\s+)?(.+?)(?:\\s+for|\\s+in|\\s+to|$)/i);\n                if (nameMatch && nameMatch[1]) {\n                    fileName = nameMatch[1].trim();\n                    if (!fileName.includes('.')) {\n                        fileName += extension;\n                    }\n                } else {\n                    fileName = \"\".concat(type).concat(extension);\n                }\n                break;\n            }\n        }\n        // Extract project name\n        const projectMatch = input.match(/(?:for|in|to)\\s+(?:the\\s+)?(.+?)(?:\\s+project)?$/i);\n        const projectName = projectMatch ? projectMatch[1].trim() : '';\n        return {\n            fileName: fileName || 'new-file.txt',\n            projectName,\n            fileType,\n            content: ''\n        };\n    }\n    /**\n   * Extract template details from natural language input\n   */ extractTemplateDetails(input) {\n        const normalizedInput = input.toLowerCase();\n        const templateTypes = [\n            'marketing',\n            'development',\n            'content',\n            'financial',\n            'social'\n        ];\n        let type = 'development'; // default\n        for (const templateType of templateTypes){\n            if (normalizedInput.includes(templateType)) {\n                type = templateType;\n                break;\n            }\n        }\n        // Extract custom name if provided\n        const nameMatch = input.match(/(?:template|scaffold)\\s+(?:for\\s+)?(.+)/i);\n        const name = nameMatch ? nameMatch[1].trim() : undefined;\n        return {\n            name,\n            type\n        };\n    }\n    /**\n   * Get default budget based on project type\n   */ getDefaultBudget(type) {\n        const budgets = {\n            marketing: 5000,\n            development: 15000,\n            content: 3000,\n            financial: 10000,\n            social: 2000\n        };\n        return budgets[type] || 10000;\n    }\n    /**\n   * Get template budget based on type\n   */ getTemplateBudget(type) {\n        return this.getDefaultBudget(type);\n    }\n    /**\n   * Get template description based on type\n   */ getTemplateDescription(type) {\n        const descriptions = {\n            marketing: 'Marketing campaign project with promotional materials and strategy planning',\n            development: 'Software development project with technical documentation and milestones',\n            content: 'Content creation project with editorial calendar and publishing workflow',\n            financial: 'Financial analysis project with budgets, forecasts, and reporting',\n            social: 'Social media project with content calendar and engagement strategies'\n        };\n        return descriptions[type] || 'General project template';\n    }\n    /**\n   * Create initial files for a project\n   */ async createInitialFiles(project, convexMutations) {\n        const files = [\n            {\n                name: 'README.md',\n                content: \"# \".concat((project === null || project === void 0 ? void 0 : project.name) || 'Project', \"\\n\\n\").concat((project === null || project === void 0 ? void 0 : project.description) || 'Project description', \"\\n\\n## Getting Started\\n\\nThis project was created using the EAC Project Creator Agent.\"),\n                type: 'note'\n            },\n            {\n                name: 'project-plan.md',\n                content: \"# Project Plan - \".concat((project === null || project === void 0 ? void 0 : project.name) || 'Project', \"\\n\\n## Objectives\\n\\n## Timeline\\n\\n## Resources\\n\\n## Milestones\\n\"),\n                type: 'note'\n            }\n        ];\n        const results = [];\n        for (const file of files){\n            try {\n                if (convexMutations.createFile) {\n                    await convexMutations.createFile({\n                        name: file.name,\n                        content: file.content,\n                        type: file.type,\n                        projectId: project === null || project === void 0 ? void 0 : project._id\n                    });\n                    results.push(\"‚úÖ \".concat(file.name));\n                }\n            } catch (error) {\n                results.push(\"‚ùå \".concat(file.name, \" (failed)\"));\n            }\n        }\n        return results.join('\\n');\n    }\n    /**\n   * Create template-specific files\n   */ async createTemplateFiles(project, templateType, convexMutations) {\n        const templateFiles = this.getTemplateFiles(templateType, (project === null || project === void 0 ? void 0 : project.name) || 'Project');\n        const results = [];\n        for (const file of templateFiles){\n            try {\n                if (convexMutations.createFile) {\n                    await convexMutations.createFile({\n                        name: file.name,\n                        content: file.content,\n                        type: file.type,\n                        projectId: project === null || project === void 0 ? void 0 : project._id\n                    });\n                    results.push(\"‚úÖ \".concat(file.name));\n                }\n            } catch (error) {\n                results.push(\"‚ùå \".concat(file.name, \" (failed)\"));\n            }\n        }\n        return results.join('\\n');\n    }\n    /**\n   * Get template files based on type\n   */ getTemplateFiles(type, projectName) {\n        const templates = {\n            marketing: [\n                {\n                    name: 'campaign-brief.md',\n                    content: \"# Campaign Brief - \".concat(projectName, \"\\n\\n## Objectives\\n\\n## Target Audience\\n\\n## Key Messages\\n\\n## Timeline\\n\"),\n                    type: 'note'\n                },\n                {\n                    name: 'budget.md',\n                    content: \"# Budget - \".concat(projectName, \"\\n\\n## Campaign Budget\\n\\n| Item | Amount |\\n|------|--------|\\n| Total | $0 |\\n\"),\n                    type: 'note'\n                }\n            ],\n            development: [\n                {\n                    name: 'README.md',\n                    content: \"# \".concat(projectName, \"\\n\\n## Setup\\n\\n## Development\\n\\n## Deployment\\n\"),\n                    type: 'note'\n                },\n                {\n                    name: 'requirements.md',\n                    content: \"# Requirements - \".concat(projectName, \"\\n\\n## Functional Requirements\\n\\n## Technical Requirements\\n\"),\n                    type: 'note'\n                }\n            ],\n            content: [\n                {\n                    name: 'content-calendar.md',\n                    content: \"# Content Calendar - \".concat(projectName, \"\\n\\n## Editorial Schedule\\n\\n## Content Topics\\n\"),\n                    type: 'note'\n                },\n                {\n                    name: 'style-guide.md',\n                    content: \"# Style Guide - \".concat(projectName, \"\\n\\n## Voice & Tone\\n\\n## Guidelines\\n\"),\n                    type: 'note'\n                }\n            ],\n            financial: [\n                {\n                    name: 'budget.md',\n                    content: \"# Budget - \".concat(projectName, \"\\n\\n## Revenue Projections\\n\\n## Expense Planning\\n\"),\n                    type: 'note'\n                },\n                {\n                    name: 'forecast.md',\n                    content: \"# Financial Forecast - \".concat(projectName, \"\\n\\n## Revenue Projections\\n\\n## Expense Planning\\n\"),\n                    type: 'note'\n                }\n            ],\n            social: [\n                {\n                    name: 'social-calendar.md',\n                    content: \"# Social Media Calendar - \".concat(projectName, \"\\n\\n## Content Schedule\\n\\n## Platform Strategy\\n\"),\n                    type: 'note'\n                },\n                {\n                    name: 'engagement-plan.md',\n                    content: \"# Engagement Plan - \".concat(projectName, \"\\n\\n## Community Guidelines\\n\\n## Response Templates\\n\"),\n                    type: 'note'\n                }\n            ]\n        };\n        return templates[type] || templates.development;\n    }\n    /**\n   * Generate file content based on type and name\n   */ generateFileContent(fileType, fileName) {\n        const baseContent = {\n            spreadsheet: \"# \".concat(fileName.replace(/\\.[^/.]+$/, \"\"), \"\\n\\n| Item | Amount |\\n|------|--------|\\n| Total | $0 |\\n\"),\n            document: \"# \".concat(fileName, \"\\n\\nDocument created on \").concat(new Date().toLocaleDateString(), \"\\n\\n## Section 1\\n\\n## Section 2\\n\"),\n            markdown: \"# \".concat(fileName.replace(/\\.[^/.]+$/, \"\"), \"\\n\\nCreated: \").concat(new Date().toLocaleDateString(), \"\\n\\n## Overview\\n\\n## Details\\n\"),\n            text: \"\".concat(fileName, \"\\n\\nCreated: \").concat(new Date().toLocaleDateString(), \"\\n\\nContent goes here...\")\n        };\n        return baseContent[fileType] || baseContent.text;\n    }\n    /**\n   * Map file type to Convex expected type\n   */ mapToConvexFileType(fileType) {\n        const typeMap = {\n            text: 'note',\n            markdown: 'note',\n            spreadsheet: 'document',\n            document: 'document',\n            presentation: 'document'\n        };\n        return typeMap[fileType] || 'note';\n    }\n    /**\n   * Get project name input prompt when project name is not specified or generic\n   */ async getProjectNameInputPrompt(projectDetails, convexMutations) {\n        try {\n            // Check if there's already a pending project creation\n            if (ProjectCreatorAgent.pendingProjectCreation) {\n                const pendingAge = Date.now() - ProjectCreatorAgent.pendingProjectCreation.timestamp;\n                // If pending request is less than 5 minutes old, remind user to use existing input\n                if (pendingAge < 5 * 60 * 1000) {\n                    return \"‚ö†Ô∏è **Please use the project name input above** to complete your previous project creation request.\\n\\nI'm still waiting for you to enter a project name.\\n\\n_To start a new project creation, wait for the current one to complete or cancel it first._\";\n                } else {\n                    // Clear expired pending request\n                    ProjectCreatorAgent.pendingProjectCreation = null;\n                }\n            }\n            // Store pending project creation state\n            ProjectCreatorAgent.pendingProjectCreation = {\n                projectDetails,\n                timestamp: Date.now()\n            };\n            // Store a message with interactive component for project name input\n            if (convexMutations.storeChatMessage) {\n                await convexMutations.storeChatMessage({\n                    role: 'assistant',\n                    content: \"\\uD83E\\uDD16 **Project Name Required**\\n\\nI'm ready to create your new project! Please enter a name for your project using the input below:\",\n                    processIndicator: {\n                        type: 'waiting',\n                        processType: 'project_name_input',\n                        color: 'green'\n                    },\n                    interactiveComponent: {\n                        type: 'project_selector',\n                        status: 'pending',\n                        data: {\n                            projectDetails,\n                            projectNameInput: true,\n                            placeholder: projectDetails.type ? \"\".concat(projectDetails.type.charAt(0).toUpperCase() + projectDetails.type.slice(1), \" Project\") : \"Enter project name...\"\n                        }\n                    }\n                });\n                // Return empty string since the interactive component will handle the response\n                return \"\";\n            } else {\n                // Fallback to text-based input if storeChatMessage is not available\n                let result = \"\\uD83E\\uDD16 **Project Name Required**\\n\\n\";\n                result += \"I'm ready to create your new project!\\n\\n\";\n                if (projectDetails.type) {\n                    result += \"**\\uD83C\\uDFAF Project Type:** \".concat(projectDetails.type.charAt(0).toUpperCase() + projectDetails.type.slice(1), \"\\n\");\n                }\n                if (projectDetails.description) {\n                    result += \"**\\uD83D\\uDCDD Description:** \".concat(projectDetails.description, \"\\n\");\n                }\n                if (projectDetails.budget) {\n                    result += \"**\\uD83D\\uDCB0 Budget:** $\".concat(projectDetails.budget.toLocaleString(), \"\\n\");\n                }\n                result += \"\\n**\\uD83D\\uDCDD Please provide a project name:**\\n\";\n                result += \"‚Ä¢ Type the project name in your next message\\n\";\n                result += '‚Ä¢ Examples: \"Marketing Campaign\", \"Website Redesign\", \"Q1 Budget Planning\"\\n\\n';\n                result += \"\\uD83D\\uDCA1 **Next message:** Just type your project name!\";\n                return result;\n            }\n        } catch (error) {\n            console.error('Error setting up project name input:', error);\n            return '\\uD83E\\uDD16 **Project Name Required**\\n\\nI\\'m ready to create your new project! Please provide a project name.\\n\\n**\\uD83D\\uDCA1 Tip:** You can say something like:\\n\"Marketing Campaign\" or \"Website Redesign Project\"';\n        }\n    }\n    /**\n   * Get help message for the agent\n   */ getHelpMessage() {\n        return '\\uD83E\\uDD16 **Project Creator Agent Help**\\n\\nI can help you create projects and files using natural language! Here are some examples:\\n\\n**\\uD83D\\uDCC1 Create Projects:**\\n‚Ä¢ \"Create a marketing project for Q1 campaign\"\\n‚Ä¢ \"Start a new development project called Mobile App\"\\n‚Ä¢ \"Make a content project with initial files\"\\n\\n**\\uD83D\\uDCC4 Create Files:**\\n‚Ä¢ \"Create a budget spreadsheet for Marketing Project\"\\n‚Ä¢ \"Add meeting notes to Development Project\"\\n‚Ä¢ \"Make a project plan document\"\\n\\n**\\uD83C\\uDFA8 Use Templates:**\\n‚Ä¢ \"Setup a marketing template\"\\n‚Ä¢ \"Create a development project from template\"\\n‚Ä¢ \"Apply financial template for Budget Analysis\"\\n\\nJust describe what you want to create and I\\'ll handle the rest! \\uD83D\\uDE80';\n    }\n    constructor(...args){\n        super(...args), this.id = 'project-creator', this.name = 'Project Creator', this.description = 'Creates projects and files on behalf of users using natural language', this.icon = 'FileText', this.tools = [\n            {\n                id: 'natural-language-creator',\n                name: 'Natural Language Creator',\n                command: 'create',\n                description: 'Create projects and files using natural language instructions',\n                parameters: []\n            }\n        ];\n    }\n}\n// State to track pending project creation\nProjectCreatorAgent.pendingProjectCreation = null;\n// Export an instance of the agent for use in the registry\nconst projectCreatorAgent = new ProjectCreatorAgent();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3N0b3JlL2FnZW50cy9wcm9qZWN0Q3JlYXRvckFnZW50LnRzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLHdCQUF3QjtBQUN4Qiw2RUFBNkU7QUFFL0I7QUFrQnZDLE1BQU1DLDRCQUE0QkQsNENBQVNBO0lBc0JoRCxNQUFNRSxRQUNKQyxJQUFlLEVBQ2ZDLEtBQWEsRUFDYkMsZUFBZ0MsRUFDZjtRQUNqQkMsUUFBUUMsR0FBRyxDQUFDLGdEQUFnREg7UUFFNUQsSUFBSTtZQUNGLE9BQU8sTUFBTSxJQUFJLENBQUNJLDZCQUE2QixDQUFDSixPQUFPQztRQUN6RCxFQUFFLE9BQU9JLE9BQU87WUFDZEgsUUFBUUcsS0FBSyxDQUFDLGdDQUFnQ0E7WUFDOUMsT0FBTyxnQ0FBeUYsT0FBekRBLGlCQUFpQkMsUUFBUUQsTUFBTUUsT0FBTyxHQUFHO1FBQ2xGO0lBQ0Y7SUFFQTs7R0FFQyxHQUNELE1BQWNILDhCQUNaSixLQUFhLEVBQ2JDLGVBQWdDLEVBQ2Y7UUFDakIsTUFBTU8sa0JBQWtCUixNQUFNUyxXQUFXLEdBQUdDLElBQUk7UUFDaERSLFFBQVFDLEdBQUcsQ0FBQyx5Q0FBeUNLO1FBQ3JETixRQUFRQyxHQUFHLENBQUMsb0NBQW9DLENBQUMsQ0FBQ04sb0JBQW9CYyxzQkFBc0I7UUFFNUYsbUVBQW1FO1FBQ25FLElBQUlkLG9CQUFvQmMsc0JBQXNCLEVBQUU7WUFDOUMsTUFBTUMsYUFBYUMsS0FBS0MsR0FBRyxLQUFLakIsb0JBQW9CYyxzQkFBc0IsQ0FBQ0ksU0FBUztZQUNwRmIsUUFBUUMsR0FBRyxDQUFDLHdDQUF3Q1M7WUFFcEQscUZBQXFGO1lBQ3JGLElBQUlBLGFBQWEsSUFBSSxLQUFLLE1BQU07Z0JBQzlCVixRQUFRQyxHQUFHLENBQUM7Z0JBQ1osTUFBTWEsb0JBQW9CLE1BQU0sSUFBSSxDQUFDQyxzQkFBc0IsQ0FBQ2pCLE9BQU9DO2dCQUNuRUMsUUFBUUMsR0FBRyxDQUFDLGlDQUFpQ2E7Z0JBQzdDLElBQUlB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TSxDQUFDaUYsY0FBYyxJQUFHO2dCQUN0RTtnQkFFQWhGLFVBQVc7Z0JBQ1hBLFVBQVc7Z0JBQ1hBLFVBQVc7Z0JBQ1hBLFVBQVc7Z0JBRVgsT0FBT0E7WUFDVDtRQUVGLEVBQUUsT0FBT3BDLE9BQU87WUFDZEgsUUFBUUcsS0FBSyxDQUFDLHdDQUF3Q0E7WUFDdEQsT0FBUTtRQU1WO0lBQ0Y7SUFFQTs7R0FFQyxHQUNELGlCQUFpQztRQUMvQixPQUFRO0lBb0JWOztRQXJ3QksscUJBQ0xxSCxLQUFLLHdCQUNMekYsT0FBTyx3QkFDUEssY0FBYyw2RUFDZHFGLE9BQU8saUJBUVBDLFFBQXFCO1lBQ25CO2dCQUNFRixJQUFJO2dCQUNKekYsTUFBTTtnQkFDTjRGLFNBQVM7Z0JBQ1R2RixhQUFhO2dCQUNid0YsWUFBWSxFQUFFO1lBQ2hCO1NBQ0Q7O0FBa3ZCSDtBQWh3QkUsMENBQTBDO0FBTi9Cakksb0JBT0ljLHlCQUdKO0FBOHZCYiwwREFBMEQ7QUFDbkQsTUFBTW9ILHNCQUFzQixJQUFJbEksc0JBQXNCIiwic291cmNlcyI6WyIvVXNlcnMvbWF0dGhld3NpbW9uL1Byb2plY3RzL2VhYy9lYWMvc3RvcmUvYWdlbnRzL3Byb2plY3RDcmVhdG9yQWdlbnQudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gUHJvamVjdCBDcmVhdG9yIEFnZW50XG4vLyBDcmVhdGVzIHByb2plY3RzIGFuZCBmaWxlcyBvbiBiZWhhbGYgb2YgdXNlcnMgdXNpbmcgbmF0dXJhbCBsYW5ndWFnZSBpbnB1dFxuXG5pbXBvcnQgeyBBZ2VudFRvb2wsIEJhc2VBZ2VudCB9IGZyb20gJy4vYmFzZSc7XG5pbXBvcnQgeyBDb252ZXhNdXRhdGlvbnMgfSBmcm9tICcuL3R5cGVzJztcblxuaW50ZXJmYWNlIFByb2plY3REZXRhaWxzIHtcbiAgbmFtZTogc3RyaW5nO1xuICBkZXNjcmlwdGlvbj86IHN0cmluZztcbiAgdHlwZT86IHN0cmluZztcbiAgYnVkZ2V0PzogbnVtYmVyO1xuICBjcmVhdGVGaWxlcz86IGJvb2xlYW47XG59XG5cbmludGVyZmFjZSBGaWxlRGV0YWlscyB7XG4gIGZpbGVOYW1lOiBzdHJpbmc7XG4gIHByb2plY3ROYW1lOiBzdHJpbmc7XG4gIGZpbGVUeXBlOiBzdHJpbmc7XG4gIGNvbnRlbnQ/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBjbGFzcyBQcm9qZWN0Q3JlYXRvckFnZW50IGV4dGVuZHMgQmFzZUFnZW50IHtcbiAgaWQgPSAncHJvamVjdC1jcmVhdG9yJztcbiAgbmFtZSA9ICdQcm9qZWN0IENyZWF0b3InO1xuICBkZXNjcmlwdGlvbiA9ICdDcmVhdGVzIHByb2plY3RzIGFuZCBmaWxlcyBvbiBiZWhhbGYgb2YgdXNlcnMgdXNpbmcgbmF0dXJhbCBsYW5ndWFnZSc7XG4gIGljb24gPSAnRmlsZVRleHQnO1xuXG4gIC8vIFN0YXRlIHRvIHRyYWNrIHBlbmRpbmcgcHJvamVjdCBjcmVhdGlvblxuICBwcml2YXRlIHN0YXRpYyBwZW5kaW5nUHJvamVjdENyZWF0aW9uOiB7XG4gICAgcHJvamVjdERldGFpbHM6IFBhcnRpYWw8UHJvamVjdERldGFpbHM+O1xuICAgIHRpbWVzdGFtcDogbnVtYmVyO1xuICB9IHwgbnVsbCA9IG51bGw7XG5cbiAgdG9vbHM6IEFnZW50VG9vbFtdID0gW1xuICAgIHtcbiAgICAgIGlkOiAnbmF0dXJhbC1sYW5ndWFnZS1jcmVhdG9yJyxcbiAgICAgIG5hbWU6ICdOYXR1cmFsIExhbmd1YWdlIENyZWF0b3InLFxuICAgICAgY29tbWFuZDogJ2NyZWF0ZScsXG4gICAgICBkZXNjcmlwdGlvbjogJ0NyZWF0ZSBwcm9qZWN0cyBhbmQgZmlsZXMgdXNpbmcgbmF0dXJhbCBsYW5ndWFnZSBpbnN0cnVjdGlvbnMnLFxuICAgICAgcGFyYW1ldGVyczogW11cbiAgICB9XG4gIF07XG5cbiAgYXN5bmMgZXhlY3V0ZShcbiAgICB0b29sOiBBZ2VudFRvb2wsXG4gICAgaW5wdXQ6IHN0cmluZyxcbiAgICBjb252ZXhNdXRhdGlvbnM6IENvbnZleE11dGF0aW9uc1xuICApOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIGNvbnNvbGUubG9nKCfwn5qAIFByb2plY3RDcmVhdG9yQWdlbnQgZXhlY3V0aW5nIHdpdGggaW5wdXQ6JywgaW5wdXQpO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5wcm9jZXNzTmF0dXJhbExhbmd1YWdlUmVxdWVzdChpbnB1dCwgY29udmV4TXV0YXRpb25zKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcign4p2MIFByb2plY3RDcmVhdG9yQWdlbnQgZXJyb3I6JywgZXJyb3IpO1xuICAgICAgcmV0dXJuIGDinYwgRmFpbGVkIHRvIHByb2Nlc3MgcmVxdWVzdDogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJ31gO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBQcm9jZXNzIG5hdHVyYWwgbGFuZ3VhZ2UgcmVxdWVzdHMgdG8gY3JlYXRlIHByb2plY3RzIGFuZCBmaWxlc1xuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBwcm9jZXNzTmF0dXJhbExhbmd1YWdlUmVxdWVzdChcbiAgICBpbnB1dDogc3RyaW5nLFxuICAgIGNvbnZleE11dGF0aW9uczogQ29udmV4TXV0YXRpb25zXG4gICk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgY29uc3Qgbm9ybWFsaXplZElucHV0ID0gaW5wdXQudG9Mb3dlckNhc2UoKS50cmltKCk7XG4gICAgY29uc29sZS5sb2coJ/CflI0gUHJvY2Vzc2luZyBuYXR1cmFsIGxhbmd1YWdlIGlucHV0OicsIG5vcm1hbGl6ZWRJbnB1dCk7XG4gICAgY29uc29sZS5sb2coJ/CflI0gSGFzIHBlbmRpbmcgcHJvamVjdCBjcmVhdGlvbjonLCAhIVByb2plY3RDcmVhdG9yQWdlbnQucGVuZGluZ1Byb2plY3RDcmVhdGlvbik7XG5cbiAgICAvLyBDaGVjayBmb3IgcGVuZGluZyBwcm9qZWN0IGNyZWF0aW9uIChwcm9qZWN0IG5hbWUgaW5wdXQgcmVzcG9uc2UpXG4gICAgaWYgKFByb2plY3RDcmVhdG9yQWdlbnQucGVuZGluZ1Byb2plY3RDcmVhdGlvbikge1xuICAgICAgY29uc3QgcGVuZGluZ0FnZSA9IERhdGUubm93KCkgLSBQcm9qZWN0Q3JlYXRvckFnZW50LnBlbmRpbmdQcm9qZWN0Q3JlYXRpb24udGltZXN0YW1wO1xuICAgICAgY29uc29sZS5sb2coJ+KPsCBQZW5kaW5nIHByb2plY3QgY3JlYXRpb24gYWdlIChtcyk6JywgcGVuZGluZ0FnZSk7XG4gICAgICBcbiAgICAgIC8vIElmIHBlbmRpbmcgcmVxdWVzdCBpcyBsZXNzIHRoYW4gNSBtaW51dGVzIG9sZCwgdHJ5IHRvIGhhbmRsZSBhcyBwcm9qZWN0IG5hbWUgaW5wdXRcbiAgICAgIGlmIChwZW5kaW5nQWdlIDwgNSAqIDYwICogMTAwMCkge1xuICAgICAgICBjb25zb2xlLmxvZygn8J+UhCBUcnlpbmcgdG8gaGFuZGxlIGFzIHByb2plY3QgbmFtZSBpbnB1dC4uLicpO1xuICAgICAgICBjb25zdCBwcm9qZWN0TmFtZVJlc3VsdCA9IGF3YWl0IHRoaXMuaGFuZGxlUHJvamVjdE5hbWVJbnB1dChpbnB1dCwgY29udmV4TXV0YXRpb25zKTtcbiAgICAgICAgY29uc29sZS5sb2coJ/Cfk4sgUHJvamVjdCBuYW1lIGlucHV0IHJlc3VsdDonLCBwcm9qZWN0TmFtZVJlc3VsdCk7XG4gICAgICAgIGlmIChwcm9qZWN0TmFtZVJlc3VsdCkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCfinIUgUmV0dXJuaW5nIHByb2plY3QgbmFtZSBpbnB1dCByZXN1bHQnKTtcbiAgICAgICAgICByZXR1cm4gcHJvamVjdE5hbWVSZXN1bHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ+KdjCBQcm9qZWN0IG5hbWUgaW5wdXQgcmV0dXJuZWQgbnVsbCcpO1xuICAgICAgICAgIC8vIERvbid0IGNvbnRpbnVlIHdpdGggbm9ybWFsIHByb2Nlc3NpbmcgLSByZW1pbmQgdXNlciB0byB1c2UgdGhlIGlucHV0XG4gICAgICAgICAgcmV0dXJuIGDimqDvuI8gKipQbGVhc2UgdXNlIHRoZSBwcm9qZWN0IG5hbWUgaW5wdXQgYWJvdmUqKiB0byBzcGVjaWZ5IHRoZSBwcm9qZWN0IG5hbWUuXFxuXFxuSSdtIHN0aWxsIHdhaXRpbmcgZm9yIHlvdSB0byBlbnRlciBhIHByb2plY3QgbmFtZS5cXG5cXG5fVG8gc3RhcnQgYSBuZXcgcHJvamVjdCBjcmVhdGlvbiwgd2FpdCBmb3IgdGhlIGN1cnJlbnQgb25lIHRvIGNvbXBsZXRlIG9yIGNhbmNlbCBpdCBmaXJzdC5fYDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQ2xlYXIgZXhwaXJlZCBwZW5kaW5nIHJlcXVlc3RcbiAgICAgICAgY29uc29sZS5sb2coJ+KPsCBDbGVhcmluZyBleHBpcmVkIHBlbmRpbmcgcmVxdWVzdCcpO1xuICAgICAgICBQcm9qZWN0Q3JlYXRvckFnZW50LnBlbmRpbmdQcm9qZWN0Q3JlYXRpb24gPSBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIERldGVjdCBpZiB0aGlzIGlzIGEgcHJvamVjdCBjcmVhdGlvbiByZXF1ZXN0XG4gICAgaWYgKHRoaXMuaXNQcm9qZWN0Q3JlYXRpb25SZXF1ZXN0KG5vcm1hbGl6ZWRJbnB1dCkpIHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLmhhbmRsZVByb2plY3RDcmVhdGlvbihpbnB1dCwgY29udmV4TXV0YXRpb25zKTtcbiAgICB9XG4gICAgXG4gICAgLy8gRGV0ZWN0IGlmIHRoaXMgaXMgYSBmaWxlIGNyZWF0aW9uIHJlcXVlc3RcbiAgICBpZiAodGhpcy5pc0ZpbGVDcmVhdGlvblJlcXVlc3Qobm9ybWFsaXplZElucHV0KSkge1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuaGFuZGxlRmlsZUNyZWF0aW9uKGlucHV0LCBjb252ZXhNdXRhdGlvbnMpO1xuICAgIH1cbiAgICBcbiAgICAvLyBEZXRlY3QgaWYgdGhpcyBpcyBhIHRlbXBsYXRlIHNldHVwIHJlcXVlc3RcbiAgICBpZiAodGhpcy5pc1RlbXBsYXRlUmVxdWVzdChub3JtYWxpemVkSW5wdXQpKSB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5oYW5kbGVUZW1wbGF0ZVNldHVwKGlucHV0LCBjb252ZXhNdXRhdGlvbnMpO1xuICAgIH1cbiAgICBcbiAgICAvLyBJZiB3ZSBjYW4ndCBkZXRlcm1pbmUgdGhlIGludGVudCwgcHJvdmlkZSBoZWxwZnVsIGd1aWRhbmNlXG4gICAgcmV0dXJuIHRoaXMuZ2V0SGVscE1lc3NhZ2UoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBpbnB1dCBpcyByZXF1ZXN0aW5nIHByb2plY3QgY3JlYXRpb25cbiAgICovXG4gIHByaXZhdGUgaXNQcm9qZWN0Q3JlYXRpb25SZXF1ZXN0KGlucHV0OiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICBjb25zdCBwcm9qZWN0UGF0dGVybnMgPSBbXG4gICAgICAvY3JlYXRlLipwcm9qZWN0LyxcbiAgICAgIC9uZXcuKnByb2plY3QvLFxuICAgICAgL21ha2UuKnByb2plY3QvLFxuICAgICAgL3N0YXJ0Lipwcm9qZWN0LyxcbiAgICAgIC9idWlsZC4qcHJvamVjdC8sXG4gICAgICAvc2V0dXAuKnByb2plY3QvXG4gICAgXTtcbiAgICByZXR1cm4gcHJvamVjdFBhdHRlcm5zLnNvbWUocGF0dGVybiA9PiBwYXR0ZXJuLnRlc3QoaW5wdXQpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBpbnB1dCBpcyByZXF1ZXN0aW5nIGZpbGUgY3JlYXRpb25cbiAgICovXG4gIHByaXZhdGUgaXNGaWxlQ3JlYXRpb25SZXF1ZXN0KGlucHV0OiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICBjb25zdCBmaWxlUGF0dGVybnMgPSBbXG4gICAgICAvY3JlYXRlLipmaWxlLyxcbiAgICAgIC9uZXcuKmZpbGUvLFxuICAgICAgL21ha2UuKmZpbGUvLFxuICAgICAgL2FkZC4qZmlsZS8sXG4gICAgICAvZ2VuZXJhdGUuKmZpbGUvXG4gICAgXTtcbiAgICByZXR1cm4gZmlsZVBhdHRlcm5zLnNvbWUocGF0dGVybiA9PiBwYXR0ZXJuLnRlc3QoaW5wdXQpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBpbnB1dCBpcyByZXF1ZXN0aW5nIHRlbXBsYXRlIHNldHVwXG4gICAqL1xuICBwcml2YXRlIGlzVGVtcGxhdGVSZXF1ZXN0KGlucHV0OiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICBjb25zdCB0ZW1wbGF0ZVBhdHRlcm5zID0gW1xuICAgICAgL3RlbXBsYXRlLyxcbiAgICAgIC9zY2FmZm9sZC8sXG4gICAgICAvYm9pbGVycGxhdGUvLFxuICAgICAgL3N0YXJ0ZXIvLFxuICAgICAgL3ByZXNldC9cbiAgICBdO1xuICAgIHJldHVybiB0ZW1wbGF0ZVBhdHRlcm5zLnNvbWUocGF0dGVybiA9PiBwYXR0ZXJuLnRlc3QoaW5wdXQpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgcHJvamVjdCBjcmVhdGlvbiBmcm9tIG5hdHVyYWwgbGFuZ3VhZ2VcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgaGFuZGxlUHJvamVjdENyZWF0aW9uKFxuICAgIGlucHV0OiBzdHJpbmcsXG4gICAgY29udmV4TXV0YXRpb25zOiBDb252ZXhNdXRhdGlvbnNcbiAgKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICB0cnkge1xuICAgICAgLy8gRXh0cmFjdCBwcm9qZWN0IGRldGFpbHMgZnJvbSBuYXR1cmFsIGxhbmd1YWdlXG4gICAgICBjb25zdCBwcm9qZWN0RGV0YWlscyA9IHRoaXMuZXh0cmFjdFByb2plY3REZXRhaWxzKGlucHV0KTtcbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coJ/Cfk4ogRXh0cmFjdGVkIHByb2plY3QgZGV0YWlsczonLCBwcm9qZWN0RGV0YWlscyk7XG5cbiAgICAgIC8vIElmIG5vIHNwZWNpZmljIHByb2plY3QgbmFtZSB3YXMgZXh0cmFjdGVkIG9yIGl0J3MgZ2VuZXJpYywgc2hvdyB0aGUgaW5wdXQgY29tcG9uZW50XG4gICAgICBpZiAoIXByb2plY3REZXRhaWxzLm5hbWUgfHwgcHJvamVjdERldGFpbHMubmFtZSA9PT0gJycgfHwgcHJvamVjdERldGFpbHMubmFtZSA9PT0gJ05ldyBQcm9qZWN0JyB8fCBwcm9qZWN0RGV0YWlscy5uYW1lLmxlbmd0aCA8IDMpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZ2V0UHJvamVjdE5hbWVJbnB1dFByb21wdChwcm9qZWN0RGV0YWlscywgY29udmV4TXV0YXRpb25zKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFjb252ZXhNdXRhdGlvbnMuY3JlYXRlUHJvamVjdCkge1xuICAgICAgICByZXR1cm4gJ+KdjCBQcm9qZWN0IGNyZWF0aW9uIGlzIG5vdCBhdmFpbGFibGUuIFBsZWFzZSBjaGVjayBzeXN0ZW0gY29uZmlndXJhdGlvbi4nO1xuICAgICAgfVxuXG4gICAgICAvLyBDcmVhdGUgdGhlIHByb2plY3RcbiAgICAgIGNvbnN0IG5ld1Byb2plY3QgPSBhd2FpdCBjb252ZXhNdXRhdGlvbnMuY3JlYXRlUHJvamVjdCh7XG4gICAgICAgIG5hbWU6IHByb2plY3REZXRhaWxzLm5hbWUsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBwcm9qZWN0RGV0YWlscy5kZXNjcmlwdGlvbixcbiAgICAgICAgc3RhdHVzOiAnYWN0aXZlJyBhcyBjb25zdCxcbiAgICAgICAgYnVkZ2V0OiBwcm9qZWN0RGV0YWlscy5idWRnZXQsXG4gICAgICB9KTtcblxuICAgICAgbGV0IHJlc3VsdCA9IGDinIUgKipQcm9qZWN0IENyZWF0ZWQgU3VjY2Vzc2Z1bGx5ISoqXFxuXFxuYDtcbiAgICAgIHJlc3VsdCArPSBg8J+TgSAqKlByb2plY3QgTmFtZToqKiAkeyhuZXdQcm9qZWN0IGFzIGFueSk/Lm5hbWUgfHwgcHJvamVjdERldGFpbHMubmFtZX1cXG5gO1xuICAgICAgXG4gICAgICBpZiAoKG5ld1Byb2plY3QgYXMgYW55KT8ucHJvamVjdE51bWJlcikge1xuICAgICAgICByZXN1bHQgKz0gYPCflKIgKipQcm9qZWN0IE51bWJlcjoqKiAjJHsobmV3UHJvamVjdCBhcyBhbnkpLnByb2plY3ROdW1iZXJ9XFxuYDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgaWYgKHByb2plY3REZXRhaWxzLmRlc2NyaXB0aW9uKSB7XG4gICAgICAgIHJlc3VsdCArPSBg8J+TnSAqKkRlc2NyaXB0aW9uOioqICR7cHJvamVjdERldGFpbHMuZGVzY3JpcHRpb259XFxuYDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmVzdWx0ICs9IGDwn5OFICoqQ3JlYXRlZDoqKiAke25ldyBEYXRlKCkudG9Mb2NhbGVEYXRlU3RyaW5nKCl9XFxuYDtcbiAgICAgIHJlc3VsdCArPSBg8J+TiiAqKlN0YXR1czoqKiBBY3RpdmVcXG5cXG5gO1xuXG4gICAgICAvLyBDcmVhdGUgaW5pdGlhbCBmaWxlcyBpZiByZXF1ZXN0ZWRcbiAgICAgIGlmIChwcm9qZWN0RGV0YWlscy5jcmVhdGVGaWxlcyAmJiBjb252ZXhNdXRhdGlvbnMuY3JlYXRlRmlsZSkge1xuICAgICAgICBjb25zdCBmaWxlUmVzdWx0cyA9IGF3YWl0IHRoaXMuY3JlYXRlSW5pdGlhbEZpbGVzKG5ld1Byb2plY3QsIGNvbnZleE11dGF0aW9ucyk7XG4gICAgICAgIHJlc3VsdCArPSBgXFxu8J+ThCAqKkluaXRpYWwgRmlsZXMgQ3JlYXRlZDoqKlxcbiR7ZmlsZVJlc3VsdHN9YDtcbiAgICAgIH1cblxuICAgICAgcmVzdWx0ICs9IGBcXG7wn46JIFlvdXIgcHJvamVjdCBpcyByZWFkeSEgWW91IGNhbiBub3cgc3RhcnQgYWRkaW5nIGZpbGVzIGFuZCBtYW5hZ2luZyB5b3VyIHByb2plY3QuYDtcbiAgICAgIFxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcign4p2MIFByb2plY3QgY3JlYXRpb24gZmFpbGVkOicsIGVycm9yKTtcbiAgICAgIHJldHVybiBg4p2MICoqUHJvamVjdCBjcmVhdGlvbiBmYWlsZWQ6KiogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJ31gO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgcHJvamVjdCBuYW1lIGlucHV0IHJlc3BvbnNlXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGhhbmRsZVByb2plY3ROYW1lSW5wdXQoaW5wdXQ6IHN0cmluZywgY29udmV4TXV0YXRpb25zOiBDb252ZXhNdXRhdGlvbnMpOiBQcm9taXNlPHN0cmluZyB8IG51bGw+IHtcbiAgICBjb25zb2xlLmxvZygn8J+OryBIYW5kbGluZyBwcm9qZWN0IG5hbWUgaW5wdXQgd2l0aCBpbnB1dDonLCBpbnB1dCk7XG4gICAgY29uc29sZS5sb2coJ/Cfk4EgUGVuZGluZyBwcm9qZWN0IGNyZWF0aW9uOicsIFByb2plY3RDcmVhdG9yQWdlbnQucGVuZGluZ1Byb2plY3RDcmVhdGlvbik7XG4gICAgXG4gICAgaWYgKCFQcm9qZWN0Q3JlYXRvckFnZW50LnBlbmRpbmdQcm9qZWN0Q3JlYXRpb24pIHtcbiAgICAgIGNvbnNvbGUubG9nKCfinYwgTm8gcGVuZGluZyBwcm9qZWN0IGNyZWF0aW9uIGZvdW5kJyk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCB7IHByb2plY3REZXRhaWxzIH0gPSBQcm9qZWN0Q3JlYXRvckFnZW50LnBlbmRpbmdQcm9qZWN0Q3JlYXRpb247XG4gICAgY29uc3QgcHJvamVjdE5hbWUgPSBpbnB1dC50cmltKCk7XG4gICAgY29uc29sZS5sb2coJ/CflI0gUHJvamVjdCBuYW1lIGlucHV0OicsIHByb2plY3ROYW1lKTtcblxuICAgIGlmICghcHJvamVjdE5hbWUgfHwgcHJvamVjdE5hbWUubGVuZ3RoIDwgMikge1xuICAgICAgcmV0dXJuIGDinYwgKipQbGVhc2UgZW50ZXIgYSB2YWxpZCBwcm9qZWN0IG5hbWUqKlxcblxcblByb2plY3QgbmFtZXMgc2hvdWxkIGJlIGF0IGxlYXN0IDIgY2hhcmFjdGVycyBsb25nLlxcblxcbioqRXhhbXBsZXM6KipcXG7igKIgXCJNYXJrZXRpbmcgQ2FtcGFpZ25cIlxcbuKAoiBcIldlYnNpdGUgUmVkZXNpZ25cIlxcbuKAoiBcIlExIEJ1ZGdldCBQbGFubmluZ1wiYDtcbiAgICB9XG5cbiAgICAvLyBDbGVhciBwZW5kaW5nIHN0YXRlXG4gICAgUHJvamVjdENyZWF0b3JBZ2VudC5wZW5kaW5nUHJvamVjdENyZWF0aW9uID0gbnVsbDtcbiAgICBjb25zb2xlLmxvZygn4pyFIENsZWFyZWQgcGVuZGluZyBwcm9qZWN0IGNyZWF0aW9uJyk7XG5cbiAgICAvLyBDcmVhdGUgdGhlIHByb2plY3Qgd2l0aCB0aGUgcHJvdmlkZWQgbmFtZVxuICAgIGNvbnN0IHVwZGF0ZWRQcm9qZWN0RGV0YWlscyA9IHtcbiAgICAgIC4uLnByb2plY3REZXRhaWxzLFxuICAgICAgbmFtZTogcHJvamVjdE5hbWVcbiAgICB9O1xuXG4gICAgY29uc29sZS5sb2coJ/Cfk4QgQ3JlYXRpbmcgcHJvamVjdCB3aXRoIGRldGFpbHM6JywgdXBkYXRlZFByb2plY3REZXRhaWxzKTtcbiAgICBcbiAgICBpZiAoIWNvbnZleE11dGF0aW9ucy5jcmVhdGVQcm9qZWN0KSB7XG4gICAgICByZXR1cm4gJ+KdjCBQcm9qZWN0IGNyZWF0aW9uIGlzIG5vdCBhdmFpbGFibGUuIFBsZWFzZSBjaGVjayBzeXN0ZW0gY29uZmlndXJhdGlvbi4nO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICAvLyBDcmVhdGUgdGhlIHByb2plY3RcbiAgICAgIGNvbnN0IG5ld1Byb2plY3QgPSBhd2FpdCBjb252ZXhNdXRhdGlvbnMuY3JlYXRlUHJvamVjdCh7XG4gICAgICAgIG5hbWU6IHVwZGF0ZWRQcm9qZWN0RGV0YWlscy5uYW1lLFxuICAgICAgICBkZXNjcmlwdGlvbjogdXBkYXRlZFByb2plY3REZXRhaWxzLmRlc2NyaXB0aW9uLFxuICAgICAgICBzdGF0dXM6ICdhY3RpdmUnIGFzIGNvbnN0LFxuICAgICAgICBidWRnZXQ6IHVwZGF0ZWRQcm9qZWN0RGV0YWlscy5idWRnZXQsXG4gICAgICB9KTtcblxuICAgICAgbGV0IHJlc3VsdCA9IGDinIUgKipQcm9qZWN0IENyZWF0ZWQgU3VjY2Vzc2Z1bGx5ISoqXFxuXFxuYDtcbiAgICAgIHJlc3VsdCArPSBg8J+TgSAqKlByb2plY3QgTmFtZToqKiAkeyhuZXdQcm9qZWN0IGFzIGFueSk/Lm5hbWUgfHwgdXBkYXRlZFByb2plY3REZXRhaWxzLm5hbWV9XFxuYDtcbiAgICAgIFxuICAgICAgaWYgKChuZXdQcm9qZWN0IGFzIGFueSk/LnByb2plY3ROdW1iZXIpIHtcbiAgICAgICAgcmVzdWx0ICs9IGDwn5SiICoqUHJvamVjdCBOdW1iZXI6KiogIyR7KG5ld1Byb2plY3QgYXMgYW55KS5wcm9qZWN0TnVtYmVyfVxcbmA7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmICh1cGRhdGVkUHJvamVjdERldGFpbHMuZGVzY3JpcHRpb24pIHtcbiAgICAgICAgcmVzdWx0ICs9IGDwn5OdICoqRGVzY3JpcHRpb246KiogJHt1cGRhdGVkUHJvamVjdERldGFpbHMuZGVzY3JpcHRpb259XFxuYDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmVzdWx0ICs9IGDwn5OFICoqQ3JlYXRlZDoqKiAke25ldyBEYXRlKCkudG9Mb2NhbGVEYXRlU3RyaW5nKCl9XFxuYDtcbiAgICAgIHJlc3VsdCArPSBg8J+TiiAqKlN0YXR1czoqKiBBY3RpdmVcXG5cXG5gO1xuXG4gICAgICAvLyBDcmVhdGUgaW5pdGlhbCBmaWxlcyBpZiByZXF1ZXN0ZWRcbiAgICAgIGlmICh1cGRhdGVkUHJvamVjdERldGFpbHMuY3JlYXRlRmlsZXMgJiYgY29udmV4TXV0YXRpb25zLmNyZWF0ZUZpbGUpIHtcbiAgICAgICAgY29uc3QgZmlsZVJlc3VsdHMgPSBhd2FpdCB0aGlzLmNyZWF0ZUluaXRpYWxGaWxlcyhuZXdQcm9qZWN0LCBjb252ZXhNdXRhdGlvbnMpO1xuICAgICAgICByZXN1bHQgKz0gYFxcbvCfk4QgKipJbml0aWFsIEZpbGVzIENyZWF0ZWQ6KipcXG4ke2ZpbGVSZXN1bHRzfWA7XG4gICAgICB9XG5cbiAgICAgIHJlc3VsdCArPSBgXFxu8J+OiSBZb3VyIHByb2plY3QgaXMgcmVhZHkhIFlvdSBjYW4gbm93IHN0YXJ0IGFkZGluZyBmaWxlcyBhbmQgbWFuYWdpbmcgeW91ciBwcm9qZWN0LmA7XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKCfwn5OdIENyZWF0ZSBwcm9qZWN0IHJlc3VsdDonLCByZXN1bHQpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcign4p2MIFByb2plY3QgY3JlYXRpb24gZmFpbGVkOicsIGVycm9yKTtcbiAgICAgIHJldHVybiBg4p2MICoqUHJvamVjdCBjcmVhdGlvbiBmYWlsZWQ6KiogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJ31gO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgZmlsZSBjcmVhdGlvbiBmcm9tIG5hdHVyYWwgbGFuZ3VhZ2VcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgaGFuZGxlRmlsZUNyZWF0aW9uKFxuICAgIGlucHV0OiBzdHJpbmcsXG4gICAgY29udmV4TXV0YXRpb25zOiBDb252ZXhNdXRhdGlvbnNcbiAgKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZmlsZURldGFpbHMgPSB0aGlzLmV4dHJhY3RGaWxlRGV0YWlscyhpbnB1dCk7XG4gICAgICBcbiAgICAgIGlmICghZmlsZURldGFpbHMuZmlsZU5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGDinYwgKipDb3VsZCBub3QgZGV0ZXJtaW5lIGZpbGUgbmFtZSoqXFxuXFxuUGxlYXNlIHNwZWNpZnkgd2hhdCBmaWxlIHlvdSB3YW50IHRvIGNyZWF0ZS5cXG5cXG4qKkV4YW1wbGVzOioqXFxu4oCiIFwiQ3JlYXRlIGEgYnVkZ2V0IHNwcmVhZHNoZWV0XCJcXG7igKIgXCJBZGQgYSBtZWV0aW5nIG5vdGVzIGZpbGVcIlxcbuKAoiBcIk1ha2UgYSBwcm9qZWN0IHBsYW4gZG9jdW1lbnRcImA7XG4gICAgICB9XG5cbiAgICAgIGlmICghZmlsZURldGFpbHMucHJvamVjdE5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGDinYwgKipDb3VsZCBub3QgZGV0ZXJtaW5lIHByb2plY3QqKlxcblxcblBsZWFzZSBzcGVjaWZ5IHdoaWNoIHByb2plY3QgdG8gYWRkIHRoZSBmaWxlIHRvLlxcblxcbioqRXhhbXBsZXM6KipcXG7igKIgXCJDcmVhdGUgYSBidWRnZXQgZmlsZSBmb3IgTWFya2V0aW5nIENhbXBhaWduXCJcXG7igKIgXCJBZGQgbm90ZXMgdG8gdGhlIERldmVsb3BtZW50IFByb2plY3RcImA7XG4gICAgICB9XG5cbiAgICAgIGlmICghY29udmV4TXV0YXRpb25zLmNyZWF0ZUZpbGUpIHtcbiAgICAgICAgcmV0dXJuICfinYwgRmlsZSBjcmVhdGlvbiBpcyBub3QgYXZhaWxhYmxlLiBQbGVhc2UgY2hlY2sgc3lzdGVtIGNvbmZpZ3VyYXRpb24uJztcbiAgICAgIH1cblxuICAgICAgY29uc3QgY29udGVudCA9IHRoaXMuZ2VuZXJhdGVGaWxlQ29udGVudChmaWxlRGV0YWlscy5maWxlVHlwZSwgZmlsZURldGFpbHMuZmlsZU5hbWUpO1xuXG4gICAgICAvLyBUT0RPOiBOZWVkIHRvIGxvb2sgdXAgcHJvamVjdCBieSBuYW1lIHRvIGdldCB0aGUgcHJvamVjdElkXG4gICAgICAvLyBGb3Igbm93LCB0aGlzIGZ1bmN0aW9uYWxpdHkgaXMgaW5jb21wbGV0ZSB3aXRob3V0IHByb2plY3QgbG9va3VwXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZpbGUgY3JlYXRpb24gcmVxdWlyZXMgYSB2YWxpZCBwcm9qZWN0LiBQcm9qZWN0IFwiJHtmaWxlRGV0YWlscy5wcm9qZWN0TmFtZX1cIiBsb29rdXAgbm90IGltcGxlbWVudGVkIHlldC5gKTtcblxuICAgICAgbGV0IHJlc3VsdCA9IGDinIUgKipGaWxlIENyZWF0ZWQgU3VjY2Vzc2Z1bGx5ISoqXFxuXFxuYDtcbiAgICAgIHJlc3VsdCArPSBg8J+ThCAqKkZpbGUgTmFtZToqKiAke2ZpbGVEZXRhaWxzLmZpbGVOYW1lfVxcbmA7XG4gICAgICByZXN1bHQgKz0gYPCfk4EgKipQcm9qZWN0OioqICR7ZmlsZURldGFpbHMucHJvamVjdE5hbWV9XFxuYDtcbiAgICAgIHJlc3VsdCArPSBg8J+Pt++4jyAqKlR5cGU6KiogJHtmaWxlRGV0YWlscy5maWxlVHlwZX1cXG5gO1xuICAgICAgcmVzdWx0ICs9IGDwn5OFICoqQ3JlYXRlZDoqKiAke25ldyBEYXRlKCkudG9Mb2NhbGVEYXRlU3RyaW5nKCl9XFxuXFxuYDtcbiAgICAgIHJlc3VsdCArPSBg8J+SoSBZb3UgY2FuIG5vdyBmaW5kIGFuZCBlZGl0IHRoaXMgZmlsZSBpbiB0aGUgc2lkZWJhciFgO1xuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCfinYwgRmlsZSBjcmVhdGlvbiBmYWlsZWQ6JywgZXJyb3IpO1xuICAgICAgcmV0dXJuIGDinYwgKipGaWxlIGNyZWF0aW9uIGZhaWxlZDoqKiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InfWA7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSB0ZW1wbGF0ZSBzZXR1cCBmcm9tIG5hdHVyYWwgbGFuZ3VhZ2VcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgaGFuZGxlVGVtcGxhdGVTZXR1cChcbiAgICBpbnB1dDogc3RyaW5nLFxuICAgIGNvbnZleE11dGF0aW9uczogQ29udmV4TXV0YXRpb25zXG4gICk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHRlbXBsYXRlRGV0YWlscyA9IHRoaXMuZXh0cmFjdFRlbXBsYXRlRGV0YWlscyhpbnB1dCk7XG4gICAgICBcbiAgICAgIGlmICghY29udmV4TXV0YXRpb25zLmNyZWF0ZVByb2plY3QpIHtcbiAgICAgICAgcmV0dXJuICfinYwgUHJvamVjdCBjcmVhdGlvbiBpcyBub3QgYXZhaWxhYmxlLiBQbGVhc2UgY2hlY2sgc3lzdGVtIGNvbmZpZ3VyYXRpb24uJztcbiAgICAgIH1cblxuICAgICAgY29uc3QgcHJvamVjdE5hbWUgPSB0ZW1wbGF0ZURldGFpbHMubmFtZSB8fCBgJHt0ZW1wbGF0ZURldGFpbHMudHlwZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHRlbXBsYXRlRGV0YWlscy50eXBlLnNsaWNlKDEpfSBQcm9qZWN0YDtcbiAgICAgIFxuICAgICAgY29uc3QgbmV3UHJvamVjdCA9IGF3YWl0IGNvbnZleE11dGF0aW9ucy5jcmVhdGVQcm9qZWN0KHtcbiAgICAgICAgbmFtZTogcHJvamVjdE5hbWUsXG4gICAgICAgIGRlc2NyaXB0aW9uOiB0aGlzLmdldFRlbXBsYXRlRGVzY3JpcHRpb24odGVtcGxhdGVEZXRhaWxzLnR5cGUpLFxuICAgICAgICBzdGF0dXM6ICdhY3RpdmUnIGFzIGNvbnN0LFxuICAgICAgICBidWRnZXQ6IHRoaXMuZ2V0VGVtcGxhdGVCdWRnZXQodGVtcGxhdGVEZXRhaWxzLnR5cGUpLFxuICAgICAgfSk7XG5cbiAgICAgIC8vIENyZWF0ZSB0ZW1wbGF0ZS1zcGVjaWZpYyBmaWxlc1xuICAgICAgbGV0IHRlbXBsYXRlRmlsZXMgPSAnJztcbiAgICAgIGlmIChjb252ZXhNdXRhdGlvbnMuY3JlYXRlRmlsZSkge1xuICAgICAgICB0ZW1wbGF0ZUZpbGVzID0gYXdhaXQgdGhpcy5jcmVhdGVUZW1wbGF0ZUZpbGVzKG5ld1Byb2plY3QsIHRlbXBsYXRlRGV0YWlscy50eXBlLCBjb252ZXhNdXRhdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICBsZXQgcmVzdWx0ID0gYOKchSAqKlRlbXBsYXRlIEFwcGxpZWQgU3VjY2Vzc2Z1bGx5ISoqXFxuXFxuYDtcbiAgICAgIHJlc3VsdCArPSBg8J+TgSAqKlByb2plY3QgTmFtZToqKiAkeyhuZXdQcm9qZWN0IGFzIGFueSk/Lm5hbWUgfHwgcHJvamVjdE5hbWV9XFxuYDtcbiAgICAgIHJlc3VsdCArPSBg8J+OqCAqKlRlbXBsYXRlIFR5cGU6KiogJHt0ZW1wbGF0ZURldGFpbHMudHlwZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHRlbXBsYXRlRGV0YWlscy50eXBlLnNsaWNlKDEpfVxcbmA7XG4gICAgICBcbiAgICAgIGlmICgobmV3UHJvamVjdCBhcyBhbnkpPy5wcm9qZWN0TnVtYmVyKSB7XG4gICAgICAgIHJlc3VsdCArPSBg8J+UoiAqKlByb2plY3QgTnVtYmVyOioqICMkeyhuZXdQcm9qZWN0IGFzIGFueSkucHJvamVjdE51bWJlcn1cXG5gO1xuICAgICAgfVxuICAgICAgXG4gICAgICBpZiAodGVtcGxhdGVGaWxlcykge1xuICAgICAgICByZXN1bHQgKz0gYFxcbvCfk4QgKipUZW1wbGF0ZSBGaWxlczoqKlxcbiR7dGVtcGxhdGVGaWxlc31cXG5gO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ICs9IGBcXG5gO1xuICAgICAgfVxuICAgICAgXG4gICAgICByZXN1bHQgKz0gYPCfjokgWW91ciB0ZW1wbGF0ZSBwcm9qZWN0IGlzIHJlYWR5IHRvIHVzZSFgO1xuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCfinYwgVGVtcGxhdGUgc2V0dXAgZmFpbGVkOicsIGVycm9yKTtcbiAgICAgIHJldHVybiBg4p2MICoqVGVtcGxhdGUgc2V0dXAgZmFpbGVkOioqICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcid9YDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRXh0cmFjdCBwcm9qZWN0IGRldGFpbHMgZnJvbSBuYXR1cmFsIGxhbmd1YWdlIGlucHV0XG4gICAqL1xuICBwcml2YXRlIGV4dHJhY3RQcm9qZWN0RGV0YWlscyhpbnB1dDogc3RyaW5nKTogUHJvamVjdERldGFpbHMge1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRJbnB1dCA9IGlucHV0LnRvTG93ZXJDYXNlKCk7XG4gICAgXG4gICAgLy8gRXh0cmFjdCBwcm9qZWN0IG5hbWUgLSBtb3JlIHNwZWNpZmljIHBhdHRlcm5zIHRoYXQgY2FwdHVyZSBhY3R1YWwgcHJvamVjdCBuYW1lc1xuICAgIGNvbnN0IG5hbWVQYXR0ZXJucyA9IFtcbiAgICAgIC8vIFBhdHRlcm4gZm9yIFwiY3JlYXRlIHByb2plY3QgY2FsbGVkIFtuYW1lXVwiIG9yIFwiY3JlYXRlIHByb2plY3QgbmFtZWQgW25hbWVdXCJcbiAgICAgIC8oPzpjcmVhdGV8bmV3fG1ha2V8c3RhcnR8YnVpbGR8c2V0dXApXFxzKyg/OmFcXHMrKT9wcm9qZWN0XFxzKyg/OmNhbGxlZHxuYW1lZClcXHMrW1xcXCJcXCddPyhbXlxcXCJcXCddKz8pW1xcXCJcXCddPyg/Olxccytmb3J8XFxzK3dpdGh8JCkvaSxcbiAgICAgIC8vIFBhdHRlcm4gZm9yIHF1b3RlZCBuYW1lczogXCJwcm9qZWN0IG5hbWVcIiBvciAncHJvamVjdCBuYW1lJ1xuICAgICAgL1tcXFwiXFwnXShbXlxcXCJcXCddezIsfSlbXFxcIlxcJ10vLCBcbiAgICAgIC8vIFBhdHRlcm4gZm9yIHNwZWNpZmljIHByb2plY3QgbmFtZXMgYWZ0ZXIgXCJjcmVhdGVcIiAoYnV0IG5vdCBnZW5lcmljIHdvcmRzKVxuICAgICAgLyg/OmNyZWF0ZXxuZXd8bWFrZXxzdGFydHxidWlsZHxzZXR1cClcXHMrKD86YVxccyspPyg/OnByb2plY3RcXHMrKT9bXFxcIlxcJ10/KFthLXpBLVpdW2EtekEtWjAtOVxcc1xcLV9dezIsfSlbXFxcIlxcJ10/KD86XFxzK2ZvcnxcXHMrd2l0aHwkKS9pXG4gICAgXTtcblxuICAgIGxldCBuYW1lID0gJyc7XG4gICAgZm9yIChjb25zdCBwYXR0ZXJuIG9mIG5hbWVQYXR0ZXJucykge1xuICAgICAgY29uc3QgbWF0Y2ggPSBpbnB1dC5tYXRjaChwYXR0ZXJuKTtcbiAgICAgIGlmIChtYXRjaCAmJiBtYXRjaFsxXSkge1xuICAgICAgICBjb25zdCBleHRyYWN0ZWROYW1lID0gbWF0Y2hbMV0udHJpbSgpO1xuICAgICAgICAvLyBSZWplY3QgZ2VuZXJpYy92YWd1ZSBuYW1lcyB0aGF0IHNob3VsZCB0cmlnZ2VyIGlucHV0IHByb21wdFxuICAgICAgICBjb25zdCBnZW5lcmljTmFtZXMgPSBbJ3Byb2plY3QnLCAnbmV3IHByb2plY3QnLCAnYSBwcm9qZWN0JywgJ25ldycsICdpdCcsICd0aGlzJywgJ3RoYXQnLCAnb25lJ107XG4gICAgICAgIGlmICghZ2VuZXJpY05hbWVzLmluY2x1ZGVzKGV4dHJhY3RlZE5hbWUudG9Mb3dlckNhc2UoKSkgJiYgZXh0cmFjdGVkTmFtZS5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgbmFtZSA9IGV4dHJhY3RlZE5hbWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiBubyBzcGVjaWZpYyBuYW1lIGZvdW5kLCByZXR1cm4gZW1wdHkgc3RyaW5nIHRvIHRyaWdnZXIgaW5wdXQgY29tcG9uZW50XG4gICAgaWYgKCFuYW1lKSB7XG4gICAgICBuYW1lID0gJyc7XG4gICAgfVxuXG4gICAgLy8gRXh0cmFjdCBkZXNjcmlwdGlvbiAod29yZHMgYWZ0ZXIgXCJmb3JcIiwgXCJhYm91dFwiLCBcInRvXCIpXG4gICAgY29uc3QgZGVzY3JpcHRpb25NYXRjaCA9IGlucHV0Lm1hdGNoKC8oPzpmb3J8YWJvdXR8dG8pXFxzKyguKykvaSk7XG4gICAgY29uc3QgZGVzY3JpcHRpb24gPSBkZXNjcmlwdGlvbk1hdGNoID8gZGVzY3JpcHRpb25NYXRjaFsxXS50cmltKCkgOiB1bmRlZmluZWQ7XG5cbiAgICAvLyBEZXRlY3QgcHJvamVjdCB0eXBlIGZyb20ga2V5d29yZHNcbiAgICBjb25zdCB0eXBlS2V5d29yZHMgPSB7XG4gICAgICBtYXJrZXRpbmc6IFsnbWFya2V0aW5nJywgJ2NhbXBhaWduJywgJ3Byb21vdGlvbicsICdhZHZlcnRpc2luZycsICdicmFuZCddLFxuICAgICAgZGV2ZWxvcG1lbnQ6IFsnZGV2ZWxvcG1lbnQnLCAnZGV2JywgJ2FwcCcsICd3ZWJzaXRlJywgJ3NvZnR3YXJlJywgJ2NvZGUnXSxcbiAgICAgIGNvbnRlbnQ6IFsnY29udGVudCcsICdibG9nJywgJ2FydGljbGUnLCAnd3JpdGluZycsICdlZGl0b3JpYWwnXSxcbiAgICAgIGZpbmFuY2lhbDogWydmaW5hbmNpYWwnLCAnYnVkZ2V0JywgJ2ZpbmFuY2UnLCAnYWNjb3VudGluZycsICdtb25leSddLFxuICAgICAgc29jaWFsOiBbJ3NvY2lhbCcsICdpbnN0YWdyYW0nLCAndHdpdHRlcicsICdmYWNlYm9vaycsICdtZWRpYSddXG4gICAgfTtcblxuICAgIGxldCB0eXBlOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gICAgZm9yIChjb25zdCBbcHJvamVjdFR5cGUsIGtleXdvcmRzXSBvZiBPYmplY3QuZW50cmllcyh0eXBlS2V5d29yZHMpKSB7XG4gICAgICBpZiAoa2V5d29yZHMuc29tZShrZXl3b3JkID0+IG5vcm1hbGl6ZWRJbnB1dC5pbmNsdWRlcyhrZXl3b3JkKSkpIHtcbiAgICAgICAgdHlwZSA9IHByb2plY3RUeXBlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBFeHRyYWN0IGJ1ZGdldCBpZiBtZW50aW9uZWRcbiAgICBjb25zdCBidWRnZXRNYXRjaCA9IGlucHV0Lm1hdGNoKC9cXCQ/KFtcXGQsXSspLyk7XG4gICAgY29uc3QgYnVkZ2V0ID0gYnVkZ2V0TWF0Y2ggPyBwYXJzZUludChidWRnZXRNYXRjaFsxXS5yZXBsYWNlKC8sL2csICcnKSkgOiB0aGlzLmdldERlZmF1bHRCdWRnZXQodHlwZSk7XG5cbiAgICAvLyBDaGVjayBpZiB1c2VyIHdhbnRzIGluaXRpYWwgZmlsZXNcbiAgICBjb25zdCBjcmVhdGVGaWxlcyA9IC8oPzp3aXRofGluY2x1ZGUpXFxzKyg/OmZpbGVzfGRvY3VtZW50c3x0ZW1wbGF0ZXMpL2kudGVzdChpbnB1dCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgbmFtZSxcbiAgICAgIGRlc2NyaXB0aW9uLFxuICAgICAgdHlwZSxcbiAgICAgIGJ1ZGdldCxcbiAgICAgIGNyZWF0ZUZpbGVzXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHRyYWN0IGZpbGUgZGV0YWlscyBmcm9tIG5hdHVyYWwgbGFuZ3VhZ2UgaW5wdXRcbiAgICovXG4gIHByaXZhdGUgZXh0cmFjdEZpbGVEZXRhaWxzKGlucHV0OiBzdHJpbmcpOiBGaWxlRGV0YWlscyB7XG4gICAgY29uc3Qgbm9ybWFsaXplZElucHV0ID0gaW5wdXQudG9Mb3dlckNhc2UoKTtcbiAgICBcbiAgICAvLyBFeHRyYWN0IGZpbGUgbmFtZSBhbmQgdHlwZVxuICAgIGxldCBmaWxlTmFtZSA9ICcnO1xuICAgIGxldCBmaWxlVHlwZSA9ICd0ZXh0JztcblxuICAgIC8vIENvbW1vbiBmaWxlIHBhdHRlcm5zXG4gICAgY29uc3QgZmlsZVBhdHRlcm5zID0gW1xuICAgICAgeyBwYXR0ZXJuOiAvKD86c3ByZWFkc2hlZXR8ZXhjZWx8XFwueGxzeD8pLywgdHlwZTogJ3NwcmVhZHNoZWV0JywgZXh0ZW5zaW9uOiAnLnhsc3gnIH0sXG4gICAgICB7IHBhdHRlcm46IC8oPzpkb2N1bWVudHxkb2N8XFwuZG9jeD8pLywgdHlwZTogJ2RvY3VtZW50JywgZXh0ZW5zaW9uOiAnLmRvY3gnIH0sXG4gICAgICB7IHBhdHRlcm46IC8oPzpub3Rlc3xcXC5tZHxtYXJrZG93bikvLCB0eXBlOiAnbWFya2Rvd24nLCBleHRlbnNpb246ICcubWQnIH0sXG4gICAgICB7IHBhdHRlcm46IC8oPzpwbGFufHBsYW5uaW5nKS8sIHR5cGU6ICdkb2N1bWVudCcsIGV4dGVuc2lvbjogJy5tZCcgfSxcbiAgICAgIHsgcGF0dGVybjogLyg/OmJ1ZGdldHxmaW5hbmNpYWwpLywgdHlwZTogJ3NwcmVhZHNoZWV0JywgZXh0ZW5zaW9uOiAnLnhsc3gnIH0sXG4gICAgICB7IHBhdHRlcm46IC8oPzpwcmVzZW50YXRpb258XFwucHB0eD8pLywgdHlwZTogJ3ByZXNlbnRhdGlvbicsIGV4dGVuc2lvbjogJy5wcHR4JyB9XG4gICAgXTtcblxuICAgIGZvciAoY29uc3QgeyBwYXR0ZXJuLCB0eXBlLCBleHRlbnNpb24gfSBvZiBmaWxlUGF0dGVybnMpIHtcbiAgICAgIGlmIChwYXR0ZXJuLnRlc3Qobm9ybWFsaXplZElucHV0KSkge1xuICAgICAgICBmaWxlVHlwZSA9IHR5cGU7XG4gICAgICAgIFxuICAgICAgICAvLyBFeHRyYWN0IHNwZWNpZmljIGZpbGUgbmFtZSBpZiBtZW50aW9uZWRcbiAgICAgICAgY29uc3QgbmFtZU1hdGNoID0gaW5wdXQubWF0Y2goLyg/OmNyZWF0ZXxhZGR8bWFrZSlcXHMrKD86YVxccyspPyguKz8pKD86XFxzK2ZvcnxcXHMraW58XFxzK3RvfCQpL2kpO1xuICAgICAgICBpZiAobmFtZU1hdGNoICYmIG5hbWVNYXRjaFsxXSkge1xuICAgICAgICAgIGZpbGVOYW1lID0gbmFtZU1hdGNoWzFdLnRyaW0oKTtcbiAgICAgICAgICBpZiAoIWZpbGVOYW1lLmluY2x1ZGVzKCcuJykpIHtcbiAgICAgICAgICAgIGZpbGVOYW1lICs9IGV4dGVuc2lvbjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZmlsZU5hbWUgPSBgJHt0eXBlfSR7ZXh0ZW5zaW9ufWA7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRXh0cmFjdCBwcm9qZWN0IG5hbWVcbiAgICBjb25zdCBwcm9qZWN0TWF0Y2ggPSBpbnB1dC5tYXRjaCgvKD86Zm9yfGlufHRvKVxccysoPzp0aGVcXHMrKT8oLis/KSg/Olxccytwcm9qZWN0KT8kL2kpO1xuICAgIGNvbnN0IHByb2plY3ROYW1lID0gcHJvamVjdE1hdGNoID8gcHJvamVjdE1hdGNoWzFdLnRyaW0oKSA6ICcnO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGZpbGVOYW1lOiBmaWxlTmFtZSB8fCAnbmV3LWZpbGUudHh0JyxcbiAgICAgIHByb2plY3ROYW1lLFxuICAgICAgZmlsZVR5cGUsXG4gICAgICBjb250ZW50OiAnJ1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRXh0cmFjdCB0ZW1wbGF0ZSBkZXRhaWxzIGZyb20gbmF0dXJhbCBsYW5ndWFnZSBpbnB1dFxuICAgKi9cbiAgcHJpdmF0ZSBleHRyYWN0VGVtcGxhdGVEZXRhaWxzKGlucHV0OiBzdHJpbmcpOiB7IG5hbWU/OiBzdHJpbmc7IHR5cGU6IHN0cmluZyB9IHtcbiAgICBjb25zdCBub3JtYWxpemVkSW5wdXQgPSBpbnB1dC50b0xvd2VyQ2FzZSgpO1xuICAgIFxuICAgIGNvbnN0IHRlbXBsYXRlVHlwZXMgPSBbJ21hcmtldGluZycsICdkZXZlbG9wbWVudCcsICdjb250ZW50JywgJ2ZpbmFuY2lhbCcsICdzb2NpYWwnXTtcbiAgICBsZXQgdHlwZSA9ICdkZXZlbG9wbWVudCc7IC8vIGRlZmF1bHRcblxuICAgIGZvciAoY29uc3QgdGVtcGxhdGVUeXBlIG9mIHRlbXBsYXRlVHlwZXMpIHtcbiAgICAgIGlmIChub3JtYWxpemVkSW5wdXQuaW5jbHVkZXModGVtcGxhdGVUeXBlKSkge1xuICAgICAgICB0eXBlID0gdGVtcGxhdGVUeXBlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBFeHRyYWN0IGN1c3RvbSBuYW1lIGlmIHByb3ZpZGVkXG4gICAgY29uc3QgbmFtZU1hdGNoID0gaW5wdXQubWF0Y2goLyg/OnRlbXBsYXRlfHNjYWZmb2xkKVxccysoPzpmb3JcXHMrKT8oLispL2kpO1xuICAgIGNvbnN0IG5hbWUgPSBuYW1lTWF0Y2ggPyBuYW1lTWF0Y2hbMV0udHJpbSgpIDogdW5kZWZpbmVkO1xuXG4gICAgcmV0dXJuIHsgbmFtZSwgdHlwZSB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBkZWZhdWx0IGJ1ZGdldCBiYXNlZCBvbiBwcm9qZWN0IHR5cGVcbiAgICovXG4gIHByaXZhdGUgZ2V0RGVmYXVsdEJ1ZGdldCh0eXBlPzogc3RyaW5nKTogbnVtYmVyIHtcbiAgICBjb25zdCBidWRnZXRzID0ge1xuICAgICAgbWFya2V0aW5nOiA1MDAwLFxuICAgICAgZGV2ZWxvcG1lbnQ6IDE1MDAwLFxuICAgICAgY29udGVudDogMzAwMCxcbiAgICAgIGZpbmFuY2lhbDogMTAwMDAsXG4gICAgICBzb2NpYWw6IDIwMDBcbiAgICB9O1xuICAgIHJldHVybiBidWRnZXRzW3R5cGUgYXMga2V5b2YgdHlwZW9mIGJ1ZGdldHNdIHx8IDEwMDAwO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0ZW1wbGF0ZSBidWRnZXQgYmFzZWQgb24gdHlwZVxuICAgKi9cbiAgcHJpdmF0ZSBnZXRUZW1wbGF0ZUJ1ZGdldCh0eXBlOiBzdHJpbmcpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmdldERlZmF1bHRCdWRnZXQodHlwZSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRlbXBsYXRlIGRlc2NyaXB0aW9uIGJhc2VkIG9uIHR5cGVcbiAgICovXG4gIHByaXZhdGUgZ2V0VGVtcGxhdGVEZXNjcmlwdGlvbih0eXBlOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGNvbnN0IGRlc2NyaXB0aW9ucyA9IHtcbiAgICAgIG1hcmtldGluZzogJ01hcmtldGluZyBjYW1wYWlnbiBwcm9qZWN0IHdpdGggcHJvbW90aW9uYWwgbWF0ZXJpYWxzIGFuZCBzdHJhdGVneSBwbGFubmluZycsXG4gICAgICBkZXZlbG9wbWVudDogJ1NvZnR3YXJlIGRldmVsb3BtZW50IHByb2plY3Qgd2l0aCB0ZWNobmljYWwgZG9jdW1lbnRhdGlvbiBhbmQgbWlsZXN0b25lcycsXG4gICAgICBjb250ZW50OiAnQ29udGVudCBjcmVhdGlvbiBwcm9qZWN0IHdpdGggZWRpdG9yaWFsIGNhbGVuZGFyIGFuZCBwdWJsaXNoaW5nIHdvcmtmbG93JyxcbiAgICAgIGZpbmFuY2lhbDogJ0ZpbmFuY2lhbCBhbmFseXNpcyBwcm9qZWN0IHdpdGggYnVkZ2V0cywgZm9yZWNhc3RzLCBhbmQgcmVwb3J0aW5nJyxcbiAgICAgIHNvY2lhbDogJ1NvY2lhbCBtZWRpYSBwcm9qZWN0IHdpdGggY29udGVudCBjYWxlbmRhciBhbmQgZW5nYWdlbWVudCBzdHJhdGVnaWVzJ1xuICAgIH07XG4gICAgcmV0dXJuIGRlc2NyaXB0aW9uc1t0eXBlIGFzIGtleW9mIHR5cGVvZiBkZXNjcmlwdGlvbnNdIHx8ICdHZW5lcmFsIHByb2plY3QgdGVtcGxhdGUnO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBpbml0aWFsIGZpbGVzIGZvciBhIHByb2plY3RcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgY3JlYXRlSW5pdGlhbEZpbGVzKHByb2plY3Q6IGFueSwgY29udmV4TXV0YXRpb25zOiBDb252ZXhNdXRhdGlvbnMpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIGNvbnN0IGZpbGVzID0gW1xuICAgICAgeyBcbiAgICAgICAgbmFtZTogJ1JFQURNRS5tZCcsIFxuICAgICAgICBjb250ZW50OiBgIyAkeyhwcm9qZWN0IGFzIGFueSk/Lm5hbWUgfHwgJ1Byb2plY3QnfVxcblxcbiR7KHByb2plY3QgYXMgYW55KT8uZGVzY3JpcHRpb24gfHwgJ1Byb2plY3QgZGVzY3JpcHRpb24nfVxcblxcbiMjIEdldHRpbmcgU3RhcnRlZFxcblxcblRoaXMgcHJvamVjdCB3YXMgY3JlYXRlZCB1c2luZyB0aGUgRUFDIFByb2plY3QgQ3JlYXRvciBBZ2VudC5gLCBcbiAgICAgICAgdHlwZTogJ25vdGUnIFxuICAgICAgfSxcbiAgICAgIHsgXG4gICAgICAgIG5hbWU6ICdwcm9qZWN0LXBsYW4ubWQnLCBcbiAgICAgICAgY29udGVudDogYCMgUHJvamVjdCBQbGFuIC0gJHsocHJvamVjdCBhcyBhbnkpPy5uYW1lIHx8ICdQcm9qZWN0J31cXG5cXG4jIyBPYmplY3RpdmVzXFxuXFxuIyMgVGltZWxpbmVcXG5cXG4jIyBSZXNvdXJjZXNcXG5cXG4jIyBNaWxlc3RvbmVzXFxuYCwgXG4gICAgICAgIHR5cGU6ICdub3RlJyBcbiAgICAgIH1cbiAgICBdO1xuXG4gICAgY29uc3QgcmVzdWx0czogc3RyaW5nW10gPSBbXTtcbiAgICBmb3IgKGNvbnN0IGZpbGUgb2YgZmlsZXMpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChjb252ZXhNdXRhdGlvbnMuY3JlYXRlRmlsZSkge1xuICAgICAgICAgIGF3YWl0IGNvbnZleE11dGF0aW9ucy5jcmVhdGVGaWxlKHtcbiAgICAgICAgICAgIG5hbWU6IGZpbGUubmFtZSxcbiAgICAgICAgICAgIGNvbnRlbnQ6IGZpbGUuY29udGVudCxcbiAgICAgICAgICAgIHR5cGU6IGZpbGUudHlwZSBhcyBhbnksXG4gICAgICAgICAgICBwcm9qZWN0SWQ6IChwcm9qZWN0IGFzIGFueSk/Ll9pZFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJlc3VsdHMucHVzaChg4pyFICR7ZmlsZS5uYW1lfWApO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXN1bHRzLnB1c2goYOKdjCAke2ZpbGUubmFtZX0gKGZhaWxlZClgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0cy5qb2luKCdcXG4nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGVtcGxhdGUtc3BlY2lmaWMgZmlsZXNcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgY3JlYXRlVGVtcGxhdGVGaWxlcyhwcm9qZWN0OiBhbnksIHRlbXBsYXRlVHlwZTogc3RyaW5nLCBjb252ZXhNdXRhdGlvbnM6IENvbnZleE11dGF0aW9ucyk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgY29uc3QgdGVtcGxhdGVGaWxlcyA9IHRoaXMuZ2V0VGVtcGxhdGVGaWxlcyh0ZW1wbGF0ZVR5cGUsIChwcm9qZWN0IGFzIGFueSk/Lm5hbWUgfHwgJ1Byb2plY3QnKTtcbiAgICBjb25zdCByZXN1bHRzOiBzdHJpbmdbXSA9IFtdO1xuXG4gICAgZm9yIChjb25zdCBmaWxlIG9mIHRlbXBsYXRlRmlsZXMpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChjb252ZXhNdXRhdGlvbnMuY3JlYXRlRmlsZSkge1xuICAgICAgICAgIGF3YWl0IGNvbnZleE11dGF0aW9ucy5jcmVhdGVGaWxlKHtcbiAgICAgICAgICAgIG5hbWU6IGZpbGUubmFtZSxcbiAgICAgICAgICAgIGNvbnRlbnQ6IGZpbGUuY29udGVudCxcbiAgICAgICAgICAgIHR5cGU6IGZpbGUudHlwZSBhcyBhbnksXG4gICAgICAgICAgICBwcm9qZWN0SWQ6IChwcm9qZWN0IGFzIGFueSk/Ll9pZFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJlc3VsdHMucHVzaChg4pyFICR7ZmlsZS5uYW1lfWApO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXN1bHRzLnB1c2goYOKdjCAke2ZpbGUubmFtZX0gKGZhaWxlZClgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0cy5qb2luKCdcXG4nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGVtcGxhdGUgZmlsZXMgYmFzZWQgb24gdHlwZVxuICAgKi9cbiAgcHJpdmF0ZSBnZXRUZW1wbGF0ZUZpbGVzKHR5cGU6IHN0cmluZywgcHJvamVjdE5hbWU6IHN0cmluZykge1xuICAgIGNvbnN0IHRlbXBsYXRlcyA9IHtcbiAgICAgIG1hcmtldGluZzogW1xuICAgICAgICB7IG5hbWU6ICdjYW1wYWlnbi1icmllZi5tZCcsIGNvbnRlbnQ6IGAjIENhbXBhaWduIEJyaWVmIC0gJHtwcm9qZWN0TmFtZX1cXG5cXG4jIyBPYmplY3RpdmVzXFxuXFxuIyMgVGFyZ2V0IEF1ZGllbmNlXFxuXFxuIyMgS2V5IE1lc3NhZ2VzXFxuXFxuIyMgVGltZWxpbmVcXG5gLCB0eXBlOiAnbm90ZScgfSxcbiAgICAgICAgeyBuYW1lOiAnYnVkZ2V0Lm1kJywgY29udGVudDogYCMgQnVkZ2V0IC0gJHtwcm9qZWN0TmFtZX1cXG5cXG4jIyBDYW1wYWlnbiBCdWRnZXRcXG5cXG58IEl0ZW0gfCBBbW91bnQgfFxcbnwtLS0tLS18LS0tLS0tLS18XFxufCBUb3RhbCB8ICQwIHxcXG5gLCB0eXBlOiAnbm90ZScgfVxuICAgICAgXSxcbiAgICAgIGRldmVsb3BtZW50OiBbXG4gICAgICAgIHsgbmFtZTogJ1JFQURNRS5tZCcsIGNvbnRlbnQ6IGAjICR7cHJvamVjdE5hbWV9XFxuXFxuIyMgU2V0dXBcXG5cXG4jIyBEZXZlbG9wbWVudFxcblxcbiMjIERlcGxveW1lbnRcXG5gLCB0eXBlOiAnbm90ZScgfSxcbiAgICAgICAgeyBuYW1lOiAncmVxdWlyZW1lbnRzLm1kJywgY29udGVudDogYCMgUmVxdWlyZW1lbnRzIC0gJHtwcm9qZWN0TmFtZX1cXG5cXG4jIyBGdW5jdGlvbmFsIFJlcXVpcmVtZW50c1xcblxcbiMjIFRlY2huaWNhbCBSZXF1aXJlbWVudHNcXG5gLCB0eXBlOiAnbm90ZScgfVxuICAgICAgXSxcbiAgICAgIGNvbnRlbnQ6IFtcbiAgICAgICAgeyBuYW1lOiAnY29udGVudC1jYWxlbmRhci5tZCcsIGNvbnRlbnQ6IGAjIENvbnRlbnQgQ2FsZW5kYXIgLSAke3Byb2plY3ROYW1lfVxcblxcbiMjIEVkaXRvcmlhbCBTY2hlZHVsZVxcblxcbiMjIENvbnRlbnQgVG9waWNzXFxuYCwgdHlwZTogJ25vdGUnIH0sXG4gICAgICAgIHsgbmFtZTogJ3N0eWxlLWd1aWRlLm1kJywgY29udGVudDogYCMgU3R5bGUgR3VpZGUgLSAke3Byb2plY3ROYW1lfVxcblxcbiMjIFZvaWNlICYgVG9uZVxcblxcbiMjIEd1aWRlbGluZXNcXG5gLCB0eXBlOiAnbm90ZScgfVxuICAgICAgXSxcbiAgICAgIGZpbmFuY2lhbDogW1xuICAgICAgICB7IG5hbWU6ICdidWRnZXQubWQnLCBjb250ZW50OiBgIyBCdWRnZXQgLSAke3Byb2plY3ROYW1lfVxcblxcbiMjIFJldmVudWUgUHJvamVjdGlvbnNcXG5cXG4jIyBFeHBlbnNlIFBsYW5uaW5nXFxuYCwgdHlwZTogJ25vdGUnIH0sXG4gICAgICAgIHsgbmFtZTogJ2ZvcmVjYXN0Lm1kJywgY29udGVudDogYCMgRmluYW5jaWFsIEZvcmVjYXN0IC0gJHtwcm9qZWN0TmFtZX1cXG5cXG4jIyBSZXZlbnVlIFByb2plY3Rpb25zXFxuXFxuIyMgRXhwZW5zZSBQbGFubmluZ1xcbmAsIHR5cGU6ICdub3RlJyB9XG4gICAgICBdLFxuICAgICAgc29jaWFsOiBbXG4gICAgICAgIHsgbmFtZTogJ3NvY2lhbC1jYWxlbmRhci5tZCcsIGNvbnRlbnQ6IGAjIFNvY2lhbCBNZWRpYSBDYWxlbmRhciAtICR7cHJvamVjdE5hbWV9XFxuXFxuIyMgQ29udGVudCBTY2hlZHVsZVxcblxcbiMjIFBsYXRmb3JtIFN0cmF0ZWd5XFxuYCwgdHlwZTogJ25vdGUnIH0sXG4gICAgICAgIHsgbmFtZTogJ2VuZ2FnZW1lbnQtcGxhbi5tZCcsIGNvbnRlbnQ6IGAjIEVuZ2FnZW1lbnQgUGxhbiAtICR7cHJvamVjdE5hbWV9XFxuXFxuIyMgQ29tbXVuaXR5IEd1aWRlbGluZXNcXG5cXG4jIyBSZXNwb25zZSBUZW1wbGF0ZXNcXG5gLCB0eXBlOiAnbm90ZScgfVxuICAgICAgXVxuICAgIH07XG5cbiAgICByZXR1cm4gdGVtcGxhdGVzW3R5cGUgYXMga2V5b2YgdHlwZW9mIHRlbXBsYXRlc10gfHwgdGVtcGxhdGVzLmRldmVsb3BtZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGZpbGUgY29udGVudCBiYXNlZCBvbiB0eXBlIGFuZCBuYW1lXG4gICAqL1xuICBwcml2YXRlIGdlbmVyYXRlRmlsZUNvbnRlbnQoZmlsZVR5cGU6IHN0cmluZywgZmlsZU5hbWU6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgY29uc3QgYmFzZUNvbnRlbnQgPSB7XG4gICAgICBzcHJlYWRzaGVldDogYCMgJHtmaWxlTmFtZS5yZXBsYWNlKC9cXC5bXi8uXSskLywgXCJcIil9XFxuXFxufCBJdGVtIHwgQW1vdW50IHxcXG58LS0tLS0tfC0tLS0tLS0tfFxcbnwgVG90YWwgfCAkMCB8XFxuYCxcbiAgICAgIGRvY3VtZW50OiBgIyAke2ZpbGVOYW1lfVxcblxcbkRvY3VtZW50IGNyZWF0ZWQgb24gJHtuZXcgRGF0ZSgpLnRvTG9jYWxlRGF0ZVN0cmluZygpfVxcblxcbiMjIFNlY3Rpb24gMVxcblxcbiMjIFNlY3Rpb24gMlxcbmAsXG4gICAgICBtYXJrZG93bjogYCMgJHtmaWxlTmFtZS5yZXBsYWNlKC9cXC5bXi8uXSskLywgXCJcIil9XFxuXFxuQ3JlYXRlZDogJHtuZXcgRGF0ZSgpLnRvTG9jYWxlRGF0ZVN0cmluZygpfVxcblxcbiMjIE92ZXJ2aWV3XFxuXFxuIyMgRGV0YWlsc1xcbmAsXG4gICAgICB0ZXh0OiBgJHtmaWxlTmFtZX1cXG5cXG5DcmVhdGVkOiAke25ldyBEYXRlKCkudG9Mb2NhbGVEYXRlU3RyaW5nKCl9XFxuXFxuQ29udGVudCBnb2VzIGhlcmUuLi5gLFxuICAgIH07XG5cbiAgICByZXR1cm4gYmFzZUNvbnRlbnRbZmlsZVR5cGUgYXMga2V5b2YgdHlwZW9mIGJhc2VDb250ZW50XSB8fCBiYXNlQ29udGVudC50ZXh0O1xuICB9XG5cbiAgLyoqXG4gICAqIE1hcCBmaWxlIHR5cGUgdG8gQ29udmV4IGV4cGVjdGVkIHR5cGVcbiAgICovXG4gIHByaXZhdGUgbWFwVG9Db252ZXhGaWxlVHlwZShmaWxlVHlwZTogc3RyaW5nKTogJ3Bvc3QnIHwgJ2NhbXBhaWduJyB8ICdub3RlJyB8ICdkb2N1bWVudCcgfCAnaW1hZ2UnIHwgJ3ZpZGVvJyB8ICdvdGhlcicge1xuICAgIGNvbnN0IHR5cGVNYXA6IFJlY29yZDxzdHJpbmcsICdwb3N0JyB8ICdjYW1wYWlnbicgfCAnbm90ZScgfCAnZG9jdW1lbnQnIHwgJ2ltYWdlJyB8ICd2aWRlbycgfCAnb3RoZXInPiA9IHtcbiAgICAgIHRleHQ6ICdub3RlJyxcbiAgICAgIG1hcmtkb3duOiAnbm90ZScsXG4gICAgICBzcHJlYWRzaGVldDogJ2RvY3VtZW50JyxcbiAgICAgIGRvY3VtZW50OiAnZG9jdW1lbnQnLFxuICAgICAgcHJlc2VudGF0aW9uOiAnZG9jdW1lbnQnXG4gICAgfTtcbiAgICByZXR1cm4gdHlwZU1hcFtmaWxlVHlwZV0gfHwgJ25vdGUnO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBwcm9qZWN0IG5hbWUgaW5wdXQgcHJvbXB0IHdoZW4gcHJvamVjdCBuYW1lIGlzIG5vdCBzcGVjaWZpZWQgb3IgZ2VuZXJpY1xuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBnZXRQcm9qZWN0TmFtZUlucHV0UHJvbXB0KHByb2plY3REZXRhaWxzOiBQYXJ0aWFsPFByb2plY3REZXRhaWxzPiwgY29udmV4TXV0YXRpb25zOiBDb252ZXhNdXRhdGlvbnMpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBDaGVjayBpZiB0aGVyZSdzIGFscmVhZHkgYSBwZW5kaW5nIHByb2plY3QgY3JlYXRpb25cbiAgICAgIGlmIChQcm9qZWN0Q3JlYXRvckFnZW50LnBlbmRpbmdQcm9qZWN0Q3JlYXRpb24pIHtcbiAgICAgICAgY29uc3QgcGVuZGluZ0FnZSA9IERhdGUubm93KCkgLSBQcm9qZWN0Q3JlYXRvckFnZW50LnBlbmRpbmdQcm9qZWN0Q3JlYXRpb24udGltZXN0YW1wO1xuICAgICAgICBcbiAgICAgICAgLy8gSWYgcGVuZGluZyByZXF1ZXN0IGlzIGxlc3MgdGhhbiA1IG1pbnV0ZXMgb2xkLCByZW1pbmQgdXNlciB0byB1c2UgZXhpc3RpbmcgaW5wdXRcbiAgICAgICAgaWYgKHBlbmRpbmdBZ2UgPCA1ICogNjAgKiAxMDAwKSB7XG4gICAgICAgICAgcmV0dXJuIGDimqDvuI8gKipQbGVhc2UgdXNlIHRoZSBwcm9qZWN0IG5hbWUgaW5wdXQgYWJvdmUqKiB0byBjb21wbGV0ZSB5b3VyIHByZXZpb3VzIHByb2plY3QgY3JlYXRpb24gcmVxdWVzdC5cXG5cXG5JJ20gc3RpbGwgd2FpdGluZyBmb3IgeW91IHRvIGVudGVyIGEgcHJvamVjdCBuYW1lLlxcblxcbl9UbyBzdGFydCBhIG5ldyBwcm9qZWN0IGNyZWF0aW9uLCB3YWl0IGZvciB0aGUgY3VycmVudCBvbmUgdG8gY29tcGxldGUgb3IgY2FuY2VsIGl0IGZpcnN0Ll9gO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIENsZWFyIGV4cGlyZWQgcGVuZGluZyByZXF1ZXN0XG4gICAgICAgICAgUHJvamVjdENyZWF0b3JBZ2VudC5wZW5kaW5nUHJvamVjdENyZWF0aW9uID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBTdG9yZSBwZW5kaW5nIHByb2plY3QgY3JlYXRpb24gc3RhdGVcbiAgICAgIFByb2plY3RDcmVhdG9yQWdlbnQucGVuZGluZ1Byb2plY3RDcmVhdGlvbiA9IHtcbiAgICAgICAgcHJvamVjdERldGFpbHMsXG4gICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKVxuICAgICAgfTtcblxuICAgICAgLy8gU3RvcmUgYSBtZXNzYWdlIHdpdGggaW50ZXJhY3RpdmUgY29tcG9uZW50IGZvciBwcm9qZWN0IG5hbWUgaW5wdXRcbiAgICAgIGlmIChjb252ZXhNdXRhdGlvbnMuc3RvcmVDaGF0TWVzc2FnZSkge1xuICAgICAgICBhd2FpdCBjb252ZXhNdXRhdGlvbnMuc3RvcmVDaGF0TWVzc2FnZSh7XG4gICAgICAgICAgcm9sZTogJ2Fzc2lzdGFudCcgYXMgY29uc3QsXG4gICAgICAgICAgY29udGVudDogYPCfpJYgKipQcm9qZWN0IE5hbWUgUmVxdWlyZWQqKlxuXG5JJ20gcmVhZHkgdG8gY3JlYXRlIHlvdXIgbmV3IHByb2plY3QhIFBsZWFzZSBlbnRlciBhIG5hbWUgZm9yIHlvdXIgcHJvamVjdCB1c2luZyB0aGUgaW5wdXQgYmVsb3c6YCxcbiAgICAgICAgICBwcm9jZXNzSW5kaWNhdG9yOiB7XG4gICAgICAgICAgICB0eXBlOiAnd2FpdGluZycgYXMgY29uc3QsXG4gICAgICAgICAgICBwcm9jZXNzVHlwZTogJ3Byb2plY3RfbmFtZV9pbnB1dCcsXG4gICAgICAgICAgICBjb2xvcjogJ2dyZWVuJyBhcyBjb25zdCxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGludGVyYWN0aXZlQ29tcG9uZW50OiB7XG4gICAgICAgICAgICB0eXBlOiAncHJvamVjdF9zZWxlY3RvcicgYXMgY29uc3QsXG4gICAgICAgICAgICBzdGF0dXM6ICdwZW5kaW5nJyBhcyBjb25zdCxcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgcHJvamVjdERldGFpbHMsXG4gICAgICAgICAgICAgIHByb2plY3ROYW1lSW5wdXQ6IHRydWUsIC8vIEZsYWcgdG8gaW5kaWNhdGUgdGhpcyBpcyBmb3IgcHJvamVjdCBuYW1lIGlucHV0XG4gICAgICAgICAgICAgIHBsYWNlaG9sZGVyOiBwcm9qZWN0RGV0YWlscy50eXBlID8gYCR7cHJvamVjdERldGFpbHMudHlwZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHByb2plY3REZXRhaWxzLnR5cGUuc2xpY2UoMSl9IFByb2plY3RgIDogXCJFbnRlciBwcm9qZWN0IG5hbWUuLi5cIixcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gUmV0dXJuIGVtcHR5IHN0cmluZyBzaW5jZSB0aGUgaW50ZXJhY3RpdmUgY29tcG9uZW50IHdpbGwgaGFuZGxlIHRoZSByZXNwb25zZVxuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEZhbGxiYWNrIHRvIHRleHQtYmFzZWQgaW5wdXQgaWYgc3RvcmVDaGF0TWVzc2FnZSBpcyBub3QgYXZhaWxhYmxlXG4gICAgICAgIGxldCByZXN1bHQgPSBg8J+kliAqKlByb2plY3QgTmFtZSBSZXF1aXJlZCoqXFxuXFxuYDtcbiAgICAgICAgcmVzdWx0ICs9IGBJJ20gcmVhZHkgdG8gY3JlYXRlIHlvdXIgbmV3IHByb2plY3QhXFxuXFxuYDtcbiAgICAgICAgXG4gICAgICAgIGlmIChwcm9qZWN0RGV0YWlscy50eXBlKSB7XG4gICAgICAgICAgcmVzdWx0ICs9IGAqKvCfjq8gUHJvamVjdCBUeXBlOioqICR7cHJvamVjdERldGFpbHMudHlwZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHByb2plY3REZXRhaWxzLnR5cGUuc2xpY2UoMSl9XFxuYDtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYgKHByb2plY3REZXRhaWxzLmRlc2NyaXB0aW9uKSB7XG4gICAgICAgICAgcmVzdWx0ICs9IGAqKvCfk50gRGVzY3JpcHRpb246KiogJHtwcm9qZWN0RGV0YWlscy5kZXNjcmlwdGlvbn1cXG5gO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAocHJvamVjdERldGFpbHMuYnVkZ2V0KSB7XG4gICAgICAgICAgcmVzdWx0ICs9IGAqKvCfkrAgQnVkZ2V0OioqICQke3Byb2plY3REZXRhaWxzLmJ1ZGdldC50b0xvY2FsZVN0cmluZygpfVxcbmA7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJlc3VsdCArPSBgXFxuKirwn5OdIFBsZWFzZSBwcm92aWRlIGEgcHJvamVjdCBuYW1lOioqXFxuYDtcbiAgICAgICAgcmVzdWx0ICs9IGDigKIgVHlwZSB0aGUgcHJvamVjdCBuYW1lIGluIHlvdXIgbmV4dCBtZXNzYWdlXFxuYDtcbiAgICAgICAgcmVzdWx0ICs9IGDigKIgRXhhbXBsZXM6IFwiTWFya2V0aW5nIENhbXBhaWduXCIsIFwiV2Vic2l0ZSBSZWRlc2lnblwiLCBcIlExIEJ1ZGdldCBQbGFubmluZ1wiXFxuXFxuYDtcbiAgICAgICAgcmVzdWx0ICs9IGDwn5KhICoqTmV4dCBtZXNzYWdlOioqIEp1c3QgdHlwZSB5b3VyIHByb2plY3QgbmFtZSFgO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cblxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBzZXR0aW5nIHVwIHByb2plY3QgbmFtZSBpbnB1dDonLCBlcnJvcik7XG4gICAgICByZXR1cm4gYPCfpJYgKipQcm9qZWN0IE5hbWUgUmVxdWlyZWQqKlxuXG5JJ20gcmVhZHkgdG8gY3JlYXRlIHlvdXIgbmV3IHByb2plY3QhIFBsZWFzZSBwcm92aWRlIGEgcHJvamVjdCBuYW1lLlxuXG4qKvCfkqEgVGlwOioqIFlvdSBjYW4gc2F5IHNvbWV0aGluZyBsaWtlOlxuXCJNYXJrZXRpbmcgQ2FtcGFpZ25cIiBvciBcIldlYnNpdGUgUmVkZXNpZ24gUHJvamVjdFwiYDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IGhlbHAgbWVzc2FnZSBmb3IgdGhlIGFnZW50XG4gICAqL1xuICBwcml2YXRlIGdldEhlbHBNZXNzYWdlKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGDwn6SWICoqUHJvamVjdCBDcmVhdG9yIEFnZW50IEhlbHAqKlxuXG5JIGNhbiBoZWxwIHlvdSBjcmVhdGUgcHJvamVjdHMgYW5kIGZpbGVzIHVzaW5nIG5hdHVyYWwgbGFuZ3VhZ2UhIEhlcmUgYXJlIHNvbWUgZXhhbXBsZXM6XG5cbioq8J+TgSBDcmVhdGUgUHJvamVjdHM6KipcbuKAoiBcIkNyZWF0ZSBhIG1hcmtldGluZyBwcm9qZWN0IGZvciBRMSBjYW1wYWlnblwiXG7igKIgXCJTdGFydCBhIG5ldyBkZXZlbG9wbWVudCBwcm9qZWN0IGNhbGxlZCBNb2JpbGUgQXBwXCJcbuKAoiBcIk1ha2UgYSBjb250ZW50IHByb2plY3Qgd2l0aCBpbml0aWFsIGZpbGVzXCJcblxuKirwn5OEIENyZWF0ZSBGaWxlczoqKlxu4oCiIFwiQ3JlYXRlIGEgYnVkZ2V0IHNwcmVhZHNoZWV0IGZvciBNYXJrZXRpbmcgUHJvamVjdFwiXG7igKIgXCJBZGQgbWVldGluZyBub3RlcyB0byBEZXZlbG9wbWVudCBQcm9qZWN0XCJcbuKAoiBcIk1ha2UgYSBwcm9qZWN0IHBsYW4gZG9jdW1lbnRcIlxuXG4qKvCfjqggVXNlIFRlbXBsYXRlczoqKlxu4oCiIFwiU2V0dXAgYSBtYXJrZXRpbmcgdGVtcGxhdGVcIlxu4oCiIFwiQ3JlYXRlIGEgZGV2ZWxvcG1lbnQgcHJvamVjdCBmcm9tIHRlbXBsYXRlXCJcbuKAoiBcIkFwcGx5IGZpbmFuY2lhbCB0ZW1wbGF0ZSBmb3IgQnVkZ2V0IEFuYWx5c2lzXCJcblxuSnVzdCBkZXNjcmliZSB3aGF0IHlvdSB3YW50IHRvIGNyZWF0ZSBhbmQgSSdsbCBoYW5kbGUgdGhlIHJlc3QhIPCfmoBgO1xuICB9XG59XG5cbi8vIEV4cG9ydCBhbiBpbnN0YW5jZSBvZiB0aGUgYWdlbnQgZm9yIHVzZSBpbiB0aGUgcmVnaXN0cnlcbmV4cG9ydCBjb25zdCBwcm9qZWN0Q3JlYXRvckFnZW50ID0gbmV3IFByb2plY3RDcmVhdG9yQWdlbnQoKTtcbiJdLCJuYW1lcyI6WyJCYXNlQWdlbnQiLCJQcm9qZWN0Q3JlYXRvckFnZW50IiwiZXhlY3V0ZSIsInRvb2wiLCJpbnB1dCIsImNvbnZleE11dGF0aW9ucyIsImNvbnNvbGUiLCJsb2ciLCJwcm9jZXNzTmF0dXJhbExhbmd1YWdlUmVxdWVzdCIsImVycm9yIiwiRXJyb3IiLCJtZXNzYWdlIiwibm9ybWFsaXplZElucHV0IiwidG9Mb3dlckNhc2UiLCJ0cmltIiwicGVuZGluZ1Byb2plY3RDcmVhdGlvbiIsInBlbmRpbmdBZ2UiLCJEYXRlIiwibm93IiwidGltZXN0YW1wIiwicHJvamVjdE5hbWVSZXN1bHQiLCJoYW5kbGVQcm9qZWN0TmFtZUlucHV0IiwiaXNQcm9qZWN0Q3JlYXRpb25SZXF1ZXN0IiwiaGFuZGxlUHJvamVjdENyZWF0aW9uIiwiaXNGaWxlQ3JlYXRpb25SZXF1ZXN0IiwiaGFuZGxlRmlsZUNyZWF0aW9uIiwiaXNUZW1wbGF0ZVJlcXVlc3QiLCJoYW5kbGVUZW1wbGF0ZVNldHVwIiwiZ2V0SGVscE1lc3NhZ2UiLCJwcm9qZWN0UGF0dGVybnMiLCJzb21lIiwicGF0dGVybiIsInRlc3QiLCJmaWxlUGF0dGVybnMiLCJ0ZW1wbGF0ZVBhdHRlcm5zIiwicHJvamVjdERldGFpbHMiLCJleHRyYWN0UHJvamVjdERldGFpbHMiLCJuYW1lIiwibGVuZ3RoIiwiZ2V0UHJvamVjdE5hbWVJbnB1dFByb21wdCIsImNyZWF0ZVByb2plY3QiLCJuZXdQcm9qZWN0IiwiZGVzY3JpcHRpb24iLCJzdGF0dXMiLCJidWRnZXQiLCJyZXN1bHQiLCJwcm9qZWN0TnVtYmVyIiwidG9Mb2NhbGVEYXRlU3RyaW5nIiwiY3JlYXRlRmlsZXMiLCJjcmVhdGVGaWxlIiwiZmlsZVJlc3VsdHMiLCJjcmVhdGVJbml0aWFsRmlsZXMiLCJwcm9qZWN0TmFtZSIsInVwZGF0ZWRQcm9qZWN0RGV0YWlscyIsImZpbGVEZXRhaWxzIiwiZXh0cmFjdEZpbGVEZXRhaWxzIiwiZmlsZU5hbWUiLCJjb250ZW50IiwiZ2VuZXJhdGVGaWxlQ29udGVudCIsImZpbGVUeXBlIiwidGVtcGxhdGVEZXRhaWxzIiwiZXh0cmFjdFRlbXBsYXRlRGV0YWlscyIsInR5cGUiLCJjaGFyQXQiLCJ0b1VwcGVyQ2FzZSIsInNsaWNlIiwiZ2V0VGVtcGxhdGVEZXNjcmlwdGlvbiIsImdldFRlbXBsYXRlQnVkZ2V0IiwidGVtcGxhdGVGaWxlcyIsImNyZWF0ZVRlbXBsYXRlRmlsZXMiLCJuYW1lUGF0dGVybnMiLCJtYXRjaCIsImV4dHJhY3RlZE5hbWUiLCJnZW5lcmljTmFtZXMiLCJpbmNsdWRlcyIsImRlc2NyaXB0aW9uTWF0Y2giLCJ1bmRlZmluZWQiLCJ0eXBlS2V5d29yZHMiLCJtYXJrZXRpbmciLCJkZXZlbG9wbWVudCIsImZpbmFuY2lhbCIsInNvY2lhbCIsInByb2plY3RUeXBlIiwia2V5d29yZHMiLCJPYmplY3QiLCJlbnRyaWVzIiwia2V5d29yZCIsImJ1ZGdldE1hdGNoIiwicGFyc2VJbnQiLCJyZXBsYWNlIiwiZ2V0RGVmYXVsdEJ1ZGdldCIsImV4dGVuc2lvbiIsIm5hbWVNYXRjaCIsInByb2plY3RNYXRjaCIsInRlbXBsYXRlVHlwZXMiLCJ0ZW1wbGF0ZVR5cGUiLCJidWRnZXRzIiwiZGVzY3JpcHRpb25zIiwicHJvamVjdCIsImZpbGVzIiwicmVzdWx0cyIsImZpbGUiLCJwcm9qZWN0SWQiLCJfaWQiLCJwdXNoIiwiam9pbiIsImdldFRlbXBsYXRlRmlsZXMiLCJ0ZW1wbGF0ZXMiLCJiYXNlQ29udGVudCIsInNwcmVhZHNoZWV0IiwiZG9jdW1lbnQiLCJtYXJrZG93biIsInRleHQiLCJtYXBUb0NvbnZleEZpbGVUeXBlIiwidHlwZU1hcCIsInByZXNlbnRhdGlvbiIsInN0b3JlQ2hhdE1lc3NhZ2UiLCJyb2xlIiwicHJvY2Vzc0luZGljYXRvciIsInByb2Nlc3NUeXBlIiwiY29sb3IiLCJpbnRlcmFjdGl2ZUNvbXBvbmVudCIsImRhdGEiLCJwcm9qZWN0TmFtZUlucHV0IiwicGxhY2Vob2xkZXIiLCJ0b0xvY2FsZVN0cmluZyIsImlkIiwiaWNvbiIsInRvb2xzIiwiY29tbWFuZCIsInBhcmFtZXRlcnMiLCJwcm9qZWN0Q3JlYXRvckFnZW50Il0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./store/agents/projectCreatorAgent.ts\n"));

/***/ })

});