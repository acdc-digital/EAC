"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./store/agents/directorAgent.ts":
/*!***************************************!*\
  !*** ./store/agents/directorAgent.ts ***!
  \***************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DirectorAgent: () => (/* binding */ DirectorAgent),\n/* harmony export */   directorAgent: () => (/* binding */ directorAgent)\n/* harmony export */ });\n/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ \"(app-pages-browser)/./store/agents/base.ts\");\n// Campaign Director Agent\n// Orchestrates large-scale marketing campaigns with 100+ posts across multiple platforms\n\nclass DirectorAgent extends _base__WEBPACK_IMPORTED_MODULE_0__.BaseAgent {\n    async execute(tool, input, convexMutations, sessionId) {\n        console.log('🔥 Director Agent: Execute called with input:', input);\n        console.log('🔥 Director Agent: Session ID:', sessionId);\n        if (!sessionId) {\n            return 'Session ID is required for campaign orchestration';\n        }\n        // Initialize or get session\n        const existingSession = this.sessions.has(sessionId);\n        console.log('🔥 Director Agent: Existing session found:', existingSession);\n        if (!this.sessions.has(sessionId)) {\n            console.log('🔥 Director Agent: Creating new session');\n            this.sessions.set(sessionId, {\n                currentStep: 'campaign-name',\n                activeCampaigns: new Map()\n            });\n        }\n        const session = this.sessions.get(sessionId);\n        console.log('🔥 Director Agent: Current session step:', session.currentStep);\n        console.log('🔥 Director Agent: Has instructions file:', !!session.instructionsFile);\n        // If session is already complete, return success message\n        if (session.currentStep === 'complete') {\n            return 'Campaign has been successfully generated and scheduled! Use `/director` to start a new campaign.';\n        }\n        // Step 1: Request campaign name and create project\n        if (session.currentStep === 'campaign-name') {\n            // Check if this is a campaign name input\n            if (input && input.trim() && !input.includes('Selected file:') && !input.startsWith('/')) {\n                const campaignName = input.trim();\n                console.log('🔥 Director Agent: Creating campaign project:', campaignName);\n                try {\n                    var _convexMutations_createProject;\n                    // Create the project using Convex mutations\n                    const project = await ((_convexMutations_createProject = convexMutations.createProject) === null || _convexMutations_createProject === void 0 ? void 0 : _convexMutations_createProject.call(convexMutations, {\n                        name: campaignName,\n                        description: \"Marketing campaign project: \".concat(campaignName),\n                        status: 'active'\n                    }));\n                    if (project) {\n                        const projectData = project;\n                        session.campaignProjectId = projectData._id || projectData.id || campaignName;\n                        session.campaignProjectName = campaignName;\n                        session.currentStep = 'instructions';\n                        console.log('🔥 Director Agent: Project created, moving to instructions step');\n                        // Continue to instructions step\n                        if (convexMutations.storeChatMessage) {\n                            await convexMutations.storeChatMessage({\n                                role: 'assistant',\n                                content: '✅ Campaign project \"'.concat(campaignName, '\" created successfully!\\n\\nNow, please select an instructions file that contains your campaign guidelines, brand voice, or marketing strategy.\\n\\nWhat you can include in your instructions file:\\n- Brand voice and tone guidelines\\n- Target audience information\\n- Campaign objectives and KPIs\\n- Content themes and messaging\\n- Platform-specific requirements\\n- Hashtag strategies\\n- Visual guidelines\\n\\nSelect your instructions file:'),\n                                sessionId,\n                                interactiveComponent: {\n                                    type: 'file_selector',\n                                    status: 'pending',\n                                    data: {\n                                        fileType: 'instructions',\n                                        filterByExtension: [\n                                            '.md',\n                                            '.txt'\n                                        ],\n                                        placeholder: 'Select campaign instructions file...'\n                                    }\n                                }\n                            });\n                        }\n                        return 'Campaign project \"'.concat(campaignName, '\" created! Please select an instructions file to continue.');\n                    } else {\n                        return 'Failed to create campaign project. Please try again.';\n                    }\n                } catch (error) {\n                    console.error('🔥 Director Agent: Error creating project:', error);\n                    return 'Error creating campaign project. Please try again with a different name.';\n                }\n            } else {\n                // Show campaign name input prompt\n                if (convexMutations.storeChatMessage) {\n                    await convexMutations.storeChatMessage({\n                        role: 'assistant',\n                        content: '🎬 **Campaign Director Agent**\\n\\nI will help you orchestrate a comprehensive marketing campaign with 100+ posts across multiple platforms.\\n\\n**Step 1: Create Campaign Project**\\n\\nFirst, let\\'s create a dedicated project folder for your campaign. This will organize all your generated content, schedules, and assets.\\n\\nWhat would you like to name your campaign project?',\n                        sessionId,\n                        interactiveComponent: {\n                            type: 'file_name_input',\n                            status: 'pending',\n                            data: {\n                                placeholder: 'Enter campaign name (e.g., \"Q4 Product Launch\", \"Holiday Marketing 2025\")',\n                                fileType: 'project'\n                            }\n                        }\n                    });\n                }\n                return 'Please enter a name for your campaign project.';\n            }\n        }\n        // Handle file selection input AFTER campaign name step\n        if (input.includes('Selected file:') && session.currentStep === 'instructions') {\n            console.log('🔥 Director Agent: Processing file selection:', input);\n            console.log('🔥 Director Agent: Session step:', session.currentStep);\n            const fileName = input.replace('Selected file:', '').trim();\n            console.log('🔥 Director Agent: Extracted filename:', fileName);\n            session.instructionsFile = fileName;\n            // Fetch the file content\n            try {\n                var _convexMutations_getAllFiles;\n                const files = await ((_convexMutations_getAllFiles = convexMutations.getAllFiles) === null || _convexMutations_getAllFiles === void 0 ? void 0 : _convexMutations_getAllFiles.call(convexMutations)) || [];\n                console.log('🔥 Director Agent: Available files count:', files.length);\n                console.log('🔥 Director Agent: Available file names:', files.map((f)=>f.name));\n                // Try to find the file with or without extension\n                let instructionFile = files.find((f)=>f.name === fileName);\n                if (!instructionFile && !fileName.includes('.')) {\n                    // Try with .md extension\n                    instructionFile = files.find((f)=>f.name === fileName + '.md');\n                    console.log('🔥 Director Agent: Trying with .md extension:', fileName + '.md');\n                }\n                console.log('🔥 Director Agent: Found instruction file:', !!instructionFile);\n                if (instructionFile) {\n                    session.instructionsContent = instructionFile.content;\n                    session.instructionsFile = fileName; // Make sure this is set\n                    session.currentStep = 'complete'; // Set to complete after generation\n                    console.log('🔥 Director Agent: Updated session step to complete');\n                    // Set default campaign settings based on instructions\n                    session.campaignName = 'EAC Marketing Campaign';\n                    session.duration = 4; // weeks\n                    session.platforms = [\n                        'twitter',\n                        'linkedin',\n                        'instagram',\n                        'facebook'\n                    ];\n                    session.postsPerDay = 3;\n                    session.campaignGoals = 'Brand awareness and lead generation based on instructions';\n                    // Immediately generate campaign\n                    const result = await this.generateCampaign(session, convexMutations, sessionId);\n                    console.log('🔥 Director Agent: Campaign generation result:', result);\n                    return result;\n                } else {\n                    console.log('🔥 Director Agent: File not found in files array');\n                    return 'File \"'.concat(fileName, '\" not found. Please select a valid instructions file.');\n                }\n            } catch (error) {\n                console.error('🔥 Director Agent: Error loading instructions file:', error);\n                return 'Error loading instructions file. Please try again.';\n            }\n        }\n        // Step 1: Request instructions file (only if we haven't processed file selection and not complete)\n        if (session.currentStep === 'instructions' && !session.instructionsFile) {\n            if (convexMutations.storeChatMessage) {\n                await convexMutations.storeChatMessage({\n                    role: 'assistant',\n                    content: 'Campaign Director Agent\\n\\nI will help you orchestrate a comprehensive marketing campaign with 100+ posts across multiple platforms.\\n\\nStep 1: Select Instructions File\\n\\nFirst, I need to understand your campaign strategy. Please select an instructions file that contains your campaign guidelines, brand voice, or marketing strategy.\\n\\nWhat you can include in your instructions file:\\n- Brand voice and tone guidelines\\n- Target audience information\\n- Campaign objectives and KPIs\\n- Content themes and messaging\\n- Platform-specific requirements\\n- Hashtag strategies\\n- Visual guidelines\\n\\nSelect your instructions file:',\n                    sessionId,\n                    interactiveComponent: {\n                        type: 'file_selector',\n                        status: 'pending',\n                        data: {\n                            fileType: 'instructions',\n                            filterByExtension: [\n                                '.md',\n                                '.txt'\n                            ],\n                            placeholder: 'Select campaign instructions file...'\n                        }\n                    }\n                });\n            }\n            return 'Please select an instructions file to get started with your campaign.';\n        }\n        // Handle campaign configuration\n        if (session.currentStep === 'campaign-setup') {\n            if (input.toLowerCase().includes('generate default campaign') || input.toLowerCase().includes('default')) {\n                // Use default campaign settings\n                session.campaignName = 'EAC Marketing Campaign';\n                session.duration = 4; // weeks\n                session.platforms = [\n                    'twitter',\n                    'linkedin',\n                    'instagram',\n                    'facebook'\n                ];\n                session.postsPerDay = 3;\n                session.campaignGoals = 'Brand awareness and lead generation';\n                session.currentStep = 'generating';\n                return await this.generateCampaign(session, convexMutations, sessionId);\n            } else {\n                // Parse custom campaign settings from user input\n                return this.parseCampaignSettings(input, session);\n            }\n        }\n        // Handle batch generation status updates\n        if (input.includes('batch completed') || input.includes('posts generated')) {\n            return this.handleBatchCompletion(input, session);\n        }\n        return 'Campaign orchestration in progress. Use /director to start a new campaign.';\n    }\n    parseCampaignSettings(input, session) {\n        var _session_platforms;\n        // Extract campaign settings from user input\n        const lines = input.split('\\n').map((line)=>line.trim()).filter((line)=>line.length > 0);\n        for (const line of lines){\n            const lower = line.toLowerCase();\n            if (lower.includes('name:') || lower.startsWith('1.')) {\n                var _line_split_;\n                session.campaignName = ((_line_split_ = line.split(':')[1]) === null || _line_split_ === void 0 ? void 0 : _line_split_.trim()) || line.replace(/^1\\./, '').trim();\n            } else if (lower.includes('duration:') || lower.includes('weeks') || lower.startsWith('2.')) {\n                const match = line.match(/(\\d+)/);\n                if (match) session.duration = parseInt(match[1]);\n            } else if (lower.includes('platform') || lower.startsWith('3.')) {\n                const platforms = line.toLowerCase().match(/(twitter|linkedin|facebook|instagram)/g);\n                if (platforms) session.platforms = platforms;\n            } else if (lower.includes('posts per day') || lower.startsWith('4.')) {\n                const match = line.match(/(\\d+)/);\n                if (match) session.postsPerDay = parseInt(match[1]);\n            } else if (lower.includes('goals:') || lower.startsWith('5.')) {\n                var _line_split_1;\n                session.campaignGoals = ((_line_split_1 = line.split(':')[1]) === null || _line_split_1 === void 0 ? void 0 : _line_split_1.trim()) || line.replace(/^5\\./, '').trim();\n            }\n        }\n        // Validate required fields\n        if (!session.campaignName || !session.duration || !((_session_platforms = session.platforms) === null || _session_platforms === void 0 ? void 0 : _session_platforms.length)) {\n            return 'Please provide all required campaign details:\\n\\n1. Campaign Name\\n2. Duration (weeks)\\n3. Platforms\\n4. Posts per day\\n5. Goals\\n\\nOr type \"generate default campaign\" to use standard settings.';\n        }\n        session.currentStep = 'generating';\n        return \"Campaign Configuration Set:\\n\\nName: \".concat(session.campaignName, \"\\nDuration: \").concat(session.duration, \" weeks\\nPlatforms: \").concat(session.platforms.join(', '), \"\\nPosts per day: \").concat(session.postsPerDay, \"\\nGoals: \").concat(session.campaignGoals, \"\\n\\nGenerating your comprehensive campaign...\");\n    }\n    async generateCampaign(session, convexMutations, sessionId) {\n        try {\n            // Calculate total posts needed\n            const totalDays = (session.duration || 4) * 7;\n            const postsPerDay = session.postsPerDay || 3;\n            const totalPosts = totalDays * postsPerDay;\n            const platforms = session.platforms || [\n                'twitter',\n                'linkedin',\n                'instagram',\n                'facebook'\n            ];\n            // Create campaign in database\n            let campaignId;\n            try {\n                var _convexMutations_createCampaign;\n                const campaign = await ((_convexMutations_createCampaign = convexMutations.createCampaign) === null || _convexMutations_createCampaign === void 0 ? void 0 : _convexMutations_createCampaign.call(convexMutations, {\n                    name: session.campaignName || 'Generated Campaign',\n                    description: \"Auto-generated campaign: \".concat(session.campaignGoals || 'Marketing campaign'),\n                    platforms,\n                    totalPosts,\n                    startDate: new Date().toISOString().split('T')[0],\n                    endDate: new Date(Date.now() + (session.duration || 4) * 7 * 24 * 60 * 60 * 1000).toISOString().split('T')[0],\n                    template: session.instructionsContent || ''\n                }));\n                campaignId = (campaign === null || campaign === void 0 ? void 0 : campaign._id) || \"campaign_\".concat(Date.now());\n            } catch (error) {\n                console.log('Campaign creation not available, using fallback ID');\n                campaignId = \"campaign_\".concat(Date.now());\n            }\n            // Generate posts in batches\n            const allPosts = await this.generateBatchesAsync(totalPosts, platforms, session.instructionsContent || '', campaignId, session.duration || 4);\n            // Create batches for processing\n            const batches = this.createBatches(allPosts, campaignId);\n            // Store batches in session\n            batches.forEach((batch)=>{\n                session.activeCampaigns.set(batch.campaignId, batch);\n            });\n            // Start with progress indicator\n            if (convexMutations.storeChatMessage) {\n                await convexMutations.storeChatMessage({\n                    role: 'assistant',\n                    content: \"Campaign Generation Complete!\\n\\nGenerated \".concat(totalPosts, \" posts across \").concat(platforms.length, \" platforms\\nOrganized into \").concat(batches.length, \" processing batches\\nStarting content creation and scheduling...\\n\\nCampaign ID: \").concat(campaignId, \"\\nTotal Posts: \").concat(totalPosts, \"\\nPlatforms: \").concat(platforms.join(', '), \"\\nDuration: \").concat(session.duration, \" weeks\"),\n                    sessionId,\n                    processIndicator: {\n                        type: 'continuing',\n                        processType: 'Processing Campaign Batches',\n                        color: 'blue'\n                    }\n                });\n            }\n            // Process all batches with progress updates\n            for(let i = 0; i < batches.length; i++){\n                const batch = batches[i];\n                console.log(\"\\uD83D\\uDD25 Director Agent: Processing batch \".concat(i + 1, \"/\").concat(batches.length));\n                // Update progress\n                if (convexMutations.storeChatMessage) {\n                    await convexMutations.storeChatMessage({\n                        role: 'assistant',\n                        content: \"Processing batch \".concat(i + 1, \" of \").concat(batches.length, \"... (\").concat(batch.posts.length, \" posts)\"),\n                        sessionId,\n                        processIndicator: {\n                            type: 'continuing',\n                            processType: \"Batch \".concat(i + 1, \"/\").concat(batches.length),\n                            color: 'blue'\n                        }\n                    });\n                }\n                await this.processBatch(batch, convexMutations, sessionId);\n                // Small delay between batches to prevent overwhelming the database\n                if (i < batches.length - 1) {\n                    await new Promise((resolve)=>setTimeout(resolve, 1000));\n                }\n            }\n            // Final success message\n            if (convexMutations.storeChatMessage) {\n                await convexMutations.storeChatMessage({\n                    role: 'assistant',\n                    content: \"✅ Campaign Successfully Created!\\n\\n\\uD83D\\uDCCA **Campaign Summary:**\\n- **Campaign ID:** \".concat(campaignId, \"\\n- **Total Posts:** \").concat(totalPosts, \"\\n- **Platforms:** \").concat(platforms.join(', '), \"\\n- **Duration:** \").concat(session.duration, \" weeks\\n- **Batches Processed:** \").concat(batches.length, \"\\n\\n\\uD83D\\uDDD3️ All posts have been scheduled and saved to the database. Use the social media dashboard to review and manage your campaign.\"),\n                    sessionId\n                });\n            }\n            session.currentStep = 'complete';\n            return 'Campaign processing completed successfully!';\n        } catch (error) {\n            console.error('Campaign generation error:', error);\n            return \"Error generating campaign: \".concat(error instanceof Error ? error.message : 'Unknown error');\n        }\n    }\n    async generateBatchesAsync(totalPosts, platforms, instructions, campaignId, duration) {\n        const posts = [];\n        const days = [\n            'Monday',\n            'Tuesday',\n            'Wednesday',\n            'Thursday',\n            'Friday',\n            'Saturday',\n            'Sunday'\n        ];\n        for(let i = 0; i < totalPosts; i++){\n            const platform = platforms[i % platforms.length];\n            const week = Math.floor(i / (totalPosts / duration)) + 1;\n            const dayIndex = i % 7;\n            const day = days[dayIndex];\n            // Determine optimal posting time based on platform\n            const time = this.getOptimalPostTime(platform, dayIndex);\n            // Calculate post date\n            const startDate = new Date();\n            const postDate = new Date(startDate);\n            postDate.setDate(startDate.getDate() + Math.floor(i / platforms.length));\n            // Determine campaign phase based on week\n            const phases = [\n                'awareness',\n                'consideration',\n                'conversion',\n                'retention'\n            ];\n            const phaseIndex = Math.floor((week - 1) / (duration / phases.length));\n            const phase = phases[Math.min(phaseIndex, phases.length - 1)];\n            // Determine content type cyclically\n            const contentTypes = [\n                'educational',\n                'promotional',\n                'engagement',\n                'announcement'\n            ];\n            const contentType = contentTypes[i % contentTypes.length];\n            // Generate content\n            const content = this.generatePlatformContent(platform, phase, contentType, instructions, week, day);\n            posts.push({\n                platform,\n                content,\n                scheduledDate: postDate.toISOString().split('T')[0],\n                scheduledTime: time,\n                metadata: {\n                    week,\n                    dayOfWeek: day,\n                    campaignPhase: phase,\n                    contentType,\n                    hashtags: this.generateHashtags(platform, phase, contentType),\n                    campaignId,\n                    batchId: \"batch_\".concat(Math.floor(i / this.BATCH_SIZE))\n                }\n            });\n        }\n        return posts;\n    }\n    getOptimalPostTime(platform, dayIndex) {\n        const times = {\n            twitter: [\n                '09:00',\n                '12:00',\n                '15:00',\n                '18:00'\n            ],\n            linkedin: [\n                '08:00',\n                '12:00',\n                '17:00'\n            ],\n            instagram: [\n                '11:00',\n                '14:00',\n                '17:00',\n                '19:00'\n            ],\n            facebook: [\n                '09:00',\n                '13:00',\n                '15:00'\n            ]\n        };\n        const platformTimes = times[platform] || times.twitter;\n        return platformTimes[dayIndex % platformTimes.length];\n    }\n    generatePlatformContent(platform, phase, contentType, instructions, week, day) {\n        const brandVoice = this.extractBrandVoice(instructions);\n        const audience = this.extractAudience(instructions);\n        const content = \"\".concat(brandVoice, \" content for \").concat(audience, \" - Week \").concat(week, \", \").concat(day, \". Phase: \").concat(phase, \", Type: \").concat(contentType, \". Platform: \").concat(platform);\n        // Platform-specific formatting\n        switch(platform){\n            case 'twitter':\n                return content.length > 250 ? content.substring(0, 247) + '...' : content;\n            case 'linkedin':\n                return \"\".concat(content, \"\\n\\n#LinkedInEngagement #ProfessionalGrowth\");\n            case 'instagram':\n                return \"\".concat(content, \" ✨\\n\\n#InstagramBusiness #VisualContent\");\n            case 'facebook':\n                return \"\".concat(content, \"\\n\\nWhat do you think? Share your thoughts below! \\uD83D\\uDC47\");\n            default:\n                return content;\n        }\n    }\n    extractBrandVoice(instructions) {\n        const voiceKeywords = [\n            'professional',\n            'friendly',\n            'innovative',\n            'trusted',\n            'expert',\n            'reliable'\n        ];\n        const lowerInstructions = instructions.toLowerCase();\n        for (const keyword of voiceKeywords){\n            if (lowerInstructions.includes(keyword)) {\n                return keyword.charAt(0).toUpperCase() + keyword.slice(1);\n            }\n        }\n        return 'Professional';\n    }\n    extractAudience(instructions) {\n        const audienceKeywords = [\n            'businesses',\n            'professionals',\n            'teams',\n            'companies',\n            'organizations',\n            'users'\n        ];\n        const lowerInstructions = instructions.toLowerCase();\n        for (const keyword of audienceKeywords){\n            if (lowerInstructions.includes(keyword)) {\n                return keyword;\n            }\n        }\n        return 'professionals';\n    }\n    generateHashtags(platform, phase, contentType) {\n        const baseHashtags = [\n            'marketing',\n            'business',\n            'growth'\n        ];\n        const phaseHashtags = {\n            awareness: [\n                'brandawareness',\n                'introduction'\n            ],\n            consideration: [\n                'solutions',\n                'evaluation'\n            ],\n            conversion: [\n                'getstarted',\n                'action'\n            ],\n            retention: [\n                'community',\n                'success'\n            ]\n        };\n        const contentHashtags = {\n            educational: [\n                'tips',\n                'learning'\n            ],\n            promotional: [\n                'offer',\n                'featured'\n            ],\n            engagement: [\n                'discussion',\n                'question'\n            ],\n            announcement: [\n                'news',\n                'update'\n            ]\n        };\n        return [\n            ...baseHashtags,\n            ...phaseHashtags[phase],\n            ...contentHashtags[contentType]\n        ].slice(0, 5);\n    }\n    createBatches(posts, campaignId) {\n        const batches = [];\n        for(let i = 0; i < posts.length; i += this.BATCH_SIZE){\n            const batchPosts = posts.slice(i, i + this.BATCH_SIZE);\n            batches.push({\n                campaignId: \"\".concat(campaignId, \"_batch_\").concat(batches.length),\n                posts: batchPosts,\n                processingStatus: 'pending',\n                processedCount: 0,\n                totalCount: batchPosts.length\n            });\n        }\n        return batches;\n    }\n    async processBatch(batch, convexMutations, sessionId) {\n        batch.processingStatus = 'processing';\n        try {\n            const postPromises = batch.posts.map(async (post)=>{\n                try {\n                    await convexMutations.upsertPost({\n                        fileName: \"\".concat(post.platform, \"_\").concat(post.metadata.week, \"_\").concat(post.metadata.dayOfWeek, \"_\").concat(Date.now()),\n                        fileType: post.platform,\n                        content: post.content,\n                        title: \"Week \".concat(post.metadata.week, \" - \").concat(post.metadata.campaignPhase),\n                        platformData: JSON.stringify({\n                            scheduledDate: post.scheduledDate,\n                            scheduledTime: post.scheduledTime,\n                            hashtags: post.metadata.hashtags,\n                            campaignId: post.metadata.campaignId,\n                            batchId: post.metadata.batchId,\n                            week: post.metadata.week,\n                            dayOfWeek: post.metadata.dayOfWeek,\n                            campaignPhase: post.metadata.campaignPhase,\n                            contentType: post.metadata.contentType\n                        }),\n                        status: 'scheduled',\n                        scheduledFor: new Date(\"\".concat(post.scheduledDate, \"T\").concat(post.scheduledTime)).getTime()\n                    });\n                    batch.processedCount++;\n                } catch (error) {\n                    console.error('Error processing post:', error);\n                }\n            });\n            await Promise.all(postPromises);\n            batch.processingStatus = 'completed';\n        } catch (error) {\n            console.error('Batch processing error:', error);\n            batch.processingStatus = 'failed';\n        }\n    }\n    handleBatchCompletion(input, session) {\n        const completedBatches = Array.from(session.activeCampaigns.values()).filter((batch)=>batch.processingStatus === 'completed');\n        const totalBatches = session.activeCampaigns.size;\n        const totalProcessed = completedBatches.reduce((sum, batch)=>sum + batch.processedCount, 0);\n        if (completedBatches.length === totalBatches) {\n            session.currentStep = 'complete';\n            return \"Campaign Complete!\\n\\nAll \".concat(totalBatches, \" batches processed successfully.\\nTotal posts created: \").concat(totalProcessed, \"\\nCampaign: \").concat(session.campaignName, \"\\n\\nYour comprehensive marketing campaign is now scheduled and ready!\");\n        }\n        return \"Progress Update:\\nCompleted: \".concat(completedBatches.length, \"/\").concat(totalBatches, \" batches\\nPosts processed: \").concat(totalProcessed, \"\\nContinuing campaign generation...\");\n    }\n    constructor(...args){\n        super(...args), this.id = 'director', this.name = 'Campaign Director', this.description = 'Orchestrates large-scale marketing campaigns with 100+ posts across multiple platforms. Integrates instruction files for brand guidelines and generates comprehensive content strategies.', this.icon = '🎬', this.sessions = new Map(), this.BATCH_SIZE = 10, this.MAX_CONCURRENT_BATCHES = 3, this.tools = [\n            {\n                id: 'orchestrate-campaign',\n                name: 'Orchestrate Campaign',\n                command: '/director',\n                description: 'Create and schedule a complete marketing campaign with 100+ posts across multiple platforms',\n                parameters: []\n            }\n        ];\n    }\n}\nconst directorAgent = new DirectorAgent();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3N0b3JlL2FnZW50cy9kaXJlY3RvckFnZW50LnRzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLDBCQUEwQjtBQUMxQix5RkFBeUY7QUFFM0M7QUEwQ3ZDLE1BQU1DLHNCQUFzQkQsNENBQVNBO0lBb0IxQyxNQUFNRSxRQUFRQyxJQUFlLEVBQUVDLEtBQWEsRUFBRUMsZUFBZ0MsRUFBRUMsU0FBa0IsRUFBbUI7UUFDbkhDLFFBQVFDLEdBQUcsQ0FBQyxpREFBaURKO1FBQzdERyxRQUFRQyxHQUFHLENBQUMsa0NBQWtDRjtRQUU5QyxJQUFJLENBQUNBLFdBQVc7WUFDZCxPQUFPO1FBQ1Q7UUFFQSw0QkFBNEI7UUFDNUIsTUFBTUcsa0JBQWtCLElBQUksQ0FBQ0MsUUFBUSxDQUFDQyxHQUFHLENBQUNMO1FBQzFDQyxRQUFRQyxHQUFHLENBQUMsOENBQThDQztRQUUxRCxJQUFJLENBQUMsSUFBSSxDQUFDQyxRQUFRLENBQUNDLEdBQUcsQ0FBQ0wsWUFBWTtZQUNqQ0MsUUFBUUMsR0FBRyxDQUFDO1lBQ1osSUFBSSxDQUFDRSxRQUFRLENBQUNFLEdBQUcsQ0FBQ04sV0FBVztnQkFDM0JPLGFBQWE7Z0JBQ2JDLGlCQUFpQixJQUFJQztZQUN2QjtRQUNGO1FBRUEsTUFBTUMsVUFBVSxJQUFJLENBQUNOLFFBQVEsQ0FBQ08sR0FBRyxDQUFDWDtRQUNsQ0MsUUFBUUMsR0FBRyxDQUFDLDRDQUE0Q1EsUUFBUUgsV0FBVztRQUMzRU4sUUFBUUMsR0FBRyxDQUFDLDZDQUE2QyxDQUFDLENBQUNRLFFBQVFFLGdCQUFnQjtRQUVuRix5REFBeUQ7UUFDekQsSUFBSUYsUUFBUUgsV0FBVyxLQUFLLFlBQVk7WUFDdEMsT0FBTztRQUNUO1FBRUEsbURBQW1EO1FBQ25ELElBQUlHLFFBQVFILFdBQVcsS0FBSyxpQkFBaUI7WUFDM0MseUNBQXlDO1lBQ3pDLElBQUlULFNBQVNBLE1BQU1lLElBQUksTUFBTSxDQUFDZixNQUFNZ0IsUUFBUSxDQUFDLHFC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QUFpQk4saUJBQWlCTyxNQUFNLENBQUMsQ0FBQ0MsS0FBSzdGLFFBQVU2RixNQUFNN0YsTUFBTXlFLGNBQWMsRUFBRTtRQUUzRixJQUFJWSxpQkFBaUI1SCxNQUFNLEtBQUtnSSxjQUFjO1lBQzVDL0osUUFBUUgsV0FBVyxHQUFHO1lBQ3RCLE9BQU8sNkJBQW1Hb0ssT0FBdEVGLGNBQWEsMkRBQXNGL0osT0FBN0JpSyxnQkFBZSxnQkFBbUMsT0FBckJqSyxRQUFRTSxZQUFZLEVBQUM7UUFDOUo7UUFFQSxPQUFPLGdDQUEyRHlKLE9BQTNCSixpQkFBaUI1SCxNQUFNLEVBQUMsS0FBNkNrSSxPQUExQ0YsY0FBYSwrQkFBNEMsT0FBZkUsZ0JBQWU7SUFDN0g7O1FBNWlCSyxxQkFDTGxKLEtBQUssaUJBQ0xOLE9BQU8sMEJBQ1BDLGNBQWMsa01BQ2QwSixPQUFPLFdBRUMxSyxXQUF5QyxJQUFJSyxZQUNwQ2dILGFBQWEsU0FDYnNELHlCQUF5QixRQUUxQ0MsUUFBcUI7WUFDbkI7Z0JBQ0V2SixJQUFJO2dCQUNKTixNQUFNO2dCQUNOOEosU0FBUztnQkFDVDdKLGFBQWE7Z0JBQ2I4SixZQUFZLEVBQUU7WUFDaEI7U0FDRDs7QUEyaEJIO0FBRU8sTUFBTUMsZ0JBQWdCLElBQUl4TCxnQkFBZ0IiLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYXR0aGV3c2ltb24vUHJvamVjdHMvZWFjL2VhYy9zdG9yZS9hZ2VudHMvZGlyZWN0b3JBZ2VudC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDYW1wYWlnbiBEaXJlY3RvciBBZ2VudFxuLy8gT3JjaGVzdHJhdGVzIGxhcmdlLXNjYWxlIG1hcmtldGluZyBjYW1wYWlnbnMgd2l0aCAxMDArIHBvc3RzIGFjcm9zcyBtdWx0aXBsZSBwbGF0Zm9ybXNcblxuaW1wb3J0IHsgQWdlbnRUb29sLCBCYXNlQWdlbnQgfSBmcm9tICcuL2Jhc2UnO1xuaW1wb3J0IHsgQ29udmV4TXV0YXRpb25zIH0gZnJvbSAnLi90eXBlcyc7XG5cbmludGVyZmFjZSBDYW1wYWlnblBvc3Qge1xuICBwbGF0Zm9ybTogJ3R3aXR0ZXInIHwgJ2xpbmtlZGluJyB8ICdmYWNlYm9vaycgfCAnaW5zdGFncmFtJztcbiAgY29udGVudDogc3RyaW5nO1xuICBzY2hlZHVsZWREYXRlOiBzdHJpbmc7XG4gIHNjaGVkdWxlZFRpbWU6IHN0cmluZztcbiAgbWV0YWRhdGE6IHtcbiAgICB3ZWVrOiBudW1iZXI7XG4gICAgZGF5T2ZXZWVrOiBzdHJpbmc7XG4gICAgY2FtcGFpZ25QaGFzZTogJ2F3YXJlbmVzcycgfCAnY29uc2lkZXJhdGlvbicgfCAnY29udmVyc2lvbicgfCAncmV0ZW50aW9uJztcbiAgICBjb250ZW50VHlwZTogJ2VkdWNhdGlvbmFsJyB8ICdwcm9tb3Rpb25hbCcgfCAnZW5nYWdlbWVudCcgfCAnYW5ub3VuY2VtZW50JztcbiAgICBoYXNodGFnczogc3RyaW5nW107XG4gICAgY2FtcGFpZ25JZD86IHN0cmluZztcbiAgICBiYXRjaElkPzogc3RyaW5nO1xuICB9O1xufVxuXG5pbnRlcmZhY2UgQ2FtcGFpZ25CYXRjaCB7XG4gIGNhbXBhaWduSWQ6IHN0cmluZztcbiAgcG9zdHM6IENhbXBhaWduUG9zdFtdO1xuICBwcm9jZXNzaW5nU3RhdHVzOiAncGVuZGluZycgfCAncHJvY2Vzc2luZycgfCAnY29tcGxldGVkJyB8ICdmYWlsZWQnO1xuICBwcm9jZXNzZWRDb3VudDogbnVtYmVyO1xuICB0b3RhbENvdW50OiBudW1iZXI7XG59XG5cbmludGVyZmFjZSBEaXJlY3RvclNlc3Npb24ge1xuICBjYW1wYWlnblByb2plY3RJZD86IHN0cmluZzsgLy8gUHJvamVjdCBJRCBmb3IgdGhlIGNhbXBhaWduXG4gIGNhbXBhaWduUHJvamVjdE5hbWU/OiBzdHJpbmc7IC8vIFVzZXItcHJvdmlkZWQgY2FtcGFpZ24gbmFtZVxuICBpbnN0cnVjdGlvbnNGaWxlPzogc3RyaW5nO1xuICBpbnN0cnVjdGlvbnNDb250ZW50Pzogc3RyaW5nO1xuICBjYW1wYWlnbk5hbWU/OiBzdHJpbmc7XG4gIGNhbXBhaWduR29hbHM/OiBzdHJpbmc7XG4gIHBsYXRmb3Jtcz86IHN0cmluZ1tdO1xuICBkdXJhdGlvbj86IG51bWJlcjsgLy8gd2Vla3NcbiAgcG9zdHNQZXJEYXk/OiBudW1iZXI7XG4gIGNvbnRlbnRTdHJhdGVneT86IHN0cmluZztcbiAgY3VycmVudFN0ZXA6ICdjYW1wYWlnbi1uYW1lJyB8ICdpbnN0cnVjdGlvbnMnIHwgJ2NhbXBhaWduLXNldHVwJyB8ICdnZW5lcmF0aW5nJyB8ICdzY2hlZHVsaW5nJyB8ICdjb21wbGV0ZSc7XG4gIGFjdGl2ZUNhbXBhaWduczogTWFwPHN0cmluZywgQ2FtcGFpZ25CYXRjaD47XG59XG5cbmV4cG9ydCBjbGFzcyBEaXJlY3RvckFnZW50IGV4dGVuZHMgQmFzZUFnZW50IHtcbiAgaWQgPSAnZGlyZWN0b3InO1xuICBuYW1lID0gJ0NhbXBhaWduIERpcmVjdG9yJztcbiAgZGVzY3JpcHRpb24gPSAnT3JjaGVzdHJhdGVzIGxhcmdlLXNjYWxlIG1hcmtldGluZyBjYW1wYWlnbnMgd2l0aCAxMDArIHBvc3RzIGFjcm9zcyBtdWx0aXBsZSBwbGF0Zm9ybXMuIEludGVncmF0ZXMgaW5zdHJ1Y3Rpb24gZmlsZXMgZm9yIGJyYW5kIGd1aWRlbGluZXMgYW5kIGdlbmVyYXRlcyBjb21wcmVoZW5zaXZlIGNvbnRlbnQgc3RyYXRlZ2llcy4nO1xuICBpY29uID0gJ/CfjqwnO1xuICBcbiAgcHJpdmF0ZSBzZXNzaW9uczogTWFwPHN0cmluZywgRGlyZWN0b3JTZXNzaW9uPiA9IG5ldyBNYXAoKTtcbiAgcHJpdmF0ZSByZWFkb25seSBCQVRDSF9TSVpFID0gMTA7XG4gIHByaXZhdGUgcmVhZG9ubHkgTUFYX0NPTkNVUlJFTlRfQkFUQ0hFUyA9IDM7XG4gIFxuICB0b29sczogQWdlbnRUb29sW10gPSBbXG4gICAge1xuICAgICAgaWQ6ICdvcmNoZXN0cmF0ZS1jYW1wYWlnbicsXG4gICAgICBuYW1lOiAnT3JjaGVzdHJhdGUgQ2FtcGFpZ24nLFxuICAgICAgY29tbWFuZDogJy9kaXJlY3RvcicsXG4gICAgICBkZXNjcmlwdGlvbjogJ0NyZWF0ZSBhbmQgc2NoZWR1bGUgYSBjb21wbGV0ZSBtYXJrZXRpbmcgY2FtcGFpZ24gd2l0aCAxMDArIHBvc3RzIGFjcm9zcyBtdWx0aXBsZSBwbGF0Zm9ybXMnLFxuICAgICAgcGFyYW1ldGVyczogW11cbiAgICB9XG4gIF07XG5cbiAgYXN5bmMgZXhlY3V0ZSh0b29sOiBBZ2VudFRvb2wsIGlucHV0OiBzdHJpbmcsIGNvbnZleE11dGF0aW9uczogQ29udmV4TXV0YXRpb25zLCBzZXNzaW9uSWQ/OiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIGNvbnNvbGUubG9nKCfwn5SlIERpcmVjdG9yIEFnZW50OiBFeGVjdXRlIGNhbGxlZCB3aXRoIGlucHV0OicsIGlucHV0KTtcbiAgICBjb25zb2xlLmxvZygn8J+UpSBEaXJlY3RvciBBZ2VudDogU2Vzc2lvbiBJRDonLCBzZXNzaW9uSWQpO1xuICAgIFxuICAgIGlmICghc2Vzc2lvbklkKSB7XG4gICAgICByZXR1cm4gJ1Nlc3Npb24gSUQgaXMgcmVxdWlyZWQgZm9yIGNhbXBhaWduIG9yY2hlc3RyYXRpb24nO1xuICAgIH1cblxuICAgIC8vIEluaXRpYWxpemUgb3IgZ2V0IHNlc3Npb25cbiAgICBjb25zdCBleGlzdGluZ1Nlc3Npb24gPSB0aGlzLnNlc3Npb25zLmhhcyhzZXNzaW9uSWQpO1xuICAgIGNvbnNvbGUubG9nKCfwn5SlIERpcmVjdG9yIEFnZW50OiBFeGlzdGluZyBzZXNzaW9uIGZvdW5kOicsIGV4aXN0aW5nU2Vzc2lvbik7XG4gICAgXG4gICAgaWYgKCF0aGlzLnNlc3Npb25zLmhhcyhzZXNzaW9uSWQpKSB7XG4gICAgICBjb25zb2xlLmxvZygn8J+UpSBEaXJlY3RvciBBZ2VudDogQ3JlYXRpbmcgbmV3IHNlc3Npb24nKTtcbiAgICAgIHRoaXMuc2Vzc2lvbnMuc2V0KHNlc3Npb25JZCwge1xuICAgICAgICBjdXJyZW50U3RlcDogJ2NhbXBhaWduLW5hbWUnLFxuICAgICAgICBhY3RpdmVDYW1wYWlnbnM6IG5ldyBNYXAoKVxuICAgICAgfSk7XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IHNlc3Npb24gPSB0aGlzLnNlc3Npb25zLmdldChzZXNzaW9uSWQpITtcbiAgICBjb25zb2xlLmxvZygn8J+UpSBEaXJlY3RvciBBZ2VudDogQ3VycmVudCBzZXNzaW9uIHN0ZXA6Jywgc2Vzc2lvbi5jdXJyZW50U3RlcCk7XG4gICAgY29uc29sZS5sb2coJ/CflKUgRGlyZWN0b3IgQWdlbnQ6IEhhcyBpbnN0cnVjdGlvbnMgZmlsZTonLCAhIXNlc3Npb24uaW5zdHJ1Y3Rpb25zRmlsZSk7XG4gICAgXG4gICAgLy8gSWYgc2Vzc2lvbiBpcyBhbHJlYWR5IGNvbXBsZXRlLCByZXR1cm4gc3VjY2VzcyBtZXNzYWdlXG4gICAgaWYgKHNlc3Npb24uY3VycmVudFN0ZXAgPT09ICdjb21wbGV0ZScpIHtcbiAgICAgIHJldHVybiAnQ2FtcGFpZ24gaGFzIGJlZW4gc3VjY2Vzc2Z1bGx5IGdlbmVyYXRlZCBhbmQgc2NoZWR1bGVkISBVc2UgYC9kaXJlY3RvcmAgdG8gc3RhcnQgYSBuZXcgY2FtcGFpZ24uJztcbiAgICB9XG5cbiAgICAvLyBTdGVwIDE6IFJlcXVlc3QgY2FtcGFpZ24gbmFtZSBhbmQgY3JlYXRlIHByb2plY3RcbiAgICBpZiAoc2Vzc2lvbi5jdXJyZW50U3RlcCA9PT0gJ2NhbXBhaWduLW5hbWUnKSB7XG4gICAgICAvLyBDaGVjayBpZiB0aGlzIGlzIGEgY2FtcGFpZ24gbmFtZSBpbnB1dFxuICAgICAgaWYgKGlucHV0ICYmIGlucHV0LnRyaW0oKSAmJiAhaW5wdXQuaW5jbHVkZXMoJ1NlbGVjdGVkIGZpbGU6JykgJiYgIWlucHV0LnN0YXJ0c1dpdGgoJy8nKSkge1xuICAgICAgICBjb25zdCBjYW1wYWlnbk5hbWUgPSBpbnB1dC50cmltKCk7XG4gICAgICAgIGNvbnNvbGUubG9nKCfwn5SlIERpcmVjdG9yIEFnZW50OiBDcmVhdGluZyBjYW1wYWlnbiBwcm9qZWN0OicsIGNhbXBhaWduTmFtZSk7XG4gICAgICAgIFxuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIENyZWF0ZSB0aGUgcHJvamVjdCB1c2luZyBDb252ZXggbXV0YXRpb25zXG4gICAgICAgICAgY29uc3QgcHJvamVjdCA9IGF3YWl0IGNvbnZleE11dGF0aW9ucy5jcmVhdGVQcm9qZWN0Py4oe1xuICAgICAgICAgICAgbmFtZTogY2FtcGFpZ25OYW1lLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246IGBNYXJrZXRpbmcgY2FtcGFpZ24gcHJvamVjdDogJHtjYW1wYWlnbk5hbWV9YCxcbiAgICAgICAgICAgIHN0YXR1czogJ2FjdGl2ZSdcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAocHJvamVjdCkge1xuICAgICAgICAgICAgY29uc3QgcHJvamVjdERhdGEgPSBwcm9qZWN0IGFzIGFueTtcbiAgICAgICAgICAgIHNlc3Npb24uY2FtcGFpZ25Qcm9qZWN0SWQgPSBwcm9qZWN0RGF0YS5faWQgfHwgcHJvamVjdERhdGEuaWQgfHwgY2FtcGFpZ25OYW1lO1xuICAgICAgICAgICAgc2Vzc2lvbi5jYW1wYWlnblByb2plY3ROYW1lID0gY2FtcGFpZ25OYW1lO1xuICAgICAgICAgICAgc2Vzc2lvbi5jdXJyZW50U3RlcCA9ICdpbnN0cnVjdGlvbnMnO1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ/CflKUgRGlyZWN0b3IgQWdlbnQ6IFByb2plY3QgY3JlYXRlZCwgbW92aW5nIHRvIGluc3RydWN0aW9ucyBzdGVwJyk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIENvbnRpbnVlIHRvIGluc3RydWN0aW9ucyBzdGVwXG4gICAgICAgICAgICBpZiAoY29udmV4TXV0YXRpb25zLnN0b3JlQ2hhdE1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgYXdhaXQgY29udmV4TXV0YXRpb25zLnN0b3JlQ2hhdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgIHJvbGU6ICdhc3Npc3RhbnQnLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGDinIUgQ2FtcGFpZ24gcHJvamVjdCBcIiR7Y2FtcGFpZ25OYW1lfVwiIGNyZWF0ZWQgc3VjY2Vzc2Z1bGx5IVxcblxcbk5vdywgcGxlYXNlIHNlbGVjdCBhbiBpbnN0cnVjdGlvbnMgZmlsZSB0aGF0IGNvbnRhaW5zIHlvdXIgY2FtcGFpZ24gZ3VpZGVsaW5lcywgYnJhbmQgdm9pY2UsIG9yIG1hcmtldGluZyBzdHJhdGVneS5cXG5cXG5XaGF0IHlvdSBjYW4gaW5jbHVkZSBpbiB5b3VyIGluc3RydWN0aW9ucyBmaWxlOlxcbi0gQnJhbmQgdm9pY2UgYW5kIHRvbmUgZ3VpZGVsaW5lc1xcbi0gVGFyZ2V0IGF1ZGllbmNlIGluZm9ybWF0aW9uXFxuLSBDYW1wYWlnbiBvYmplY3RpdmVzIGFuZCBLUElzXFxuLSBDb250ZW50IHRoZW1lcyBhbmQgbWVzc2FnaW5nXFxuLSBQbGF0Zm9ybS1zcGVjaWZpYyByZXF1aXJlbWVudHNcXG4tIEhhc2h0YWcgc3RyYXRlZ2llc1xcbi0gVmlzdWFsIGd1aWRlbGluZXNcXG5cXG5TZWxlY3QgeW91ciBpbnN0cnVjdGlvbnMgZmlsZTpgLFxuICAgICAgICAgICAgICAgIHNlc3Npb25JZCxcbiAgICAgICAgICAgICAgICBpbnRlcmFjdGl2ZUNvbXBvbmVudDoge1xuICAgICAgICAgICAgICAgICAgdHlwZTogJ2ZpbGVfc2VsZWN0b3InLFxuICAgICAgICAgICAgICAgICAgc3RhdHVzOiAncGVuZGluZycsXG4gICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIGZpbGVUeXBlOiAnaW5zdHJ1Y3Rpb25zJyxcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyQnlFeHRlbnNpb246IFsnLm1kJywgJy50eHQnXSxcbiAgICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI6ICdTZWxlY3QgY2FtcGFpZ24gaW5zdHJ1Y3Rpb25zIGZpbGUuLi4nXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBgQ2FtcGFpZ24gcHJvamVjdCBcIiR7Y2FtcGFpZ25OYW1lfVwiIGNyZWF0ZWQhIFBsZWFzZSBzZWxlY3QgYW4gaW5zdHJ1Y3Rpb25zIGZpbGUgdG8gY29udGludWUuYDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICdGYWlsZWQgdG8gY3JlYXRlIGNhbXBhaWduIHByb2plY3QuIFBsZWFzZSB0cnkgYWdhaW4uJztcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcign8J+UpSBEaXJlY3RvciBBZ2VudDogRXJyb3IgY3JlYXRpbmcgcHJvamVjdDonLCBlcnJvcik7XG4gICAgICAgICAgcmV0dXJuICdFcnJvciBjcmVhdGluZyBjYW1wYWlnbiBwcm9qZWN0LiBQbGVhc2UgdHJ5IGFnYWluIHdpdGggYSBkaWZmZXJlbnQgbmFtZS4nO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBTaG93IGNhbXBhaWduIG5hbWUgaW5wdXQgcHJvbXB0XG4gICAgICAgIGlmIChjb252ZXhNdXRhdGlvbnMuc3RvcmVDaGF0TWVzc2FnZSkge1xuICAgICAgICAgIGF3YWl0IGNvbnZleE11dGF0aW9ucy5zdG9yZUNoYXRNZXNzYWdlKHtcbiAgICAgICAgICAgIHJvbGU6ICdhc3Npc3RhbnQnLFxuICAgICAgICAgICAgY29udGVudDogJ/CfjqwgKipDYW1wYWlnbiBEaXJlY3RvciBBZ2VudCoqXFxuXFxuSSB3aWxsIGhlbHAgeW91IG9yY2hlc3RyYXRlIGEgY29tcHJlaGVuc2l2ZSBtYXJrZXRpbmcgY2FtcGFpZ24gd2l0aCAxMDArIHBvc3RzIGFjcm9zcyBtdWx0aXBsZSBwbGF0Zm9ybXMuXFxuXFxuKipTdGVwIDE6IENyZWF0ZSBDYW1wYWlnbiBQcm9qZWN0KipcXG5cXG5GaXJzdCwgbGV0XFwncyBjcmVhdGUgYSBkZWRpY2F0ZWQgcHJvamVjdCBmb2xkZXIgZm9yIHlvdXIgY2FtcGFpZ24uIFRoaXMgd2lsbCBvcmdhbml6ZSBhbGwgeW91ciBnZW5lcmF0ZWQgY29udGVudCwgc2NoZWR1bGVzLCBhbmQgYXNzZXRzLlxcblxcbldoYXQgd291bGQgeW91IGxpa2UgdG8gbmFtZSB5b3VyIGNhbXBhaWduIHByb2plY3Q/JyxcbiAgICAgICAgICAgIHNlc3Npb25JZCxcbiAgICAgICAgICAgIGludGVyYWN0aXZlQ29tcG9uZW50OiB7XG4gICAgICAgICAgICAgIHR5cGU6ICdmaWxlX25hbWVfaW5wdXQnLFxuICAgICAgICAgICAgICBzdGF0dXM6ICdwZW5kaW5nJyxcbiAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyOiAnRW50ZXIgY2FtcGFpZ24gbmFtZSAoZS5nLiwgXCJRNCBQcm9kdWN0IExhdW5jaFwiLCBcIkhvbGlkYXkgTWFya2V0aW5nIDIwMjVcIiknLFxuICAgICAgICAgICAgICAgIGZpbGVUeXBlOiAncHJvamVjdCdcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnUGxlYXNlIGVudGVyIGEgbmFtZSBmb3IgeW91ciBjYW1wYWlnbiBwcm9qZWN0Lic7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIGZpbGUgc2VsZWN0aW9uIGlucHV0IEFGVEVSIGNhbXBhaWduIG5hbWUgc3RlcFxuICAgIGlmIChpbnB1dC5pbmNsdWRlcygnU2VsZWN0ZWQgZmlsZTonKSAmJiBzZXNzaW9uLmN1cnJlbnRTdGVwID09PSAnaW5zdHJ1Y3Rpb25zJykge1xuICAgICAgY29uc29sZS5sb2coJ/CflKUgRGlyZWN0b3IgQWdlbnQ6IFByb2Nlc3NpbmcgZmlsZSBzZWxlY3Rpb246JywgaW5wdXQpO1xuICAgICAgY29uc29sZS5sb2coJ/CflKUgRGlyZWN0b3IgQWdlbnQ6IFNlc3Npb24gc3RlcDonLCBzZXNzaW9uLmN1cnJlbnRTdGVwKTtcbiAgICAgIFxuICAgICAgY29uc3QgZmlsZU5hbWUgPSBpbnB1dC5yZXBsYWNlKCdTZWxlY3RlZCBmaWxlOicsICcnKS50cmltKCk7XG4gICAgICBjb25zb2xlLmxvZygn8J+UpSBEaXJlY3RvciBBZ2VudDogRXh0cmFjdGVkIGZpbGVuYW1lOicsIGZpbGVOYW1lKTtcbiAgICAgIFxuICAgICAgc2Vzc2lvbi5pbnN0cnVjdGlvbnNGaWxlID0gZmlsZU5hbWU7XG4gICAgICBcbiAgICAgIC8vIEZldGNoIHRoZSBmaWxlIGNvbnRlbnRcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGZpbGVzID0gYXdhaXQgY29udmV4TXV0YXRpb25zLmdldEFsbEZpbGVzPy4oKSB8fCBbXTtcbiAgICAgICAgY29uc29sZS5sb2coJ/CflKUgRGlyZWN0b3IgQWdlbnQ6IEF2YWlsYWJsZSBmaWxlcyBjb3VudDonLCBmaWxlcy5sZW5ndGgpO1xuICAgICAgICBjb25zb2xlLmxvZygn8J+UpSBEaXJlY3RvciBBZ2VudDogQXZhaWxhYmxlIGZpbGUgbmFtZXM6JywgZmlsZXMubWFwKChmOiBhbnkpID0+IGYubmFtZSkpO1xuICAgICAgICBcbiAgICAgICAgLy8gVHJ5IHRvIGZpbmQgdGhlIGZpbGUgd2l0aCBvciB3aXRob3V0IGV4dGVuc2lvblxuICAgICAgICBsZXQgaW5zdHJ1Y3Rpb25GaWxlID0gZmlsZXMuZmluZCgoZjogYW55KSA9PiBmLm5hbWUgPT09IGZpbGVOYW1lKTtcbiAgICAgICAgaWYgKCFpbnN0cnVjdGlvbkZpbGUgJiYgIWZpbGVOYW1lLmluY2x1ZGVzKCcuJykpIHtcbiAgICAgICAgICAvLyBUcnkgd2l0aCAubWQgZXh0ZW5zaW9uXG4gICAgICAgICAgaW5zdHJ1Y3Rpb25GaWxlID0gZmlsZXMuZmluZCgoZjogYW55KSA9PiBmLm5hbWUgPT09IGZpbGVOYW1lICsgJy5tZCcpO1xuICAgICAgICAgIGNvbnNvbGUubG9nKCfwn5SlIERpcmVjdG9yIEFnZW50OiBUcnlpbmcgd2l0aCAubWQgZXh0ZW5zaW9uOicsIGZpbGVOYW1lICsgJy5tZCcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUubG9nKCfwn5SlIERpcmVjdG9yIEFnZW50OiBGb3VuZCBpbnN0cnVjdGlvbiBmaWxlOicsICEhaW5zdHJ1Y3Rpb25GaWxlKTtcbiAgICAgICAgXG4gICAgICAgIGlmIChpbnN0cnVjdGlvbkZpbGUpIHtcbiAgICAgICAgICBzZXNzaW9uLmluc3RydWN0aW9uc0NvbnRlbnQgPSBpbnN0cnVjdGlvbkZpbGUuY29udGVudDtcbiAgICAgICAgICBzZXNzaW9uLmluc3RydWN0aW9uc0ZpbGUgPSBmaWxlTmFtZTsgLy8gTWFrZSBzdXJlIHRoaXMgaXMgc2V0XG4gICAgICAgICAgc2Vzc2lvbi5jdXJyZW50U3RlcCA9ICdjb21wbGV0ZSc7IC8vIFNldCB0byBjb21wbGV0ZSBhZnRlciBnZW5lcmF0aW9uXG4gICAgICAgICAgY29uc29sZS5sb2coJ/CflKUgRGlyZWN0b3IgQWdlbnQ6IFVwZGF0ZWQgc2Vzc2lvbiBzdGVwIHRvIGNvbXBsZXRlJyk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gU2V0IGRlZmF1bHQgY2FtcGFpZ24gc2V0dGluZ3MgYmFzZWQgb24gaW5zdHJ1Y3Rpb25zXG4gICAgICAgICAgc2Vzc2lvbi5jYW1wYWlnbk5hbWUgPSAnRUFDIE1hcmtldGluZyBDYW1wYWlnbic7XG4gICAgICAgICAgc2Vzc2lvbi5kdXJhdGlvbiA9IDQ7IC8vIHdlZWtzXG4gICAgICAgICAgc2Vzc2lvbi5wbGF0Zm9ybXMgPSBbJ3R3aXR0ZXInLCAnbGlua2VkaW4nLCAnaW5zdGFncmFtJywgJ2ZhY2Vib29rJ107XG4gICAgICAgICAgc2Vzc2lvbi5wb3N0c1BlckRheSA9IDM7XG4gICAgICAgICAgc2Vzc2lvbi5jYW1wYWlnbkdvYWxzID0gJ0JyYW5kIGF3YXJlbmVzcyBhbmQgbGVhZCBnZW5lcmF0aW9uIGJhc2VkIG9uIGluc3RydWN0aW9ucyc7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gSW1tZWRpYXRlbHkgZ2VuZXJhdGUgY2FtcGFpZ25cbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmdlbmVyYXRlQ2FtcGFpZ24oc2Vzc2lvbiwgY29udmV4TXV0YXRpb25zLCBzZXNzaW9uSWQpO1xuICAgICAgICAgIGNvbnNvbGUubG9nKCfwn5SlIERpcmVjdG9yIEFnZW50OiBDYW1wYWlnbiBnZW5lcmF0aW9uIHJlc3VsdDonLCByZXN1bHQpO1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ/CflKUgRGlyZWN0b3IgQWdlbnQ6IEZpbGUgbm90IGZvdW5kIGluIGZpbGVzIGFycmF5Jyk7XG4gICAgICAgICAgcmV0dXJuIGBGaWxlIFwiJHtmaWxlTmFtZX1cIiBub3QgZm91bmQuIFBsZWFzZSBzZWxlY3QgYSB2YWxpZCBpbnN0cnVjdGlvbnMgZmlsZS5gO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCfwn5SlIERpcmVjdG9yIEFnZW50OiBFcnJvciBsb2FkaW5nIGluc3RydWN0aW9ucyBmaWxlOicsIGVycm9yKTtcbiAgICAgICAgcmV0dXJuICdFcnJvciBsb2FkaW5nIGluc3RydWN0aW9ucyBmaWxlLiBQbGVhc2UgdHJ5IGFnYWluLic7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIFN0ZXAgMTogUmVxdWVzdCBpbnN0cnVjdGlvbnMgZmlsZSAob25seSBpZiB3ZSBoYXZlbid0IHByb2Nlc3NlZCBmaWxlIHNlbGVjdGlvbiBhbmQgbm90IGNvbXBsZXRlKVxuICAgIGlmIChzZXNzaW9uLmN1cnJlbnRTdGVwID09PSAnaW5zdHJ1Y3Rpb25zJyAmJiAhc2Vzc2lvbi5pbnN0cnVjdGlvbnNGaWxlKSB7XG4gICAgICBpZiAoY29udmV4TXV0YXRpb25zLnN0b3JlQ2hhdE1lc3NhZ2UpIHtcbiAgICAgICAgYXdhaXQgY29udmV4TXV0YXRpb25zLnN0b3JlQ2hhdE1lc3NhZ2Uoe1xuICAgICAgICAgIHJvbGU6ICdhc3Npc3RhbnQnLFxuICAgICAgICAgIGNvbnRlbnQ6ICdDYW1wYWlnbiBEaXJlY3RvciBBZ2VudFxcblxcbkkgd2lsbCBoZWxwIHlvdSBvcmNoZXN0cmF0ZSBhIGNvbXByZWhlbnNpdmUgbWFya2V0aW5nIGNhbXBhaWduIHdpdGggMTAwKyBwb3N0cyBhY3Jvc3MgbXVsdGlwbGUgcGxhdGZvcm1zLlxcblxcblN0ZXAgMTogU2VsZWN0IEluc3RydWN0aW9ucyBGaWxlXFxuXFxuRmlyc3QsIEkgbmVlZCB0byB1bmRlcnN0YW5kIHlvdXIgY2FtcGFpZ24gc3RyYXRlZ3kuIFBsZWFzZSBzZWxlY3QgYW4gaW5zdHJ1Y3Rpb25zIGZpbGUgdGhhdCBjb250YWlucyB5b3VyIGNhbXBhaWduIGd1aWRlbGluZXMsIGJyYW5kIHZvaWNlLCBvciBtYXJrZXRpbmcgc3RyYXRlZ3kuXFxuXFxuV2hhdCB5b3UgY2FuIGluY2x1ZGUgaW4geW91ciBpbnN0cnVjdGlvbnMgZmlsZTpcXG4tIEJyYW5kIHZvaWNlIGFuZCB0b25lIGd1aWRlbGluZXNcXG4tIFRhcmdldCBhdWRpZW5jZSBpbmZvcm1hdGlvblxcbi0gQ2FtcGFpZ24gb2JqZWN0aXZlcyBhbmQgS1BJc1xcbi0gQ29udGVudCB0aGVtZXMgYW5kIG1lc3NhZ2luZ1xcbi0gUGxhdGZvcm0tc3BlY2lmaWMgcmVxdWlyZW1lbnRzXFxuLSBIYXNodGFnIHN0cmF0ZWdpZXNcXG4tIFZpc3VhbCBndWlkZWxpbmVzXFxuXFxuU2VsZWN0IHlvdXIgaW5zdHJ1Y3Rpb25zIGZpbGU6JyxcbiAgICAgICAgICBzZXNzaW9uSWQsXG4gICAgICAgICAgaW50ZXJhY3RpdmVDb21wb25lbnQ6IHtcbiAgICAgICAgICAgIHR5cGU6ICdmaWxlX3NlbGVjdG9yJyxcbiAgICAgICAgICAgIHN0YXR1czogJ3BlbmRpbmcnLFxuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICBmaWxlVHlwZTogJ2luc3RydWN0aW9ucycsXG4gICAgICAgICAgICAgIGZpbHRlckJ5RXh0ZW5zaW9uOiBbJy5tZCcsICcudHh0J10sXG4gICAgICAgICAgICAgIHBsYWNlaG9sZGVyOiAnU2VsZWN0IGNhbXBhaWduIGluc3RydWN0aW9ucyBmaWxlLi4uJ1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gJ1BsZWFzZSBzZWxlY3QgYW4gaW5zdHJ1Y3Rpb25zIGZpbGUgdG8gZ2V0IHN0YXJ0ZWQgd2l0aCB5b3VyIGNhbXBhaWduLic7XG4gICAgfVxuICAgIFxuICAgIC8vIEhhbmRsZSBjYW1wYWlnbiBjb25maWd1cmF0aW9uXG4gICAgaWYgKHNlc3Npb24uY3VycmVudFN0ZXAgPT09ICdjYW1wYWlnbi1zZXR1cCcpIHtcbiAgICAgIGlmIChpbnB1dC50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCdnZW5lcmF0ZSBkZWZhdWx0IGNhbXBhaWduJykgfHwgaW5wdXQudG9Mb3dlckNhc2UoKS5pbmNsdWRlcygnZGVmYXVsdCcpKSB7XG4gICAgICAgIC8vIFVzZSBkZWZhdWx0IGNhbXBhaWduIHNldHRpbmdzXG4gICAgICAgIHNlc3Npb24uY2FtcGFpZ25OYW1lID0gJ0VBQyBNYXJrZXRpbmcgQ2FtcGFpZ24nO1xuICAgICAgICBzZXNzaW9uLmR1cmF0aW9uID0gNDsgLy8gd2Vla3NcbiAgICAgICAgc2Vzc2lvbi5wbGF0Zm9ybXMgPSBbJ3R3aXR0ZXInLCAnbGlua2VkaW4nLCAnaW5zdGFncmFtJywgJ2ZhY2Vib29rJ107XG4gICAgICAgIHNlc3Npb24ucG9zdHNQZXJEYXkgPSAzO1xuICAgICAgICBzZXNzaW9uLmNhbXBhaWduR29hbHMgPSAnQnJhbmQgYXdhcmVuZXNzIGFuZCBsZWFkIGdlbmVyYXRpb24nO1xuICAgICAgICBzZXNzaW9uLmN1cnJlbnRTdGVwID0gJ2dlbmVyYXRpbmcnO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZ2VuZXJhdGVDYW1wYWlnbihzZXNzaW9uLCBjb252ZXhNdXRhdGlvbnMsIHNlc3Npb25JZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBQYXJzZSBjdXN0b20gY2FtcGFpZ24gc2V0dGluZ3MgZnJvbSB1c2VyIGlucHV0XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlQ2FtcGFpZ25TZXR0aW5ncyhpbnB1dCwgc2Vzc2lvbik7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIEhhbmRsZSBiYXRjaCBnZW5lcmF0aW9uIHN0YXR1cyB1cGRhdGVzXG4gICAgaWYgKGlucHV0LmluY2x1ZGVzKCdiYXRjaCBjb21wbGV0ZWQnKSB8fCBpbnB1dC5pbmNsdWRlcygncG9zdHMgZ2VuZXJhdGVkJykpIHtcbiAgICAgIHJldHVybiB0aGlzLmhhbmRsZUJhdGNoQ29tcGxldGlvbihpbnB1dCwgc2Vzc2lvbik7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiAnQ2FtcGFpZ24gb3JjaGVzdHJhdGlvbiBpbiBwcm9ncmVzcy4gVXNlIC9kaXJlY3RvciB0byBzdGFydCBhIG5ldyBjYW1wYWlnbi4nO1xuICB9XG5cbiAgcHJpdmF0ZSBwYXJzZUNhbXBhaWduU2V0dGluZ3MoaW5wdXQ6IHN0cmluZywgc2Vzc2lvbjogRGlyZWN0b3JTZXNzaW9uKTogc3RyaW5nIHtcbiAgICAvLyBFeHRyYWN0IGNhbXBhaWduIHNldHRpbmdzIGZyb20gdXNlciBpbnB1dFxuICAgIGNvbnN0IGxpbmVzID0gaW5wdXQuc3BsaXQoJ1xcbicpLm1hcChsaW5lID0+IGxpbmUudHJpbSgpKS5maWx0ZXIobGluZSA9PiBsaW5lLmxlbmd0aCA+IDApO1xuICAgIFxuICAgIGZvciAoY29uc3QgbGluZSBvZiBsaW5lcykge1xuICAgICAgY29uc3QgbG93ZXIgPSBsaW5lLnRvTG93ZXJDYXNlKCk7XG4gICAgICBpZiAobG93ZXIuaW5jbHVkZXMoJ25hbWU6JykgfHwgbG93ZXIuc3RhcnRzV2l0aCgnMS4nKSkge1xuICAgICAgICBzZXNzaW9uLmNhbXBhaWduTmFtZSA9IGxpbmUuc3BsaXQoJzonKVsxXT8udHJpbSgpIHx8IGxpbmUucmVwbGFjZSgvXjFcXC4vLCAnJykudHJpbSgpO1xuICAgICAgfSBlbHNlIGlmIChsb3dlci5pbmNsdWRlcygnZHVyYXRpb246JykgfHwgbG93ZXIuaW5jbHVkZXMoJ3dlZWtzJykgfHwgbG93ZXIuc3RhcnRzV2l0aCgnMi4nKSkge1xuICAgICAgICBjb25zdCBtYXRjaCA9IGxpbmUubWF0Y2goLyhcXGQrKS8pO1xuICAgICAgICBpZiAobWF0Y2gpIHNlc3Npb24uZHVyYXRpb24gPSBwYXJzZUludChtYXRjaFsxXSk7XG4gICAgICB9IGVsc2UgaWYgKGxvd2VyLmluY2x1ZGVzKCdwbGF0Zm9ybScpIHx8IGxvd2VyLnN0YXJ0c1dpdGgoJzMuJykpIHtcbiAgICAgICAgY29uc3QgcGxhdGZvcm1zID0gbGluZS50b0xvd2VyQ2FzZSgpLm1hdGNoKC8odHdpdHRlcnxsaW5rZWRpbnxmYWNlYm9va3xpbnN0YWdyYW0pL2cpO1xuICAgICAgICBpZiAocGxhdGZvcm1zKSBzZXNzaW9uLnBsYXRmb3JtcyA9IHBsYXRmb3JtcztcbiAgICAgIH0gZWxzZSBpZiAobG93ZXIuaW5jbHVkZXMoJ3Bvc3RzIHBlciBkYXknKSB8fCBsb3dlci5zdGFydHNXaXRoKCc0LicpKSB7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gbGluZS5tYXRjaCgvKFxcZCspLyk7XG4gICAgICAgIGlmIChtYXRjaCkgc2Vzc2lvbi5wb3N0c1BlckRheSA9IHBhcnNlSW50KG1hdGNoWzFdKTtcbiAgICAgIH0gZWxzZSBpZiAobG93ZXIuaW5jbHVkZXMoJ2dvYWxzOicpIHx8IGxvd2VyLnN0YXJ0c1dpdGgoJzUuJykpIHtcbiAgICAgICAgc2Vzc2lvbi5jYW1wYWlnbkdvYWxzID0gbGluZS5zcGxpdCgnOicpWzFdPy50cmltKCkgfHwgbGluZS5yZXBsYWNlKC9eNVxcLi8sICcnKS50cmltKCk7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIFZhbGlkYXRlIHJlcXVpcmVkIGZpZWxkc1xuICAgIGlmICghc2Vzc2lvbi5jYW1wYWlnbk5hbWUgfHwgIXNlc3Npb24uZHVyYXRpb24gfHwgIXNlc3Npb24ucGxhdGZvcm1zPy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiAnUGxlYXNlIHByb3ZpZGUgYWxsIHJlcXVpcmVkIGNhbXBhaWduIGRldGFpbHM6XFxuXFxuMS4gQ2FtcGFpZ24gTmFtZVxcbjIuIER1cmF0aW9uICh3ZWVrcylcXG4zLiBQbGF0Zm9ybXNcXG40LiBQb3N0cyBwZXIgZGF5XFxuNS4gR29hbHNcXG5cXG5PciB0eXBlIFwiZ2VuZXJhdGUgZGVmYXVsdCBjYW1wYWlnblwiIHRvIHVzZSBzdGFuZGFyZCBzZXR0aW5ncy4nO1xuICAgIH1cbiAgICBcbiAgICBzZXNzaW9uLmN1cnJlbnRTdGVwID0gJ2dlbmVyYXRpbmcnO1xuICAgIHJldHVybiBgQ2FtcGFpZ24gQ29uZmlndXJhdGlvbiBTZXQ6XFxuXFxuTmFtZTogJHtzZXNzaW9uLmNhbXBhaWduTmFtZX1cXG5EdXJhdGlvbjogJHtzZXNzaW9uLmR1cmF0aW9ufSB3ZWVrc1xcblBsYXRmb3JtczogJHtzZXNzaW9uLnBsYXRmb3Jtcy5qb2luKCcsICcpfVxcblBvc3RzIHBlciBkYXk6ICR7c2Vzc2lvbi5wb3N0c1BlckRheX1cXG5Hb2FsczogJHtzZXNzaW9uLmNhbXBhaWduR29hbHN9XFxuXFxuR2VuZXJhdGluZyB5b3VyIGNvbXByZWhlbnNpdmUgY2FtcGFpZ24uLi5gO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBnZW5lcmF0ZUNhbXBhaWduKHNlc3Npb246IERpcmVjdG9yU2Vzc2lvbiwgY29udmV4TXV0YXRpb25zOiBDb252ZXhNdXRhdGlvbnMsIHNlc3Npb25JZDogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICB0cnkge1xuICAgICAgLy8gQ2FsY3VsYXRlIHRvdGFsIHBvc3RzIG5lZWRlZFxuICAgICAgY29uc3QgdG90YWxEYXlzID0gKHNlc3Npb24uZHVyYXRpb24gfHwgNCkgKiA3O1xuICAgICAgY29uc3QgcG9zdHNQZXJEYXkgPSBzZXNzaW9uLnBvc3RzUGVyRGF5IHx8IDM7XG4gICAgICBjb25zdCB0b3RhbFBvc3RzID0gdG90YWxEYXlzICogcG9zdHNQZXJEYXk7XG4gICAgICBjb25zdCBwbGF0Zm9ybXMgPSBzZXNzaW9uLnBsYXRmb3JtcyB8fCBbJ3R3aXR0ZXInLCAnbGlua2VkaW4nLCAnaW5zdGFncmFtJywgJ2ZhY2Vib29rJ107XG4gICAgICBcbiAgICAgIC8vIENyZWF0ZSBjYW1wYWlnbiBpbiBkYXRhYmFzZVxuICAgICAgbGV0IGNhbXBhaWduSWQ6IHN0cmluZztcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGNhbXBhaWduID0gYXdhaXQgY29udmV4TXV0YXRpb25zLmNyZWF0ZUNhbXBhaWduPy4oe1xuICAgICAgICAgIG5hbWU6IHNlc3Npb24uY2FtcGFpZ25OYW1lIHx8ICdHZW5lcmF0ZWQgQ2FtcGFpZ24nLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiBgQXV0by1nZW5lcmF0ZWQgY2FtcGFpZ246ICR7c2Vzc2lvbi5jYW1wYWlnbkdvYWxzIHx8ICdNYXJrZXRpbmcgY2FtcGFpZ24nfWAsXG4gICAgICAgICAgcGxhdGZvcm1zLFxuICAgICAgICAgIHRvdGFsUG9zdHMsXG4gICAgICAgICAgc3RhcnREYXRlOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkuc3BsaXQoJ1QnKVswXSxcbiAgICAgICAgICBlbmREYXRlOiBuZXcgRGF0ZShEYXRlLm5vdygpICsgKHNlc3Npb24uZHVyYXRpb24gfHwgNCkgKiA3ICogMjQgKiA2MCAqIDYwICogMTAwMCkudG9JU09TdHJpbmcoKS5zcGxpdCgnVCcpWzBdLFxuICAgICAgICAgIHRlbXBsYXRlOiBzZXNzaW9uLmluc3RydWN0aW9uc0NvbnRlbnQgfHwgJydcbiAgICAgICAgfSk7XG4gICAgICAgIGNhbXBhaWduSWQgPSBjYW1wYWlnbj8uX2lkIHx8IGBjYW1wYWlnbl8ke0RhdGUubm93KCl9YDtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdDYW1wYWlnbiBjcmVhdGlvbiBub3QgYXZhaWxhYmxlLCB1c2luZyBmYWxsYmFjayBJRCcpO1xuICAgICAgICBjYW1wYWlnbklkID0gYGNhbXBhaWduXyR7RGF0ZS5ub3coKX1gO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBHZW5lcmF0ZSBwb3N0cyBpbiBiYXRjaGVzXG4gICAgICBjb25zdCBhbGxQb3N0cyA9IGF3YWl0IHRoaXMuZ2VuZXJhdGVCYXRjaGVzQXN5bmMoXG4gICAgICAgIHRvdGFsUG9zdHMsXG4gICAgICAgIHBsYXRmb3JtcyxcbiAgICAgICAgc2Vzc2lvbi5pbnN0cnVjdGlvbnNDb250ZW50IHx8ICcnLFxuICAgICAgICBjYW1wYWlnbklkLFxuICAgICAgICBzZXNzaW9uLmR1cmF0aW9uIHx8IDRcbiAgICAgICk7XG4gICAgICBcbiAgICAgIC8vIENyZWF0ZSBiYXRjaGVzIGZvciBwcm9jZXNzaW5nXG4gICAgICBjb25zdCBiYXRjaGVzID0gdGhpcy5jcmVhdGVCYXRjaGVzKGFsbFBvc3RzLCBjYW1wYWlnbklkKTtcbiAgICAgIFxuICAgICAgLy8gU3RvcmUgYmF0Y2hlcyBpbiBzZXNzaW9uXG4gICAgICBiYXRjaGVzLmZvckVhY2goYmF0Y2ggPT4ge1xuICAgICAgICBzZXNzaW9uLmFjdGl2ZUNhbXBhaWducy5zZXQoYmF0Y2guY2FtcGFpZ25JZCwgYmF0Y2gpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIFN0YXJ0IHdpdGggcHJvZ3Jlc3MgaW5kaWNhdG9yXG4gICAgICBpZiAoY29udmV4TXV0YXRpb25zLnN0b3JlQ2hhdE1lc3NhZ2UpIHtcbiAgICAgICAgYXdhaXQgY29udmV4TXV0YXRpb25zLnN0b3JlQ2hhdE1lc3NhZ2Uoe1xuICAgICAgICAgIHJvbGU6ICdhc3Npc3RhbnQnLFxuICAgICAgICAgIGNvbnRlbnQ6IGBDYW1wYWlnbiBHZW5lcmF0aW9uIENvbXBsZXRlIVxcblxcbkdlbmVyYXRlZCAke3RvdGFsUG9zdHN9IHBvc3RzIGFjcm9zcyAke3BsYXRmb3Jtcy5sZW5ndGh9IHBsYXRmb3Jtc1xcbk9yZ2FuaXplZCBpbnRvICR7YmF0Y2hlcy5sZW5ndGh9IHByb2Nlc3NpbmcgYmF0Y2hlc1xcblN0YXJ0aW5nIGNvbnRlbnQgY3JlYXRpb24gYW5kIHNjaGVkdWxpbmcuLi5cXG5cXG5DYW1wYWlnbiBJRDogJHtjYW1wYWlnbklkfVxcblRvdGFsIFBvc3RzOiAke3RvdGFsUG9zdHN9XFxuUGxhdGZvcm1zOiAke3BsYXRmb3Jtcy5qb2luKCcsICcpfVxcbkR1cmF0aW9uOiAke3Nlc3Npb24uZHVyYXRpb259IHdlZWtzYCxcbiAgICAgICAgICBzZXNzaW9uSWQsXG4gICAgICAgICAgcHJvY2Vzc0luZGljYXRvcjoge1xuICAgICAgICAgICAgdHlwZTogJ2NvbnRpbnVpbmcnLFxuICAgICAgICAgICAgcHJvY2Vzc1R5cGU6ICdQcm9jZXNzaW5nIENhbXBhaWduIEJhdGNoZXMnLFxuICAgICAgICAgICAgY29sb3I6ICdibHVlJ1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFByb2Nlc3MgYWxsIGJhdGNoZXMgd2l0aCBwcm9ncmVzcyB1cGRhdGVzXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJhdGNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYmF0Y2ggPSBiYXRjaGVzW2ldO1xuICAgICAgICBjb25zb2xlLmxvZyhg8J+UpSBEaXJlY3RvciBBZ2VudDogUHJvY2Vzc2luZyBiYXRjaCAke2kgKyAxfS8ke2JhdGNoZXMubGVuZ3RofWApO1xuICAgICAgICBcbiAgICAgICAgLy8gVXBkYXRlIHByb2dyZXNzXG4gICAgICAgIGlmIChjb252ZXhNdXRhdGlvbnMuc3RvcmVDaGF0TWVzc2FnZSkge1xuICAgICAgICAgIGF3YWl0IGNvbnZleE11dGF0aW9ucy5zdG9yZUNoYXRNZXNzYWdlKHtcbiAgICAgICAgICAgIHJvbGU6ICdhc3Npc3RhbnQnLFxuICAgICAgICAgICAgY29udGVudDogYFByb2Nlc3NpbmcgYmF0Y2ggJHtpICsgMX0gb2YgJHtiYXRjaGVzLmxlbmd0aH0uLi4gKCR7YmF0Y2gucG9zdHMubGVuZ3RofSBwb3N0cylgLFxuICAgICAgICAgICAgc2Vzc2lvbklkLFxuICAgICAgICAgICAgcHJvY2Vzc0luZGljYXRvcjoge1xuICAgICAgICAgICAgICB0eXBlOiAnY29udGludWluZycsXG4gICAgICAgICAgICAgIHByb2Nlc3NUeXBlOiBgQmF0Y2ggJHtpICsgMX0vJHtiYXRjaGVzLmxlbmd0aH1gLFxuICAgICAgICAgICAgICBjb2xvcjogJ2JsdWUnXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGF3YWl0IHRoaXMucHJvY2Vzc0JhdGNoKGJhdGNoLCBjb252ZXhNdXRhdGlvbnMsIHNlc3Npb25JZCk7XG4gICAgICAgIFxuICAgICAgICAvLyBTbWFsbCBkZWxheSBiZXR3ZWVuIGJhdGNoZXMgdG8gcHJldmVudCBvdmVyd2hlbG1pbmcgdGhlIGRhdGFiYXNlXG4gICAgICAgIGlmIChpIDwgYmF0Y2hlcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDEwMDApKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBGaW5hbCBzdWNjZXNzIG1lc3NhZ2VcbiAgICAgIGlmIChjb252ZXhNdXRhdGlvbnMuc3RvcmVDaGF0TWVzc2FnZSkge1xuICAgICAgICBhd2FpdCBjb252ZXhNdXRhdGlvbnMuc3RvcmVDaGF0TWVzc2FnZSh7XG4gICAgICAgICAgcm9sZTogJ2Fzc2lzdGFudCcsXG4gICAgICAgICAgY29udGVudDogYOKchSBDYW1wYWlnbiBTdWNjZXNzZnVsbHkgQ3JlYXRlZCFcXG5cXG7wn5OKICoqQ2FtcGFpZ24gU3VtbWFyeToqKlxcbi0gKipDYW1wYWlnbiBJRDoqKiAke2NhbXBhaWduSWR9XFxuLSAqKlRvdGFsIFBvc3RzOioqICR7dG90YWxQb3N0c31cXG4tICoqUGxhdGZvcm1zOioqICR7cGxhdGZvcm1zLmpvaW4oJywgJyl9XFxuLSAqKkR1cmF0aW9uOioqICR7c2Vzc2lvbi5kdXJhdGlvbn0gd2Vla3NcXG4tICoqQmF0Y2hlcyBQcm9jZXNzZWQ6KiogJHtiYXRjaGVzLmxlbmd0aH1cXG5cXG7wn5eT77iPIEFsbCBwb3N0cyBoYXZlIGJlZW4gc2NoZWR1bGVkIGFuZCBzYXZlZCB0byB0aGUgZGF0YWJhc2UuIFVzZSB0aGUgc29jaWFsIG1lZGlhIGRhc2hib2FyZCB0byByZXZpZXcgYW5kIG1hbmFnZSB5b3VyIGNhbXBhaWduLmAsXG4gICAgICAgICAgc2Vzc2lvbklkXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBzZXNzaW9uLmN1cnJlbnRTdGVwID0gJ2NvbXBsZXRlJztcbiAgICAgIFxuICAgICAgcmV0dXJuICdDYW1wYWlnbiBwcm9jZXNzaW5nIGNvbXBsZXRlZCBzdWNjZXNzZnVsbHkhJzsgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0NhbXBhaWduIGdlbmVyYXRpb24gZXJyb3I6JywgZXJyb3IpO1xuICAgICAgcmV0dXJuIGBFcnJvciBnZW5lcmF0aW5nIGNhbXBhaWduOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InfWA7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBnZW5lcmF0ZUJhdGNoZXNBc3luYyhcbiAgICB0b3RhbFBvc3RzOiBudW1iZXIsXG4gICAgcGxhdGZvcm1zOiBzdHJpbmdbXSxcbiAgICBpbnN0cnVjdGlvbnM6IHN0cmluZyxcbiAgICBjYW1wYWlnbklkOiBzdHJpbmcsXG4gICAgZHVyYXRpb246IG51bWJlclxuICApOiBQcm9taXNlPENhbXBhaWduUG9zdFtdPiB7XG4gICAgY29uc3QgcG9zdHM6IENhbXBhaWduUG9zdFtdID0gW107XG4gICAgXG4gICAgY29uc3QgZGF5cyA9IFsnTW9uZGF5JywgJ1R1ZXNkYXknLCAnV2VkbmVzZGF5JywgJ1RodXJzZGF5JywgJ0ZyaWRheScsICdTYXR1cmRheScsICdTdW5kYXknXTtcbiAgICBcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRvdGFsUG9zdHM7IGkrKykge1xuICAgICAgY29uc3QgcGxhdGZvcm0gPSBwbGF0Zm9ybXNbaSAlIHBsYXRmb3Jtcy5sZW5ndGhdIGFzIGFueTtcbiAgICAgIGNvbnN0IHdlZWsgPSBNYXRoLmZsb29yKGkgLyAodG90YWxQb3N0cyAvIGR1cmF0aW9uKSkgKyAxO1xuICAgICAgY29uc3QgZGF5SW5kZXggPSBpICUgNztcbiAgICAgIGNvbnN0IGRheSA9IGRheXNbZGF5SW5kZXhdO1xuICAgICAgXG4gICAgICAvLyBEZXRlcm1pbmUgb3B0aW1hbCBwb3N0aW5nIHRpbWUgYmFzZWQgb24gcGxhdGZvcm1cbiAgICAgIGNvbnN0IHRpbWUgPSB0aGlzLmdldE9wdGltYWxQb3N0VGltZShwbGF0Zm9ybSwgZGF5SW5kZXgpO1xuICAgICAgXG4gICAgICAvLyBDYWxjdWxhdGUgcG9zdCBkYXRlXG4gICAgICBjb25zdCBzdGFydERhdGUgPSBuZXcgRGF0ZSgpO1xuICAgICAgY29uc3QgcG9zdERhdGUgPSBuZXcgRGF0ZShzdGFydERhdGUpO1xuICAgICAgcG9zdERhdGUuc2V0RGF0ZShzdGFydERhdGUuZ2V0RGF0ZSgpICsgTWF0aC5mbG9vcihpIC8gcGxhdGZvcm1zLmxlbmd0aCkpO1xuICAgICAgXG4gICAgICAvLyBEZXRlcm1pbmUgY2FtcGFpZ24gcGhhc2UgYmFzZWQgb24gd2Vla1xuICAgICAgY29uc3QgcGhhc2VzID0gWydhd2FyZW5lc3MnLCAnY29uc2lkZXJhdGlvbicsICdjb252ZXJzaW9uJywgJ3JldGVudGlvbiddIGFzIGNvbnN0O1xuICAgICAgY29uc3QgcGhhc2VJbmRleCA9IE1hdGguZmxvb3IoKHdlZWsgLSAxKSAvIChkdXJhdGlvbiAvIHBoYXNlcy5sZW5ndGgpKTtcbiAgICAgIGNvbnN0IHBoYXNlID0gcGhhc2VzW01hdGgubWluKHBoYXNlSW5kZXgsIHBoYXNlcy5sZW5ndGggLSAxKV07XG4gICAgICBcbiAgICAgIC8vIERldGVybWluZSBjb250ZW50IHR5cGUgY3ljbGljYWxseVxuICAgICAgY29uc3QgY29udGVudFR5cGVzID0gWydlZHVjYXRpb25hbCcsICdwcm9tb3Rpb25hbCcsICdlbmdhZ2VtZW50JywgJ2Fubm91bmNlbWVudCddIGFzIGNvbnN0O1xuICAgICAgY29uc3QgY29udGVudFR5cGUgPSBjb250ZW50VHlwZXNbaSAlIGNvbnRlbnRUeXBlcy5sZW5ndGhdO1xuICAgICAgXG4gICAgICAvLyBHZW5lcmF0ZSBjb250ZW50XG4gICAgICBjb25zdCBjb250ZW50ID0gdGhpcy5nZW5lcmF0ZVBsYXRmb3JtQ29udGVudChwbGF0Zm9ybSwgcGhhc2UsIGNvbnRlbnRUeXBlLCBpbnN0cnVjdGlvbnMsIHdlZWssIGRheSk7XG4gICAgICBcbiAgICAgIHBvc3RzLnB1c2goe1xuICAgICAgICBwbGF0Zm9ybSxcbiAgICAgICAgY29udGVudCxcbiAgICAgICAgc2NoZWR1bGVkRGF0ZTogcG9zdERhdGUudG9JU09TdHJpbmcoKS5zcGxpdCgnVCcpWzBdLFxuICAgICAgICBzY2hlZHVsZWRUaW1lOiB0aW1lLFxuICAgICAgICBtZXRhZGF0YToge1xuICAgICAgICAgIHdlZWssXG4gICAgICAgICAgZGF5T2ZXZWVrOiBkYXksXG4gICAgICAgICAgY2FtcGFpZ25QaGFzZTogcGhhc2UsXG4gICAgICAgICAgY29udGVudFR5cGUsXG4gICAgICAgICAgaGFzaHRhZ3M6IHRoaXMuZ2VuZXJhdGVIYXNodGFncyhwbGF0Zm9ybSwgcGhhc2UsIGNvbnRlbnRUeXBlKSxcbiAgICAgICAgICBjYW1wYWlnbklkLFxuICAgICAgICAgIGJhdGNoSWQ6IGBiYXRjaF8ke01hdGguZmxvb3IoaSAvIHRoaXMuQkFUQ0hfU0laRSl9YFxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIHBvc3RzO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXRPcHRpbWFsUG9zdFRpbWUocGxhdGZvcm06IHN0cmluZywgZGF5SW5kZXg6IG51bWJlcik6IHN0cmluZyB7XG4gICAgY29uc3QgdGltZXMgPSB7XG4gICAgICB0d2l0dGVyOiBbJzA5OjAwJywgJzEyOjAwJywgJzE1OjAwJywgJzE4OjAwJ10sXG4gICAgICBsaW5rZWRpbjogWycwODowMCcsICcxMjowMCcsICcxNzowMCddLFxuICAgICAgaW5zdGFncmFtOiBbJzExOjAwJywgJzE0OjAwJywgJzE3OjAwJywgJzE5OjAwJ10sXG4gICAgICBmYWNlYm9vazogWycwOTowMCcsICcxMzowMCcsICcxNTowMCddXG4gICAgfTtcbiAgICBcbiAgICBjb25zdCBwbGF0Zm9ybVRpbWVzID0gdGltZXNbcGxhdGZvcm0gYXMga2V5b2YgdHlwZW9mIHRpbWVzXSB8fCB0aW1lcy50d2l0dGVyO1xuICAgIHJldHVybiBwbGF0Zm9ybVRpbWVzW2RheUluZGV4ICUgcGxhdGZvcm1UaW1lcy5sZW5ndGhdO1xuICB9XG5cbiAgcHJpdmF0ZSBnZW5lcmF0ZVBsYXRmb3JtQ29udGVudChwbGF0Zm9ybTogc3RyaW5nLCBwaGFzZTogc3RyaW5nLCBjb250ZW50VHlwZTogc3RyaW5nLCBpbnN0cnVjdGlvbnM6IHN0cmluZywgd2VlazogbnVtYmVyLCBkYXk6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgY29uc3QgYnJhbmRWb2ljZSA9IHRoaXMuZXh0cmFjdEJyYW5kVm9pY2UoaW5zdHJ1Y3Rpb25zKTtcbiAgICBjb25zdCBhdWRpZW5jZSA9IHRoaXMuZXh0cmFjdEF1ZGllbmNlKGluc3RydWN0aW9ucyk7XG4gICAgXG4gICAgY29uc3QgY29udGVudCA9IGAke2JyYW5kVm9pY2V9IGNvbnRlbnQgZm9yICR7YXVkaWVuY2V9IC0gV2VlayAke3dlZWt9LCAke2RheX0uIFBoYXNlOiAke3BoYXNlfSwgVHlwZTogJHtjb250ZW50VHlwZX0uIFBsYXRmb3JtOiAke3BsYXRmb3JtfWA7XG4gICAgXG4gICAgLy8gUGxhdGZvcm0tc3BlY2lmaWMgZm9ybWF0dGluZ1xuICAgIHN3aXRjaCAocGxhdGZvcm0pIHtcbiAgICAgIGNhc2UgJ3R3aXR0ZXInOlxuICAgICAgICByZXR1cm4gY29udGVudC5sZW5ndGggPiAyNTAgPyBjb250ZW50LnN1YnN0cmluZygwLCAyNDcpICsgJy4uLicgOiBjb250ZW50O1xuICAgICAgY2FzZSAnbGlua2VkaW4nOlxuICAgICAgICByZXR1cm4gYCR7Y29udGVudH1cXG5cXG4jTGlua2VkSW5FbmdhZ2VtZW50ICNQcm9mZXNzaW9uYWxHcm93dGhgO1xuICAgICAgY2FzZSAnaW5zdGFncmFtJzpcbiAgICAgICAgcmV0dXJuIGAke2NvbnRlbnR9IOKcqFxcblxcbiNJbnN0YWdyYW1CdXNpbmVzcyAjVmlzdWFsQ29udGVudGA7XG4gICAgICBjYXNlICdmYWNlYm9vayc6XG4gICAgICAgIHJldHVybiBgJHtjb250ZW50fVxcblxcbldoYXQgZG8geW91IHRoaW5rPyBTaGFyZSB5b3VyIHRob3VnaHRzIGJlbG93ISDwn5GHYDtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBjb250ZW50O1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgZXh0cmFjdEJyYW5kVm9pY2UoaW5zdHJ1Y3Rpb25zOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGNvbnN0IHZvaWNlS2V5d29yZHMgPSBbJ3Byb2Zlc3Npb25hbCcsICdmcmllbmRseScsICdpbm5vdmF0aXZlJywgJ3RydXN0ZWQnLCAnZXhwZXJ0JywgJ3JlbGlhYmxlJ107XG4gICAgY29uc3QgbG93ZXJJbnN0cnVjdGlvbnMgPSBpbnN0cnVjdGlvbnMudG9Mb3dlckNhc2UoKTtcbiAgICBcbiAgICBmb3IgKGNvbnN0IGtleXdvcmQgb2Ygdm9pY2VLZXl3b3Jkcykge1xuICAgICAgaWYgKGxvd2VySW5zdHJ1Y3Rpb25zLmluY2x1ZGVzKGtleXdvcmQpKSB7XG4gICAgICAgIHJldHVybiBrZXl3b3JkLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsga2V5d29yZC5zbGljZSgxKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuICdQcm9mZXNzaW9uYWwnO1xuICB9XG5cbiAgcHJpdmF0ZSBleHRyYWN0QXVkaWVuY2UoaW5zdHJ1Y3Rpb25zOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGNvbnN0IGF1ZGllbmNlS2V5d29yZHMgPSBbJ2J1c2luZXNzZXMnLCAncHJvZmVzc2lvbmFscycsICd0ZWFtcycsICdjb21wYW5pZXMnLCAnb3JnYW5pemF0aW9ucycsICd1c2VycyddO1xuICAgIGNvbnN0IGxvd2VySW5zdHJ1Y3Rpb25zID0gaW5zdHJ1Y3Rpb25zLnRvTG93ZXJDYXNlKCk7XG4gICAgXG4gICAgZm9yIChjb25zdCBrZXl3b3JkIG9mIGF1ZGllbmNlS2V5d29yZHMpIHtcbiAgICAgIGlmIChsb3dlckluc3RydWN0aW9ucy5pbmNsdWRlcyhrZXl3b3JkKSkge1xuICAgICAgICByZXR1cm4ga2V5d29yZDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuICdwcm9mZXNzaW9uYWxzJztcbiAgfVxuXG4gIHByaXZhdGUgZ2VuZXJhdGVIYXNodGFncyhwbGF0Zm9ybTogc3RyaW5nLCBwaGFzZTogc3RyaW5nLCBjb250ZW50VHlwZTogc3RyaW5nKTogc3RyaW5nW10ge1xuICAgIGNvbnN0IGJhc2VIYXNodGFncyA9IFsnbWFya2V0aW5nJywgJ2J1c2luZXNzJywgJ2dyb3d0aCddO1xuICAgIGNvbnN0IHBoYXNlSGFzaHRhZ3MgPSB7XG4gICAgICBhd2FyZW5lc3M6IFsnYnJhbmRhd2FyZW5lc3MnLCAnaW50cm9kdWN0aW9uJ10sXG4gICAgICBjb25zaWRlcmF0aW9uOiBbJ3NvbHV0aW9ucycsICdldmFsdWF0aW9uJ10sXG4gICAgICBjb252ZXJzaW9uOiBbJ2dldHN0YXJ0ZWQnLCAnYWN0aW9uJ10sXG4gICAgICByZXRlbnRpb246IFsnY29tbXVuaXR5JywgJ3N1Y2Nlc3MnXVxuICAgIH07XG4gICAgY29uc3QgY29udGVudEhhc2h0YWdzID0ge1xuICAgICAgZWR1Y2F0aW9uYWw6IFsndGlwcycsICdsZWFybmluZyddLFxuICAgICAgcHJvbW90aW9uYWw6IFsnb2ZmZXInLCAnZmVhdHVyZWQnXSxcbiAgICAgIGVuZ2FnZW1lbnQ6IFsnZGlzY3Vzc2lvbicsICdxdWVzdGlvbiddLFxuICAgICAgYW5ub3VuY2VtZW50OiBbJ25ld3MnLCAndXBkYXRlJ11cbiAgICB9O1xuICAgIFxuICAgIHJldHVybiBbXG4gICAgICAuLi5iYXNlSGFzaHRhZ3MsXG4gICAgICAuLi5waGFzZUhhc2h0YWdzW3BoYXNlIGFzIGtleW9mIHR5cGVvZiBwaGFzZUhhc2h0YWdzXSxcbiAgICAgIC4uLmNvbnRlbnRIYXNodGFnc1tjb250ZW50VHlwZSBhcyBrZXlvZiB0eXBlb2YgY29udGVudEhhc2h0YWdzXVxuICAgIF0uc2xpY2UoMCwgNSk7XG4gIH1cblxuICBwcml2YXRlIGNyZWF0ZUJhdGNoZXMocG9zdHM6IENhbXBhaWduUG9zdFtdLCBjYW1wYWlnbklkOiBzdHJpbmcpOiBDYW1wYWlnbkJhdGNoW10ge1xuICAgIGNvbnN0IGJhdGNoZXM6IENhbXBhaWduQmF0Y2hbXSA9IFtdO1xuICAgIFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9zdHMubGVuZ3RoOyBpICs9IHRoaXMuQkFUQ0hfU0laRSkge1xuICAgICAgY29uc3QgYmF0Y2hQb3N0cyA9IHBvc3RzLnNsaWNlKGksIGkgKyB0aGlzLkJBVENIX1NJWkUpO1xuICAgICAgYmF0Y2hlcy5wdXNoKHtcbiAgICAgICAgY2FtcGFpZ25JZDogYCR7Y2FtcGFpZ25JZH1fYmF0Y2hfJHtiYXRjaGVzLmxlbmd0aH1gLFxuICAgICAgICBwb3N0czogYmF0Y2hQb3N0cyxcbiAgICAgICAgcHJvY2Vzc2luZ1N0YXR1czogJ3BlbmRpbmcnLFxuICAgICAgICBwcm9jZXNzZWRDb3VudDogMCxcbiAgICAgICAgdG90YWxDb3VudDogYmF0Y2hQb3N0cy5sZW5ndGhcbiAgICAgIH0pO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gYmF0Y2hlcztcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgcHJvY2Vzc0JhdGNoKGJhdGNoOiBDYW1wYWlnbkJhdGNoLCBjb252ZXhNdXRhdGlvbnM6IENvbnZleE11dGF0aW9ucywgc2Vzc2lvbklkOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBiYXRjaC5wcm9jZXNzaW5nU3RhdHVzID0gJ3Byb2Nlc3NpbmcnO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICBjb25zdCBwb3N0UHJvbWlzZXMgPSBiYXRjaC5wb3N0cy5tYXAoYXN5bmMgKHBvc3QpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhd2FpdCBjb252ZXhNdXRhdGlvbnMudXBzZXJ0UG9zdCh7XG4gICAgICAgICAgICBmaWxlTmFtZTogYCR7cG9zdC5wbGF0Zm9ybX1fJHtwb3N0Lm1ldGFkYXRhLndlZWt9XyR7cG9zdC5tZXRhZGF0YS5kYXlPZldlZWt9XyR7RGF0ZS5ub3coKX1gLFxuICAgICAgICAgICAgZmlsZVR5cGU6IHBvc3QucGxhdGZvcm0gYXMgYW55LFxuICAgICAgICAgICAgY29udGVudDogcG9zdC5jb250ZW50LFxuICAgICAgICAgICAgdGl0bGU6IGBXZWVrICR7cG9zdC5tZXRhZGF0YS53ZWVrfSAtICR7cG9zdC5tZXRhZGF0YS5jYW1wYWlnblBoYXNlfWAsXG4gICAgICAgICAgICBwbGF0Zm9ybURhdGE6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgc2NoZWR1bGVkRGF0ZTogcG9zdC5zY2hlZHVsZWREYXRlLFxuICAgICAgICAgICAgICBzY2hlZHVsZWRUaW1lOiBwb3N0LnNjaGVkdWxlZFRpbWUsXG4gICAgICAgICAgICAgIGhhc2h0YWdzOiBwb3N0Lm1ldGFkYXRhLmhhc2h0YWdzLFxuICAgICAgICAgICAgICBjYW1wYWlnbklkOiBwb3N0Lm1ldGFkYXRhLmNhbXBhaWduSWQsXG4gICAgICAgICAgICAgIGJhdGNoSWQ6IHBvc3QubWV0YWRhdGEuYmF0Y2hJZCxcbiAgICAgICAgICAgICAgd2VlazogcG9zdC5tZXRhZGF0YS53ZWVrLFxuICAgICAgICAgICAgICBkYXlPZldlZWs6IHBvc3QubWV0YWRhdGEuZGF5T2ZXZWVrLFxuICAgICAgICAgICAgICBjYW1wYWlnblBoYXNlOiBwb3N0Lm1ldGFkYXRhLmNhbXBhaWduUGhhc2UsXG4gICAgICAgICAgICAgIGNvbnRlbnRUeXBlOiBwb3N0Lm1ldGFkYXRhLmNvbnRlbnRUeXBlXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHN0YXR1czogJ3NjaGVkdWxlZCcsXG4gICAgICAgICAgICBzY2hlZHVsZWRGb3I6IG5ldyBEYXRlKGAke3Bvc3Quc2NoZWR1bGVkRGF0ZX1UJHtwb3N0LnNjaGVkdWxlZFRpbWV9YCkuZ2V0VGltZSgpXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgXG4gICAgICAgICAgYmF0Y2gucHJvY2Vzc2VkQ291bnQrKztcbiAgICAgICAgICBcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBwcm9jZXNzaW5nIHBvc3Q6JywgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgYXdhaXQgUHJvbWlzZS5hbGwocG9zdFByb21pc2VzKTtcbiAgICAgIGJhdGNoLnByb2Nlc3NpbmdTdGF0dXMgPSAnY29tcGxldGVkJztcbiAgICAgIFxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdCYXRjaCBwcm9jZXNzaW5nIGVycm9yOicsIGVycm9yKTtcbiAgICAgIGJhdGNoLnByb2Nlc3NpbmdTdGF0dXMgPSAnZmFpbGVkJztcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGhhbmRsZUJhdGNoQ29tcGxldGlvbihpbnB1dDogc3RyaW5nLCBzZXNzaW9uOiBEaXJlY3RvclNlc3Npb24pOiBzdHJpbmcge1xuICAgIGNvbnN0IGNvbXBsZXRlZEJhdGNoZXMgPSBBcnJheS5mcm9tKHNlc3Npb24uYWN0aXZlQ2FtcGFpZ25zLnZhbHVlcygpKVxuICAgICAgLmZpbHRlcihiYXRjaCA9PiBiYXRjaC5wcm9jZXNzaW5nU3RhdHVzID09PSAnY29tcGxldGVkJyk7XG4gICAgXG4gICAgY29uc3QgdG90YWxCYXRjaGVzID0gc2Vzc2lvbi5hY3RpdmVDYW1wYWlnbnMuc2l6ZTtcbiAgICBjb25zdCB0b3RhbFByb2Nlc3NlZCA9IGNvbXBsZXRlZEJhdGNoZXMucmVkdWNlKChzdW0sIGJhdGNoKSA9PiBzdW0gKyBiYXRjaC5wcm9jZXNzZWRDb3VudCwgMCk7XG4gICAgXG4gICAgaWYgKGNvbXBsZXRlZEJhdGNoZXMubGVuZ3RoID09PSB0b3RhbEJhdGNoZXMpIHtcbiAgICAgIHNlc3Npb24uY3VycmVudFN0ZXAgPSAnY29tcGxldGUnO1xuICAgICAgcmV0dXJuIGBDYW1wYWlnbiBDb21wbGV0ZSFcXG5cXG5BbGwgJHt0b3RhbEJhdGNoZXN9IGJhdGNoZXMgcHJvY2Vzc2VkIHN1Y2Nlc3NmdWxseS5cXG5Ub3RhbCBwb3N0cyBjcmVhdGVkOiAke3RvdGFsUHJvY2Vzc2VkfVxcbkNhbXBhaWduOiAke3Nlc3Npb24uY2FtcGFpZ25OYW1lfVxcblxcbllvdXIgY29tcHJlaGVuc2l2ZSBtYXJrZXRpbmcgY2FtcGFpZ24gaXMgbm93IHNjaGVkdWxlZCBhbmQgcmVhZHkhYDtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIGBQcm9ncmVzcyBVcGRhdGU6XFxuQ29tcGxldGVkOiAke2NvbXBsZXRlZEJhdGNoZXMubGVuZ3RofS8ke3RvdGFsQmF0Y2hlc30gYmF0Y2hlc1xcblBvc3RzIHByb2Nlc3NlZDogJHt0b3RhbFByb2Nlc3NlZH1cXG5Db250aW51aW5nIGNhbXBhaWduIGdlbmVyYXRpb24uLi5gO1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCBkaXJlY3RvckFnZW50ID0gbmV3IERpcmVjdG9yQWdlbnQoKTtcbiJdLCJuYW1lcyI6WyJCYXNlQWdlbnQiLCJEaXJlY3RvckFnZW50IiwiZXhlY3V0ZSIsInRvb2wiLCJpbnB1dCIsImNvbnZleE11dGF0aW9ucyIsInNlc3Npb25JZCIsImNvbnNvbGUiLCJsb2ciLCJleGlzdGluZ1Nlc3Npb24iLCJzZXNzaW9ucyIsImhhcyIsInNldCIsImN1cnJlbnRTdGVwIiwiYWN0aXZlQ2FtcGFpZ25zIiwiTWFwIiwic2Vzc2lvbiIsImdldCIsImluc3RydWN0aW9uc0ZpbGUiLCJ0cmltIiwiaW5jbHVkZXMiLCJzdGFydHNXaXRoIiwiY2FtcGFpZ25OYW1lIiwicHJvamVjdCIsImNyZWF0ZVByb2plY3QiLCJuYW1lIiwiZGVzY3JpcHRpb24iLCJzdGF0dXMiLCJwcm9qZWN0RGF0YSIsImNhbXBhaWduUHJvamVjdElkIiwiX2lkIiwiaWQiLCJjYW1wYWlnblByb2plY3ROYW1lIiwic3RvcmVDaGF0TWVzc2FnZSIsInJvbGUiLCJjb250ZW50IiwiaW50ZXJhY3RpdmVDb21wb25lbnQiLCJ0eXBlIiwiZGF0YSIsImZpbGVUeXBlIiwiZmlsdGVyQnlFeHRlbnNpb24iLCJwbGFjZWhvbGRlciIsImVycm9yIiwiZmlsZU5hbWUiLCJyZXBsYWNlIiwiZmlsZXMiLCJnZXRBbGxGaWxlcyIsImxlbmd0aCIsIm1hcCIsImYiLCJpbnN0cnVjdGlvbkZpbGUiLCJmaW5kIiwiaW5zdHJ1Y3Rpb25zQ29udGVudCIsImR1cmF0aW9uIiwicGxhdGZvcm1zIiwicG9zdHNQZXJEYXkiLCJjYW1wYWlnbkdvYWxzIiwicmVzdWx0IiwiZ2VuZXJhdGVDYW1wYWlnbiIsInRvTG93ZXJDYXNlIiwicGFyc2VDYW1wYWlnblNldHRpbmdzIiwiaGFuZGxlQmF0Y2hDb21wbGV0aW9uIiwibGluZXMiLCJzcGxpdCIsImxpbmUiLCJmaWx0ZXIiLCJsb3dlciIsIm1hdGNoIiwicGFyc2VJbnQiLCJqb2luIiwidG90YWxEYXlzIiwidG90YWxQb3N0cyIsImNhbXBhaWduSWQiLCJjYW1wYWlnbiIsImNyZWF0ZUNhbXBhaWduIiwic3RhcnREYXRlIiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwiZW5kRGF0ZSIsIm5vdyIsInRlbXBsYXRlIiwiYWxsUG9zdHMiLCJnZW5lcmF0ZUJhdGNoZXNBc3luYyIsImJhdGNoZXMiLCJjcmVhdGVCYXRjaGVzIiwiZm9yRWFjaCIsImJhdGNoIiwicHJvY2Vzc0luZGljYXRvciIsInByb2Nlc3NUeXBlIiwiY29sb3IiLCJpIiwicG9zdHMiLCJwcm9jZXNzQmF0Y2giLCJQcm9taXNlIiwicmVzb2x2ZSIsInNldFRpbWVvdXQiLCJFcnJvciIsIm1lc3NhZ2UiLCJpbnN0cnVjdGlvbnMiLCJkYXlzIiwicGxhdGZvcm0iLCJ3ZWVrIiwiTWF0aCIsImZsb29yIiwiZGF5SW5kZXgiLCJkYXkiLCJ0aW1lIiwiZ2V0T3B0aW1hbFBvc3RUaW1lIiwicG9zdERhdGUiLCJzZXREYXRlIiwiZ2V0RGF0ZSIsInBoYXNlcyIsInBoYXNlSW5kZXgiLCJwaGFzZSIsIm1pbiIsImNvbnRlbnRUeXBlcyIsImNvbnRlbnRUeXBlIiwiZ2VuZXJhdGVQbGF0Zm9ybUNvbnRlbnQiLCJwdXNoIiwic2NoZWR1bGVkRGF0ZSIsInNjaGVkdWxlZFRpbWUiLCJtZXRhZGF0YSIsImRheU9mV2VlayIsImNhbXBhaWduUGhhc2UiLCJoYXNodGFncyIsImdlbmVyYXRlSGFzaHRhZ3MiLCJiYXRjaElkIiwiQkFUQ0hfU0laRSIsInRpbWVzIiwidHdpdHRlciIsImxpbmtlZGluIiwiaW5zdGFncmFtIiwiZmFjZWJvb2siLCJwbGF0Zm9ybVRpbWVzIiwiYnJhbmRWb2ljZSIsImV4dHJhY3RCcmFuZFZvaWNlIiwiYXVkaWVuY2UiLCJleHRyYWN0QXVkaWVuY2UiLCJzdWJzdHJpbmciLCJ2b2ljZUtleXdvcmRzIiwibG93ZXJJbnN0cnVjdGlvbnMiLCJrZXl3b3JkIiwiY2hhckF0IiwidG9VcHBlckNhc2UiLCJzbGljZSIsImF1ZGllbmNlS2V5d29yZHMiLCJiYXNlSGFzaHRhZ3MiLCJwaGFzZUhhc2h0YWdzIiwiYXdhcmVuZXNzIiwiY29uc2lkZXJhdGlvbiIsImNvbnZlcnNpb24iLCJyZXRlbnRpb24iLCJjb250ZW50SGFzaHRhZ3MiLCJlZHVjYXRpb25hbCIsInByb21vdGlvbmFsIiwiZW5nYWdlbWVudCIsImFubm91bmNlbWVudCIsImJhdGNoUG9zdHMiLCJwcm9jZXNzaW5nU3RhdHVzIiwicHJvY2Vzc2VkQ291bnQiLCJ0b3RhbENvdW50IiwicG9zdFByb21pc2VzIiwicG9zdCIsInVwc2VydFBvc3QiLCJ0aXRsZSIsInBsYXRmb3JtRGF0YSIsIkpTT04iLCJzdHJpbmdpZnkiLCJzY2hlZHVsZWRGb3IiLCJnZXRUaW1lIiwiYWxsIiwiY29tcGxldGVkQmF0Y2hlcyIsIkFycmF5IiwiZnJvbSIsInZhbHVlcyIsInRvdGFsQmF0Y2hlcyIsInNpemUiLCJ0b3RhbFByb2Nlc3NlZCIsInJlZHVjZSIsInN1bSIsImljb24iLCJNQVhfQ09OQ1VSUkVOVF9CQVRDSEVTIiwidG9vbHMiLCJjb21tYW5kIiwicGFyYW1ldGVycyIsImRpcmVjdG9yQWdlbnQiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./store/agents/directorAgent.ts\n"));

/***/ })

});