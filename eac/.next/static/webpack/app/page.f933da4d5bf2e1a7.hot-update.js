"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./store/agents/logoGeneratorAgent.ts":
/*!********************************************!*\
  !*** ./store/agents/logoGeneratorAgent.ts ***!
  \********************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LogoGeneratorAgent: () => (/* binding */ LogoGeneratorAgent),\n/* harmony export */   logoGeneratorAgent: () => (/* binding */ logoGeneratorAgent)\n/* harmony export */ });\n/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ \"(app-pages-browser)/./store/agents/base.ts\");\n/* harmony import */ var _lib_api_imagen__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/lib/api/imagen */ \"(app-pages-browser)/./lib/api/imagen.ts\");\n// Logo Generator Agent\n// /Users/matthewsimon/Projects/eac/eac/store/agents/logoGeneratorAgent.ts\n\n\nclass LogoGeneratorAgent extends _base__WEBPACK_IMPORTED_MODULE_0__.BaseAgent {\n    async execute(tool, input, convexMutations, sessionId) {\n        try {\n            // For the logo generator, we always use the conversational flow\n            // The slash command '/logo' is handled within processInput\n            return await this.processInput(input, convexMutations, sessionId || '');\n        } catch (error) {\n            console.error('Logo Generator Agent error:', error);\n            return \"‚ùå **Error in Logo Generation**\\n\\nSomething went wrong: \".concat(error instanceof Error ? error.message : 'Unknown error');\n        }\n    }\n    getInitialPrompt() {\n        this.currentStep = 'welcome';\n        return \"\\uD83C\\uDFA8 **Welcome to the Logo Generator!**\\n\\nI'll help you create a professional logo using Google's Imagen AI. Let's start by learning about your business.\\n\\n**What's the name of your company or brand?**\\n\\n(This will be the primary text in your logo)\";\n    }\n    async processInput(input, convexMutations, sessionId) {\n        var _this_currentBrief;\n        const normalizedInput = input.toLowerCase().trim();\n        // Debug logging\n        console.log('üé® LogoGenerator processInput:', {\n            input: normalizedInput,\n            currentStep: this.currentStep,\n            briefExists: !!this.currentBrief,\n            companyName: (_this_currentBrief = this.currentBrief) === null || _this_currentBrief === void 0 ? void 0 : _this_currentBrief.companyName\n        });\n        // Handle slash commands first\n        if (normalizedInput.startsWith('/logo')) {\n            return this.handleLogoGeneration(input, convexMutations, sessionId);\n        }\n        // Handle conversation flow based on current step\n        switch(this.currentStep){\n            case 'welcome':\n                return this.handleWelcomeStep(input, convexMutations, sessionId);\n            case 'company':\n                return this.handleCompanyStep(input, convexMutations, sessionId);\n            case 'business':\n                return this.handleBusinessStep(input, convexMutations, sessionId);\n            case 'style':\n                return this.handleStyleStep(input, convexMutations, sessionId);\n            case 'colors':\n                return this.handleColorsStep(input, convexMutations, sessionId);\n            case 'type':\n                return this.handleTypeStep(input, convexMutations, sessionId);\n            case 'audience':\n                return this.handleAudienceStep(input, convexMutations, sessionId);\n            case 'instructions':\n                return this.handleInstructionsStep(input, convexMutations, sessionId);\n            case 'generate':\n                return this.handleGenerateStep(input, convexMutations, sessionId);\n            default:\n                return this.getInitialPrompt();\n        }\n    }\n    async handleWelcomeStep(input, convexMutations, sessionId) {\n        if (!this.currentBrief) {\n            this.currentBrief = {};\n        }\n        this.currentBrief.companyName = input.trim();\n        this.currentStep = 'business';\n        return \"Great! **\".concat(input.trim(), \"** is a wonderful name.\\n\\nNow, tell me about your business:\\n\\n**What industry are you in and what does \").concat(input.trim(), ' do?**\\n\\n(For example: \"We\\'re a sustainable fashion brand that creates eco-friendly clothing\" or \"We provide cloud-based accounting software for small businesses\")');\n    }\n    async handleCompanyStep(input, convexMutations, sessionId) {\n        this.currentBrief.companyName = input.trim();\n        this.currentStep = 'business';\n        return \"Perfect! Now let's learn about **\".concat(input.trim(), \"**.\\n\\n**What industry are you in and what does your business do?**\\n\\n(Be specific about your products, services, or mission. This helps me understand the right visual direction for your logo.)\");\n    }\n    async handleBusinessStep(input, convexMutations, sessionId) {\n        this.currentBrief.businessDescription = input.trim();\n        // Try to extract industry from the description\n        const businessDesc = input.toLowerCase();\n        let suggestedIndustry = '';\n        if (businessDesc.includes('tech') || businessDesc.includes('software') || businessDesc.includes('app')) {\n            suggestedIndustry = 'Technology';\n        } else if (businessDesc.includes('fashion') || businessDesc.includes('clothing') || businessDesc.includes('apparel')) {\n            suggestedIndustry = 'Fashion & Retail';\n        } else if (businessDesc.includes('food') || businessDesc.includes('restaurant') || businessDesc.includes('culinary')) {\n            suggestedIndustry = 'Food & Beverage';\n        } else if (businessDesc.includes('health') || businessDesc.includes('medical') || businessDesc.includes('wellness')) {\n            suggestedIndustry = 'Healthcare';\n        } else if (businessDesc.includes('finance') || businessDesc.includes('accounting') || businessDesc.includes('banking')) {\n            suggestedIndustry = 'Financial Services';\n        } else {\n            suggestedIndustry = 'Professional Services';\n        }\n        this.currentBrief.industry = suggestedIndustry;\n        this.currentStep = 'style';\n        return \"Excellent! I understand that \".concat(this.currentBrief.companyName, \" \").concat(input.trim().toLowerCase(), \".\\n\\nNow, what style direction appeals to you? Choose one:\\n\\n1. **Minimalist** - Clean, simple, timeless\\n2. **Modern** - Contemporary, sleek, geometric\\n3. **Traditional** - Classic, established, trustworthy\\n4. **Playful** - Fun, creative, approachable\\n5. **Elegant** - Sophisticated, refined, luxury\\n6. **Bold** - Strong, impactful, confident\\n\\n**Type the number or style name you prefer:**\");\n    }\n    async handleStyleStep(input, convexMutations, sessionId) {\n        const normalizedInput = input.toLowerCase().trim();\n        let selectedStyle;\n        // Map input to style preference\n        if (normalizedInput.includes('1') || normalizedInput.includes('minimalist')) {\n            selectedStyle = 'minimalist';\n        } else if (normalizedInput.includes('2') || normalizedInput.includes('modern')) {\n            selectedStyle = 'modern';\n        } else if (normalizedInput.includes('3') || normalizedInput.includes('traditional')) {\n            selectedStyle = 'traditional';\n        } else if (normalizedInput.includes('4') || normalizedInput.includes('playful')) {\n            selectedStyle = 'playful';\n        } else if (normalizedInput.includes('5') || normalizedInput.includes('elegant')) {\n            selectedStyle = 'elegant';\n        } else if (normalizedInput.includes('6') || normalizedInput.includes('bold')) {\n            selectedStyle = 'bold';\n        } else {\n            return \"I didn't understand that style choice. Please choose:\\n\\n1. **Minimalist** 2. **Modern** 3. **Traditional** 4. **Playful** 5. **Elegant** 6. **Bold**\\n\\n**Type the number or style name:**\";\n        }\n        this.currentBrief.stylePreference = selectedStyle;\n        this.currentStep = 'colors';\n        return \"Perfect! A **\".concat(selectedStyle, \"** style will work great for \").concat(this.currentBrief.companyName, '.\\n\\n**What color preferences do you have?**\\n\\nYou can mention:\\n- Specific colors (blue, green, red, etc.)\\n- Color themes (corporate, vibrant, earthy, etc.)  \\n- \"No preference\" if you want me to suggest colors based on your industry\\n\\n**Your color preference:**');\n    }\n    async handleColorsStep(input, convexMutations, sessionId) {\n        const colorInput = input.trim();\n        this.currentBrief.colorPreferences = [\n            colorInput\n        ];\n        this.currentStep = 'type';\n        return \"Great color choice! Now, what type of logo do you prefer?\\n\\n1. **Text-only** - Company name styled beautifully (like Google, Coca-Cola)\\n2. **Icon-only** - A symbol that represents your brand (like Apple, Nike swoosh)\\n3. **Combination** - Both text and icon together (like Adidas, McDonald's)\\n\\n**Type the number or logo type you prefer:**\";\n    }\n    async handleTypeStep(input, convexMutations, sessionId) {\n        const normalizedInput = input.toLowerCase().trim();\n        let logoType;\n        if (normalizedInput.includes('1') || normalizedInput.includes('text')) {\n            logoType = 'text';\n        } else if (normalizedInput.includes('2') || normalizedInput.includes('icon')) {\n            logoType = 'icon';\n        } else if (normalizedInput.includes('3') || normalizedInput.includes('combination')) {\n            logoType = 'combination';\n        } else {\n            return \"Please choose a logo type:\\n\\n1. **Text-only** 2. **Icon-only** 3. **Combination**\\n\\n**Type the number or logo type:**\";\n        }\n        this.currentBrief.logoType = logoType;\n        this.currentStep = 'audience';\n        return \"Excellent! A **\".concat(logoType, '** logo will be perfect.\\n\\n**Who is your target audience?**\\n\\n(For example: \"Young professionals\", \"Families with children\", \"Small business owners\", \"Tech startups\", etc. This helps inform the design approach.)');\n    }\n    async handleAudienceStep(input, convexMutations, sessionId) {\n        this.currentBrief.targetAudience = input.trim();\n        this.currentStep = 'instructions';\n        return 'Perfect! Understanding your audience helps create the right visual impact.\\n\\n**Any additional instructions or specific elements you\\'d like included?**\\n\\n(Optional - you can mention specific symbols, avoid certain elements, or say \"none\" to proceed)\\n\\n**Additional instructions:**';\n    }\n    async handleInstructionsStep(input, convexMutations, sessionId) {\n        var _brief_colorPreferences;\n        const instructions = input.trim();\n        if (instructions.toLowerCase() !== 'none') {\n            this.currentBrief.additionalInstructions = instructions;\n        }\n        this.currentStep = 'generate';\n        const brief = this.currentBrief;\n        return \"\\uD83C\\uDFAF **Logo Brief Complete!**\\n\\nHere's what I'll create for you:\\n\\n‚Ä¢ **Company:** \".concat(brief.companyName, \"\\n‚Ä¢ **Business:** \").concat(brief.businessDescription, \"\\n‚Ä¢ **Industry:** \").concat(brief.industry, \"\\n‚Ä¢ **Style:** \").concat(brief.stylePreference, \"\\n‚Ä¢ **Colors:** \").concat((_brief_colorPreferences = brief.colorPreferences) === null || _brief_colorPreferences === void 0 ? void 0 : _brief_colorPreferences[0], \"\\n‚Ä¢ **Type:** \").concat(brief.logoType, \"\\n‚Ä¢ **Audience:** \").concat(brief.targetAudience, \"\\n\").concat(brief.additionalInstructions ? \"‚Ä¢ **Special Instructions:** \".concat(brief.additionalInstructions) : '', '\\n\\n**Ready to generate your logo?**\\n\\nType \"yes\" to start generation or \"edit\" if you want to modify anything.');\n    }\n    async handleGenerateStep(input, convexMutations, sessionId) {\n        const normalizedInput = input.toLowerCase().trim();\n        if (normalizedInput.includes('edit') || normalizedInput.includes('modify')) {\n            this.currentStep = 'welcome';\n            this.currentBrief = {};\n            return \"No problem! Let's start over with any changes you'd like to make.\\n\\n**What's the name of your company or brand?**\";\n        }\n        if (normalizedInput.includes('yes') || normalizedInput.includes('generate') || normalizedInput.includes('create')) {\n            return this.handleLogoGeneration(input, convexMutations, sessionId);\n        }\n        return 'Please type \"yes\" to generate your logo or \"edit\" to make changes to your brief.';\n    }\n    async handleLogoGeneration(input, convexMutations, sessionId) {\n        const brief = this.currentBrief;\n        if (!brief || !brief.companyName) {\n            this.currentStep = 'welcome';\n            return \"I need more information to generate your logo. Let's start with your company name.\\n\\n**What's the name of your company or brand?**\";\n        }\n        try {\n            var _brief_colorPreferences, _generationResult_imageUrl, _generationResult_imageUrl1;\n            // Create optimized Imagen prompt from the brief\n            const imagePrompt = (0,_lib_api_imagen__WEBPACK_IMPORTED_MODULE_1__.optimizeLogoPrompt)(brief.companyName, brief.businessDescription || '', brief.stylePreference || 'modern', ((_brief_colorPreferences = brief.colorPreferences) === null || _brief_colorPreferences === void 0 ? void 0 : _brief_colorPreferences[0]) || '', brief.logoType || 'combination', brief.targetAudience || '', brief.additionalInstructions);\n            // Start generation process\n            const generationResult = await (0,_lib_api_imagen__WEBPACK_IMPORTED_MODULE_1__.generateLogoWithImagen)(imagePrompt);\n            console.log('üé® Logo generation result:', {\n                success: generationResult.success,\n                hasImageUrl: !!generationResult.imageUrl,\n                imageUrlLength: (_generationResult_imageUrl = generationResult.imageUrl) === null || _generationResult_imageUrl === void 0 ? void 0 : _generationResult_imageUrl.length,\n                imageUrlPreview: (_generationResult_imageUrl1 = generationResult.imageUrl) === null || _generationResult_imageUrl1 === void 0 ? void 0 : _generationResult_imageUrl1.substring(0, 50),\n                error: generationResult.error\n            });\n            if (generationResult.success && generationResult.imageUrl) {\n                var _brief_colorPreferences1;\n                // Store the generated logo in Convex for persistence\n                if (sessionId && convexMutations.storeChatMessage) {\n                    var _brief_colorPreferences2;\n                    await convexMutations.storeChatMessage({\n                        role: \"assistant\",\n                        content: \"\\uD83C\\uDFA8 **Logo Generated Successfully!**\\n\\nHere's your custom logo for **\".concat(brief.companyName, \"**:\\n\\n![Generated Logo](\").concat(generationResult.imageUrl, \")\\n\\n**Generation Details:**\\n‚Ä¢ **Style:** \").concat(brief.stylePreference, \"\\n‚Ä¢ **Type:** \").concat(brief.logoType, \"\\n‚Ä¢ **Colors:** \").concat((_brief_colorPreferences2 = brief.colorPreferences) === null || _brief_colorPreferences2 === void 0 ? void 0 : _brief_colorPreferences2[0], \"\\n‚Ä¢ **Target Audience:** \").concat(brief.targetAudience, \"\\n\\n**Imagen Prompt Used:**\\n`\").concat(imagePrompt, \"`\\n\\n**What's Next?**\\n1. **Generate Variation** - Create another version\\n2. **Export Logo** - Download in different formats\\n3. **Start New Project** - Create another logo\\n\\nType your choice to continue!\"),\n                        sessionId,\n                        operation: {\n                            type: \"tool_executed\",\n                            details: {\n                                tool: \"logo_generation\",\n                                imageUrl: generationResult.imageUrl,\n                                imageData: generationResult.imageData,\n                                prompt: imagePrompt,\n                                brief: brief\n                            }\n                        }\n                    });\n                }\n                // Reset for next generation\n                this.reset();\n                return \"\\uD83C\\uDFA8 **Logo Generated Successfully!**\\n\\nYour custom logo for **\".concat(brief.companyName, \"** has been created and will appear in the Logo Generator tab.\\n\\n**Generation Details:**\\n‚Ä¢ **Style:** \").concat(brief.stylePreference, \"\\n‚Ä¢ **Type:** \").concat(brief.logoType, \"\\n‚Ä¢ **Colors:** \").concat((_brief_colorPreferences1 = brief.colorPreferences) === null || _brief_colorPreferences1 === void 0 ? void 0 : _brief_colorPreferences1[0], \"\\n‚Ä¢ **Target Audience:** \").concat(brief.targetAudience, \"\\n\\nThe logo is now available in the preview panel. You can:\\n\\n1. **Generate Variation** - Create another version\\n2. **Export Logo** - Download in different formats  \\n3. **Start New Project** - Create another logo\\n\\nType your choice to continue!\");\n            } else {\n                return \"‚ùå **Logo Generation Failed**\\n\\nSorry, there was an issue generating your logo: \".concat(generationResult.error || 'Unknown error', '\\n\\nPlease try again or modify your requirements. Type \"restart\" to begin with a new brief.');\n            }\n        } catch (error) {\n            console.error('‚ùå Logo generation error:', error);\n            return \"‚ùå **Logo Generation Error**\\n\\nAn unexpected error occurred during logo generation. Please try again.\\n\\nError: \".concat(error instanceof Error ? error.message : 'Unknown error', '\\n\\nType \"restart\" to begin with a new brief.');\n        }\n    }\n    createImagenPrompt(brief) {\n        const { companyName, businessDescription, stylePreference, colorPreferences, logoType, targetAudience, additionalInstructions } = brief;\n        let prompt = 'Create a professional logo design for \"'.concat(companyName, '\"');\n        if (businessDescription) {\n            prompt += \", a company that \".concat(businessDescription.toLowerCase());\n        }\n        if (stylePreference) {\n            prompt += \". Style: \".concat(stylePreference);\n        }\n        if (logoType) {\n            if (logoType === 'text') {\n                prompt += '. Text-only logo with stylized typography';\n            } else if (logoType === 'icon') {\n                prompt += '. Icon-only logo, no text, symbolic design';\n            } else {\n                prompt += '. Combination logo with both text and icon elements';\n            }\n        }\n        if (colorPreferences && colorPreferences[0] && colorPreferences[0].toLowerCase() !== 'no preference') {\n            prompt += \". Color scheme: \".concat(colorPreferences[0]);\n        }\n        if (targetAudience) {\n            prompt += \". Target audience: \".concat(targetAudience);\n        }\n        if (additionalInstructions) {\n            prompt += \". Special requirements: \".concat(additionalInstructions);\n        }\n        prompt += '. High quality, professional, scalable vector design, clean background, suitable for business use.';\n        return prompt;\n    }\n    // Reset the agent state\n    reset() {\n        this.currentBrief = {};\n        this.currentStep = 'welcome';\n    }\n    constructor(){\n        super(), this.id = 'logo-generator', this.name = 'Logo Generator', this.description = 'AI-powered logo creation and brand identity generation using Google Imagen', this.icon = 'Puzzle', // Instance state to track the logo generation process\n        this.currentBrief = {}, this.currentStep = 'welcome', this.tools = [\n            {\n                id: 'logo-generation',\n                name: 'Logo Generation',\n                command: '/logo',\n                description: 'Generate professional logos with Google Imagen AI',\n                parameters: []\n            }\n        ];\n        // Initialize the brief when agent is created\n        this.currentBrief = {};\n        this.currentStep = 'welcome';\n    }\n}\n// Export the instantiated agent for registry\nconst logoGeneratorAgent = new LogoGeneratorAgent();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3N0b3JlL2FnZW50cy9sb2dvR2VuZXJhdG9yQWdlbnQudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBLHVCQUF1QjtBQUN2QiwwRUFBMEU7QUFFNUI7QUFFZ0M7QUFjdkUsTUFBTUcsMkJBQTJCSCw0Q0FBU0E7SUEyQi9DLE1BQU1JLFFBQ0pDLElBQWUsRUFDZkMsS0FBYSxFQUNiQyxlQUFnQyxFQUNoQ0MsU0FBa0IsRUFDRDtRQUNqQixJQUFJO1lBQ0YsZ0VBQWdFO1lBQ2hFLDJEQUEyRDtZQUMzRCxPQUFPLE1BQU0sSUFBSSxDQUFDQyxZQUFZLENBQUNILE9BQU9DLGlCQUFpQkMsYUFBYTtRQUN0RSxFQUFFLE9BQU9FLE9BQU87WUFDZEMsUUFBUUQsS0FBSyxDQUFDLCtCQUErQkE7WUFDN0MsT0FBTywyREFBb0gsT0FBekRBLGlCQUFpQkUsUUFBUUYsTUFBTUcsT0FBTyxHQUFHO1FBQzdHO0lBQ0Y7SUFFQUMsbUJBQTJCO1FBQ3pCLElBQUksQ0FBQ0MsV0FBVyxHQUFHO1FBQ25CLE9BQVE7SUFPVjtJQUVBLE1BQU1OLGFBQWFILEtBQWEsRUFBRUMsZUFBZ0MsRUFBRUMsU0FBaUIsRUFBbUI7WUFRdkY7UUFQZixNQUFNUSxrQkFBa0JWLE1BQU1XLFdBQVcsR0FBR0MsSUFBSTtRQUVoRCxnQkFBZ0I7UUFDaEJQLFFBQVFRLEdBQUcsQ0FBQyxrQ0FBa0M7WUFDNUNiLE9BQU9VO1lBQ1BELGFBQWEsSUFBSSxDQUFDQSxXQUFXO1lBQzdCSyxhQUFhLENBQUMsQ0FBQyxJQUFJLENBQUNDLFlBQVk7WUFDaENDLFdBQVcsR0FBRSx5QkFBSSxDQUFDRCxZQUFZLGNBQWpCLDREQUFtQkMsV0FBVztRQUM3QztRQUVBLDhCQUE4QjtRQUM5QixJQUFJTixnQkFBZ0JPLFVBQVUsQ0FBQyxVQUFVO1lBQ3ZDLE9BQU8sSUFBSSxDQUFDQyxvQkFBb0IsQ0FBQ2xCLE9BQU9DLGlCQUFpQkM7UUFDM0Q7UUFFQSxpREFBaUQ7UUFDakQsT0FBUSxJ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QUFNO2dCQUNOSSxTQUFTO2dCQUNUSCxhQUFhO2dCQUNiSSxZQUFZLEVBQUU7WUFDaEI7U0FDRDtRQUlDLDZDQUE2QztRQUM3QyxJQUFJLENBQUNyRCxZQUFZLEdBQUcsQ0FBQztRQUNyQixJQUFJLENBQUNOLFdBQVcsR0FBRztJQUNyQjtBQW9jRjtBQUVBLDZDQUE2QztBQUN0QyxNQUFNNEQscUJBQXFCLElBQUl4RSxxQkFBcUIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYXR0aGV3c2ltb24vUHJvamVjdHMvZWFjL2VhYy9zdG9yZS9hZ2VudHMvbG9nb0dlbmVyYXRvckFnZW50LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIExvZ28gR2VuZXJhdG9yIEFnZW50XG4vLyAvVXNlcnMvbWF0dGhld3NpbW9uL1Byb2plY3RzL2VhYy9lYWMvc3RvcmUvYWdlbnRzL2xvZ29HZW5lcmF0b3JBZ2VudC50c1xuXG5pbXBvcnQgeyBBZ2VudFRvb2wsIEJhc2VBZ2VudCB9IGZyb20gJy4vYmFzZSc7XG5pbXBvcnQgeyBDb252ZXhNdXRhdGlvbnMgfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7IGdlbmVyYXRlTG9nb1dpdGhJbWFnZW4sIG9wdGltaXplTG9nb1Byb21wdCB9IGZyb20gJ0AvbGliL2FwaS9pbWFnZW4nO1xuXG5pbnRlcmZhY2UgTG9nb0JyaWVmIHtcbiAgY29tcGFueU5hbWU6IHN0cmluZztcbiAgcHJvZHVjdE5hbWU/OiBzdHJpbmc7XG4gIGluZHVzdHJ5OiBzdHJpbmc7XG4gIGJ1c2luZXNzRGVzY3JpcHRpb246IHN0cmluZztcbiAgc3R5bGVQcmVmZXJlbmNlOiAnbWluaW1hbGlzdCcgfCAnbW9kZXJuJyB8ICd0cmFkaXRpb25hbCcgfCAncGxheWZ1bCcgfCAnZWxlZ2FudCcgfCAnYm9sZCc7XG4gIGNvbG9yUHJlZmVyZW5jZXM6IHN0cmluZ1tdO1xuICBsb2dvVHlwZTogJ3RleHQnIHwgJ2ljb24nIHwgJ2NvbWJpbmF0aW9uJztcbiAgdGFyZ2V0QXVkaWVuY2U6IHN0cmluZztcbiAgYWRkaXRpb25hbEluc3RydWN0aW9ucz86IHN0cmluZztcbn1cblxuZXhwb3J0IGNsYXNzIExvZ29HZW5lcmF0b3JBZ2VudCBleHRlbmRzIEJhc2VBZ2VudCB7XG4gIGlkID0gJ2xvZ28tZ2VuZXJhdG9yJztcbiAgbmFtZSA9ICdMb2dvIEdlbmVyYXRvcic7XG4gIGRlc2NyaXB0aW9uID0gJ0FJLXBvd2VyZWQgbG9nbyBjcmVhdGlvbiBhbmQgYnJhbmQgaWRlbnRpdHkgZ2VuZXJhdGlvbiB1c2luZyBHb29nbGUgSW1hZ2VuJztcbiAgaWNvbiA9ICdQdXp6bGUnO1xuXG4gIC8vIEluc3RhbmNlIHN0YXRlIHRvIHRyYWNrIHRoZSBsb2dvIGdlbmVyYXRpb24gcHJvY2Vzc1xuICBwcml2YXRlIGN1cnJlbnRCcmllZjogUGFydGlhbDxMb2dvQnJpZWY+ID0ge307XG4gIHByaXZhdGUgY3VycmVudFN0ZXA6ICd3ZWxjb21lJyB8ICdjb21wYW55JyB8ICdidXNpbmVzcycgfCAnc3R5bGUnIHwgJ2NvbG9ycycgfCAndHlwZScgfCAnYXVkaWVuY2UnIHwgJ2luc3RydWN0aW9ucycgfCAnZ2VuZXJhdGUnID0gJ3dlbGNvbWUnO1xuXG4gIHRvb2xzOiBBZ2VudFRvb2xbXSA9IFtcbiAgICB7XG4gICAgICBpZDogJ2xvZ28tZ2VuZXJhdGlvbicsXG4gICAgICBuYW1lOiAnTG9nbyBHZW5lcmF0aW9uJyxcbiAgICAgIGNvbW1hbmQ6ICcvbG9nbycsXG4gICAgICBkZXNjcmlwdGlvbjogJ0dlbmVyYXRlIHByb2Zlc3Npb25hbCBsb2dvcyB3aXRoIEdvb2dsZSBJbWFnZW4gQUknLFxuICAgICAgcGFyYW1ldGVyczogW11cbiAgICB9XG4gIF07XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICAvLyBJbml0aWFsaXplIHRoZSBicmllZiB3aGVuIGFnZW50IGlzIGNyZWF0ZWRcbiAgICB0aGlzLmN1cnJlbnRCcmllZiA9IHt9O1xuICAgIHRoaXMuY3VycmVudFN0ZXAgPSAnd2VsY29tZSc7XG4gIH1cblxuICBhc3luYyBleGVjdXRlKFxuICAgIHRvb2w6IEFnZW50VG9vbCxcbiAgICBpbnB1dDogc3RyaW5nLFxuICAgIGNvbnZleE11dGF0aW9uczogQ29udmV4TXV0YXRpb25zLFxuICAgIHNlc3Npb25JZD86IHN0cmluZ1xuICApOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBGb3IgdGhlIGxvZ28gZ2VuZXJhdG9yLCB3ZSBhbHdheXMgdXNlIHRoZSBjb252ZXJzYXRpb25hbCBmbG93XG4gICAgICAvLyBUaGUgc2xhc2ggY29tbWFuZCAnL2xvZ28nIGlzIGhhbmRsZWQgd2l0aGluIHByb2Nlc3NJbnB1dFxuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucHJvY2Vzc0lucHV0KGlucHV0LCBjb252ZXhNdXRhdGlvbnMsIHNlc3Npb25JZCB8fCAnJyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0xvZ28gR2VuZXJhdG9yIEFnZW50IGVycm9yOicsIGVycm9yKTtcbiAgICAgIHJldHVybiBg4p2MICoqRXJyb3IgaW4gTG9nbyBHZW5lcmF0aW9uKipcXG5cXG5Tb21ldGhpbmcgd2VudCB3cm9uZzogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJ31gO1xuICAgIH1cbiAgfVxuXG4gIGdldEluaXRpYWxQcm9tcHQoKTogc3RyaW5nIHtcbiAgICB0aGlzLmN1cnJlbnRTdGVwID0gJ3dlbGNvbWUnO1xuICAgIHJldHVybiBg8J+OqCAqKldlbGNvbWUgdG8gdGhlIExvZ28gR2VuZXJhdG9yISoqXG5cbkknbGwgaGVscCB5b3UgY3JlYXRlIGEgcHJvZmVzc2lvbmFsIGxvZ28gdXNpbmcgR29vZ2xlJ3MgSW1hZ2VuIEFJLiBMZXQncyBzdGFydCBieSBsZWFybmluZyBhYm91dCB5b3VyIGJ1c2luZXNzLlxuXG4qKldoYXQncyB0aGUgbmFtZSBvZiB5b3VyIGNvbXBhbnkgb3IgYnJhbmQ/KipcblxuKFRoaXMgd2lsbCBiZSB0aGUgcHJpbWFyeSB0ZXh0IGluIHlvdXIgbG9nbylgO1xuICB9XG5cbiAgYXN5bmMgcHJvY2Vzc0lucHV0KGlucHV0OiBzdHJpbmcsIGNvbnZleE11dGF0aW9uczogQ29udmV4TXV0YXRpb25zLCBzZXNzaW9uSWQ6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgY29uc3Qgbm9ybWFsaXplZElucHV0ID0gaW5wdXQudG9Mb3dlckNhc2UoKS50cmltKCk7XG4gICAgXG4gICAgLy8gRGVidWcgbG9nZ2luZ1xuICAgIGNvbnNvbGUubG9nKCfwn46oIExvZ29HZW5lcmF0b3IgcHJvY2Vzc0lucHV0OicsIHtcbiAgICAgIGlucHV0OiBub3JtYWxpemVkSW5wdXQsXG4gICAgICBjdXJyZW50U3RlcDogdGhpcy5jdXJyZW50U3RlcCxcbiAgICAgIGJyaWVmRXhpc3RzOiAhIXRoaXMuY3VycmVudEJyaWVmLFxuICAgICAgY29tcGFueU5hbWU6IHRoaXMuY3VycmVudEJyaWVmPy5jb21wYW55TmFtZVxuICAgIH0pO1xuICAgIFxuICAgIC8vIEhhbmRsZSBzbGFzaCBjb21tYW5kcyBmaXJzdFxuICAgIGlmIChub3JtYWxpemVkSW5wdXQuc3RhcnRzV2l0aCgnL2xvZ28nKSkge1xuICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlTG9nb0dlbmVyYXRpb24oaW5wdXQsIGNvbnZleE11dGF0aW9ucywgc2Vzc2lvbklkKTtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgY29udmVyc2F0aW9uIGZsb3cgYmFzZWQgb24gY3VycmVudCBzdGVwXG4gICAgc3dpdGNoICh0aGlzLmN1cnJlbnRTdGVwKSB7XG4gICAgICBjYXNlICd3ZWxjb21lJzpcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlV2VsY29tZVN0ZXAoaW5wdXQsIGNvbnZleE11dGF0aW9ucywgc2Vzc2lvbklkKTtcbiAgICAgIFxuICAgICAgY2FzZSAnY29tcGFueSc6XG4gICAgICAgIHJldHVybiB0aGlzLmhhbmRsZUNvbXBhbnlTdGVwKGlucHV0LCBjb252ZXhNdXRhdGlvbnMsIHNlc3Npb25JZCk7XG4gICAgICBcbiAgICAgIGNhc2UgJ2J1c2luZXNzJzpcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlQnVzaW5lc3NTdGVwKGlucHV0LCBjb252ZXhNdXRhdGlvbnMsIHNlc3Npb25JZCk7XG4gICAgICBcbiAgICAgIGNhc2UgJ3N0eWxlJzpcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlU3R5bGVTdGVwKGlucHV0LCBjb252ZXhNdXRhdGlvbnMsIHNlc3Npb25JZCk7XG4gICAgICBcbiAgICAgIGNhc2UgJ2NvbG9ycyc6XG4gICAgICAgIHJldHVybiB0aGlzLmhhbmRsZUNvbG9yc1N0ZXAoaW5wdXQsIGNvbnZleE11dGF0aW9ucywgc2Vzc2lvbklkKTtcbiAgICAgIFxuICAgICAgY2FzZSAndHlwZSc6XG4gICAgICAgIHJldHVybiB0aGlzLmhhbmRsZVR5cGVTdGVwKGlucHV0LCBjb252ZXhNdXRhdGlvbnMsIHNlc3Npb25JZCk7XG4gICAgICBcbiAgICAgIGNhc2UgJ2F1ZGllbmNlJzpcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlQXVkaWVuY2VTdGVwKGlucHV0LCBjb252ZXhNdXRhdGlvbnMsIHNlc3Npb25JZCk7XG4gICAgICBcbiAgICAgIGNhc2UgJ2luc3RydWN0aW9ucyc6XG4gICAgICAgIHJldHVybiB0aGlzLmhhbmRsZUluc3RydWN0aW9uc1N0ZXAoaW5wdXQsIGNvbnZleE11dGF0aW9ucywgc2Vzc2lvbklkKTtcbiAgICAgIFxuICAgICAgY2FzZSAnZ2VuZXJhdGUnOlxuICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVHZW5lcmF0ZVN0ZXAoaW5wdXQsIGNvbnZleE11dGF0aW9ucywgc2Vzc2lvbklkKTtcbiAgICAgIFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0SW5pdGlhbFByb21wdCgpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgaGFuZGxlV2VsY29tZVN0ZXAoaW5wdXQ6IHN0cmluZywgY29udmV4TXV0YXRpb25zOiBDb252ZXhNdXRhdGlvbnMsIHNlc3Npb25JZDogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICBpZiAoIXRoaXMuY3VycmVudEJyaWVmKSB7XG4gICAgICB0aGlzLmN1cnJlbnRCcmllZiA9IHt9O1xuICAgIH1cbiAgICBcbiAgICB0aGlzLmN1cnJlbnRCcmllZi5jb21wYW55TmFtZSA9IGlucHV0LnRyaW0oKTtcbiAgICB0aGlzLmN1cnJlbnRTdGVwID0gJ2J1c2luZXNzJztcbiAgICBcbiAgICByZXR1cm4gYEdyZWF0ISAqKiR7aW5wdXQudHJpbSgpfSoqIGlzIGEgd29uZGVyZnVsIG5hbWUuXG5cbk5vdywgdGVsbCBtZSBhYm91dCB5b3VyIGJ1c2luZXNzOlxuXG4qKldoYXQgaW5kdXN0cnkgYXJlIHlvdSBpbiBhbmQgd2hhdCBkb2VzICR7aW5wdXQudHJpbSgpfSBkbz8qKlxuXG4oRm9yIGV4YW1wbGU6IFwiV2UncmUgYSBzdXN0YWluYWJsZSBmYXNoaW9uIGJyYW5kIHRoYXQgY3JlYXRlcyBlY28tZnJpZW5kbHkgY2xvdGhpbmdcIiBvciBcIldlIHByb3ZpZGUgY2xvdWQtYmFzZWQgYWNjb3VudGluZyBzb2Z0d2FyZSBmb3Igc21hbGwgYnVzaW5lc3Nlc1wiKWA7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGhhbmRsZUNvbXBhbnlTdGVwKGlucHV0OiBzdHJpbmcsIGNvbnZleE11dGF0aW9uczogQ29udmV4TXV0YXRpb25zLCBzZXNzaW9uSWQ6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgdGhpcy5jdXJyZW50QnJpZWYhLmNvbXBhbnlOYW1lID0gaW5wdXQudHJpbSgpO1xuICAgIHRoaXMuY3VycmVudFN0ZXAgPSAnYnVzaW5lc3MnO1xuICAgIFxuICAgIHJldHVybiBgUGVyZmVjdCEgTm93IGxldCdzIGxlYXJuIGFib3V0ICoqJHtpbnB1dC50cmltKCl9KiouXG5cbioqV2hhdCBpbmR1c3RyeSBhcmUgeW91IGluIGFuZCB3aGF0IGRvZXMgeW91ciBidXNpbmVzcyBkbz8qKlxuXG4oQmUgc3BlY2lmaWMgYWJvdXQgeW91ciBwcm9kdWN0cywgc2VydmljZXMsIG9yIG1pc3Npb24uIFRoaXMgaGVscHMgbWUgdW5kZXJzdGFuZCB0aGUgcmlnaHQgdmlzdWFsIGRpcmVjdGlvbiBmb3IgeW91ciBsb2dvLilgO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBoYW5kbGVCdXNpbmVzc1N0ZXAoaW5wdXQ6IHN0cmluZywgY29udmV4TXV0YXRpb25zOiBDb252ZXhNdXRhdGlvbnMsIHNlc3Npb25JZDogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICB0aGlzLmN1cnJlbnRCcmllZiEuYnVzaW5lc3NEZXNjcmlwdGlvbiA9IGlucHV0LnRyaW0oKTtcbiAgICBcbiAgICAvLyBUcnkgdG8gZXh0cmFjdCBpbmR1c3RyeSBmcm9tIHRoZSBkZXNjcmlwdGlvblxuICAgIGNvbnN0IGJ1c2luZXNzRGVzYyA9IGlucHV0LnRvTG93ZXJDYXNlKCk7XG4gICAgbGV0IHN1Z2dlc3RlZEluZHVzdHJ5ID0gJyc7XG4gICAgXG4gICAgaWYgKGJ1c2luZXNzRGVzYy5pbmNsdWRlcygndGVjaCcpIHx8IGJ1c2luZXNzRGVzYy5pbmNsdWRlcygnc29mdHdhcmUnKSB8fCBidXNpbmVzc0Rlc2MuaW5jbHVkZXMoJ2FwcCcpKSB7XG4gICAgICBzdWdnZXN0ZWRJbmR1c3RyeSA9ICdUZWNobm9sb2d5JztcbiAgICB9IGVsc2UgaWYgKGJ1c2luZXNzRGVzYy5pbmNsdWRlcygnZmFzaGlvbicpIHx8IGJ1c2luZXNzRGVzYy5pbmNsdWRlcygnY2xvdGhpbmcnKSB8fCBidXNpbmVzc0Rlc2MuaW5jbHVkZXMoJ2FwcGFyZWwnKSkge1xuICAgICAgc3VnZ2VzdGVkSW5kdXN0cnkgPSAnRmFzaGlvbiAmIFJldGFpbCc7XG4gICAgfSBlbHNlIGlmIChidXNpbmVzc0Rlc2MuaW5jbHVkZXMoJ2Zvb2QnKSB8fCBidXNpbmVzc0Rlc2MuaW5jbHVkZXMoJ3Jlc3RhdXJhbnQnKSB8fCBidXNpbmVzc0Rlc2MuaW5jbHVkZXMoJ2N1bGluYXJ5JykpIHtcbiAgICAgIHN1Z2dlc3RlZEluZHVzdHJ5ID0gJ0Zvb2QgJiBCZXZlcmFnZSc7XG4gICAgfSBlbHNlIGlmIChidXNpbmVzc0Rlc2MuaW5jbHVkZXMoJ2hlYWx0aCcpIHx8IGJ1c2luZXNzRGVzYy5pbmNsdWRlcygnbWVkaWNhbCcpIHx8IGJ1c2luZXNzRGVzYy5pbmNsdWRlcygnd2VsbG5lc3MnKSkge1xuICAgICAgc3VnZ2VzdGVkSW5kdXN0cnkgPSAnSGVhbHRoY2FyZSc7XG4gICAgfSBlbHNlIGlmIChidXNpbmVzc0Rlc2MuaW5jbHVkZXMoJ2ZpbmFuY2UnKSB8fCBidXNpbmVzc0Rlc2MuaW5jbHVkZXMoJ2FjY291bnRpbmcnKSB8fCBidXNpbmVzc0Rlc2MuaW5jbHVkZXMoJ2JhbmtpbmcnKSkge1xuICAgICAgc3VnZ2VzdGVkSW5kdXN0cnkgPSAnRmluYW5jaWFsIFNlcnZpY2VzJztcbiAgICB9IGVsc2Uge1xuICAgICAgc3VnZ2VzdGVkSW5kdXN0cnkgPSAnUHJvZmVzc2lvbmFsIFNlcnZpY2VzJztcbiAgICB9XG4gICAgXG4gICAgdGhpcy5jdXJyZW50QnJpZWYhLmluZHVzdHJ5ID0gc3VnZ2VzdGVkSW5kdXN0cnk7XG4gICAgdGhpcy5jdXJyZW50U3RlcCA9ICdzdHlsZSc7XG4gICAgXG4gICAgcmV0dXJuIGBFeGNlbGxlbnQhIEkgdW5kZXJzdGFuZCB0aGF0ICR7dGhpcy5jdXJyZW50QnJpZWYhLmNvbXBhbnlOYW1lfSAke2lucHV0LnRyaW0oKS50b0xvd2VyQ2FzZSgpfS5cblxuTm93LCB3aGF0IHN0eWxlIGRpcmVjdGlvbiBhcHBlYWxzIHRvIHlvdT8gQ2hvb3NlIG9uZTpcblxuMS4gKipNaW5pbWFsaXN0KiogLSBDbGVhbiwgc2ltcGxlLCB0aW1lbGVzc1xuMi4gKipNb2Rlcm4qKiAtIENvbnRlbXBvcmFyeSwgc2xlZWssIGdlb21ldHJpY1xuMy4gKipUcmFkaXRpb25hbCoqIC0gQ2xhc3NpYywgZXN0YWJsaXNoZWQsIHRydXN0d29ydGh5XG40LiAqKlBsYXlmdWwqKiAtIEZ1biwgY3JlYXRpdmUsIGFwcHJvYWNoYWJsZVxuNS4gKipFbGVnYW50KiogLSBTb3BoaXN0aWNhdGVkLCByZWZpbmVkLCBsdXh1cnlcbjYuICoqQm9sZCoqIC0gU3Ryb25nLCBpbXBhY3RmdWwsIGNvbmZpZGVudFxuXG4qKlR5cGUgdGhlIG51bWJlciBvciBzdHlsZSBuYW1lIHlvdSBwcmVmZXI6KipgO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBoYW5kbGVTdHlsZVN0ZXAoaW5wdXQ6IHN0cmluZywgY29udmV4TXV0YXRpb25zOiBDb252ZXhNdXRhdGlvbnMsIHNlc3Npb25JZDogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICBjb25zdCBub3JtYWxpemVkSW5wdXQgPSBpbnB1dC50b0xvd2VyQ2FzZSgpLnRyaW0oKTtcbiAgICBsZXQgc2VsZWN0ZWRTdHlsZTogTG9nb0JyaWVmWydzdHlsZVByZWZlcmVuY2UnXTtcbiAgICBcbiAgICAvLyBNYXAgaW5wdXQgdG8gc3R5bGUgcHJlZmVyZW5jZVxuICAgIGlmIChub3JtYWxpemVkSW5wdXQuaW5jbHVkZXMoJzEnKSB8fCBub3JtYWxpemVkSW5wdXQuaW5jbHVkZXMoJ21pbmltYWxpc3QnKSkge1xuICAgICAgc2VsZWN0ZWRTdHlsZSA9ICdtaW5pbWFsaXN0JztcbiAgICB9IGVsc2UgaWYgKG5vcm1hbGl6ZWRJbnB1dC5pbmNsdWRlcygnMicpIHx8IG5vcm1hbGl6ZWRJbnB1dC5pbmNsdWRlcygnbW9kZXJuJykpIHtcbiAgICAgIHNlbGVjdGVkU3R5bGUgPSAnbW9kZXJuJztcbiAgICB9IGVsc2UgaWYgKG5vcm1hbGl6ZWRJbnB1dC5pbmNsdWRlcygnMycpIHx8IG5vcm1hbGl6ZWRJbnB1dC5pbmNsdWRlcygndHJhZGl0aW9uYWwnKSkge1xuICAgICAgc2VsZWN0ZWRTdHlsZSA9ICd0cmFkaXRpb25hbCc7XG4gICAgfSBlbHNlIGlmIChub3JtYWxpemVkSW5wdXQuaW5jbHVkZXMoJzQnKSB8fCBub3JtYWxpemVkSW5wdXQuaW5jbHVkZXMoJ3BsYXlmdWwnKSkge1xuICAgICAgc2VsZWN0ZWRTdHlsZSA9ICdwbGF5ZnVsJztcbiAgICB9IGVsc2UgaWYgKG5vcm1hbGl6ZWRJbnB1dC5pbmNsdWRlcygnNScpIHx8IG5vcm1hbGl6ZWRJbnB1dC5pbmNsdWRlcygnZWxlZ2FudCcpKSB7XG4gICAgICBzZWxlY3RlZFN0eWxlID0gJ2VsZWdhbnQnO1xuICAgIH0gZWxzZSBpZiAobm9ybWFsaXplZElucHV0LmluY2x1ZGVzKCc2JykgfHwgbm9ybWFsaXplZElucHV0LmluY2x1ZGVzKCdib2xkJykpIHtcbiAgICAgIHNlbGVjdGVkU3R5bGUgPSAnYm9sZCc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBgSSBkaWRuJ3QgdW5kZXJzdGFuZCB0aGF0IHN0eWxlIGNob2ljZS4gUGxlYXNlIGNob29zZTpcblxuMS4gKipNaW5pbWFsaXN0KiogMi4gKipNb2Rlcm4qKiAzLiAqKlRyYWRpdGlvbmFsKiogNC4gKipQbGF5ZnVsKiogNS4gKipFbGVnYW50KiogNi4gKipCb2xkKipcblxuKipUeXBlIHRoZSBudW1iZXIgb3Igc3R5bGUgbmFtZToqKmA7XG4gICAgfVxuICAgIFxuICAgIHRoaXMuY3VycmVudEJyaWVmIS5zdHlsZVByZWZlcmVuY2UgPSBzZWxlY3RlZFN0eWxlO1xuICAgIHRoaXMuY3VycmVudFN0ZXAgPSAnY29sb3JzJztcbiAgICBcbiAgICByZXR1cm4gYFBlcmZlY3QhIEEgKioke3NlbGVjdGVkU3R5bGV9Kiogc3R5bGUgd2lsbCB3b3JrIGdyZWF0IGZvciAke3RoaXMuY3VycmVudEJyaWVmIS5jb21wYW55TmFtZX0uXG5cbioqV2hhdCBjb2xvciBwcmVmZXJlbmNlcyBkbyB5b3UgaGF2ZT8qKlxuXG5Zb3UgY2FuIG1lbnRpb246XG4tIFNwZWNpZmljIGNvbG9ycyAoYmx1ZSwgZ3JlZW4sIHJlZCwgZXRjLilcbi0gQ29sb3IgdGhlbWVzIChjb3Jwb3JhdGUsIHZpYnJhbnQsIGVhcnRoeSwgZXRjLikgIFxuLSBcIk5vIHByZWZlcmVuY2VcIiBpZiB5b3Ugd2FudCBtZSB0byBzdWdnZXN0IGNvbG9ycyBiYXNlZCBvbiB5b3VyIGluZHVzdHJ5XG5cbioqWW91ciBjb2xvciBwcmVmZXJlbmNlOioqYDtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgaGFuZGxlQ29sb3JzU3RlcChpbnB1dDogc3RyaW5nLCBjb252ZXhNdXRhdGlvbnM6IENvbnZleE11dGF0aW9ucywgc2Vzc2lvbklkOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIGNvbnN0IGNvbG9ySW5wdXQgPSBpbnB1dC50cmltKCk7XG4gICAgdGhpcy5jdXJyZW50QnJpZWYhLmNvbG9yUHJlZmVyZW5jZXMgPSBbY29sb3JJbnB1dF07XG4gICAgdGhpcy5jdXJyZW50U3RlcCA9ICd0eXBlJztcbiAgICBcbiAgICByZXR1cm4gYEdyZWF0IGNvbG9yIGNob2ljZSEgTm93LCB3aGF0IHR5cGUgb2YgbG9nbyBkbyB5b3UgcHJlZmVyP1xuXG4xLiAqKlRleHQtb25seSoqIC0gQ29tcGFueSBuYW1lIHN0eWxlZCBiZWF1dGlmdWxseSAobGlrZSBHb29nbGUsIENvY2EtQ29sYSlcbjIuICoqSWNvbi1vbmx5KiogLSBBIHN5bWJvbCB0aGF0IHJlcHJlc2VudHMgeW91ciBicmFuZCAobGlrZSBBcHBsZSwgTmlrZSBzd29vc2gpXG4zLiAqKkNvbWJpbmF0aW9uKiogLSBCb3RoIHRleHQgYW5kIGljb24gdG9nZXRoZXIgKGxpa2UgQWRpZGFzLCBNY0RvbmFsZCdzKVxuXG4qKlR5cGUgdGhlIG51bWJlciBvciBsb2dvIHR5cGUgeW91IHByZWZlcjoqKmA7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGhhbmRsZVR5cGVTdGVwKGlucHV0OiBzdHJpbmcsIGNvbnZleE11dGF0aW9uczogQ29udmV4TXV0YXRpb25zLCBzZXNzaW9uSWQ6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgY29uc3Qgbm9ybWFsaXplZElucHV0ID0gaW5wdXQudG9Mb3dlckNhc2UoKS50cmltKCk7XG4gICAgbGV0IGxvZ29UeXBlOiBMb2dvQnJpZWZbJ2xvZ29UeXBlJ107XG4gICAgXG4gICAgaWYgKG5vcm1hbGl6ZWRJbnB1dC5pbmNsdWRlcygnMScpIHx8IG5vcm1hbGl6ZWRJbnB1dC5pbmNsdWRlcygndGV4dCcpKSB7XG4gICAgICBsb2dvVHlwZSA9ICd0ZXh0JztcbiAgICB9IGVsc2UgaWYgKG5vcm1hbGl6ZWRJbnB1dC5pbmNsdWRlcygnMicpIHx8IG5vcm1hbGl6ZWRJbnB1dC5pbmNsdWRlcygnaWNvbicpKSB7XG4gICAgICBsb2dvVHlwZSA9ICdpY29uJztcbiAgICB9IGVsc2UgaWYgKG5vcm1hbGl6ZWRJbnB1dC5pbmNsdWRlcygnMycpIHx8IG5vcm1hbGl6ZWRJbnB1dC5pbmNsdWRlcygnY29tYmluYXRpb24nKSkge1xuICAgICAgbG9nb1R5cGUgPSAnY29tYmluYXRpb24nO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYFBsZWFzZSBjaG9vc2UgYSBsb2dvIHR5cGU6XG5cbjEuICoqVGV4dC1vbmx5KiogMi4gKipJY29uLW9ubHkqKiAzLiAqKkNvbWJpbmF0aW9uKipcblxuKipUeXBlIHRoZSBudW1iZXIgb3IgbG9nbyB0eXBlOioqYDtcbiAgICB9XG4gICAgXG4gICAgdGhpcy5jdXJyZW50QnJpZWYhLmxvZ29UeXBlID0gbG9nb1R5cGU7XG4gICAgdGhpcy5jdXJyZW50U3RlcCA9ICdhdWRpZW5jZSc7XG4gICAgXG4gICAgcmV0dXJuIGBFeGNlbGxlbnQhIEEgKioke2xvZ29UeXBlfSoqIGxvZ28gd2lsbCBiZSBwZXJmZWN0LlxuXG4qKldobyBpcyB5b3VyIHRhcmdldCBhdWRpZW5jZT8qKlxuXG4oRm9yIGV4YW1wbGU6IFwiWW91bmcgcHJvZmVzc2lvbmFsc1wiLCBcIkZhbWlsaWVzIHdpdGggY2hpbGRyZW5cIiwgXCJTbWFsbCBidXNpbmVzcyBvd25lcnNcIiwgXCJUZWNoIHN0YXJ0dXBzXCIsIGV0Yy4gVGhpcyBoZWxwcyBpbmZvcm0gdGhlIGRlc2lnbiBhcHByb2FjaC4pYDtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgaGFuZGxlQXVkaWVuY2VTdGVwKGlucHV0OiBzdHJpbmcsIGNvbnZleE11dGF0aW9uczogQ29udmV4TXV0YXRpb25zLCBzZXNzaW9uSWQ6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgdGhpcy5jdXJyZW50QnJpZWYhLnRhcmdldEF1ZGllbmNlID0gaW5wdXQudHJpbSgpO1xuICAgIHRoaXMuY3VycmVudFN0ZXAgPSAnaW5zdHJ1Y3Rpb25zJztcbiAgICBcbiAgICByZXR1cm4gYFBlcmZlY3QhIFVuZGVyc3RhbmRpbmcgeW91ciBhdWRpZW5jZSBoZWxwcyBjcmVhdGUgdGhlIHJpZ2h0IHZpc3VhbCBpbXBhY3QuXG5cbioqQW55IGFkZGl0aW9uYWwgaW5zdHJ1Y3Rpb25zIG9yIHNwZWNpZmljIGVsZW1lbnRzIHlvdSdkIGxpa2UgaW5jbHVkZWQ/KipcblxuKE9wdGlvbmFsIC0geW91IGNhbiBtZW50aW9uIHNwZWNpZmljIHN5bWJvbHMsIGF2b2lkIGNlcnRhaW4gZWxlbWVudHMsIG9yIHNheSBcIm5vbmVcIiB0byBwcm9jZWVkKVxuXG4qKkFkZGl0aW9uYWwgaW5zdHJ1Y3Rpb25zOioqYDtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgaGFuZGxlSW5zdHJ1Y3Rpb25zU3RlcChpbnB1dDogc3RyaW5nLCBjb252ZXhNdXRhdGlvbnM6IENvbnZleE11dGF0aW9ucywgc2Vzc2lvbklkOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIGNvbnN0IGluc3RydWN0aW9ucyA9IGlucHV0LnRyaW0oKTtcbiAgICBpZiAoaW5zdHJ1Y3Rpb25zLnRvTG93ZXJDYXNlKCkgIT09ICdub25lJykge1xuICAgICAgdGhpcy5jdXJyZW50QnJpZWYhLmFkZGl0aW9uYWxJbnN0cnVjdGlvbnMgPSBpbnN0cnVjdGlvbnM7XG4gICAgfVxuICAgIFxuICAgIHRoaXMuY3VycmVudFN0ZXAgPSAnZ2VuZXJhdGUnO1xuICAgIFxuICAgIGNvbnN0IGJyaWVmID0gdGhpcy5jdXJyZW50QnJpZWYhO1xuICAgIFxuICAgIHJldHVybiBg8J+OryAqKkxvZ28gQnJpZWYgQ29tcGxldGUhKipcblxuSGVyZSdzIHdoYXQgSSdsbCBjcmVhdGUgZm9yIHlvdTpcblxu4oCiICoqQ29tcGFueToqKiAke2JyaWVmLmNvbXBhbnlOYW1lfVxu4oCiICoqQnVzaW5lc3M6KiogJHticmllZi5idXNpbmVzc0Rlc2NyaXB0aW9ufVxu4oCiICoqSW5kdXN0cnk6KiogJHticmllZi5pbmR1c3RyeX1cbuKAoiAqKlN0eWxlOioqICR7YnJpZWYuc3R5bGVQcmVmZXJlbmNlfVxu4oCiICoqQ29sb3JzOioqICR7YnJpZWYuY29sb3JQcmVmZXJlbmNlcz8uWzBdfVxu4oCiICoqVHlwZToqKiAke2JyaWVmLmxvZ29UeXBlfVxu4oCiICoqQXVkaWVuY2U6KiogJHticmllZi50YXJnZXRBdWRpZW5jZX1cbiR7YnJpZWYuYWRkaXRpb25hbEluc3RydWN0aW9ucyA/IGDigKIgKipTcGVjaWFsIEluc3RydWN0aW9uczoqKiAke2JyaWVmLmFkZGl0aW9uYWxJbnN0cnVjdGlvbnN9YCA6ICcnfVxuXG4qKlJlYWR5IHRvIGdlbmVyYXRlIHlvdXIgbG9nbz8qKlxuXG5UeXBlIFwieWVzXCIgdG8gc3RhcnQgZ2VuZXJhdGlvbiBvciBcImVkaXRcIiBpZiB5b3Ugd2FudCB0byBtb2RpZnkgYW55dGhpbmcuYDtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgaGFuZGxlR2VuZXJhdGVTdGVwKGlucHV0OiBzdHJpbmcsIGNvbnZleE11dGF0aW9uczogQ29udmV4TXV0YXRpb25zLCBzZXNzaW9uSWQ6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgY29uc3Qgbm9ybWFsaXplZElucHV0ID0gaW5wdXQudG9Mb3dlckNhc2UoKS50cmltKCk7XG4gICAgXG4gICAgaWYgKG5vcm1hbGl6ZWRJbnB1dC5pbmNsdWRlcygnZWRpdCcpIHx8IG5vcm1hbGl6ZWRJbnB1dC5pbmNsdWRlcygnbW9kaWZ5JykpIHtcbiAgICAgIHRoaXMuY3VycmVudFN0ZXAgPSAnd2VsY29tZSc7XG4gICAgICB0aGlzLmN1cnJlbnRCcmllZiA9IHt9O1xuICAgICAgcmV0dXJuIGBObyBwcm9ibGVtISBMZXQncyBzdGFydCBvdmVyIHdpdGggYW55IGNoYW5nZXMgeW91J2QgbGlrZSB0byBtYWtlLlxuXG4qKldoYXQncyB0aGUgbmFtZSBvZiB5b3VyIGNvbXBhbnkgb3IgYnJhbmQ/KipgO1xuICAgIH1cbiAgICBcbiAgICBpZiAobm9ybWFsaXplZElucHV0LmluY2x1ZGVzKCd5ZXMnKSB8fCBub3JtYWxpemVkSW5wdXQuaW5jbHVkZXMoJ2dlbmVyYXRlJykgfHwgbm9ybWFsaXplZElucHV0LmluY2x1ZGVzKCdjcmVhdGUnKSkge1xuICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlTG9nb0dlbmVyYXRpb24oaW5wdXQsIGNvbnZleE11dGF0aW9ucywgc2Vzc2lvbklkKTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIGBQbGVhc2UgdHlwZSBcInllc1wiIHRvIGdlbmVyYXRlIHlvdXIgbG9nbyBvciBcImVkaXRcIiB0byBtYWtlIGNoYW5nZXMgdG8geW91ciBicmllZi5gO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBoYW5kbGVMb2dvR2VuZXJhdGlvbihpbnB1dDogc3RyaW5nLCBjb252ZXhNdXRhdGlvbnM6IENvbnZleE11dGF0aW9ucywgc2Vzc2lvbklkPzogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICBjb25zdCBicmllZiA9IHRoaXMuY3VycmVudEJyaWVmO1xuICAgIFxuICAgIGlmICghYnJpZWYgfHwgIWJyaWVmLmNvbXBhbnlOYW1lKSB7XG4gICAgICB0aGlzLmN1cnJlbnRTdGVwID0gJ3dlbGNvbWUnO1xuICAgICAgcmV0dXJuIGBJIG5lZWQgbW9yZSBpbmZvcm1hdGlvbiB0byBnZW5lcmF0ZSB5b3VyIGxvZ28uIExldCdzIHN0YXJ0IHdpdGggeW91ciBjb21wYW55IG5hbWUuXG5cbioqV2hhdCdzIHRoZSBuYW1lIG9mIHlvdXIgY29tcGFueSBvciBicmFuZD8qKmA7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIC8vIENyZWF0ZSBvcHRpbWl6ZWQgSW1hZ2VuIHByb21wdCBmcm9tIHRoZSBicmllZlxuICAgICAgY29uc3QgaW1hZ2VQcm9tcHQgPSBvcHRpbWl6ZUxvZ29Qcm9tcHQoXG4gICAgICAgIGJyaWVmLmNvbXBhbnlOYW1lLFxuICAgICAgICBicmllZi5idXNpbmVzc0Rlc2NyaXB0aW9uIHx8ICcnLFxuICAgICAgICBicmllZi5zdHlsZVByZWZlcmVuY2UgfHwgJ21vZGVybicsXG4gICAgICAgIGJyaWVmLmNvbG9yUHJlZmVyZW5jZXM/LlswXSB8fCAnJyxcbiAgICAgICAgYnJpZWYubG9nb1R5cGUgfHwgJ2NvbWJpbmF0aW9uJyxcbiAgICAgICAgYnJpZWYudGFyZ2V0QXVkaWVuY2UgfHwgJycsXG4gICAgICAgIGJyaWVmLmFkZGl0aW9uYWxJbnN0cnVjdGlvbnNcbiAgICAgICk7XG4gICAgICBcbiAgICAgIC8vIFN0YXJ0IGdlbmVyYXRpb24gcHJvY2Vzc1xuICAgICAgY29uc3QgZ2VuZXJhdGlvblJlc3VsdCA9IGF3YWl0IGdlbmVyYXRlTG9nb1dpdGhJbWFnZW4oaW1hZ2VQcm9tcHQpO1xuICAgICAgXG4gICAgICBjb25zb2xlLmxvZygn8J+OqCBMb2dvIGdlbmVyYXRpb24gcmVzdWx0OicsIHtcbiAgICAgICAgc3VjY2VzczogZ2VuZXJhdGlvblJlc3VsdC5zdWNjZXNzLFxuICAgICAgICBoYXNJbWFnZVVybDogISFnZW5lcmF0aW9uUmVzdWx0LmltYWdlVXJsLFxuICAgICAgICBpbWFnZVVybExlbmd0aDogZ2VuZXJhdGlvblJlc3VsdC5pbWFnZVVybD8ubGVuZ3RoLFxuICAgICAgICBpbWFnZVVybFByZXZpZXc6IGdlbmVyYXRpb25SZXN1bHQuaW1hZ2VVcmw/LnN1YnN0cmluZygwLCA1MCksXG4gICAgICAgIGVycm9yOiBnZW5lcmF0aW9uUmVzdWx0LmVycm9yXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgaWYgKGdlbmVyYXRpb25SZXN1bHQuc3VjY2VzcyAmJiBnZW5lcmF0aW9uUmVzdWx0LmltYWdlVXJsKSB7XG4gICAgICAgIC8vIFN0b3JlIHRoZSBnZW5lcmF0ZWQgbG9nbyBpbiBDb252ZXggZm9yIHBlcnNpc3RlbmNlXG4gICAgICAgIGlmIChzZXNzaW9uSWQgJiYgY29udmV4TXV0YXRpb25zLnN0b3JlQ2hhdE1lc3NhZ2UpIHtcbiAgICAgICAgICBhd2FpdCBjb252ZXhNdXRhdGlvbnMuc3RvcmVDaGF0TWVzc2FnZSh7XG4gICAgICAgICAgICByb2xlOiBcImFzc2lzdGFudFwiLFxuICAgICAgICAgICAgY29udGVudDogYPCfjqggKipMb2dvIEdlbmVyYXRlZCBTdWNjZXNzZnVsbHkhKipcblxuSGVyZSdzIHlvdXIgY3VzdG9tIGxvZ28gZm9yICoqJHticmllZi5jb21wYW55TmFtZX0qKjpcblxuIVtHZW5lcmF0ZWQgTG9nb10oJHtnZW5lcmF0aW9uUmVzdWx0LmltYWdlVXJsfSlcblxuKipHZW5lcmF0aW9uIERldGFpbHM6KipcbuKAoiAqKlN0eWxlOioqICR7YnJpZWYuc3R5bGVQcmVmZXJlbmNlfVxu4oCiICoqVHlwZToqKiAke2JyaWVmLmxvZ29UeXBlfVxu4oCiICoqQ29sb3JzOioqICR7YnJpZWYuY29sb3JQcmVmZXJlbmNlcz8uWzBdfVxu4oCiICoqVGFyZ2V0IEF1ZGllbmNlOioqICR7YnJpZWYudGFyZ2V0QXVkaWVuY2V9XG5cbioqSW1hZ2VuIFByb21wdCBVc2VkOioqXG5cXGAke2ltYWdlUHJvbXB0fVxcYFxuXG4qKldoYXQncyBOZXh0PyoqXG4xLiAqKkdlbmVyYXRlIFZhcmlhdGlvbioqIC0gQ3JlYXRlIGFub3RoZXIgdmVyc2lvblxuMi4gKipFeHBvcnQgTG9nbyoqIC0gRG93bmxvYWQgaW4gZGlmZmVyZW50IGZvcm1hdHNcbjMuICoqU3RhcnQgTmV3IFByb2plY3QqKiAtIENyZWF0ZSBhbm90aGVyIGxvZ29cblxuVHlwZSB5b3VyIGNob2ljZSB0byBjb250aW51ZSFgLFxuICAgICAgICAgICAgc2Vzc2lvbklkLFxuICAgICAgICAgICAgb3BlcmF0aW9uOiB7XG4gICAgICAgICAgICAgIHR5cGU6IFwidG9vbF9leGVjdXRlZFwiLFxuICAgICAgICAgICAgICBkZXRhaWxzOiB7XG4gICAgICAgICAgICAgICAgdG9vbDogXCJsb2dvX2dlbmVyYXRpb25cIixcbiAgICAgICAgICAgICAgICBpbWFnZVVybDogZ2VuZXJhdGlvblJlc3VsdC5pbWFnZVVybCxcbiAgICAgICAgICAgICAgICBpbWFnZURhdGE6IGdlbmVyYXRpb25SZXN1bHQuaW1hZ2VEYXRhLFxuICAgICAgICAgICAgICAgIHByb21wdDogaW1hZ2VQcm9tcHQsXG4gICAgICAgICAgICAgICAgYnJpZWY6IGJyaWVmXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gUmVzZXQgZm9yIG5leHQgZ2VuZXJhdGlvblxuICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gYPCfjqggKipMb2dvIEdlbmVyYXRlZCBTdWNjZXNzZnVsbHkhKipcblxuWW91ciBjdXN0b20gbG9nbyBmb3IgKioke2JyaWVmLmNvbXBhbnlOYW1lfSoqIGhhcyBiZWVuIGNyZWF0ZWQgYW5kIHdpbGwgYXBwZWFyIGluIHRoZSBMb2dvIEdlbmVyYXRvciB0YWIuXG5cbioqR2VuZXJhdGlvbiBEZXRhaWxzOioqXG7igKIgKipTdHlsZToqKiAke2JyaWVmLnN0eWxlUHJlZmVyZW5jZX1cbuKAoiAqKlR5cGU6KiogJHticmllZi5sb2dvVHlwZX1cbuKAoiAqKkNvbG9yczoqKiAke2JyaWVmLmNvbG9yUHJlZmVyZW5jZXM/LlswXX1cbuKAoiAqKlRhcmdldCBBdWRpZW5jZToqKiAke2JyaWVmLnRhcmdldEF1ZGllbmNlfVxuXG5UaGUgbG9nbyBpcyBub3cgYXZhaWxhYmxlIGluIHRoZSBwcmV2aWV3IHBhbmVsLiBZb3UgY2FuOlxuXG4xLiAqKkdlbmVyYXRlIFZhcmlhdGlvbioqIC0gQ3JlYXRlIGFub3RoZXIgdmVyc2lvblxuMi4gKipFeHBvcnQgTG9nbyoqIC0gRG93bmxvYWQgaW4gZGlmZmVyZW50IGZvcm1hdHMgIFxuMy4gKipTdGFydCBOZXcgUHJvamVjdCoqIC0gQ3JlYXRlIGFub3RoZXIgbG9nb1xuXG5UeXBlIHlvdXIgY2hvaWNlIHRvIGNvbnRpbnVlIWA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gYOKdjCAqKkxvZ28gR2VuZXJhdGlvbiBGYWlsZWQqKlxuXG5Tb3JyeSwgdGhlcmUgd2FzIGFuIGlzc3VlIGdlbmVyYXRpbmcgeW91ciBsb2dvOiAke2dlbmVyYXRpb25SZXN1bHQuZXJyb3IgfHwgJ1Vua25vd24gZXJyb3InfVxuXG5QbGVhc2UgdHJ5IGFnYWluIG9yIG1vZGlmeSB5b3VyIHJlcXVpcmVtZW50cy4gVHlwZSBcInJlc3RhcnRcIiB0byBiZWdpbiB3aXRoIGEgbmV3IGJyaWVmLmA7XG4gICAgICB9XG4gICAgICBcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcign4p2MIExvZ28gZ2VuZXJhdGlvbiBlcnJvcjonLCBlcnJvcik7XG4gICAgICByZXR1cm4gYOKdjCAqKkxvZ28gR2VuZXJhdGlvbiBFcnJvcioqXG5cbkFuIHVuZXhwZWN0ZWQgZXJyb3Igb2NjdXJyZWQgZHVyaW5nIGxvZ28gZ2VuZXJhdGlvbi4gUGxlYXNlIHRyeSBhZ2Fpbi5cblxuRXJyb3I6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcid9XG5cblR5cGUgXCJyZXN0YXJ0XCIgdG8gYmVnaW4gd2l0aCBhIG5ldyBicmllZi5gO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgY3JlYXRlSW1hZ2VuUHJvbXB0KGJyaWVmOiBQYXJ0aWFsPExvZ29CcmllZj4pOiBzdHJpbmcge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbXBhbnlOYW1lLFxuICAgICAgYnVzaW5lc3NEZXNjcmlwdGlvbixcbiAgICAgIHN0eWxlUHJlZmVyZW5jZSxcbiAgICAgIGNvbG9yUHJlZmVyZW5jZXMsXG4gICAgICBsb2dvVHlwZSxcbiAgICAgIHRhcmdldEF1ZGllbmNlLFxuICAgICAgYWRkaXRpb25hbEluc3RydWN0aW9uc1xuICAgIH0gPSBicmllZjtcblxuICAgIGxldCBwcm9tcHQgPSBgQ3JlYXRlIGEgcHJvZmVzc2lvbmFsIGxvZ28gZGVzaWduIGZvciBcIiR7Y29tcGFueU5hbWV9XCJgO1xuICAgIFxuICAgIGlmIChidXNpbmVzc0Rlc2NyaXB0aW9uKSB7XG4gICAgICBwcm9tcHQgKz0gYCwgYSBjb21wYW55IHRoYXQgJHtidXNpbmVzc0Rlc2NyaXB0aW9uLnRvTG93ZXJDYXNlKCl9YDtcbiAgICB9XG4gICAgXG4gICAgaWYgKHN0eWxlUHJlZmVyZW5jZSkge1xuICAgICAgcHJvbXB0ICs9IGAuIFN0eWxlOiAke3N0eWxlUHJlZmVyZW5jZX1gO1xuICAgIH1cbiAgICBcbiAgICBpZiAobG9nb1R5cGUpIHtcbiAgICAgIGlmIChsb2dvVHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgIHByb21wdCArPSAnLiBUZXh0LW9ubHkgbG9nbyB3aXRoIHN0eWxpemVkIHR5cG9ncmFwaHknO1xuICAgICAgfSBlbHNlIGlmIChsb2dvVHlwZSA9PT0gJ2ljb24nKSB7XG4gICAgICAgIHByb21wdCArPSAnLiBJY29uLW9ubHkgbG9nbywgbm8gdGV4dCwgc3ltYm9saWMgZGVzaWduJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb21wdCArPSAnLiBDb21iaW5hdGlvbiBsb2dvIHdpdGggYm90aCB0ZXh0IGFuZCBpY29uIGVsZW1lbnRzJztcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgaWYgKGNvbG9yUHJlZmVyZW5jZXMgJiYgY29sb3JQcmVmZXJlbmNlc1swXSAmJiBjb2xvclByZWZlcmVuY2VzWzBdLnRvTG93ZXJDYXNlKCkgIT09ICdubyBwcmVmZXJlbmNlJykge1xuICAgICAgcHJvbXB0ICs9IGAuIENvbG9yIHNjaGVtZTogJHtjb2xvclByZWZlcmVuY2VzWzBdfWA7XG4gICAgfVxuICAgIFxuICAgIGlmICh0YXJnZXRBdWRpZW5jZSkge1xuICAgICAgcHJvbXB0ICs9IGAuIFRhcmdldCBhdWRpZW5jZTogJHt0YXJnZXRBdWRpZW5jZX1gO1xuICAgIH1cbiAgICBcbiAgICBpZiAoYWRkaXRpb25hbEluc3RydWN0aW9ucykge1xuICAgICAgcHJvbXB0ICs9IGAuIFNwZWNpYWwgcmVxdWlyZW1lbnRzOiAke2FkZGl0aW9uYWxJbnN0cnVjdGlvbnN9YDtcbiAgICB9XG4gICAgXG4gICAgcHJvbXB0ICs9ICcuIEhpZ2ggcXVhbGl0eSwgcHJvZmVzc2lvbmFsLCBzY2FsYWJsZSB2ZWN0b3IgZGVzaWduLCBjbGVhbiBiYWNrZ3JvdW5kLCBzdWl0YWJsZSBmb3IgYnVzaW5lc3MgdXNlLic7XG4gICAgXG4gICAgcmV0dXJuIHByb21wdDtcbiAgfVxuXG4gIC8vIFJlc2V0IHRoZSBhZ2VudCBzdGF0ZVxuICByZXNldCgpOiB2b2lkIHtcbiAgICB0aGlzLmN1cnJlbnRCcmllZiA9IHt9O1xuICAgIHRoaXMuY3VycmVudFN0ZXAgPSAnd2VsY29tZSc7XG4gIH1cbn1cblxuLy8gRXhwb3J0IHRoZSBpbnN0YW50aWF0ZWQgYWdlbnQgZm9yIHJlZ2lzdHJ5XG5leHBvcnQgY29uc3QgbG9nb0dlbmVyYXRvckFnZW50ID0gbmV3IExvZ29HZW5lcmF0b3JBZ2VudCgpO1xuIl0sIm5hbWVzIjpbIkJhc2VBZ2VudCIsImdlbmVyYXRlTG9nb1dpdGhJbWFnZW4iLCJvcHRpbWl6ZUxvZ29Qcm9tcHQiLCJMb2dvR2VuZXJhdG9yQWdlbnQiLCJleGVjdXRlIiwidG9vbCIsImlucHV0IiwiY29udmV4TXV0YXRpb25zIiwic2Vzc2lvbklkIiwicHJvY2Vzc0lucHV0IiwiZXJyb3IiLCJjb25zb2xlIiwiRXJyb3IiLCJtZXNzYWdlIiwiZ2V0SW5pdGlhbFByb21wdCIsImN1cnJlbnRTdGVwIiwibm9ybWFsaXplZElucHV0IiwidG9Mb3dlckNhc2UiLCJ0cmltIiwibG9nIiwiYnJpZWZFeGlzdHMiLCJjdXJyZW50QnJpZWYiLCJjb21wYW55TmFtZSIsInN0YXJ0c1dpdGgiLCJoYW5kbGVMb2dvR2VuZXJhdGlvbiIsImhhbmRsZVdlbGNvbWVTdGVwIiwiaGFuZGxlQ29tcGFueVN0ZXAiLCJoYW5kbGVCdXNpbmVzc1N0ZXAiLCJoYW5kbGVTdHlsZVN0ZXAiLCJoYW5kbGVDb2xvcnNTdGVwIiwiaGFuZGxlVHlwZVN0ZXAiLCJoYW5kbGVBdWRpZW5jZVN0ZXAiLCJoYW5kbGVJbnN0cnVjdGlvbnNTdGVwIiwiaGFuZGxlR2VuZXJhdGVTdGVwIiwiYnVzaW5lc3NEZXNjcmlwdGlvbiIsImJ1c2luZXNzRGVzYyIsInN1Z2dlc3RlZEluZHVzdHJ5IiwiaW5jbHVkZXMiLCJpbmR1c3RyeSIsInNlbGVjdGVkU3R5bGUiLCJzdHlsZVByZWZlcmVuY2UiLCJjb2xvcklucHV0IiwiY29sb3JQcmVmZXJlbmNlcyIsImxvZ29UeXBlIiwidGFyZ2V0QXVkaWVuY2UiLCJicmllZiIsImluc3RydWN0aW9ucyIsImFkZGl0aW9uYWxJbnN0cnVjdGlvbnMiLCJnZW5lcmF0aW9uUmVzdWx0IiwiaW1hZ2VQcm9tcHQiLCJzdWNjZXNzIiwiaGFzSW1hZ2VVcmwiLCJpbWFnZVVybCIsImltYWdlVXJsTGVuZ3RoIiwibGVuZ3RoIiwiaW1hZ2VVcmxQcmV2aWV3Iiwic3Vic3RyaW5nIiwic3RvcmVDaGF0TWVzc2FnZSIsInJvbGUiLCJjb250ZW50Iiwib3BlcmF0aW9uIiwidHlwZSIsImRldGFpbHMiLCJpbWFnZURhdGEiLCJwcm9tcHQiLCJyZXNldCIsImNyZWF0ZUltYWdlblByb21wdCIsImNvbnN0cnVjdG9yIiwiaWQiLCJuYW1lIiwiZGVzY3JpcHRpb24iLCJpY29uIiwidG9vbHMiLCJjb21tYW5kIiwicGFyYW1ldGVycyIsImxvZ29HZW5lcmF0b3JBZ2VudCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./store/agents/logoGeneratorAgent.ts\n"));

/***/ })

});