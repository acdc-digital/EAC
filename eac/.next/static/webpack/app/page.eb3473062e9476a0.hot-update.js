"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./store/editor/index.ts":
/*!*******************************!*\
  !*** ./store/editor/index.ts ***!
  \*******************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useEditorStore: () => (/* binding */ useEditorStore)\n/* harmony export */ });\n/* harmony import */ var _barrel_optimize_names_AtSign_Braces_Calendar_Camera_FileCode_FileSpreadsheet_FileText_FileType_MessageSquare_lucide_react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! __barrel_optimize__?names=AtSign,Braces,Calendar,Camera,FileCode,FileSpreadsheet,FileText,FileType,MessageSquare!=!lucide-react */ \"(app-pages-browser)/../node_modules/.pnpm/lucide-react@0.525.0_react@18.3.1/node_modules/lucide-react/dist/esm/icons/file-code.js\");\n/* harmony import */ var _barrel_optimize_names_AtSign_Braces_Calendar_Camera_FileCode_FileSpreadsheet_FileText_FileType_MessageSquare_lucide_react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! __barrel_optimize__?names=AtSign,Braces,Calendar,Camera,FileCode,FileSpreadsheet,FileText,FileType,MessageSquare!=!lucide-react */ \"(app-pages-browser)/../node_modules/.pnpm/lucide-react@0.525.0_react@18.3.1/node_modules/lucide-react/dist/esm/icons/braces.js\");\n/* harmony import */ var _barrel_optimize_names_AtSign_Braces_Calendar_Camera_FileCode_FileSpreadsheet_FileText_FileType_MessageSquare_lucide_react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! __barrel_optimize__?names=AtSign,Braces,Calendar,Camera,FileCode,FileSpreadsheet,FileText,FileType,MessageSquare!=!lucide-react */ \"(app-pages-browser)/../node_modules/.pnpm/lucide-react@0.525.0_react@18.3.1/node_modules/lucide-react/dist/esm/icons/file-spreadsheet.js\");\n/* harmony import */ var _barrel_optimize_names_AtSign_Braces_Calendar_Camera_FileCode_FileSpreadsheet_FileText_FileType_MessageSquare_lucide_react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! __barrel_optimize__?names=AtSign,Braces,Calendar,Camera,FileCode,FileSpreadsheet,FileText,FileType,MessageSquare!=!lucide-react */ \"(app-pages-browser)/../node_modules/.pnpm/lucide-react@0.525.0_react@18.3.1/node_modules/lucide-react/dist/esm/icons/file-text.js\");\n/* harmony import */ var _barrel_optimize_names_AtSign_Braces_Calendar_Camera_FileCode_FileSpreadsheet_FileText_FileType_MessageSquare_lucide_react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! __barrel_optimize__?names=AtSign,Braces,Calendar,Camera,FileCode,FileSpreadsheet,FileText,FileType,MessageSquare!=!lucide-react */ \"(app-pages-browser)/../node_modules/.pnpm/lucide-react@0.525.0_react@18.3.1/node_modules/lucide-react/dist/esm/icons/file-type.js\");\n/* harmony import */ var _barrel_optimize_names_AtSign_Braces_Calendar_Camera_FileCode_FileSpreadsheet_FileText_FileType_MessageSquare_lucide_react__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! __barrel_optimize__?names=AtSign,Braces,Calendar,Camera,FileCode,FileSpreadsheet,FileText,FileType,MessageSquare!=!lucide-react */ \"(app-pages-browser)/../node_modules/.pnpm/lucide-react@0.525.0_react@18.3.1/node_modules/lucide-react/dist/esm/icons/message-square.js\");\n/* harmony import */ var _barrel_optimize_names_AtSign_Braces_Calendar_Camera_FileCode_FileSpreadsheet_FileText_FileType_MessageSquare_lucide_react__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! __barrel_optimize__?names=AtSign,Braces,Calendar,Camera,FileCode,FileSpreadsheet,FileText,FileType,MessageSquare!=!lucide-react */ \"(app-pages-browser)/../node_modules/.pnpm/lucide-react@0.525.0_react@18.3.1/node_modules/lucide-react/dist/esm/icons/camera.js\");\n/* harmony import */ var _barrel_optimize_names_AtSign_Braces_Calendar_Camera_FileCode_FileSpreadsheet_FileText_FileType_MessageSquare_lucide_react__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! __barrel_optimize__?names=AtSign,Braces,Calendar,Camera,FileCode,FileSpreadsheet,FileText,FileType,MessageSquare!=!lucide-react */ \"(app-pages-browser)/../node_modules/.pnpm/lucide-react@0.525.0_react@18.3.1/node_modules/lucide-react/dist/esm/icons/at-sign.js\");\n/* harmony import */ var _barrel_optimize_names_AtSign_Braces_Calendar_Camera_FileCode_FileSpreadsheet_FileText_FileType_MessageSquare_lucide_react__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! __barrel_optimize__?names=AtSign,Braces,Calendar,Camera,FileCode,FileSpreadsheet,FileText,FileType,MessageSquare!=!lucide-react */ \"(app-pages-browser)/../node_modules/.pnpm/lucide-react@0.525.0_react@18.3.1/node_modules/lucide-react/dist/esm/icons/calendar.js\");\n/* harmony import */ var zustand__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! zustand */ \"(app-pages-browser)/../node_modules/.pnpm/zustand@5.0.6_@types+react@19.1.9_react@18.3.1_use-sync-external-store@1.5.0_react@18.3.1_/node_modules/zustand/esm/react.mjs\");\n/* harmony import */ var zustand_middleware__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! zustand/middleware */ \"(app-pages-browser)/../node_modules/.pnpm/zustand@5.0.6_@types+react@19.1.9_react@18.3.1_use-sync-external-store@1.5.0_react@18.3.1_/node_modules/zustand/esm/middleware.mjs\");\n// Editor Store\n// /Users/matthewsimon/Projects/EAC/eac/store/editor/index.ts\n\n\n\n// Helper function to get icon based on file type\nconst getFileIcon = (type)=>{\n    switch(type){\n        case 'typescript':\n            return _barrel_optimize_names_AtSign_Braces_Calendar_Camera_FileCode_FileSpreadsheet_FileText_FileType_MessageSquare_lucide_react__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\n        case 'javascript':\n            return _barrel_optimize_names_AtSign_Braces_Calendar_Camera_FileCode_FileSpreadsheet_FileText_FileType_MessageSquare_lucide_react__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\n        case 'json':\n            return _barrel_optimize_names_AtSign_Braces_Calendar_Camera_FileCode_FileSpreadsheet_FileText_FileType_MessageSquare_lucide_react__WEBPACK_IMPORTED_MODULE_1__[\"default\"];\n        case 'excel':\n            return _barrel_optimize_names_AtSign_Braces_Calendar_Camera_FileCode_FileSpreadsheet_FileText_FileType_MessageSquare_lucide_react__WEBPACK_IMPORTED_MODULE_2__[\"default\"];\n        case 'markdown':\n            return _barrel_optimize_names_AtSign_Braces_Calendar_Camera_FileCode_FileSpreadsheet_FileText_FileType_MessageSquare_lucide_react__WEBPACK_IMPORTED_MODULE_3__[\"default\"];\n        case 'pdf':\n            return _barrel_optimize_names_AtSign_Braces_Calendar_Camera_FileCode_FileSpreadsheet_FileText_FileType_MessageSquare_lucide_react__WEBPACK_IMPORTED_MODULE_4__[\"default\"];\n        case 'generals':\n            return _barrel_optimize_names_AtSign_Braces_Calendar_Camera_FileCode_FileSpreadsheet_FileText_FileType_MessageSquare_lucide_react__WEBPACK_IMPORTED_MODULE_3__[\"default\"];\n        case 'percent-complete':\n            return _barrel_optimize_names_AtSign_Braces_Calendar_Camera_FileCode_FileSpreadsheet_FileText_FileType_MessageSquare_lucide_react__WEBPACK_IMPORTED_MODULE_2__[\"default\"];\n        case 'schedule':\n            return _barrel_optimize_names_AtSign_Braces_Calendar_Camera_FileCode_FileSpreadsheet_FileText_FileType_MessageSquare_lucide_react__WEBPACK_IMPORTED_MODULE_2__[\"default\"];\n        case 'materials':\n            return _barrel_optimize_names_AtSign_Braces_Calendar_Camera_FileCode_FileSpreadsheet_FileText_FileType_MessageSquare_lucide_react__WEBPACK_IMPORTED_MODULE_2__[\"default\"];\n        case 'facebook':\n            return _barrel_optimize_names_AtSign_Braces_Calendar_Camera_FileCode_FileSpreadsheet_FileText_FileType_MessageSquare_lucide_react__WEBPACK_IMPORTED_MODULE_5__[\"default\"];\n        case 'reddit':\n            return 'r/'; // Changed from Hash to r/ text\n        case 'instagram':\n            return _barrel_optimize_names_AtSign_Braces_Calendar_Camera_FileCode_FileSpreadsheet_FileText_FileType_MessageSquare_lucide_react__WEBPACK_IMPORTED_MODULE_6__[\"default\"];\n        case 'x':\n            return _barrel_optimize_names_AtSign_Braces_Calendar_Camera_FileCode_FileSpreadsheet_FileText_FileType_MessageSquare_lucide_react__WEBPACK_IMPORTED_MODULE_7__[\"default\"];\n        case 'calendar':\n            return _barrel_optimize_names_AtSign_Braces_Calendar_Camera_FileCode_FileSpreadsheet_FileText_FileType_MessageSquare_lucide_react__WEBPACK_IMPORTED_MODULE_8__[\"default\"];\n        default:\n            return _barrel_optimize_names_AtSign_Braces_Calendar_Camera_FileCode_FileSpreadsheet_FileText_FileType_MessageSquare_lucide_react__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\n    }\n};\n// Helper function to get file extension\n// Helper function to get file extension\nconst getFileExtension = (type)=>{\n    switch(type){\n        case 'typescript':\n            return '.ts';\n        case 'javascript':\n            return '.js';\n        case 'json':\n            return '.json';\n        case 'excel':\n            return '.xlsx';\n        case 'pdf':\n            return '.pdf';\n        case 'generals':\n            return '.generals';\n        case 'percent-complete':\n            return '.percent';\n        case 'schedule':\n            return '.schedule';\n        case 'materials':\n            return '.materials';\n        case 'facebook':\n            return '.facebook';\n        case 'reddit':\n            return '.reddit';\n        case 'instagram':\n            return '.instagram';\n        case 'x':\n            return '.x';\n        case 'markdown':\n            return '.md';\n        default:\n            return '.txt';\n    }\n};\n// Helper function to generate default content for new files\nconst getDefaultContent = (type, name)=>{\n    switch(type){\n        case 'typescript':\n            return \"// \".concat(name, \"\\n// Auto-generated TypeScript file\\n\\nimport React from 'react';\\n\\ninterface \").concat(name.replace(/[^a-zA-Z0-9]/g, ''), \"Props {\\n  // Define props here\\n}\\n\\nexport function \").concat(name.replace(/[^a-zA-Z0-9]/g, ''), \"({ }: \").concat(name.replace(/[^a-zA-Z0-9]/g, ''), 'Props) {\\n  return (\\n    <div className=\"p-4\">\\n      <h1 className=\"text-xl font-bold\">New Component: ').concat(name, '</h1>\\n      <p className=\"text-gray-600\">Start building your component here...</p>\\n    </div>\\n  );\\n}');\n        case 'javascript':\n            return \"// \".concat(name, \"\\n// Auto-generated JavaScript file\\n\\nexport function \").concat(name.replace(/[^a-zA-Z0-9]/g, ''), \"() {\\n  return {\\n    message: 'Hello from \").concat(name, \"!',\\n    data: []\\n  };\\n}\");\n        case 'json':\n            return '{\\n  \"name\": \"'.concat(name, '\",\\n  \"description\": \"Auto-generated JSON file\",\\n  \"version\": \"1.0.0\",\\n  \"data\": {}\\n}');\n        case 'markdown':\n            return \"Start writing your content here...\";\n        case 'generals':\n            return \"// \".concat(name, \" - Project General Information\\n// This file contains general project details and financial information\\n// Created on: \").concat(new Date().toISOString(), \"\\n\\nProject: \").concat(name, \"\\nStatus: Active\\nCreated: \").concat(new Date().toLocaleDateString(), \"\\n\\n// This file will display the project generals module interface\");\n        case 'percent-complete':\n            return \"// \".concat(name, \" - Percent Complete Tracker\\n// This file contains project completion tracking data\\n// Created on: \").concat(new Date().toISOString(), \"\\n\\nProject: \").concat(name, \"\\nType: Percent Complete Tracker\\nCreated: \").concat(new Date().toLocaleDateString(), \"\\n\\n// This file will display the percent complete tracking interface\");\n        case 'schedule':\n            return \"// \".concat(name, \" - Project Schedule\\n// This file contains project schedule and timeline data\\n// Created on: \").concat(new Date().toISOString(), \"\\n\\nProject: \").concat(name, \"\\nType: Project Schedule\\nCreated: \").concat(new Date().toLocaleDateString(), \"\\n\\n// This file will display the project schedule interface with Gantt chart\");\n        case 'materials':\n            return \"// \".concat(name, \" - Materials Management\\n// This file contains materials tracking and management data\\n// Created on: \").concat(new Date().toISOString(), \"\\n\\nProject: \").concat(name, \"\\nType: Materials Management\\nCreated: \").concat(new Date().toLocaleDateString(), \"\\n\\n// This file will display the materials management interface with manufactured and miscellaneous materials\");\n        case 'facebook':\n            return \"# \".concat(name, \" - Facebook Post\\nPlatform: Facebook\\nCreated: \").concat(new Date().toLocaleDateString(), \"\\n\\n## Post Content\\nWrite your Facebook post content here...\\n\\n## Settings\\n- Audience: Public\\n- Schedule: Now\\n- Hashtags: #example\\n\\n## Media\\n- Images: []\\n- Videos: []\\n\\n## Analytics\\n- Engagement: 0\\n- Reach: 0\\n- Clicks: 0\");\n        case 'reddit':\n            return \"# \".concat(name, \" - Reddit Post\\nPlatform: Reddit\\nCreated: \").concat(new Date().toLocaleDateString(), \"\\n\\n## Post Content\\nWrite your Reddit post content here...\\n\\n## Settings\\n- Subreddit: r/example\\n- Post Type: Text/Link/Image\\n- Flair: Discussion\\n- NSFW: No\\n\\n## Media\\n- Images: []\\n- Links: []\\n\\n## Analytics\\n- Upvotes: 0\\n- Comments: 0\\n- Awards: 0\");\n        case 'instagram':\n            return \"# \".concat(name, \" - Instagram Post\\nPlatform: Instagram\\nCreated: \").concat(new Date().toLocaleDateString(), \"\\n\\n## Post Content\\nWrite your Instagram post content here...\\n\\n## Settings\\n- Post Type: Feed/Story/Reel\\n- Location: City, Country\\n- Alt Text: Describe image\\n- Comment Settings: Public\\n\\n## Media\\n- Images: []\\n- Videos: []\\n\\n## Hashtags\\n#hashtag1 #hashtag2 #hashtag3\\n\\n## Analytics\\n- Likes: 0\\n- Comments: 0\\n- Shares: 0\\n- Reach: 0\");\n        case 'x':\n            return \"# \".concat(name, \" - X/Twitter Post\\nPlatform: X (Twitter)\\nCreated: \").concat(new Date().toLocaleDateString(), \"\\n\\n## Post Content\\nWrite your X post content here... (280 character limit)\\n\\n## Settings\\n- Reply Settings: Everyone\\n- Schedule: Now\\n- Thread: Single Tweet\\n\\n## Media\\n- Images: []\\n- Videos: []\\n- GIFs: []\\n\\n## Analytics\\n- Impressions: 0\\n- Engagements: 0\\n- Retweets: 0\\n- Likes: 0\\n- Replies: 0\");\n        default:\n            return \"# \".concat(name, \"\\n\\nThis is a new file created in the EAC Dashboard.\\nCreated on: \").concat(new Date().toISOString());\n    }\n};\n// Initial project files - empty by default, only created when needed\nconst initialProjectFiles = [];\n// Initial financial files - empty by default, only created when needed  \nconst initialFinancialFiles = [];\n// Initial project folders - only created when explicitly needed, not on storage clear\nconst initialProjectFolders = [];\nconst useEditorStore = (0,zustand__WEBPACK_IMPORTED_MODULE_9__.create)()((0,zustand_middleware__WEBPACK_IMPORTED_MODULE_10__.devtools)((0,zustand_middleware__WEBPACK_IMPORTED_MODULE_10__.persist)((set, get)=>({\n        // Initial state\n        openTabs: [],\n        activeTab: '',\n        projectFiles: initialProjectFiles,\n        financialFiles: initialFinancialFiles,\n        projectFolders: initialProjectFolders,\n        financialFolders: [],\n        trashItems: [],\n        showProjectsCategory: true,\n        showFinancialCategory: false,\n        isLoading: false,\n        error: null,\n        // Actions\n        openTab: (file)=>{\n            const { openTabs } = get();\n            // Check if tab is already open\n            const existingTab = openTabs.find((tab)=>tab.id === file.id);\n            if (existingTab) {\n                set({\n                    activeTab: existingTab.id\n                });\n                return;\n            }\n            // Define which file types should be auto-pinned\n            // You can add more file types here if needed\n            const autoPinFileTypes = [\n                'calendar',\n                'social-connect',\n                'user-profile',\n                'post-creator'\n            ];\n            const shouldAutoPinn = autoPinFileTypes.includes(file.type);\n            let pinnedOrder;\n            if (shouldAutoPinn) {\n                // Get the highest pinned order for auto-pinned tabs\n                const pinnedTabs = openTabs.filter((t)=>t.pinned);\n                pinnedOrder = pinnedTabs.length > 0 ? Math.max(...pinnedTabs.map((t)=>t.pinnedOrder || 0)) + 1 : 1;\n            }\n            // Create new tab with content\n            const newTab = {\n                id: file.id,\n                name: file.name,\n                modified: false,\n                content: file.content || getDefaultContent(file.type, file.name),\n                filePath: file.filePath,\n                type: file.type,\n                pinned: shouldAutoPinn,\n                pinnedOrder: shouldAutoPinn ? pinnedOrder : undefined\n            };\n            let newTabs;\n            if (shouldAutoPinn) {\n                // For auto-pinned tabs, insert in correct pinned position\n                const otherTabs = [\n                    ...openTabs\n                ];\n                const insertIndex = otherTabs.filter((t)=>t.pinned && (t.pinnedOrder || 0) < (pinnedOrder || 0)).length;\n                otherTabs.splice(insertIndex, 0, newTab);\n                newTabs = otherTabs;\n            } else {\n                // For non-auto-pinned tabs, insert after all pinned tabs\n                const pinnedTabs = openTabs.filter((tab)=>tab.pinned);\n                const unpinnedTabs = openTabs.filter((tab)=>!tab.pinned);\n                newTabs = [\n                    ...pinnedTabs,\n                    ...unpinnedTabs,\n                    newTab\n                ];\n            }\n            set({\n                openTabs: newTabs,\n                activeTab: newTab.id\n            });\n        },\n        openSpecialTab: (id, name, type)=>{\n            const { openTabs } = get();\n            // Check if tab is already open\n            const existingTab = openTabs.find((tab)=>tab.id === id);\n            if (existingTab) {\n                set({\n                    activeTab: existingTab.id\n                });\n                return;\n            }\n            // Define which tab types should be auto-pinned\n            const autoPinTypes = [\n                'user-profile',\n                'calendar',\n                'social-connect',\n                'post-creator'\n            ];\n            const shouldAutoPinn = autoPinTypes.includes(type);\n            let pinnedOrder;\n            if (shouldAutoPinn) {\n                // Get the highest pinned order for auto-pinned tabs\n                const pinnedTabs = openTabs.filter((t)=>t.pinned);\n                pinnedOrder = pinnedTabs.length > 0 ? Math.max(...pinnedTabs.map((t)=>t.pinnedOrder || 0)) + 1 : 1;\n            }\n            // Create new special tab\n            const newTab = {\n                id,\n                name,\n                modified: false,\n                content: '',\n                filePath: \"/\".concat(type),\n                type,\n                pinned: shouldAutoPinn,\n                pinnedOrder: shouldAutoPinn ? pinnedOrder : undefined\n            };\n            let newTabs;\n            if (shouldAutoPinn) {\n                // For auto-pinned tabs, insert in correct pinned position\n                const otherTabs = [\n                    ...openTabs\n                ];\n                const insertIndex = otherTabs.filter((t)=>t.pinned && (t.pinnedOrder || 0) < (pinnedOrder || 0)).length;\n                otherTabs.splice(insertIndex, 0, newTab);\n                newTabs = otherTabs;\n            } else {\n                // For non-auto-pinned tabs, insert after all pinned tabs\n                const pinnedTabs = openTabs.filter((tab)=>tab.pinned);\n                const unpinnedTabs = openTabs.filter((tab)=>!tab.pinned);\n                newTabs = [\n                    ...pinnedTabs,\n                    ...unpinnedTabs,\n                    newTab\n                ];\n            }\n            set({\n                openTabs: newTabs,\n                activeTab: newTab.id\n            });\n        },\n        closeTab: (tabId)=>{\n            const { openTabs, activeTab } = get();\n            const tabIndex = openTabs.findIndex((tab)=>tab.id === tabId);\n            if (tabIndex === -1) return;\n            const newTabs = openTabs.filter((tab)=>tab.id !== tabId);\n            let newActiveTab = activeTab;\n            // If closing the active tab, switch to another tab\n            if (activeTab === tabId) {\n                if (newTabs.length > 0) {\n                    // Switch to the tab to the right, or the last tab if closing the last one\n                    const nextIndex = tabIndex < newTabs.length ? tabIndex : newTabs.length - 1;\n                    newActiveTab = newTabs[nextIndex].id;\n                } else {\n                    newActiveTab = '';\n                }\n            }\n            set({\n                openTabs: newTabs,\n                activeTab: newActiveTab\n            });\n        },\n        closeAllTabs: ()=>{\n            set({\n                openTabs: [],\n                activeTab: ''\n            });\n        },\n        setActiveTab: (tabId)=>{\n            const { openTabs } = get();\n            const tabExists = openTabs.some((tab)=>tab.id === tabId);\n            if (tabExists) {\n                set({\n                    activeTab: tabId\n                });\n            }\n        },\n        reorderTabs: (fromTabId, toTabId)=>{\n            const { openTabs } = get();\n            const fromIndex = openTabs.findIndex((tab)=>tab.id === fromTabId);\n            const toIndex = openTabs.findIndex((tab)=>tab.id === toTabId);\n            if (fromIndex !== -1 && toIndex !== -1 && fromIndex !== toIndex) {\n                const newTabs = [\n                    ...openTabs\n                ];\n                const [movedTab] = newTabs.splice(fromIndex, 1);\n                newTabs.splice(toIndex, 0, movedTab);\n                set({\n                    openTabs: newTabs\n                });\n            }\n        },\n        pinTab: (tabId)=>{\n            const { openTabs } = get();\n            const tabIndex = openTabs.findIndex((tab)=>tab.id === tabId);\n            if (tabIndex !== -1) {\n                const tab = openTabs[tabIndex];\n                // Don't pin if already pinned\n                if (tab.pinned) return;\n                // Get the highest pinned order\n                const pinnedTabs = openTabs.filter((t)=>t.pinned);\n                const nextPinnedOrder = pinnedTabs.length > 0 ? Math.max(...pinnedTabs.map((t)=>t.pinnedOrder || 0)) + 1 : 1;\n                // Update the tab to be pinned\n                const updatedTab = {\n                    ...tab,\n                    pinned: true,\n                    pinnedOrder: nextPinnedOrder\n                };\n                // Remove tab from current position and add to correct pinned position\n                const newTabs = [\n                    ...openTabs\n                ];\n                newTabs.splice(tabIndex, 1);\n                // Find the correct position among pinned tabs\n                const insertIndex = newTabs.filter((t)=>t.pinned && (t.pinnedOrder || 0) < nextPinnedOrder).length;\n                newTabs.splice(insertIndex, 0, updatedTab);\n                set({\n                    openTabs: newTabs\n                });\n            }\n        },\n        unpinTab: (tabId)=>{\n            const { openTabs } = get();\n            const tabIndex = openTabs.findIndex((tab)=>tab.id === tabId);\n            if (tabIndex !== -1) {\n                const tab = openTabs[tabIndex];\n                // Don't unpin if not pinned\n                if (!tab.pinned) return;\n                // Update the tab to be unpinned\n                const updatedTab = {\n                    ...tab,\n                    pinned: false,\n                    pinnedOrder: undefined\n                };\n                // Remove tab from current position\n                const newTabs = [\n                    ...openTabs\n                ];\n                newTabs.splice(tabIndex, 1);\n                // Find the position after all pinned tabs\n                const pinnedCount = newTabs.filter((t)=>t.pinned).length;\n                newTabs.splice(pinnedCount, 0, updatedTab);\n                set({\n                    openTabs: newTabs\n                });\n            }\n        },\n        updateTabContent: (tabId, content)=>{\n            const { openTabs } = get();\n            const updatedTabs = openTabs.map((tab)=>tab.id === tabId ? {\n                    ...tab,\n                    content,\n                    modified: true\n                } : tab);\n            set({\n                openTabs: updatedTabs\n            });\n        },\n        updateFileContent: (tabId, content)=>{\n            const { openTabs } = get();\n            const updatedTabs = openTabs.map((tab)=>tab.id === tabId ? {\n                    ...tab,\n                    content,\n                    modified: true\n                } : tab);\n            set({\n                openTabs: updatedTabs\n            });\n        },\n        updateFileContentInStore: (fileId, content)=>{\n            const { projectFiles, financialFiles, openTabs } = get();\n            // Update the file in the appropriate store\n            const updatedProjectFiles = projectFiles.map((file)=>file.id === fileId ? {\n                    ...file,\n                    content,\n                    modifiedAt: new Date()\n                } : file);\n            const updatedFinancialFiles = financialFiles.map((file)=>file.id === fileId ? {\n                    ...file,\n                    content,\n                    modifiedAt: new Date()\n                } : file);\n            // Also update the tab if it's open\n            const updatedTabs = openTabs.map((tab)=>tab.id === fileId ? {\n                    ...tab,\n                    content,\n                    modified: true\n                } : tab);\n            set({\n                projectFiles: updatedProjectFiles,\n                financialFiles: updatedFinancialFiles,\n                openTabs: updatedTabs\n            });\n        },\n        updateFileStatus: (fileId, status)=>{\n            const { projectFiles, financialFiles } = get();\n            // Update in project files\n            const updatedProjectFiles = projectFiles.map((file)=>file.id === fileId ? {\n                    ...file,\n                    status,\n                    modifiedAt: new Date()\n                } : file);\n            // Update in financial files\n            const updatedFinancialFiles = financialFiles.map((file)=>file.id === fileId ? {\n                    ...file,\n                    status,\n                    modifiedAt: new Date()\n                } : file);\n            set({\n                projectFiles: updatedProjectFiles,\n                financialFiles: updatedFinancialFiles\n            });\n        },\n        createNewFile: function(name, type) {\n            let category = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 'project', folderId = arguments.length > 3 ? arguments[3] : void 0, customContent = arguments.length > 4 ? arguments[4] : void 0;\n            const { projectFiles, financialFiles } = get();\n            // Generate unique ID\n            const id = \"\".concat(name.toLowerCase().replace(/[^a-z0-9]/g, '-'), \"-\").concat(Date.now());\n            const fileName = \"\".concat(name).concat(getFileExtension(type));\n            const basePath = category === 'financial' ? '/financial-data' : '/eac-projects';\n            // Use custom content if provided, otherwise use default\n            const fileContent = customContent || getDefaultContent(type, name);\n            // Create new file\n            const newFile = {\n                id,\n                name: fileName,\n                icon: getFileIcon(type),\n                type,\n                category,\n                content: fileContent,\n                filePath: \"\".concat(basePath, \"/\").concat(fileName),\n                createdAt: new Date(),\n                modifiedAt: new Date(),\n                folderId,\n                status: [\n                    'facebook',\n                    'reddit',\n                    'instagram',\n                    'x'\n                ].includes(type) ? 'draft' : undefined\n            };\n            // Add to appropriate file array and ensure category is visible\n            if (category === 'financial') {\n                set({\n                    financialFiles: [\n                        ...financialFiles,\n                        newFile\n                    ],\n                    showFinancialCategory: true\n                });\n            } else {\n                set({\n                    projectFiles: [\n                        ...projectFiles,\n                        newFile\n                    ],\n                    showProjectsCategory: true\n                });\n            }\n            // Automatically open the new file\n            get().openTab(newFile);\n            // Save to Convex database (async - don't block UI)\n            try {\n                // We need to import the Convex hooks here, which isn't ideal\n                // Better to handle this in the component level\n                console.log('File created locally:', newFile);\n                // Dispatch custom event that components can listen to\n                if (true) {\n                    window.dispatchEvent(new CustomEvent('fileCreated', {\n                        detail: {\n                            file: newFile,\n                            projectId: folderId // Using folderId as projectId for now\n                        }\n                    }));\n                }\n            } catch (error) {\n                console.error('Failed to save file to database:', error);\n            }\n            // Return the file ID so caller can reference it\n            return id;\n        },\n        createFolder: (name, category, convexId)=>{\n            const { projectFolders, financialFolders } = get();\n            // Check if folder with this name already exists to prevent duplicates\n            const existingFolders = category === 'financial' ? financialFolders : projectFolders;\n            const folderExists = existingFolders.some((folder)=>folder.name.toLowerCase() === name.toLowerCase());\n            if (folderExists) {\n                console.log('Folder \"'.concat(name, '\" already exists in ').concat(category, \" category, skipping creation\"));\n                return;\n            }\n            // Generate truly unique ID using crypto if available, otherwise fallback to timestamp + random\n            let uniqueId;\n            if (typeof crypto !== 'undefined' && crypto.randomUUID) {\n                uniqueId = \"folder-\".concat(name.toLowerCase().replace(/[^a-z0-9]/g, '-'), \"-\").concat(crypto.randomUUID());\n            } else {\n                // Fallback for environments without crypto.randomUUID\n                const timestamp = Date.now();\n                const random = Math.random().toString(36).substring(2, 12);\n                const counter = Math.floor(Math.random() * 10000);\n                uniqueId = \"folder-\".concat(name.toLowerCase().replace(/[^a-z0-9]/g, '-'), \"-\").concat(timestamp, \"-\").concat(random, \"-\").concat(counter);\n            }\n            // Double-check uniqueness against all existing folder IDs\n            const allFolders = [\n                ...projectFolders,\n                ...financialFolders\n            ];\n            while(allFolders.some((folder)=>folder.id === uniqueId)){\n                const randomSuffix = Math.random().toString(36).substring(2, 8);\n                uniqueId = \"\".concat(uniqueId, \"-\").concat(randomSuffix);\n            }\n            // Create new folder\n            const newFolder = {\n                id: uniqueId,\n                name,\n                category,\n                createdAt: new Date(),\n                convexId\n            };\n            // Add to appropriate folder array and ensure category is visible\n            if (category === 'financial') {\n                set({\n                    financialFolders: [\n                        newFolder,\n                        ...financialFolders\n                    ],\n                    showFinancialCategory: true\n                });\n            } else {\n                set({\n                    projectFolders: [\n                        newFolder,\n                        ...projectFolders\n                    ],\n                    showProjectsCategory: true\n                });\n            }\n        },\n        // Emergency cleanup function for duplicate folder IDs\n        cleanupDuplicateFolders: ()=>{\n            const { projectFolders, financialFolders } = get();\n            // Function to remove duplicates and fix bad IDs\n            const cleanupFolders = (folders)=>{\n                const seen = new Set();\n                const cleaned = folders.filter((folder)=>{\n                    // Remove folders with the problematic key pattern\n                    if (folder.id.includes('folder-index-1753064508939')) {\n                        console.log(\"\\uD83E\\uDDF9 Removing problematic folder: \".concat(folder.id, \" (\").concat(folder.name, \")\"));\n                        return false;\n                    }\n                    // Remove duplicate IDs\n                    if (seen.has(folder.id)) {\n                        console.log(\"\\uD83E\\uDDF9 Removing duplicate folder: \".concat(folder.id, \" (\").concat(folder.name, \")\"));\n                        return false;\n                    }\n                    seen.add(folder.id);\n                    return true;\n                });\n                // Regenerate IDs for any remaining folders with old patterns\n                return cleaned.map((folder)=>{\n                    if (folder.id.startsWith('folder-index-') || folder.id.length < 20) {\n                        const newId = typeof crypto !== 'undefined' && crypto.randomUUID ? \"folder-\".concat(folder.name.toLowerCase().replace(/[^a-z0-9]/g, '-'), \"-\").concat(crypto.randomUUID()) : \"folder-\".concat(folder.name.toLowerCase().replace(/[^a-z0-9]/g, '-'), \"-\").concat(Date.now(), \"-\").concat(Math.random().toString(36).substring(2, 12));\n                        console.log(\"\\uD83D\\uDD04 Regenerating ID for folder: \".concat(folder.id, \" â†’ \").concat(newId, \" (\").concat(folder.name, \")\"));\n                        return {\n                            ...folder,\n                            id: newId\n                        };\n                    }\n                    return folder;\n                });\n            };\n            const cleanedProjectFolders = cleanupFolders(projectFolders);\n            const cleanedFinancialFolders = cleanupFolders(financialFolders);\n            if (cleanedProjectFolders.length !== projectFolders.length || cleanedFinancialFolders.length !== financialFolders.length) {\n                console.log('ðŸ§¹ Cleanup completed, updating store...');\n                set({\n                    projectFolders: cleanedProjectFolders,\n                    financialFolders: cleanedFinancialFolders\n                });\n            }\n        },\n        deleteFile: (fileId)=>{\n            const { projectFiles, financialFiles, openTabs } = get();\n            // Find and remove from appropriate array\n            const updatedProjectFiles = projectFiles.filter((file)=>file.id !== fileId);\n            const updatedFinancialFiles = financialFiles.filter((file)=>file.id !== fileId);\n            // Close tab if it's open\n            const tabToClose = openTabs.find((tab)=>tab.id === fileId);\n            if (tabToClose) {\n                get().closeTab(fileId);\n            }\n            set({\n                projectFiles: updatedProjectFiles,\n                financialFiles: updatedFinancialFiles\n            });\n        },\n        renameFile: (fileId, newName)=>{\n            const { projectFiles, financialFiles, openTabs } = get();\n            // Find the file to get its type and generate new filename with extension\n            const projectFile = projectFiles.find((file)=>file.id === fileId);\n            const financialFile = financialFiles.find((file)=>file.id === fileId);\n            const file = projectFile || financialFile;\n            if (!file) return;\n            // Generate new filename with appropriate extension\n            const newFileName = \"\".concat(newName).concat(getFileExtension(file.type));\n            const basePath = file.category === 'financial' ? '/financial-data' : '/eac-projects';\n            const newFilePath = \"\".concat(basePath, \"/\").concat(newFileName);\n            // Update the file in appropriate array\n            const updatedProjectFiles = projectFiles.map((f)=>f.id === fileId ? {\n                    ...f,\n                    name: newFileName,\n                    filePath: newFilePath,\n                    modifiedAt: new Date()\n                } : f);\n            const updatedFinancialFiles = financialFiles.map((f)=>f.id === fileId ? {\n                    ...f,\n                    name: newFileName,\n                    filePath: newFilePath,\n                    modifiedAt: new Date()\n                } : f);\n            // Update open tabs if the file is open\n            const updatedTabs = openTabs.map((tab)=>tab.id === fileId ? {\n                    ...tab,\n                    name: newFileName,\n                    filePath: newFilePath,\n                    modified: true\n                } : tab);\n            set({\n                projectFiles: updatedProjectFiles,\n                financialFiles: updatedFinancialFiles,\n                openTabs: updatedTabs\n            });\n        },\n        renameFolder: (folderId, newName)=>{\n            const { projectFolders, financialFolders } = get();\n            // Update the folder in appropriate array\n            const updatedProjectFolders = projectFolders.map((folder)=>folder.id === folderId ? {\n                    ...folder,\n                    name: newName\n                } : folder);\n            const updatedFinancialFolders = financialFolders.map((folder)=>folder.id === folderId ? {\n                    ...folder,\n                    name: newName\n                } : folder);\n            set({\n                projectFolders: updatedProjectFolders,\n                financialFolders: updatedFinancialFolders\n            });\n        },\n        deleteFolder: (folderId)=>{\n            const { projectFolders, financialFolders, projectFiles, financialFiles, openTabs } = get();\n            // Find all files that were in this folder\n            const filesToDelete = [\n                ...projectFiles.filter((file)=>file.folderId === folderId),\n                ...financialFiles.filter((file)=>file.folderId === folderId)\n            ];\n            // Close tabs for all files in this folder\n            filesToDelete.forEach((file)=>{\n                const tabToClose = openTabs.find((tab)=>tab.id === file.id);\n                if (tabToClose) {\n                    get().closeTab(file.id);\n                }\n            });\n            // Remove from appropriate folder array\n            const updatedProjectFolders = projectFolders.filter((folder)=>folder.id !== folderId);\n            const updatedFinancialFolders = financialFolders.filter((folder)=>folder.id !== folderId);\n            // Also remove any files that were in this folder\n            const updatedProjectFiles = projectFiles.filter((file)=>file.folderId !== folderId);\n            const updatedFinancialFiles = financialFiles.filter((file)=>file.folderId !== folderId);\n            set({\n                projectFolders: updatedProjectFolders,\n                financialFolders: updatedFinancialFolders,\n                projectFiles: updatedProjectFiles,\n                financialFiles: updatedFinancialFiles\n            });\n        },\n        moveToTrash: (item, type)=>{\n            const { trashItems, projectFiles, financialFiles, projectFolders, financialFolders, openTabs } = get();\n            // Create trash item\n            const trashItem = {\n                id: \"trash_\".concat(item.id, \"_\").concat(Date.now()),\n                name: item.name,\n                type,\n                originalData: item,\n                deletedAt: new Date(),\n                category: item.category\n            };\n            if (type === 'file') {\n                const file = item;\n                // Close tab if it's open\n                const tabToClose = openTabs.find((tab)=>tab.id === file.id);\n                if (tabToClose) {\n                    get().closeTab(file.id);\n                }\n                // Remove from appropriate file array\n                const updatedProjectFiles = projectFiles.filter((f)=>f.id !== file.id);\n                const updatedFinancialFiles = financialFiles.filter((f)=>f.id !== file.id);\n                set({\n                    trashItems: [\n                        ...trashItems,\n                        trashItem\n                    ],\n                    projectFiles: updatedProjectFiles,\n                    financialFiles: updatedFinancialFiles\n                });\n            } else {\n                const folder = item;\n                // Find all files that were in this folder and move them to trash too\n                const filesToTrash = [\n                    ...projectFiles.filter((file)=>file.folderId === folder.id),\n                    ...financialFiles.filter((file)=>file.folderId === folder.id)\n                ];\n                // Close tabs for all files in this folder\n                filesToTrash.forEach((file)=>{\n                    const tabToClose = openTabs.find((tab)=>tab.id === file.id);\n                    if (tabToClose) {\n                        get().closeTab(file.id);\n                    }\n                });\n                // Create trash items for all files in the folder\n                const fileTrashItems = filesToTrash.map((file)=>({\n                        id: \"trash_\".concat(file.id, \"_\").concat(Date.now()),\n                        name: file.name,\n                        type: 'file',\n                        originalData: file,\n                        deletedAt: new Date(),\n                        category: file.category\n                    }));\n                // Remove folder and its files from arrays\n                const updatedProjectFolders = projectFolders.filter((f)=>f.id !== folder.id);\n                const updatedFinancialFolders = financialFolders.filter((f)=>f.id !== folder.id);\n                const updatedProjectFiles = projectFiles.filter((file)=>file.folderId !== folder.id);\n                const updatedFinancialFiles = financialFiles.filter((file)=>file.folderId !== folder.id);\n                set({\n                    trashItems: [\n                        ...trashItems,\n                        trashItem,\n                        ...fileTrashItems\n                    ],\n                    projectFolders: updatedProjectFolders,\n                    financialFolders: updatedFinancialFolders,\n                    projectFiles: updatedProjectFiles,\n                    financialFiles: updatedFinancialFiles\n                });\n            }\n        },\n        restoreFromTrash: (trashItemId)=>{\n            const { trashItems, projectFiles, financialFiles, projectFolders, financialFolders } = get();\n            const trashItem = trashItems.find((item)=>item.id === trashItemId);\n            if (!trashItem) return;\n            // Remove from trash\n            const updatedTrashItems = trashItems.filter((item)=>item.id !== trashItemId);\n            // Restore to appropriate array\n            if (trashItem.type === 'file') {\n                const file = trashItem.originalData;\n                if (file.category === 'project') {\n                    set({\n                        trashItems: updatedTrashItems,\n                        projectFiles: [\n                            ...projectFiles,\n                            {\n                                ...file,\n                                modifiedAt: new Date()\n                            }\n                        ]\n                    });\n                } else {\n                    set({\n                        trashItems: updatedTrashItems,\n                        financialFiles: [\n                            ...financialFiles,\n                            {\n                                ...file,\n                                modifiedAt: new Date()\n                            }\n                        ]\n                    });\n                }\n            } else {\n                const folder = trashItem.originalData;\n                if (folder.category === 'project') {\n                    set({\n                        trashItems: updatedTrashItems,\n                        projectFolders: [\n                            ...projectFolders,\n                            folder\n                        ]\n                    });\n                } else {\n                    set({\n                        trashItems: updatedTrashItems,\n                        financialFolders: [\n                            ...financialFolders,\n                            folder\n                        ]\n                    });\n                }\n            }\n        },\n        permanentlyDelete: (trashItemId)=>{\n            const { trashItems } = get();\n            // Remove from trash permanently\n            const updatedTrashItems = trashItems.filter((item)=>item.id !== trashItemId);\n            set({\n                trashItems: updatedTrashItems\n            });\n        },\n        emptyTrash: ()=>{\n            set({\n                trashItems: []\n            });\n        },\n        clearProjectCategory: ()=>{\n            const { openTabs } = get();\n            // Close all project-related tabs\n            const projectTabIds = openTabs.filter((tab)=>{\n                // Find the corresponding file to check its category\n                const { projectFiles } = get();\n                const file = projectFiles.find((f)=>f.id === tab.id);\n                return (file === null || file === void 0 ? void 0 : file.category) === 'project';\n            }).map((tab)=>tab.id);\n            projectTabIds.forEach((tabId)=>get().closeTab(tabId));\n            // Clear all project files and folders\n            set({\n                projectFiles: [],\n                projectFolders: []\n            });\n        },\n        clearFinancialCategory: ()=>{\n            const { openTabs } = get();\n            // Close all financial-related tabs\n            const financialTabIds = openTabs.filter((tab)=>{\n                // Find the corresponding file to check its category\n                const { financialFiles } = get();\n                const file = financialFiles.find((f)=>f.id === tab.id);\n                return (file === null || file === void 0 ? void 0 : file.category) === 'financial';\n            }).map((tab)=>tab.id);\n            financialTabIds.forEach((tabId)=>get().closeTab(tabId));\n            // Clear all financial files and folders\n            set({\n                financialFiles: [],\n                financialFolders: []\n            });\n        },\n        deleteProjectsCategory: ()=>{\n            get().clearProjectCategory();\n            set({\n                showProjectsCategory: false\n            });\n        },\n        deleteFinancialCategory: ()=>{\n            get().clearFinancialCategory();\n            set({\n                showFinancialCategory: false\n            });\n        },\n        reorderProjectFolders: (fromIndex, toIndex)=>{\n            const { projectFolders } = get();\n            const newFolders = [\n                ...projectFolders\n            ];\n            const [movedFolder] = newFolders.splice(fromIndex, 1);\n            newFolders.splice(toIndex, 0, movedFolder);\n            set({\n                projectFolders: newFolders\n            });\n        },\n        updateProjectFolders: (folders)=>{\n            set({\n                projectFolders: folders\n            });\n        },\n        reorderFilesInFolder: (folderId, fromIndex, toIndex, category)=>{\n            const { projectFiles, financialFiles } = get();\n            if (category === 'project') {\n                // Filter files in the specific folder\n                const folderFiles = projectFiles.filter((file)=>file.folderId === folderId);\n                const otherFiles = projectFiles.filter((file)=>file.folderId !== folderId);\n                // Reorder files within the folder\n                const reorderedFolderFiles = [\n                    ...folderFiles\n                ];\n                const [movedFile] = reorderedFolderFiles.splice(fromIndex, 1);\n                reorderedFolderFiles.splice(toIndex, 0, movedFile);\n                // Combine with other files\n                const newProjectFiles = [\n                    ...otherFiles,\n                    ...reorderedFolderFiles\n                ];\n                set({\n                    projectFiles: newProjectFiles\n                });\n            } else {\n                // Similar logic for financial files\n                const folderFiles = financialFiles.filter((file)=>file.folderId === folderId);\n                const otherFiles = financialFiles.filter((file)=>file.folderId !== folderId);\n                const reorderedFolderFiles = [\n                    ...folderFiles\n                ];\n                const [movedFile] = reorderedFolderFiles.splice(fromIndex, 1);\n                reorderedFolderFiles.splice(toIndex, 0, movedFile);\n                const newFinancialFiles = [\n                    ...otherFiles,\n                    ...reorderedFolderFiles\n                ];\n                set({\n                    financialFiles: newFinancialFiles\n                });\n            }\n        },\n        saveFile: (tabId)=>{\n            const { openTabs, projectFiles, financialFiles } = get();\n            const tab = openTabs.find((t)=>t.id === tabId);\n            if (!tab) return;\n            // Update the file content in appropriate array\n            const updatedProjectFiles = projectFiles.map((file)=>file.id === tabId ? {\n                    ...file,\n                    content: tab.content,\n                    modifiedAt: new Date()\n                } : file);\n            const updatedFinancialFiles = financialFiles.map((file)=>file.id === tabId ? {\n                    ...file,\n                    content: tab.content,\n                    modifiedAt: new Date()\n                } : file);\n            const updatedTabs = openTabs.map((t)=>t.id === tabId ? {\n                    ...t,\n                    modified: false\n                } : t);\n            set({\n                projectFiles: updatedProjectFiles,\n                financialFiles: updatedFinancialFiles,\n                openTabs: updatedTabs\n            });\n        },\n        setError: (error)=>{\n            set({\n                error\n            });\n        },\n        // Fix files that don't have content\n        repairFilesWithoutContent: ()=>{\n            const { projectFiles, financialFiles } = get();\n            const repairedProjectFiles = projectFiles.map((file)=>{\n                if (!file.content || file.content.trim() === '') {\n                    return {\n                        ...file,\n                        content: getDefaultContent(file.type, file.name),\n                        modifiedAt: new Date()\n                    };\n                }\n                return file;\n            });\n            const repairedFinancialFiles = financialFiles.map((file)=>{\n                if (!file.content || file.content.trim() === '') {\n                    return {\n                        ...file,\n                        content: getDefaultContent(file.type, file.name),\n                        modifiedAt: new Date()\n                    };\n                }\n                return file;\n            });\n            set({\n                projectFiles: repairedProjectFiles,\n                financialFiles: repairedFinancialFiles\n            });\n        },\n        reset: ()=>{\n            set({\n                openTabs: [],\n                activeTab: '',\n                projectFiles: initialProjectFiles,\n                financialFiles: initialFinancialFiles,\n                projectFolders: [],\n                financialFolders: [],\n                showProjectsCategory: true,\n                showFinancialCategory: false,\n                isLoading: false,\n                error: null\n            });\n        },\n        // Clear user data when signing out (but keep UI state like theme, etc.)\n        clearUserData: ()=>{\n            set({\n                openTabs: [],\n                activeTab: '',\n                projectFiles: [],\n                financialFiles: [],\n                projectFolders: [],\n                financialFolders: [],\n                trashItems: [],\n                showProjectsCategory: true,\n                showFinancialCategory: false\n            });\n        }\n    }), {\n    name: 'editor-storage',\n    version: 1,\n    // Only persist specific fields\n    partialize: (state)=>({\n            openTabs: state.openTabs.map((tab)=>({\n                    id: tab.id,\n                    name: tab.name,\n                    modified: tab.modified,\n                    content: tab.content,\n                    filePath: tab.filePath,\n                    type: tab.type,\n                    pinned: tab.pinned,\n                    pinnedOrder: tab.pinnedOrder\n                })),\n            activeTab: state.activeTab,\n            projectFiles: state.projectFiles,\n            financialFiles: state.financialFiles,\n            projectFolders: state.projectFolders,\n            financialFolders: state.financialFolders,\n            showProjectsCategory: state.showProjectsCategory,\n            showFinancialCategory: state.showFinancialCategory\n        }),\n    // Custom storage to handle icon restoration\n    storage: {\n        getItem: (name)=>{\n            const str = localStorage.getItem(name);\n            if (!str) return null;\n            const { state } = JSON.parse(str);\n            // Restore icons based on file type\n            const restoredTabs = (state.openTabs || []).map((tab)=>{\n                let icon = _barrel_optimize_names_AtSign_Braces_Calendar_Camera_FileCode_FileSpreadsheet_FileText_FileType_MessageSquare_lucide_react__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\n                switch(tab.type){\n                    case 'typescript':\n                    case 'javascript':\n                        icon = _barrel_optimize_names_AtSign_Braces_Calendar_Camera_FileCode_FileSpreadsheet_FileText_FileType_MessageSquare_lucide_react__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\n                        break;\n                    case 'json':\n                        icon = _barrel_optimize_names_AtSign_Braces_Calendar_Camera_FileCode_FileSpreadsheet_FileText_FileType_MessageSquare_lucide_react__WEBPACK_IMPORTED_MODULE_1__[\"default\"];\n                        break;\n                    case 'excel':\n                        icon = _barrel_optimize_names_AtSign_Braces_Calendar_Camera_FileCode_FileSpreadsheet_FileText_FileType_MessageSquare_lucide_react__WEBPACK_IMPORTED_MODULE_2__[\"default\"];\n                        break;\n                    case 'markdown':\n                        icon = _barrel_optimize_names_AtSign_Braces_Calendar_Camera_FileCode_FileSpreadsheet_FileText_FileType_MessageSquare_lucide_react__WEBPACK_IMPORTED_MODULE_3__[\"default\"];\n                        break;\n                    case 'pdf':\n                        icon = _barrel_optimize_names_AtSign_Braces_Calendar_Camera_FileCode_FileSpreadsheet_FileText_FileType_MessageSquare_lucide_react__WEBPACK_IMPORTED_MODULE_4__[\"default\"];\n                        break;\n                }\n                return {\n                    ...tab,\n                    icon\n                };\n            });\n            return {\n                state: {\n                    ...state,\n                    openTabs: restoredTabs\n                }\n            };\n        },\n        setItem: (name, value)=>{\n            if ( true && localStorage) {\n                localStorage.setItem(name, JSON.stringify(value));\n            }\n        },\n        removeItem: (name)=>{\n            if ( true && localStorage) {\n                localStorage.removeItem(name);\n            }\n        }\n    },\n    onRehydrateStorage: ()=>(state)=>{\n            if (state) {\n                // Repair any files that don't have content\n                if (state.projectFiles) {\n                    state.projectFiles = state.projectFiles.map((file)=>{\n                        if (!file.content || file.content.trim() === '') {\n                            return {\n                                ...file,\n                                content: getDefaultContent(file.type, file.name),\n                                modifiedAt: new Date()\n                            };\n                        }\n                        return file;\n                    });\n                }\n                if (state.financialFiles) {\n                    state.financialFiles = state.financialFiles.map((file)=>{\n                        if (!file.content || file.content.trim() === '') {\n                            return {\n                                ...file,\n                                content: getDefaultContent(file.type, file.name),\n                                modifiedAt: new Date()\n                            };\n                        }\n                        return file;\n                    });\n                }\n                // Ensure Instructions folder exists if there are project folders\n                if (state.projectFolders && state.projectFolders.length > 0) {\n                    // Only ensure the Instructions folder if there are already some project folders\n                    // This prevents auto-creation when storage is intentionally cleared\n                    const hasInstructionsFolder = state.projectFolders.some((folder)=>folder.id === 'instructions-folder' && folder.pinned);\n                    if (!hasInstructionsFolder) {\n                        state.projectFolders = [\n                            {\n                                id: 'instructions-folder',\n                                name: 'Instructions',\n                                category: 'project',\n                                createdAt: new Date(),\n                                pinned: true\n                            },\n                            ...state.projectFolders\n                        ];\n                    }\n                }\n            }\n        // If projectFolders is empty, respect that (don't auto-create anything)\n        }\n}), {\n    name: 'editor-store'\n}));\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3N0b3JlL2VkaXRvci9pbmRleC50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBQSxlQUFlO0FBQ2YsNkRBQTZEO0FBRWlFO0FBQzdGO0FBQ3NCO0FBR3ZELGlEQUFpRDtBQUNqRCxNQUFNWSxjQUFjLENBQUNDO0lBQ25CLE9BQVFBO1FBQ04sS0FBSztZQUNILE9BQU9ULGtLQUFRQTtRQUNqQixLQUFLO1lBQ0gsT0FBT0Esa0tBQVFBO1FBQ2pCLEtBQUs7WUFDSCxPQUFPSCxrS0FBTUE7UUFDZixLQUFLO1lBQ0gsT0FBT0ksa0tBQWVBO1FBQ3hCLEtBQUs7WUFDSCxPQUFPQyxrS0FBUUE7UUFDakIsS0FBSztZQUNILE9BQU9DLGtLQUFRQTtRQUNqQixLQUFLO1lBQ0gsT0FBT0Qsa0tBQVFBO1FBQ2pCLEtBQUs7WUFDSCxPQUFPRCxrS0FBZUE7UUFDeEIsS0FBSztZQUNILE9BQU9BLGtLQUFlQTtRQUN4QixLQUFLO1lBQ0gsT0FBT0Esa0tBQWVBO1FBQ3hCLEtBQUs7WUFDSCxPQUFPRyxrS0FBYUE7UUFDdEIsS0FBSztZQUNILE9BQU8sTUFBTSwrQkFBK0I7UUFDOUMsS0FBSztZQUNILE9BQU9MLGtLQUFNQTtRQUNmLEtBQUs7WUFDSCxPQUFPSCxrS0FBTUE7UUFDZixLQUFLO1lBQ0gsT0FBT0Usa0tBQVFBO1FBQ2pCO1lBQ0UsT0FBT0Usa0tBQVFBO0lBQ25CO0FBQ0Y7QUFFQSx3Q0FBd0M7QUFDeEMsd0NBQXdDO0FBQ3hDLE1BQU1VLG1CQUFtQixDQUFDRDtJQUN4QixPQUFRQTtRQUNOLEtBQUs7WUFDSCxPQUFPO1FBQ1QsS0FBSztZQUNILE9BQU87UUFDVCxLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7WUFDSCxPQUFPO1FBQ1QsS0FBSztZQUNILE9BQU87UUFDVCxLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7WUFDSCxPQUFPO1FBQ1QsS0FBSztZQUNILE9BQU87UUFDVCxLQUFLO1lBQ0gsT0FBTztRQUNULEtB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QUV6QiIsInNvdXJjZXMiOlsiL1VzZXJzL21hdHRoZXdzaW1vbi9Qcm9qZWN0cy9lYWMvZWFjL3N0b3JlL2VkaXRvci9pbmRleC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBFZGl0b3IgU3RvcmVcbi8vIC9Vc2Vycy9tYXR0aGV3c2ltb24vUHJvamVjdHMvRUFDL2VhYy9zdG9yZS9lZGl0b3IvaW5kZXgudHNcblxuaW1wb3J0IHsgQXRTaWduLCBCcmFjZXMsIENhbGVuZGFyLCBDYW1lcmEsIEZpbGVDb2RlLCBGaWxlU3ByZWFkc2hlZXQsIEZpbGVUZXh0LCBGaWxlVHlwZSwgTWVzc2FnZVNxdWFyZSB9IGZyb20gJ2x1Y2lkZS1yZWFjdCc7XG5pbXBvcnQgeyBjcmVhdGUgfSBmcm9tICd6dXN0YW5kJztcbmltcG9ydCB7IGRldnRvb2xzLCBwZXJzaXN0IH0gZnJvbSAnenVzdGFuZC9taWRkbGV3YXJlJztcbmltcG9ydCB7IEVkaXRvclN0YXRlLCBFZGl0b3JUYWIsIFByb2plY3RGaWxlLCBQcm9qZWN0Rm9sZGVyLCBUcmFzaEl0ZW0gfSBmcm9tICcuL3R5cGVzJztcblxuLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGdldCBpY29uIGJhc2VkIG9uIGZpbGUgdHlwZVxuY29uc3QgZ2V0RmlsZUljb24gPSAodHlwZTogUHJvamVjdEZpbGVbJ3R5cGUnXSkgPT4ge1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICd0eXBlc2NyaXB0JzpcbiAgICAgIHJldHVybiBGaWxlQ29kZTtcbiAgICBjYXNlICdqYXZhc2NyaXB0JzpcbiAgICAgIHJldHVybiBGaWxlQ29kZTtcbiAgICBjYXNlICdqc29uJzpcbiAgICAgIHJldHVybiBCcmFjZXM7XG4gICAgY2FzZSAnZXhjZWwnOlxuICAgICAgcmV0dXJuIEZpbGVTcHJlYWRzaGVldDtcbiAgICBjYXNlICdtYXJrZG93bic6XG4gICAgICByZXR1cm4gRmlsZVRleHQ7XG4gICAgY2FzZSAncGRmJzpcbiAgICAgIHJldHVybiBGaWxlVHlwZTtcbiAgICBjYXNlICdnZW5lcmFscyc6XG4gICAgICByZXR1cm4gRmlsZVRleHQ7XG4gICAgY2FzZSAncGVyY2VudC1jb21wbGV0ZSc6XG4gICAgICByZXR1cm4gRmlsZVNwcmVhZHNoZWV0O1xuICAgIGNhc2UgJ3NjaGVkdWxlJzpcbiAgICAgIHJldHVybiBGaWxlU3ByZWFkc2hlZXQ7XG4gICAgY2FzZSAnbWF0ZXJpYWxzJzpcbiAgICAgIHJldHVybiBGaWxlU3ByZWFkc2hlZXQ7XG4gICAgY2FzZSAnZmFjZWJvb2snOlxuICAgICAgcmV0dXJuIE1lc3NhZ2VTcXVhcmU7XG4gICAgY2FzZSAncmVkZGl0JzpcbiAgICAgIHJldHVybiAnci8nOyAvLyBDaGFuZ2VkIGZyb20gSGFzaCB0byByLyB0ZXh0XG4gICAgY2FzZSAnaW5zdGFncmFtJzpcbiAgICAgIHJldHVybiBDYW1lcmE7XG4gICAgY2FzZSAneCc6XG4gICAgICByZXR1cm4gQXRTaWduO1xuICAgIGNhc2UgJ2NhbGVuZGFyJzpcbiAgICAgIHJldHVybiBDYWxlbmRhcjtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIEZpbGVDb2RlO1xuICB9XG59O1xuXG4vLyBIZWxwZXIgZnVuY3Rpb24gdG8gZ2V0IGZpbGUgZXh0ZW5zaW9uXG4vLyBIZWxwZXIgZnVuY3Rpb24gdG8gZ2V0IGZpbGUgZXh0ZW5zaW9uXG5jb25zdCBnZXRGaWxlRXh0ZW5zaW9uID0gKHR5cGU6IFByb2plY3RGaWxlWyd0eXBlJ10pOiBzdHJpbmcgPT4ge1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICd0eXBlc2NyaXB0JzpcbiAgICAgIHJldHVybiAnLnRzJztcbiAgICBjYXNlICdqYXZhc2NyaXB0JzpcbiAgICAgIHJldHVybiAnLmpzJztcbiAgICBjYXNlICdqc29uJzpcbiAgICAgIHJldHVybiAnLmpzb24nO1xuICAgIGNhc2UgJ2V4Y2VsJzpcbiAgICAgIHJldHVybiAnLnhsc3gnO1xuICAgIGNhc2UgJ3BkZic6XG4gICAgICByZXR1cm4gJy5wZGYnO1xuICAgIGNhc2UgJ2dlbmVyYWxzJzpcbiAgICAgIHJldHVybiAnLmdlbmVyYWxzJztcbiAgICBjYXNlICdwZXJjZW50LWNvbXBsZXRlJzpcbiAgICAgIHJldHVybiAnLnBlcmNlbnQnO1xuICAgIGNhc2UgJ3NjaGVkdWxlJzpcbiAgICAgIHJldHVybiAnLnNjaGVkdWxlJztcbiAgICBjYXNlICdtYXRlcmlhbHMnOlxuICAgICAgcmV0dXJuICcubWF0ZXJpYWxzJztcbiAgICBjYXNlICdmYWNlYm9vayc6XG4gICAgICByZXR1cm4gJy5mYWNlYm9vayc7XG4gICAgY2FzZSAncmVkZGl0JzpcbiAgICAgIHJldHVybiAnLnJlZGRpdCc7XG4gICAgY2FzZSAnaW5zdGFncmFtJzpcbiAgICAgIHJldHVybiAnLmluc3RhZ3JhbSc7XG4gICAgY2FzZSAneCc6XG4gICAgICByZXR1cm4gJy54JztcbiAgICBjYXNlICdtYXJrZG93bic6XG4gICAgICByZXR1cm4gJy5tZCc7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAnLnR4dCc7XG4gIH1cbn07XG5cbi8vIEhlbHBlciBmdW5jdGlvbiB0byBnZW5lcmF0ZSBkZWZhdWx0IGNvbnRlbnQgZm9yIG5ldyBmaWxlc1xuY29uc3QgZ2V0RGVmYXVsdENvbnRlbnQgPSAodHlwZTogUHJvamVjdEZpbGVbJ3R5cGUnXSwgbmFtZTogc3RyaW5nKSA9PiB7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ3R5cGVzY3JpcHQnOlxuICAgICAgcmV0dXJuIGAvLyAke25hbWV9XG4vLyBBdXRvLWdlbmVyYXRlZCBUeXBlU2NyaXB0IGZpbGVcblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuaW50ZXJmYWNlICR7bmFtZS5yZXBsYWNlKC9bXmEtekEtWjAtOV0vZywgJycpfVByb3BzIHtcbiAgLy8gRGVmaW5lIHByb3BzIGhlcmVcbn1cblxuZXhwb3J0IGZ1bmN0aW9uICR7bmFtZS5yZXBsYWNlKC9bXmEtekEtWjAtOV0vZywgJycpfSh7IH06ICR7bmFtZS5yZXBsYWNlKC9bXmEtekEtWjAtOV0vZywgJycpfVByb3BzKSB7XG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9XCJwLTRcIj5cbiAgICAgIDxoMSBjbGFzc05hbWU9XCJ0ZXh0LXhsIGZvbnQtYm9sZFwiPk5ldyBDb21wb25lbnQ6ICR7bmFtZX08L2gxPlxuICAgICAgPHAgY2xhc3NOYW1lPVwidGV4dC1ncmF5LTYwMFwiPlN0YXJ0IGJ1aWxkaW5nIHlvdXIgY29tcG9uZW50IGhlcmUuLi48L3A+XG4gICAgPC9kaXY+XG4gICk7XG59YDtcbiAgICBjYXNlICdqYXZhc2NyaXB0JzpcbiAgICAgIHJldHVybiBgLy8gJHtuYW1lfVxuLy8gQXV0by1nZW5lcmF0ZWQgSmF2YVNjcmlwdCBmaWxlXG5cbmV4cG9ydCBmdW5jdGlvbiAke25hbWUucmVwbGFjZSgvW15hLXpBLVowLTldL2csICcnKX0oKSB7XG4gIHJldHVybiB7XG4gICAgbWVzc2FnZTogJ0hlbGxvIGZyb20gJHtuYW1lfSEnLFxuICAgIGRhdGE6IFtdXG4gIH07XG59YDtcbiAgICBjYXNlICdqc29uJzpcbiAgICAgIHJldHVybiBge1xuICBcIm5hbWVcIjogXCIke25hbWV9XCIsXG4gIFwiZGVzY3JpcHRpb25cIjogXCJBdXRvLWdlbmVyYXRlZCBKU09OIGZpbGVcIixcbiAgXCJ2ZXJzaW9uXCI6IFwiMS4wLjBcIixcbiAgXCJkYXRhXCI6IHt9XG59YDtcbiAgICBjYXNlICdtYXJrZG93bic6XG4gICAgICByZXR1cm4gYFN0YXJ0IHdyaXRpbmcgeW91ciBjb250ZW50IGhlcmUuLi5gO1xuICAgIGNhc2UgJ2dlbmVyYWxzJzpcbiAgICAgIHJldHVybiBgLy8gJHtuYW1lfSAtIFByb2plY3QgR2VuZXJhbCBJbmZvcm1hdGlvblxuLy8gVGhpcyBmaWxlIGNvbnRhaW5zIGdlbmVyYWwgcHJvamVjdCBkZXRhaWxzIGFuZCBmaW5hbmNpYWwgaW5mb3JtYXRpb25cbi8vIENyZWF0ZWQgb246ICR7bmV3IERhdGUoKS50b0lTT1N0cmluZygpfVxuXG5Qcm9qZWN0OiAke25hbWV9XG5TdGF0dXM6IEFjdGl2ZVxuQ3JlYXRlZDogJHtuZXcgRGF0ZSgpLnRvTG9jYWxlRGF0ZVN0cmluZygpfVxuXG4vLyBUaGlzIGZpbGUgd2lsbCBkaXNwbGF5IHRoZSBwcm9qZWN0IGdlbmVyYWxzIG1vZHVsZSBpbnRlcmZhY2VgO1xuICAgIGNhc2UgJ3BlcmNlbnQtY29tcGxldGUnOlxuICAgICAgcmV0dXJuIGAvLyAke25hbWV9IC0gUGVyY2VudCBDb21wbGV0ZSBUcmFja2VyXG4vLyBUaGlzIGZpbGUgY29udGFpbnMgcHJvamVjdCBjb21wbGV0aW9uIHRyYWNraW5nIGRhdGFcbi8vIENyZWF0ZWQgb246ICR7bmV3IERhdGUoKS50b0lTT1N0cmluZygpfVxuXG5Qcm9qZWN0OiAke25hbWV9XG5UeXBlOiBQZXJjZW50IENvbXBsZXRlIFRyYWNrZXJcbkNyZWF0ZWQ6ICR7bmV3IERhdGUoKS50b0xvY2FsZURhdGVTdHJpbmcoKX1cblxuLy8gVGhpcyBmaWxlIHdpbGwgZGlzcGxheSB0aGUgcGVyY2VudCBjb21wbGV0ZSB0cmFja2luZyBpbnRlcmZhY2VgO1xuICAgIGNhc2UgJ3NjaGVkdWxlJzpcbiAgICAgIHJldHVybiBgLy8gJHtuYW1lfSAtIFByb2plY3QgU2NoZWR1bGVcbi8vIFRoaXMgZmlsZSBjb250YWlucyBwcm9qZWN0IHNjaGVkdWxlIGFuZCB0aW1lbGluZSBkYXRhXG4vLyBDcmVhdGVkIG9uOiAke25ldyBEYXRlKCkudG9JU09TdHJpbmcoKX1cblxuUHJvamVjdDogJHtuYW1lfVxuVHlwZTogUHJvamVjdCBTY2hlZHVsZVxuQ3JlYXRlZDogJHtuZXcgRGF0ZSgpLnRvTG9jYWxlRGF0ZVN0cmluZygpfVxuXG4vLyBUaGlzIGZpbGUgd2lsbCBkaXNwbGF5IHRoZSBwcm9qZWN0IHNjaGVkdWxlIGludGVyZmFjZSB3aXRoIEdhbnR0IGNoYXJ0YDtcbiAgICBjYXNlICdtYXRlcmlhbHMnOlxuICAgICAgcmV0dXJuIGAvLyAke25hbWV9IC0gTWF0ZXJpYWxzIE1hbmFnZW1lbnRcbi8vIFRoaXMgZmlsZSBjb250YWlucyBtYXRlcmlhbHMgdHJhY2tpbmcgYW5kIG1hbmFnZW1lbnQgZGF0YVxuLy8gQ3JlYXRlZCBvbjogJHtuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCl9XG5cblByb2plY3Q6ICR7bmFtZX1cblR5cGU6IE1hdGVyaWFscyBNYW5hZ2VtZW50XG5DcmVhdGVkOiAke25ldyBEYXRlKCkudG9Mb2NhbGVEYXRlU3RyaW5nKCl9XG5cbi8vIFRoaXMgZmlsZSB3aWxsIGRpc3BsYXkgdGhlIG1hdGVyaWFscyBtYW5hZ2VtZW50IGludGVyZmFjZSB3aXRoIG1hbnVmYWN0dXJlZCBhbmQgbWlzY2VsbGFuZW91cyBtYXRlcmlhbHNgO1xuICAgIGNhc2UgJ2ZhY2Vib29rJzpcbiAgICAgIHJldHVybiBgIyAke25hbWV9IC0gRmFjZWJvb2sgUG9zdFxuUGxhdGZvcm06IEZhY2Vib29rXG5DcmVhdGVkOiAke25ldyBEYXRlKCkudG9Mb2NhbGVEYXRlU3RyaW5nKCl9XG5cbiMjIFBvc3QgQ29udGVudFxuV3JpdGUgeW91ciBGYWNlYm9vayBwb3N0IGNvbnRlbnQgaGVyZS4uLlxuXG4jIyBTZXR0aW5nc1xuLSBBdWRpZW5jZTogUHVibGljXG4tIFNjaGVkdWxlOiBOb3dcbi0gSGFzaHRhZ3M6ICNleGFtcGxlXG5cbiMjIE1lZGlhXG4tIEltYWdlczogW11cbi0gVmlkZW9zOiBbXVxuXG4jIyBBbmFseXRpY3Ncbi0gRW5nYWdlbWVudDogMFxuLSBSZWFjaDogMFxuLSBDbGlja3M6IDBgO1xuICAgIGNhc2UgJ3JlZGRpdCc6XG4gICAgICByZXR1cm4gYCMgJHtuYW1lfSAtIFJlZGRpdCBQb3N0XG5QbGF0Zm9ybTogUmVkZGl0XG5DcmVhdGVkOiAke25ldyBEYXRlKCkudG9Mb2NhbGVEYXRlU3RyaW5nKCl9XG5cbiMjIFBvc3QgQ29udGVudFxuV3JpdGUgeW91ciBSZWRkaXQgcG9zdCBjb250ZW50IGhlcmUuLi5cblxuIyMgU2V0dGluZ3Ncbi0gU3VicmVkZGl0OiByL2V4YW1wbGVcbi0gUG9zdCBUeXBlOiBUZXh0L0xpbmsvSW1hZ2Vcbi0gRmxhaXI6IERpc2N1c3Npb25cbi0gTlNGVzogTm9cblxuIyMgTWVkaWFcbi0gSW1hZ2VzOiBbXVxuLSBMaW5rczogW11cblxuIyMgQW5hbHl0aWNzXG4tIFVwdm90ZXM6IDBcbi0gQ29tbWVudHM6IDBcbi0gQXdhcmRzOiAwYDtcbiAgICBjYXNlICdpbnN0YWdyYW0nOlxuICAgICAgcmV0dXJuIGAjICR7bmFtZX0gLSBJbnN0YWdyYW0gUG9zdFxuUGxhdGZvcm06IEluc3RhZ3JhbVxuQ3JlYXRlZDogJHtuZXcgRGF0ZSgpLnRvTG9jYWxlRGF0ZVN0cmluZygpfVxuXG4jIyBQb3N0IENvbnRlbnRcbldyaXRlIHlvdXIgSW5zdGFncmFtIHBvc3QgY29udGVudCBoZXJlLi4uXG5cbiMjIFNldHRpbmdzXG4tIFBvc3QgVHlwZTogRmVlZC9TdG9yeS9SZWVsXG4tIExvY2F0aW9uOiBDaXR5LCBDb3VudHJ5XG4tIEFsdCBUZXh0OiBEZXNjcmliZSBpbWFnZVxuLSBDb21tZW50IFNldHRpbmdzOiBQdWJsaWNcblxuIyMgTWVkaWFcbi0gSW1hZ2VzOiBbXVxuLSBWaWRlb3M6IFtdXG5cbiMjIEhhc2h0YWdzXG4jaGFzaHRhZzEgI2hhc2h0YWcyICNoYXNodGFnM1xuXG4jIyBBbmFseXRpY3Ncbi0gTGlrZXM6IDBcbi0gQ29tbWVudHM6IDBcbi0gU2hhcmVzOiAwXG4tIFJlYWNoOiAwYDtcbiAgICBjYXNlICd4JzpcbiAgICAgIHJldHVybiBgIyAke25hbWV9IC0gWC9Ud2l0dGVyIFBvc3RcblBsYXRmb3JtOiBYIChUd2l0dGVyKVxuQ3JlYXRlZDogJHtuZXcgRGF0ZSgpLnRvTG9jYWxlRGF0ZVN0cmluZygpfVxuXG4jIyBQb3N0IENvbnRlbnRcbldyaXRlIHlvdXIgWCBwb3N0IGNvbnRlbnQgaGVyZS4uLiAoMjgwIGNoYXJhY3RlciBsaW1pdClcblxuIyMgU2V0dGluZ3Ncbi0gUmVwbHkgU2V0dGluZ3M6IEV2ZXJ5b25lXG4tIFNjaGVkdWxlOiBOb3dcbi0gVGhyZWFkOiBTaW5nbGUgVHdlZXRcblxuIyMgTWVkaWFcbi0gSW1hZ2VzOiBbXVxuLSBWaWRlb3M6IFtdXG4tIEdJRnM6IFtdXG5cbiMjIEFuYWx5dGljc1xuLSBJbXByZXNzaW9uczogMFxuLSBFbmdhZ2VtZW50czogMFxuLSBSZXR3ZWV0czogMFxuLSBMaWtlczogMFxuLSBSZXBsaWVzOiAwYDtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGAjICR7bmFtZX1cblxuVGhpcyBpcyBhIG5ldyBmaWxlIGNyZWF0ZWQgaW4gdGhlIEVBQyBEYXNoYm9hcmQuXG5DcmVhdGVkIG9uOiAke25ldyBEYXRlKCkudG9JU09TdHJpbmcoKX1gO1xuICB9XG59O1xuXG4vLyBJbml0aWFsIHByb2plY3QgZmlsZXMgLSBlbXB0eSBieSBkZWZhdWx0LCBvbmx5IGNyZWF0ZWQgd2hlbiBuZWVkZWRcbmNvbnN0IGluaXRpYWxQcm9qZWN0RmlsZXM6IFByb2plY3RGaWxlW10gPSBbXTtcblxuLy8gSW5pdGlhbCBmaW5hbmNpYWwgZmlsZXMgLSBlbXB0eSBieSBkZWZhdWx0LCBvbmx5IGNyZWF0ZWQgd2hlbiBuZWVkZWQgIFxuY29uc3QgaW5pdGlhbEZpbmFuY2lhbEZpbGVzOiBQcm9qZWN0RmlsZVtdID0gW107XG5cbi8vIEluaXRpYWwgcHJvamVjdCBmb2xkZXJzIC0gb25seSBjcmVhdGVkIHdoZW4gZXhwbGljaXRseSBuZWVkZWQsIG5vdCBvbiBzdG9yYWdlIGNsZWFyXG5jb25zdCBpbml0aWFsUHJvamVjdEZvbGRlcnM6IFByb2plY3RGb2xkZXJbXSA9IFtdO1xuXG5leHBvcnQgY29uc3QgdXNlRWRpdG9yU3RvcmUgPSBjcmVhdGU8RWRpdG9yU3RhdGU+KCkoXG4gIGRldnRvb2xzKFxuICAgIHBlcnNpc3QoXG4gICAgICAoc2V0LCBnZXQpID0+ICh7XG4gICAgICAgIC8vIEluaXRpYWwgc3RhdGVcbiAgICAgICAgb3BlblRhYnM6IFtdLFxuICAgICAgICBhY3RpdmVUYWI6ICcnLFxuICAgICAgICBwcm9qZWN0RmlsZXM6IGluaXRpYWxQcm9qZWN0RmlsZXMsXG4gICAgICAgIGZpbmFuY2lhbEZpbGVzOiBpbml0aWFsRmluYW5jaWFsRmlsZXMsXG4gICAgICAgIHByb2plY3RGb2xkZXJzOiBpbml0aWFsUHJvamVjdEZvbGRlcnMsXG4gICAgICAgIGZpbmFuY2lhbEZvbGRlcnM6IFtdLFxuICAgICAgICB0cmFzaEl0ZW1zOiBbXSxcbiAgICAgICAgc2hvd1Byb2plY3RzQ2F0ZWdvcnk6IHRydWUsXG4gICAgICAgIHNob3dGaW5hbmNpYWxDYXRlZ29yeTogZmFsc2UsIC8vIERvbid0IHNob3cgYnkgZGVmYXVsdCAtIG9ubHkgc2hvdyB3aGVuIHVzZXIgY3JlYXRlcyBmaW5hbmNpYWwgY29udGVudFxuICAgICAgICBpc0xvYWRpbmc6IGZhbHNlLFxuICAgICAgICBlcnJvcjogbnVsbCxcblxuICAgICAgICAvLyBBY3Rpb25zXG4gICAgICAgIG9wZW5UYWI6IChmaWxlOiBQcm9qZWN0RmlsZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHsgb3BlblRhYnMgfSA9IGdldCgpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIENoZWNrIGlmIHRhYiBpcyBhbHJlYWR5IG9wZW5cbiAgICAgICAgICBjb25zdCBleGlzdGluZ1RhYiA9IG9wZW5UYWJzLmZpbmQodGFiID0+IHRhYi5pZCA9PT0gZmlsZS5pZCk7XG4gICAgICAgICAgaWYgKGV4aXN0aW5nVGFiKSB7XG4gICAgICAgICAgICBzZXQoeyBhY3RpdmVUYWI6IGV4aXN0aW5nVGFiLmlkIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIERlZmluZSB3aGljaCBmaWxlIHR5cGVzIHNob3VsZCBiZSBhdXRvLXBpbm5lZFxuICAgICAgICAgIC8vIFlvdSBjYW4gYWRkIG1vcmUgZmlsZSB0eXBlcyBoZXJlIGlmIG5lZWRlZFxuICAgICAgICAgIGNvbnN0IGF1dG9QaW5GaWxlVHlwZXMgPSBbJ2NhbGVuZGFyJywgJ3NvY2lhbC1jb25uZWN0JywgJ3VzZXItcHJvZmlsZScsICdwb3N0LWNyZWF0b3InXTtcbiAgICAgICAgICBjb25zdCBzaG91bGRBdXRvUGlubiA9IGF1dG9QaW5GaWxlVHlwZXMuaW5jbHVkZXMoZmlsZS50eXBlKTtcbiAgICAgICAgICBcbiAgICAgICAgICBsZXQgcGlubmVkT3JkZXI6IG51bWJlciB8IHVuZGVmaW5lZDtcbiAgICAgICAgICBpZiAoc2hvdWxkQXV0b1Bpbm4pIHtcbiAgICAgICAgICAgIC8vIEdldCB0aGUgaGlnaGVzdCBwaW5uZWQgb3JkZXIgZm9yIGF1dG8tcGlubmVkIHRhYnNcbiAgICAgICAgICAgIGNvbnN0IHBpbm5lZFRhYnMgPSBvcGVuVGFicy5maWx0ZXIodCA9PiB0LnBpbm5lZCk7XG4gICAgICAgICAgICBwaW5uZWRPcmRlciA9IHBpbm5lZFRhYnMubGVuZ3RoID4gMCA/IE1hdGgubWF4KC4uLnBpbm5lZFRhYnMubWFwKHQgPT4gdC5waW5uZWRPcmRlciB8fCAwKSkgKyAxIDogMTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBDcmVhdGUgbmV3IHRhYiB3aXRoIGNvbnRlbnRcbiAgICAgICAgICBjb25zdCBuZXdUYWI6IEVkaXRvclRhYiA9IHtcbiAgICAgICAgICAgIGlkOiBmaWxlLmlkLFxuICAgICAgICAgICAgbmFtZTogZmlsZS5uYW1lLFxuICAgICAgICAgICAgbW9kaWZpZWQ6IGZhbHNlLFxuICAgICAgICAgICAgY29udGVudDogZmlsZS5jb250ZW50IHx8IGdldERlZmF1bHRDb250ZW50KGZpbGUudHlwZSwgZmlsZS5uYW1lKSxcbiAgICAgICAgICAgIGZpbGVQYXRoOiBmaWxlLmZpbGVQYXRoLFxuICAgICAgICAgICAgdHlwZTogZmlsZS50eXBlLFxuICAgICAgICAgICAgcGlubmVkOiBzaG91bGRBdXRvUGlubixcbiAgICAgICAgICAgIHBpbm5lZE9yZGVyOiBzaG91bGRBdXRvUGlubiA/IHBpbm5lZE9yZGVyIDogdW5kZWZpbmVkLFxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBsZXQgbmV3VGFiczogRWRpdG9yVGFiW107XG4gICAgICAgICAgaWYgKHNob3VsZEF1dG9QaW5uKSB7XG4gICAgICAgICAgICAvLyBGb3IgYXV0by1waW5uZWQgdGFicywgaW5zZXJ0IGluIGNvcnJlY3QgcGlubmVkIHBvc2l0aW9uXG4gICAgICAgICAgICBjb25zdCBvdGhlclRhYnMgPSBbLi4ub3BlblRhYnNdO1xuICAgICAgICAgICAgY29uc3QgaW5zZXJ0SW5kZXggPSBvdGhlclRhYnMuZmlsdGVyKHQgPT4gdC5waW5uZWQgJiYgKHQucGlubmVkT3JkZXIgfHwgMCkgPCAocGlubmVkT3JkZXIgfHwgMCkpLmxlbmd0aDtcbiAgICAgICAgICAgIG90aGVyVGFicy5zcGxpY2UoaW5zZXJ0SW5kZXgsIDAsIG5ld1RhYik7XG4gICAgICAgICAgICBuZXdUYWJzID0gb3RoZXJUYWJzO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBGb3Igbm9uLWF1dG8tcGlubmVkIHRhYnMsIGluc2VydCBhZnRlciBhbGwgcGlubmVkIHRhYnNcbiAgICAgICAgICAgIGNvbnN0IHBpbm5lZFRhYnMgPSBvcGVuVGFicy5maWx0ZXIodGFiID0+IHRhYi5waW5uZWQpO1xuICAgICAgICAgICAgY29uc3QgdW5waW5uZWRUYWJzID0gb3BlblRhYnMuZmlsdGVyKHRhYiA9PiAhdGFiLnBpbm5lZCk7XG4gICAgICAgICAgICBuZXdUYWJzID0gWy4uLnBpbm5lZFRhYnMsIC4uLnVucGlubmVkVGFicywgbmV3VGFiXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzZXQoe1xuICAgICAgICAgICAgb3BlblRhYnM6IG5ld1RhYnMsXG4gICAgICAgICAgICBhY3RpdmVUYWI6IG5ld1RhYi5pZCxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBvcGVuU3BlY2lhbFRhYjogKGlkOiBzdHJpbmcsIG5hbWU6IHN0cmluZywgdHlwZTogJ3NvY2lhbC1jb25uZWN0JyB8ICdwb3N0LWNyZWF0b3InIHwgJ2NhbGVuZGFyJyB8ICd1c2VyLXByb2ZpbGUnIHwgJ3NpZ24taW4nKSA9PiB7XG4gICAgICAgICAgY29uc3QgeyBvcGVuVGFicyB9ID0gZ2V0KCk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQ2hlY2sgaWYgdGFiIGlzIGFscmVhZHkgb3BlblxuICAgICAgICAgIGNvbnN0IGV4aXN0aW5nVGFiID0gb3BlblRhYnMuZmluZCh0YWIgPT4gdGFiLmlkID09PSBpZCk7XG4gICAgICAgICAgaWYgKGV4aXN0aW5nVGFiKSB7XG4gICAgICAgICAgICBzZXQoeyBhY3RpdmVUYWI6IGV4aXN0aW5nVGFiLmlkIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIERlZmluZSB3aGljaCB0YWIgdHlwZXMgc2hvdWxkIGJlIGF1dG8tcGlubmVkXG4gICAgICAgICAgY29uc3QgYXV0b1BpblR5cGVzID0gWyd1c2VyLXByb2ZpbGUnLCAnY2FsZW5kYXInLCAnc29jaWFsLWNvbm5lY3QnLCAncG9zdC1jcmVhdG9yJ107XG4gICAgICAgICAgY29uc3Qgc2hvdWxkQXV0b1Bpbm4gPSBhdXRvUGluVHlwZXMuaW5jbHVkZXModHlwZSk7XG4gICAgICAgICAgXG4gICAgICAgICAgbGV0IHBpbm5lZE9yZGVyOiBudW1iZXIgfCB1bmRlZmluZWQ7XG4gICAgICAgICAgaWYgKHNob3VsZEF1dG9QaW5uKSB7XG4gICAgICAgICAgICAvLyBHZXQgdGhlIGhpZ2hlc3QgcGlubmVkIG9yZGVyIGZvciBhdXRvLXBpbm5lZCB0YWJzXG4gICAgICAgICAgICBjb25zdCBwaW5uZWRUYWJzID0gb3BlblRhYnMuZmlsdGVyKHQgPT4gdC5waW5uZWQpO1xuICAgICAgICAgICAgcGlubmVkT3JkZXIgPSBwaW5uZWRUYWJzLmxlbmd0aCA+IDAgPyBNYXRoLm1heCguLi5waW5uZWRUYWJzLm1hcCh0ID0+IHQucGlubmVkT3JkZXIgfHwgMCkpICsgMSA6IDE7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gQ3JlYXRlIG5ldyBzcGVjaWFsIHRhYlxuICAgICAgICAgIGNvbnN0IG5ld1RhYjogRWRpdG9yVGFiID0ge1xuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgbW9kaWZpZWQ6IGZhbHNlLFxuICAgICAgICAgICAgY29udGVudDogJycsXG4gICAgICAgICAgICBmaWxlUGF0aDogYC8ke3R5cGV9YCxcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICBwaW5uZWQ6IHNob3VsZEF1dG9QaW5uLFxuICAgICAgICAgICAgcGlubmVkT3JkZXI6IHNob3VsZEF1dG9QaW5uID8gcGlubmVkT3JkZXIgOiB1bmRlZmluZWQsXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGxldCBuZXdUYWJzOiBFZGl0b3JUYWJbXTtcbiAgICAgICAgICBpZiAoc2hvdWxkQXV0b1Bpbm4pIHtcbiAgICAgICAgICAgIC8vIEZvciBhdXRvLXBpbm5lZCB0YWJzLCBpbnNlcnQgaW4gY29ycmVjdCBwaW5uZWQgcG9zaXRpb25cbiAgICAgICAgICAgIGNvbnN0IG90aGVyVGFicyA9IFsuLi5vcGVuVGFic107XG4gICAgICAgICAgICBjb25zdCBpbnNlcnRJbmRleCA9IG90aGVyVGFicy5maWx0ZXIodCA9PiB0LnBpbm5lZCAmJiAodC5waW5uZWRPcmRlciB8fCAwKSA8IChwaW5uZWRPcmRlciB8fCAwKSkubGVuZ3RoO1xuICAgICAgICAgICAgb3RoZXJUYWJzLnNwbGljZShpbnNlcnRJbmRleCwgMCwgbmV3VGFiKTtcbiAgICAgICAgICAgIG5ld1RhYnMgPSBvdGhlclRhYnM7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEZvciBub24tYXV0by1waW5uZWQgdGFicywgaW5zZXJ0IGFmdGVyIGFsbCBwaW5uZWQgdGFic1xuICAgICAgICAgICAgY29uc3QgcGlubmVkVGFicyA9IG9wZW5UYWJzLmZpbHRlcih0YWIgPT4gdGFiLnBpbm5lZCk7XG4gICAgICAgICAgICBjb25zdCB1bnBpbm5lZFRhYnMgPSBvcGVuVGFicy5maWx0ZXIodGFiID0+ICF0YWIucGlubmVkKTtcbiAgICAgICAgICAgIG5ld1RhYnMgPSBbLi4ucGlubmVkVGFicywgLi4udW5waW5uZWRUYWJzLCBuZXdUYWJdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHNldCh7XG4gICAgICAgICAgICBvcGVuVGFiczogbmV3VGFicyxcbiAgICAgICAgICAgIGFjdGl2ZVRhYjogbmV3VGFiLmlkLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNsb3NlVGFiOiAodGFiSWQ6IHN0cmluZykgPT4ge1xuICAgICAgICAgIGNvbnN0IHsgb3BlblRhYnMsIGFjdGl2ZVRhYiB9ID0gZ2V0KCk7XG4gICAgICAgICAgY29uc3QgdGFiSW5kZXggPSBvcGVuVGFicy5maW5kSW5kZXgodGFiID0+IHRhYi5pZCA9PT0gdGFiSWQpO1xuICAgICAgICAgIFxuICAgICAgICAgIGlmICh0YWJJbmRleCA9PT0gLTEpIHJldHVybjtcblxuICAgICAgICAgIGNvbnN0IG5ld1RhYnMgPSBvcGVuVGFicy5maWx0ZXIodGFiID0+IHRhYi5pZCAhPT0gdGFiSWQpO1xuICAgICAgICAgIGxldCBuZXdBY3RpdmVUYWIgPSBhY3RpdmVUYWI7XG5cbiAgICAgICAgICAvLyBJZiBjbG9zaW5nIHRoZSBhY3RpdmUgdGFiLCBzd2l0Y2ggdG8gYW5vdGhlciB0YWJcbiAgICAgICAgICBpZiAoYWN0aXZlVGFiID09PSB0YWJJZCkge1xuICAgICAgICAgICAgaWYgKG5ld1RhYnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAvLyBTd2l0Y2ggdG8gdGhlIHRhYiB0byB0aGUgcmlnaHQsIG9yIHRoZSBsYXN0IHRhYiBpZiBjbG9zaW5nIHRoZSBsYXN0IG9uZVxuICAgICAgICAgICAgICBjb25zdCBuZXh0SW5kZXggPSB0YWJJbmRleCA8IG5ld1RhYnMubGVuZ3RoID8gdGFiSW5kZXggOiBuZXdUYWJzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgIG5ld0FjdGl2ZVRhYiA9IG5ld1RhYnNbbmV4dEluZGV4XS5pZDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5ld0FjdGl2ZVRhYiA9ICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHNldCh7XG4gICAgICAgICAgICBvcGVuVGFiczogbmV3VGFicyxcbiAgICAgICAgICAgIGFjdGl2ZVRhYjogbmV3QWN0aXZlVGFiLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNsb3NlQWxsVGFiczogKCkgPT4ge1xuICAgICAgICAgIHNldCh7XG4gICAgICAgICAgICBvcGVuVGFiczogW10sXG4gICAgICAgICAgICBhY3RpdmVUYWI6ICcnLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldEFjdGl2ZVRhYjogKHRhYklkOiBzdHJpbmcpID0+IHtcbiAgICAgICAgICBjb25zdCB7IG9wZW5UYWJzIH0gPSBnZXQoKTtcbiAgICAgICAgICBjb25zdCB0YWJFeGlzdHMgPSBvcGVuVGFicy5zb21lKHRhYiA9PiB0YWIuaWQgPT09IHRhYklkKTtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAodGFiRXhpc3RzKSB7XG4gICAgICAgICAgICBzZXQoeyBhY3RpdmVUYWI6IHRhYklkIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICByZW9yZGVyVGFiczogKGZyb21UYWJJZDogc3RyaW5nLCB0b1RhYklkOiBzdHJpbmcpID0+IHtcbiAgICAgICAgICBjb25zdCB7IG9wZW5UYWJzIH0gPSBnZXQoKTtcbiAgICAgICAgICBjb25zdCBmcm9tSW5kZXggPSBvcGVuVGFicy5maW5kSW5kZXgodGFiID0+IHRhYi5pZCA9PT0gZnJvbVRhYklkKTtcbiAgICAgICAgICBjb25zdCB0b0luZGV4ID0gb3BlblRhYnMuZmluZEluZGV4KHRhYiA9PiB0YWIuaWQgPT09IHRvVGFiSWQpO1xuICAgICAgICAgIFxuICAgICAgICAgIGlmIChmcm9tSW5kZXggIT09IC0xICYmIHRvSW5kZXggIT09IC0xICYmIGZyb21JbmRleCAhPT0gdG9JbmRleCkge1xuICAgICAgICAgICAgY29uc3QgbmV3VGFicyA9IFsuLi5vcGVuVGFic107XG4gICAgICAgICAgICBjb25zdCBbbW92ZWRUYWJdID0gbmV3VGFicy5zcGxpY2UoZnJvbUluZGV4LCAxKTtcbiAgICAgICAgICAgIG5ld1RhYnMuc3BsaWNlKHRvSW5kZXgsIDAsIG1vdmVkVGFiKTtcbiAgICAgICAgICAgIHNldCh7IG9wZW5UYWJzOiBuZXdUYWJzIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBwaW5UYWI6ICh0YWJJZDogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgY29uc3QgeyBvcGVuVGFicyB9ID0gZ2V0KCk7XG4gICAgICAgICAgY29uc3QgdGFiSW5kZXggPSBvcGVuVGFicy5maW5kSW5kZXgodGFiID0+IHRhYi5pZCA9PT0gdGFiSWQpO1xuICAgICAgICAgIFxuICAgICAgICAgIGlmICh0YWJJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhYiA9IG9wZW5UYWJzW3RhYkluZGV4XTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gRG9uJ3QgcGluIGlmIGFscmVhZHkgcGlubmVkXG4gICAgICAgICAgICBpZiAodGFiLnBpbm5lZCkgcmV0dXJuO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBHZXQgdGhlIGhpZ2hlc3QgcGlubmVkIG9yZGVyXG4gICAgICAgICAgICBjb25zdCBwaW5uZWRUYWJzID0gb3BlblRhYnMuZmlsdGVyKHQgPT4gdC5waW5uZWQpO1xuICAgICAgICAgICAgY29uc3QgbmV4dFBpbm5lZE9yZGVyID0gcGlubmVkVGFicy5sZW5ndGggPiAwID8gTWF0aC5tYXgoLi4ucGlubmVkVGFicy5tYXAodCA9PiB0LnBpbm5lZE9yZGVyIHx8IDApKSArIDEgOiAxO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIHRhYiB0byBiZSBwaW5uZWRcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRUYWIgPSB7IC4uLnRhYiwgcGlubmVkOiB0cnVlLCBwaW5uZWRPcmRlcjogbmV4dFBpbm5lZE9yZGVyIH07XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIFJlbW92ZSB0YWIgZnJvbSBjdXJyZW50IHBvc2l0aW9uIGFuZCBhZGQgdG8gY29ycmVjdCBwaW5uZWQgcG9zaXRpb25cbiAgICAgICAgICAgIGNvbnN0IG5ld1RhYnMgPSBbLi4ub3BlblRhYnNdO1xuICAgICAgICAgICAgbmV3VGFicy5zcGxpY2UodGFiSW5kZXgsIDEpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBGaW5kIHRoZSBjb3JyZWN0IHBvc2l0aW9uIGFtb25nIHBpbm5lZCB0YWJzXG4gICAgICAgICAgICBjb25zdCBpbnNlcnRJbmRleCA9IG5ld1RhYnMuZmlsdGVyKHQgPT4gdC5waW5uZWQgJiYgKHQucGlubmVkT3JkZXIgfHwgMCkgPCBuZXh0UGlubmVkT3JkZXIpLmxlbmd0aDtcbiAgICAgICAgICAgIG5ld1RhYnMuc3BsaWNlKGluc2VydEluZGV4LCAwLCB1cGRhdGVkVGFiKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgc2V0KHsgb3BlblRhYnM6IG5ld1RhYnMgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHVucGluVGFiOiAodGFiSWQ6IHN0cmluZykgPT4ge1xuICAgICAgICAgIGNvbnN0IHsgb3BlblRhYnMgfSA9IGdldCgpO1xuICAgICAgICAgIGNvbnN0IHRhYkluZGV4ID0gb3BlblRhYnMuZmluZEluZGV4KHRhYiA9PiB0YWIuaWQgPT09IHRhYklkKTtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAodGFiSW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICBjb25zdCB0YWIgPSBvcGVuVGFic1t0YWJJbmRleF07XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIERvbid0IHVucGluIGlmIG5vdCBwaW5uZWRcbiAgICAgICAgICAgIGlmICghdGFiLnBpbm5lZCkgcmV0dXJuO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIHRhYiB0byBiZSB1bnBpbm5lZFxuICAgICAgICAgICAgY29uc3QgdXBkYXRlZFRhYiA9IHsgLi4udGFiLCBwaW5uZWQ6IGZhbHNlLCBwaW5uZWRPcmRlcjogdW5kZWZpbmVkIH07XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIFJlbW92ZSB0YWIgZnJvbSBjdXJyZW50IHBvc2l0aW9uXG4gICAgICAgICAgICBjb25zdCBuZXdUYWJzID0gWy4uLm9wZW5UYWJzXTtcbiAgICAgICAgICAgIG5ld1RhYnMuc3BsaWNlKHRhYkluZGV4LCAxKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gRmluZCB0aGUgcG9zaXRpb24gYWZ0ZXIgYWxsIHBpbm5lZCB0YWJzXG4gICAgICAgICAgICBjb25zdCBwaW5uZWRDb3VudCA9IG5ld1RhYnMuZmlsdGVyKHQgPT4gdC5waW5uZWQpLmxlbmd0aDtcbiAgICAgICAgICAgIG5ld1RhYnMuc3BsaWNlKHBpbm5lZENvdW50LCAwLCB1cGRhdGVkVGFiKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgc2V0KHsgb3BlblRhYnM6IG5ld1RhYnMgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHVwZGF0ZVRhYkNvbnRlbnQ6ICh0YWJJZDogc3RyaW5nLCBjb250ZW50OiBzdHJpbmcpID0+IHtcbiAgICAgICAgICBjb25zdCB7IG9wZW5UYWJzIH0gPSBnZXQoKTtcbiAgICAgICAgICBjb25zdCB1cGRhdGVkVGFicyA9IG9wZW5UYWJzLm1hcCgodGFiOiBFZGl0b3JUYWIpID0+IFxuICAgICAgICAgICAgdGFiLmlkID09PSB0YWJJZCBcbiAgICAgICAgICAgICAgPyB7IC4uLnRhYiwgY29udGVudCwgbW9kaWZpZWQ6IHRydWUgfVxuICAgICAgICAgICAgICA6IHRhYlxuICAgICAgICAgICk7XG4gICAgICAgICAgXG4gICAgICAgICAgc2V0KHsgb3BlblRhYnM6IHVwZGF0ZWRUYWJzIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIHVwZGF0ZUZpbGVDb250ZW50OiAodGFiSWQ6IHN0cmluZywgY29udGVudDogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgY29uc3QgeyBvcGVuVGFicyB9ID0gZ2V0KCk7XG4gICAgICAgICAgY29uc3QgdXBkYXRlZFRhYnMgPSBvcGVuVGFicy5tYXAoKHRhYjogRWRpdG9yVGFiKSA9PiBcbiAgICAgICAgICAgIHRhYi5pZCA9PT0gdGFiSWQgXG4gICAgICAgICAgICAgID8geyAuLi50YWIsIGNvbnRlbnQsIG1vZGlmaWVkOiB0cnVlIH1cbiAgICAgICAgICAgICAgOiB0YWJcbiAgICAgICAgICApO1xuICAgICAgICAgIFxuICAgICAgICAgIHNldCh7IG9wZW5UYWJzOiB1cGRhdGVkVGFicyB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICB1cGRhdGVGaWxlQ29udGVudEluU3RvcmU6IChmaWxlSWQ6IHN0cmluZywgY29udGVudDogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgY29uc3QgeyBwcm9qZWN0RmlsZXMsIGZpbmFuY2lhbEZpbGVzLCBvcGVuVGFicyB9ID0gZ2V0KCk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gVXBkYXRlIHRoZSBmaWxlIGluIHRoZSBhcHByb3ByaWF0ZSBzdG9yZVxuICAgICAgICAgIGNvbnN0IHVwZGF0ZWRQcm9qZWN0RmlsZXMgPSBwcm9qZWN0RmlsZXMubWFwKGZpbGUgPT5cbiAgICAgICAgICAgIGZpbGUuaWQgPT09IGZpbGVJZCA/IHsgLi4uZmlsZSwgY29udGVudCwgbW9kaWZpZWRBdDogbmV3IERhdGUoKSB9IDogZmlsZVxuICAgICAgICAgICk7XG4gICAgICAgICAgXG4gICAgICAgICAgY29uc3QgdXBkYXRlZEZpbmFuY2lhbEZpbGVzID0gZmluYW5jaWFsRmlsZXMubWFwKGZpbGUgPT5cbiAgICAgICAgICAgIGZpbGUuaWQgPT09IGZpbGVJZCA/IHsgLi4uZmlsZSwgY29udGVudCwgbW9kaWZpZWRBdDogbmV3IERhdGUoKSB9IDogZmlsZVxuICAgICAgICAgICk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQWxzbyB1cGRhdGUgdGhlIHRhYiBpZiBpdCdzIG9wZW5cbiAgICAgICAgICBjb25zdCB1cGRhdGVkVGFicyA9IG9wZW5UYWJzLm1hcCgodGFiOiBFZGl0b3JUYWIpID0+IFxuICAgICAgICAgICAgdGFiLmlkID09PSBmaWxlSWQgXG4gICAgICAgICAgICAgID8geyAuLi50YWIsIGNvbnRlbnQsIG1vZGlmaWVkOiB0cnVlIH1cbiAgICAgICAgICAgICAgOiB0YWJcbiAgICAgICAgICApO1xuICAgICAgICAgIFxuICAgICAgICAgIHNldCh7IFxuICAgICAgICAgICAgcHJvamVjdEZpbGVzOiB1cGRhdGVkUHJvamVjdEZpbGVzLFxuICAgICAgICAgICAgZmluYW5jaWFsRmlsZXM6IHVwZGF0ZWRGaW5hbmNpYWxGaWxlcyxcbiAgICAgICAgICAgIG9wZW5UYWJzOiB1cGRhdGVkVGFic1xuICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIHVwZGF0ZUZpbGVTdGF0dXM6IChmaWxlSWQ6IHN0cmluZywgc3RhdHVzOiAnZHJhZnQnIHwgJ3NjaGVkdWxlZCcgfCAnY29tcGxldGUnKSA9PiB7XG4gICAgICAgICAgY29uc3QgeyBwcm9qZWN0RmlsZXMsIGZpbmFuY2lhbEZpbGVzIH0gPSBnZXQoKTtcblxuICAgICAgICAgIC8vIFVwZGF0ZSBpbiBwcm9qZWN0IGZpbGVzXG4gICAgICAgICAgY29uc3QgdXBkYXRlZFByb2plY3RGaWxlcyA9IHByb2plY3RGaWxlcy5tYXAoZmlsZSA9PlxuICAgICAgICAgICAgZmlsZS5pZCA9PT0gZmlsZUlkID8geyAuLi5maWxlLCBzdGF0dXMsIG1vZGlmaWVkQXQ6IG5ldyBEYXRlKCkgfSA6IGZpbGVcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgLy8gVXBkYXRlIGluIGZpbmFuY2lhbCBmaWxlc1xuICAgICAgICAgIGNvbnN0IHVwZGF0ZWRGaW5hbmNpYWxGaWxlcyA9IGZpbmFuY2lhbEZpbGVzLm1hcChmaWxlID0+XG4gICAgICAgICAgICBmaWxlLmlkID09PSBmaWxlSWQgPyB7IC4uLmZpbGUsIHN0YXR1cywgbW9kaWZpZWRBdDogbmV3IERhdGUoKSB9IDogZmlsZVxuICAgICAgICAgICk7XG5cbiAgICAgICAgICBzZXQoe1xuICAgICAgICAgICAgcHJvamVjdEZpbGVzOiB1cGRhdGVkUHJvamVjdEZpbGVzLFxuICAgICAgICAgICAgZmluYW5jaWFsRmlsZXM6IHVwZGF0ZWRGaW5hbmNpYWxGaWxlc1xuICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNyZWF0ZU5ld0ZpbGU6IChuYW1lOiBzdHJpbmcsIHR5cGU6IFByb2plY3RGaWxlWyd0eXBlJ10sIGNhdGVnb3J5OiBQcm9qZWN0RmlsZVsnY2F0ZWdvcnknXSA9ICdwcm9qZWN0JywgZm9sZGVySWQ/OiBzdHJpbmcsIGN1c3RvbUNvbnRlbnQ/OiBzdHJpbmcpID0+IHtcbiAgICAgICAgICBjb25zdCB7IHByb2plY3RGaWxlcywgZmluYW5jaWFsRmlsZXMgfSA9IGdldCgpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIEdlbmVyYXRlIHVuaXF1ZSBJRFxuICAgICAgICAgIGNvbnN0IGlkID0gYCR7bmFtZS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1teYS16MC05XS9nLCAnLScpfS0ke0RhdGUubm93KCl9YDtcbiAgICAgICAgICBjb25zdCBmaWxlTmFtZSA9IGAke25hbWV9JHtnZXRGaWxlRXh0ZW5zaW9uKHR5cGUpfWA7XG4gICAgICAgICAgY29uc3QgYmFzZVBhdGggPSBjYXRlZ29yeSA9PT0gJ2ZpbmFuY2lhbCcgPyAnL2ZpbmFuY2lhbC1kYXRhJyA6ICcvZWFjLXByb2plY3RzJztcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBVc2UgY3VzdG9tIGNvbnRlbnQgaWYgcHJvdmlkZWQsIG90aGVyd2lzZSB1c2UgZGVmYXVsdFxuICAgICAgICAgIGNvbnN0IGZpbGVDb250ZW50ID0gY3VzdG9tQ29udGVudCB8fCBnZXREZWZhdWx0Q29udGVudCh0eXBlLCBuYW1lKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBDcmVhdGUgbmV3IGZpbGVcbiAgICAgICAgICBjb25zdCBuZXdGaWxlOiBQcm9qZWN0RmlsZSA9IHtcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgbmFtZTogZmlsZU5hbWUsXG4gICAgICAgICAgICBpY29uOiBnZXRGaWxlSWNvbih0eXBlKSxcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICBjYXRlZ29yeSxcbiAgICAgICAgICAgIGNvbnRlbnQ6IGZpbGVDb250ZW50LFxuICAgICAgICAgICAgZmlsZVBhdGg6IGAke2Jhc2VQYXRofS8ke2ZpbGVOYW1lfWAsXG4gICAgICAgICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCksXG4gICAgICAgICAgICBtb2RpZmllZEF0OiBuZXcgRGF0ZSgpLFxuICAgICAgICAgICAgZm9sZGVySWQsIC8vIEFkZCBmb2xkZXIgYXNzaWdubWVudFxuICAgICAgICAgICAgc3RhdHVzOiBbJ2ZhY2Vib29rJywgJ3JlZGRpdCcsICdpbnN0YWdyYW0nLCAneCddLmluY2x1ZGVzKHR5cGUpID8gJ2RyYWZ0JyA6IHVuZGVmaW5lZCwgLy8gRGVmYXVsdCBzb2NpYWwgbWVkaWEgZmlsZXMgdG8gZHJhZnRcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgLy8gQWRkIHRvIGFwcHJvcHJpYXRlIGZpbGUgYXJyYXkgYW5kIGVuc3VyZSBjYXRlZ29yeSBpcyB2aXNpYmxlXG4gICAgICAgICAgaWYgKGNhdGVnb3J5ID09PSAnZmluYW5jaWFsJykge1xuICAgICAgICAgICAgc2V0KHtcbiAgICAgICAgICAgICAgZmluYW5jaWFsRmlsZXM6IFsuLi5maW5hbmNpYWxGaWxlcywgbmV3RmlsZV0sXG4gICAgICAgICAgICAgIHNob3dGaW5hbmNpYWxDYXRlZ29yeTogdHJ1ZSwgLy8gRW5zdXJlIGZpbmFuY2lhbCBjYXRlZ29yeSBpcyB2aXNpYmxlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2V0KHtcbiAgICAgICAgICAgICAgcHJvamVjdEZpbGVzOiBbLi4ucHJvamVjdEZpbGVzLCBuZXdGaWxlXSxcbiAgICAgICAgICAgICAgc2hvd1Byb2plY3RzQ2F0ZWdvcnk6IHRydWUsIC8vIEVuc3VyZSBwcm9qZWN0cyBjYXRlZ29yeSBpcyB2aXNpYmxlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBBdXRvbWF0aWNhbGx5IG9wZW4gdGhlIG5ldyBmaWxlXG4gICAgICAgICAgZ2V0KCkub3BlblRhYihuZXdGaWxlKTtcblxuICAgICAgICAgIC8vIFNhdmUgdG8gQ29udmV4IGRhdGFiYXNlIChhc3luYyAtIGRvbid0IGJsb2NrIFVJKVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXZSBuZWVkIHRvIGltcG9ydCB0aGUgQ29udmV4IGhvb2tzIGhlcmUsIHdoaWNoIGlzbid0IGlkZWFsXG4gICAgICAgICAgICAvLyBCZXR0ZXIgdG8gaGFuZGxlIHRoaXMgaW4gdGhlIGNvbXBvbmVudCBsZXZlbFxuICAgICAgICAgICAgY29uc29sZS5sb2coJ0ZpbGUgY3JlYXRlZCBsb2NhbGx5OicsIG5ld0ZpbGUpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBEaXNwYXRjaCBjdXN0b20gZXZlbnQgdGhhdCBjb21wb25lbnRzIGNhbiBsaXN0ZW4gdG9cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICB3aW5kb3cuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ2ZpbGVDcmVhdGVkJywgeyBcbiAgICAgICAgICAgICAgICBkZXRhaWw6IHsgXG4gICAgICAgICAgICAgICAgICBmaWxlOiBuZXdGaWxlLFxuICAgICAgICAgICAgICAgICAgcHJvamVjdElkOiBmb2xkZXJJZCAvLyBVc2luZyBmb2xkZXJJZCBhcyBwcm9qZWN0SWQgZm9yIG5vd1xuICAgICAgICAgICAgICAgIH0gXG4gICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gc2F2ZSBmaWxlIHRvIGRhdGFiYXNlOicsIGVycm9yKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBSZXR1cm4gdGhlIGZpbGUgSUQgc28gY2FsbGVyIGNhbiByZWZlcmVuY2UgaXRcbiAgICAgICAgICByZXR1cm4gaWQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY3JlYXRlRm9sZGVyOiAobmFtZTogc3RyaW5nLCBjYXRlZ29yeTogJ3Byb2plY3QnIHwgJ2ZpbmFuY2lhbCcsIGNvbnZleElkPzogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgY29uc3QgeyBwcm9qZWN0Rm9sZGVycywgZmluYW5jaWFsRm9sZGVycyB9ID0gZ2V0KCk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQ2hlY2sgaWYgZm9sZGVyIHdpdGggdGhpcyBuYW1lIGFscmVhZHkgZXhpc3RzIHRvIHByZXZlbnQgZHVwbGljYXRlc1xuICAgICAgICAgIGNvbnN0IGV4aXN0aW5nRm9sZGVycyA9IGNhdGVnb3J5ID09PSAnZmluYW5jaWFsJyA/IGZpbmFuY2lhbEZvbGRlcnMgOiBwcm9qZWN0Rm9sZGVycztcbiAgICAgICAgICBjb25zdCBmb2xkZXJFeGlzdHMgPSBleGlzdGluZ0ZvbGRlcnMuc29tZShmb2xkZXIgPT4gXG4gICAgICAgICAgICBmb2xkZXIubmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lLnRvTG93ZXJDYXNlKClcbiAgICAgICAgICApO1xuICAgICAgICAgIFxuICAgICAgICAgIGlmIChmb2xkZXJFeGlzdHMpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBGb2xkZXIgXCIke25hbWV9XCIgYWxyZWFkeSBleGlzdHMgaW4gJHtjYXRlZ29yeX0gY2F0ZWdvcnksIHNraXBwaW5nIGNyZWF0aW9uYCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIEdlbmVyYXRlIHRydWx5IHVuaXF1ZSBJRCB1c2luZyBjcnlwdG8gaWYgYXZhaWxhYmxlLCBvdGhlcndpc2UgZmFsbGJhY2sgdG8gdGltZXN0YW1wICsgcmFuZG9tXG4gICAgICAgICAgbGV0IHVuaXF1ZUlkOiBzdHJpbmc7XG4gICAgICAgICAgaWYgKHR5cGVvZiBjcnlwdG8gIT09ICd1bmRlZmluZWQnICYmIGNyeXB0by5yYW5kb21VVUlEKSB7XG4gICAgICAgICAgICB1bmlxdWVJZCA9IGBmb2xkZXItJHtuYW1lLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvW15hLXowLTldL2csICctJyl9LSR7Y3J5cHRvLnJhbmRvbVVVSUQoKX1gO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBGYWxsYmFjayBmb3IgZW52aXJvbm1lbnRzIHdpdGhvdXQgY3J5cHRvLnJhbmRvbVVVSURcbiAgICAgICAgICAgIGNvbnN0IHRpbWVzdGFtcCA9IERhdGUubm93KCk7XG4gICAgICAgICAgICBjb25zdCByYW5kb20gPSBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMiwgMTIpO1xuICAgICAgICAgICAgY29uc3QgY291bnRlciA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDAwKTtcbiAgICAgICAgICAgIHVuaXF1ZUlkID0gYGZvbGRlci0ke25hbWUudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9bXmEtejAtOV0vZywgJy0nKX0tJHt0aW1lc3RhbXB9LSR7cmFuZG9tfS0ke2NvdW50ZXJ9YDtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gRG91YmxlLWNoZWNrIHVuaXF1ZW5lc3MgYWdhaW5zdCBhbGwgZXhpc3RpbmcgZm9sZGVyIElEc1xuICAgICAgICAgIGNvbnN0IGFsbEZvbGRlcnMgPSBbLi4ucHJvamVjdEZvbGRlcnMsIC4uLmZpbmFuY2lhbEZvbGRlcnNdO1xuICAgICAgICAgIHdoaWxlIChhbGxGb2xkZXJzLnNvbWUoZm9sZGVyID0+IGZvbGRlci5pZCA9PT0gdW5pcXVlSWQpKSB7XG4gICAgICAgICAgICBjb25zdCByYW5kb21TdWZmaXggPSBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMiwgOCk7XG4gICAgICAgICAgICB1bmlxdWVJZCA9IGAke3VuaXF1ZUlkfS0ke3JhbmRvbVN1ZmZpeH1gO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBDcmVhdGUgbmV3IGZvbGRlclxuICAgICAgICAgIGNvbnN0IG5ld0ZvbGRlcjogUHJvamVjdEZvbGRlciA9IHtcbiAgICAgICAgICAgIGlkOiB1bmlxdWVJZCxcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICBjYXRlZ29yeSxcbiAgICAgICAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKSxcbiAgICAgICAgICAgIGNvbnZleElkLCAvLyBTdG9yZSB0aGUgQ29udmV4IHByb2plY3QgSURcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgLy8gQWRkIHRvIGFwcHJvcHJpYXRlIGZvbGRlciBhcnJheSBhbmQgZW5zdXJlIGNhdGVnb3J5IGlzIHZpc2libGVcbiAgICAgICAgICBpZiAoY2F0ZWdvcnkgPT09ICdmaW5hbmNpYWwnKSB7XG4gICAgICAgICAgICBzZXQoe1xuICAgICAgICAgICAgICBmaW5hbmNpYWxGb2xkZXJzOiBbbmV3Rm9sZGVyLCAuLi5maW5hbmNpYWxGb2xkZXJzXSxcbiAgICAgICAgICAgICAgc2hvd0ZpbmFuY2lhbENhdGVnb3J5OiB0cnVlLCAvLyBFbnN1cmUgZmluYW5jaWFsIGNhdGVnb3J5IGlzIHZpc2libGVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZXQoe1xuICAgICAgICAgICAgICBwcm9qZWN0Rm9sZGVyczogW25ld0ZvbGRlciwgLi4ucHJvamVjdEZvbGRlcnNdLFxuICAgICAgICAgICAgICBzaG93UHJvamVjdHNDYXRlZ29yeTogdHJ1ZSwgLy8gRW5zdXJlIHByb2plY3RzIGNhdGVnb3J5IGlzIHZpc2libGVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvLyBFbWVyZ2VuY3kgY2xlYW51cCBmdW5jdGlvbiBmb3IgZHVwbGljYXRlIGZvbGRlciBJRHNcbiAgICAgICAgY2xlYW51cER1cGxpY2F0ZUZvbGRlcnM6ICgpID0+IHtcbiAgICAgICAgICBjb25zdCB7IHByb2plY3RGb2xkZXJzLCBmaW5hbmNpYWxGb2xkZXJzIH0gPSBnZXQoKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBGdW5jdGlvbiB0byByZW1vdmUgZHVwbGljYXRlcyBhbmQgZml4IGJhZCBJRHNcbiAgICAgICAgICBjb25zdCBjbGVhbnVwRm9sZGVycyA9IChmb2xkZXJzOiBQcm9qZWN0Rm9sZGVyW10pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHNlZW4gPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgICAgICAgICAgIGNvbnN0IGNsZWFuZWQgPSBmb2xkZXJzLmZpbHRlcihmb2xkZXIgPT4ge1xuICAgICAgICAgICAgICAvLyBSZW1vdmUgZm9sZGVycyB3aXRoIHRoZSBwcm9ibGVtYXRpYyBrZXkgcGF0dGVyblxuICAgICAgICAgICAgICBpZiAoZm9sZGVyLmlkLmluY2x1ZGVzKCdmb2xkZXItaW5kZXgtMTc1MzA2NDUwODkzOScpKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYPCfp7kgUmVtb3ZpbmcgcHJvYmxlbWF0aWMgZm9sZGVyOiAke2ZvbGRlci5pZH0gKCR7Zm9sZGVyLm5hbWV9KWApO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgLy8gUmVtb3ZlIGR1cGxpY2F0ZSBJRHNcbiAgICAgICAgICAgICAgaWYgKHNlZW4uaGFzKGZvbGRlci5pZCkpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhg8J+nuSBSZW1vdmluZyBkdXBsaWNhdGUgZm9sZGVyOiAke2ZvbGRlci5pZH0gKCR7Zm9sZGVyLm5hbWV9KWApO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgc2Vlbi5hZGQoZm9sZGVyLmlkKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gUmVnZW5lcmF0ZSBJRHMgZm9yIGFueSByZW1haW5pbmcgZm9sZGVycyB3aXRoIG9sZCBwYXR0ZXJuc1xuICAgICAgICAgICAgcmV0dXJuIGNsZWFuZWQubWFwKGZvbGRlciA9PiB7XG4gICAgICAgICAgICAgIGlmIChmb2xkZXIuaWQuc3RhcnRzV2l0aCgnZm9sZGVyLWluZGV4LScpIHx8IGZvbGRlci5pZC5sZW5ndGggPCAyMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0lkID0gdHlwZW9mIGNyeXB0byAhPT0gJ3VuZGVmaW5lZCcgJiYgY3J5cHRvLnJhbmRvbVVVSURcbiAgICAgICAgICAgICAgICAgID8gYGZvbGRlci0ke2ZvbGRlci5uYW1lLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvW15hLXowLTldL2csICctJyl9LSR7Y3J5cHRvLnJhbmRvbVVVSUQoKX1gXG4gICAgICAgICAgICAgICAgICA6IGBmb2xkZXItJHtmb2xkZXIubmFtZS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1teYS16MC05XS9nLCAnLScpfS0ke0RhdGUubm93KCl9LSR7TWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDIsIDEyKX1gO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGDwn5SEIFJlZ2VuZXJhdGluZyBJRCBmb3IgZm9sZGVyOiAke2ZvbGRlci5pZH0g4oaSICR7bmV3SWR9ICgke2ZvbGRlci5uYW1lfSlgKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICByZXR1cm4geyAuLi5mb2xkZXIsIGlkOiBuZXdJZCB9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBmb2xkZXI7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIFxuICAgICAgICAgIGNvbnN0IGNsZWFuZWRQcm9qZWN0Rm9sZGVycyA9IGNsZWFudXBGb2xkZXJzKHByb2plY3RGb2xkZXJzKTtcbiAgICAgICAgICBjb25zdCBjbGVhbmVkRmluYW5jaWFsRm9sZGVycyA9IGNsZWFudXBGb2xkZXJzKGZpbmFuY2lhbEZvbGRlcnMpO1xuICAgICAgICAgIFxuICAgICAgICAgIGlmIChjbGVhbmVkUHJvamVjdEZvbGRlcnMubGVuZ3RoICE9PSBwcm9qZWN0Rm9sZGVycy5sZW5ndGggfHwgXG4gICAgICAgICAgICAgIGNsZWFuZWRGaW5hbmNpYWxGb2xkZXJzLmxlbmd0aCAhPT0gZmluYW5jaWFsRm9sZGVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCfwn6e5IENsZWFudXAgY29tcGxldGVkLCB1cGRhdGluZyBzdG9yZS4uLicpO1xuICAgICAgICAgICAgc2V0KHtcbiAgICAgICAgICAgICAgcHJvamVjdEZvbGRlcnM6IGNsZWFuZWRQcm9qZWN0Rm9sZGVycyxcbiAgICAgICAgICAgICAgZmluYW5jaWFsRm9sZGVyczogY2xlYW5lZEZpbmFuY2lhbEZvbGRlcnNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBkZWxldGVGaWxlOiAoZmlsZUlkOiBzdHJpbmcpID0+IHtcbiAgICAgICAgICBjb25zdCB7IHByb2plY3RGaWxlcywgZmluYW5jaWFsRmlsZXMsIG9wZW5UYWJzIH0gPSBnZXQoKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBGaW5kIGFuZCByZW1vdmUgZnJvbSBhcHByb3ByaWF0ZSBhcnJheVxuICAgICAgICAgIGNvbnN0IHVwZGF0ZWRQcm9qZWN0RmlsZXMgPSBwcm9qZWN0RmlsZXMuZmlsdGVyKChmaWxlOiBQcm9qZWN0RmlsZSkgPT4gZmlsZS5pZCAhPT0gZmlsZUlkKTtcbiAgICAgICAgICBjb25zdCB1cGRhdGVkRmluYW5jaWFsRmlsZXMgPSBmaW5hbmNpYWxGaWxlcy5maWx0ZXIoKGZpbGU6IFByb2plY3RGaWxlKSA9PiBmaWxlLmlkICE9PSBmaWxlSWQpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIENsb3NlIHRhYiBpZiBpdCdzIG9wZW5cbiAgICAgICAgICBjb25zdCB0YWJUb0Nsb3NlID0gb3BlblRhYnMuZmluZCgodGFiOiBFZGl0b3JUYWIpID0+IHRhYi5pZCA9PT0gZmlsZUlkKTtcbiAgICAgICAgICBpZiAodGFiVG9DbG9zZSkge1xuICAgICAgICAgICAgZ2V0KCkuY2xvc2VUYWIoZmlsZUlkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgc2V0KHsgXG4gICAgICAgICAgICBwcm9qZWN0RmlsZXM6IHVwZGF0ZWRQcm9qZWN0RmlsZXMsXG4gICAgICAgICAgICBmaW5hbmNpYWxGaWxlczogdXBkYXRlZEZpbmFuY2lhbEZpbGVzIFxuICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlbmFtZUZpbGU6IChmaWxlSWQ6IHN0cmluZywgbmV3TmFtZTogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgY29uc3QgeyBwcm9qZWN0RmlsZXMsIGZpbmFuY2lhbEZpbGVzLCBvcGVuVGFicyB9ID0gZ2V0KCk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gRmluZCB0aGUgZmlsZSB0byBnZXQgaXRzIHR5cGUgYW5kIGdlbmVyYXRlIG5ldyBmaWxlbmFtZSB3aXRoIGV4dGVuc2lvblxuICAgICAgICAgIGNvbnN0IHByb2plY3RGaWxlID0gcHJvamVjdEZpbGVzLmZpbmQoKGZpbGU6IFByb2plY3RGaWxlKSA9PiBmaWxlLmlkID09PSBmaWxlSWQpO1xuICAgICAgICAgIGNvbnN0IGZpbmFuY2lhbEZpbGUgPSBmaW5hbmNpYWxGaWxlcy5maW5kKChmaWxlOiBQcm9qZWN0RmlsZSkgPT4gZmlsZS5pZCA9PT0gZmlsZUlkKTtcbiAgICAgICAgICBjb25zdCBmaWxlID0gcHJvamVjdEZpbGUgfHwgZmluYW5jaWFsRmlsZTtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAoIWZpbGUpIHJldHVybjtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBHZW5lcmF0ZSBuZXcgZmlsZW5hbWUgd2l0aCBhcHByb3ByaWF0ZSBleHRlbnNpb25cbiAgICAgICAgICBjb25zdCBuZXdGaWxlTmFtZSA9IGAke25ld05hbWV9JHtnZXRGaWxlRXh0ZW5zaW9uKGZpbGUudHlwZSl9YDtcbiAgICAgICAgICBjb25zdCBiYXNlUGF0aCA9IGZpbGUuY2F0ZWdvcnkgPT09ICdmaW5hbmNpYWwnID8gJy9maW5hbmNpYWwtZGF0YScgOiAnL2VhYy1wcm9qZWN0cyc7XG4gICAgICAgICAgY29uc3QgbmV3RmlsZVBhdGggPSBgJHtiYXNlUGF0aH0vJHtuZXdGaWxlTmFtZX1gO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgZmlsZSBpbiBhcHByb3ByaWF0ZSBhcnJheVxuICAgICAgICAgIGNvbnN0IHVwZGF0ZWRQcm9qZWN0RmlsZXMgPSBwcm9qZWN0RmlsZXMubWFwKChmOiBQcm9qZWN0RmlsZSkgPT5cbiAgICAgICAgICAgIGYuaWQgPT09IGZpbGVJZFxuICAgICAgICAgICAgICA/IHsgLi4uZiwgbmFtZTogbmV3RmlsZU5hbWUsIGZpbGVQYXRoOiBuZXdGaWxlUGF0aCwgbW9kaWZpZWRBdDogbmV3IERhdGUoKSB9XG4gICAgICAgICAgICAgIDogZlxuICAgICAgICAgICk7XG5cbiAgICAgICAgICBjb25zdCB1cGRhdGVkRmluYW5jaWFsRmlsZXMgPSBmaW5hbmNpYWxGaWxlcy5tYXAoKGY6IFByb2plY3RGaWxlKSA9PlxuICAgICAgICAgICAgZi5pZCA9PT0gZmlsZUlkXG4gICAgICAgICAgICAgID8geyAuLi5mLCBuYW1lOiBuZXdGaWxlTmFtZSwgZmlsZVBhdGg6IG5ld0ZpbGVQYXRoLCBtb2RpZmllZEF0OiBuZXcgRGF0ZSgpIH1cbiAgICAgICAgICAgICAgOiBmXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIC8vIFVwZGF0ZSBvcGVuIHRhYnMgaWYgdGhlIGZpbGUgaXMgb3BlblxuICAgICAgICAgIGNvbnN0IHVwZGF0ZWRUYWJzID0gb3BlblRhYnMubWFwKCh0YWI6IEVkaXRvclRhYikgPT5cbiAgICAgICAgICAgIHRhYi5pZCA9PT0gZmlsZUlkXG4gICAgICAgICAgICAgID8geyAuLi50YWIsIG5hbWU6IG5ld0ZpbGVOYW1lLCBmaWxlUGF0aDogbmV3RmlsZVBhdGgsIG1vZGlmaWVkOiB0cnVlIH1cbiAgICAgICAgICAgICAgOiB0YWJcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgc2V0KHtcbiAgICAgICAgICAgIHByb2plY3RGaWxlczogdXBkYXRlZFByb2plY3RGaWxlcyxcbiAgICAgICAgICAgIGZpbmFuY2lhbEZpbGVzOiB1cGRhdGVkRmluYW5jaWFsRmlsZXMsXG4gICAgICAgICAgICBvcGVuVGFiczogdXBkYXRlZFRhYnMsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVuYW1lRm9sZGVyOiAoZm9sZGVySWQ6IHN0cmluZywgbmV3TmFtZTogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgY29uc3QgeyBwcm9qZWN0Rm9sZGVycywgZmluYW5jaWFsRm9sZGVycyB9ID0gZ2V0KCk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gVXBkYXRlIHRoZSBmb2xkZXIgaW4gYXBwcm9wcmlhdGUgYXJyYXlcbiAgICAgICAgICBjb25zdCB1cGRhdGVkUHJvamVjdEZvbGRlcnMgPSBwcm9qZWN0Rm9sZGVycy5tYXAoKGZvbGRlcjogUHJvamVjdEZvbGRlcikgPT5cbiAgICAgICAgICAgIGZvbGRlci5pZCA9PT0gZm9sZGVySWRcbiAgICAgICAgICAgICAgPyB7IC4uLmZvbGRlciwgbmFtZTogbmV3TmFtZSB9XG4gICAgICAgICAgICAgIDogZm9sZGVyXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIGNvbnN0IHVwZGF0ZWRGaW5hbmNpYWxGb2xkZXJzID0gZmluYW5jaWFsRm9sZGVycy5tYXAoKGZvbGRlcjogUHJvamVjdEZvbGRlcikgPT5cbiAgICAgICAgICAgIGZvbGRlci5pZCA9PT0gZm9sZGVySWRcbiAgICAgICAgICAgICAgPyB7IC4uLmZvbGRlciwgbmFtZTogbmV3TmFtZSB9XG4gICAgICAgICAgICAgIDogZm9sZGVyXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIHNldCh7XG4gICAgICAgICAgICBwcm9qZWN0Rm9sZGVyczogdXBkYXRlZFByb2plY3RGb2xkZXJzLFxuICAgICAgICAgICAgZmluYW5jaWFsRm9sZGVyczogdXBkYXRlZEZpbmFuY2lhbEZvbGRlcnMsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGVsZXRlRm9sZGVyOiAoZm9sZGVySWQ6IHN0cmluZykgPT4ge1xuICAgICAgICAgIGNvbnN0IHsgcHJvamVjdEZvbGRlcnMsIGZpbmFuY2lhbEZvbGRlcnMsIHByb2plY3RGaWxlcywgZmluYW5jaWFsRmlsZXMsIG9wZW5UYWJzIH0gPSBnZXQoKTtcblxuICAgICAgICAgIC8vIEZpbmQgYWxsIGZpbGVzIHRoYXQgd2VyZSBpbiB0aGlzIGZvbGRlclxuICAgICAgICAgIGNvbnN0IGZpbGVzVG9EZWxldGUgPSBbXG4gICAgICAgICAgICAuLi5wcm9qZWN0RmlsZXMuZmlsdGVyKChmaWxlOiBQcm9qZWN0RmlsZSkgPT4gZmlsZS5mb2xkZXJJZCA9PT0gZm9sZGVySWQpLFxuICAgICAgICAgICAgLi4uZmluYW5jaWFsRmlsZXMuZmlsdGVyKChmaWxlOiBQcm9qZWN0RmlsZSkgPT4gZmlsZS5mb2xkZXJJZCA9PT0gZm9sZGVySWQpXG4gICAgICAgICAgXTtcblxuICAgICAgICAgIC8vIENsb3NlIHRhYnMgZm9yIGFsbCBmaWxlcyBpbiB0aGlzIGZvbGRlclxuICAgICAgICAgIGZpbGVzVG9EZWxldGUuZm9yRWFjaCgoZmlsZTogUHJvamVjdEZpbGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRhYlRvQ2xvc2UgPSBvcGVuVGFicy5maW5kKCh0YWI6IEVkaXRvclRhYikgPT4gdGFiLmlkID09PSBmaWxlLmlkKTtcbiAgICAgICAgICAgIGlmICh0YWJUb0Nsb3NlKSB7XG4gICAgICAgICAgICAgIGdldCgpLmNsb3NlVGFiKGZpbGUuaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIFJlbW92ZSBmcm9tIGFwcHJvcHJpYXRlIGZvbGRlciBhcnJheVxuICAgICAgICAgIGNvbnN0IHVwZGF0ZWRQcm9qZWN0Rm9sZGVycyA9IHByb2plY3RGb2xkZXJzLmZpbHRlcigoZm9sZGVyOiBQcm9qZWN0Rm9sZGVyKSA9PiBmb2xkZXIuaWQgIT09IGZvbGRlcklkKTtcbiAgICAgICAgICBjb25zdCB1cGRhdGVkRmluYW5jaWFsRm9sZGVycyA9IGZpbmFuY2lhbEZvbGRlcnMuZmlsdGVyKChmb2xkZXI6IFByb2plY3RGb2xkZXIpID0+IGZvbGRlci5pZCAhPT0gZm9sZGVySWQpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIEFsc28gcmVtb3ZlIGFueSBmaWxlcyB0aGF0IHdlcmUgaW4gdGhpcyBmb2xkZXJcbiAgICAgICAgICBjb25zdCB1cGRhdGVkUHJvamVjdEZpbGVzID0gcHJvamVjdEZpbGVzLmZpbHRlcigoZmlsZTogUHJvamVjdEZpbGUpID0+IGZpbGUuZm9sZGVySWQgIT09IGZvbGRlcklkKTtcbiAgICAgICAgICBjb25zdCB1cGRhdGVkRmluYW5jaWFsRmlsZXMgPSBmaW5hbmNpYWxGaWxlcy5maWx0ZXIoKGZpbGU6IFByb2plY3RGaWxlKSA9PiBmaWxlLmZvbGRlcklkICE9PSBmb2xkZXJJZCk7XG4gICAgICAgICAgXG4gICAgICAgICAgc2V0KHsgXG4gICAgICAgICAgICBwcm9qZWN0Rm9sZGVyczogdXBkYXRlZFByb2plY3RGb2xkZXJzLFxuICAgICAgICAgICAgZmluYW5jaWFsRm9sZGVyczogdXBkYXRlZEZpbmFuY2lhbEZvbGRlcnMsXG4gICAgICAgICAgICBwcm9qZWN0RmlsZXM6IHVwZGF0ZWRQcm9qZWN0RmlsZXMsXG4gICAgICAgICAgICBmaW5hbmNpYWxGaWxlczogdXBkYXRlZEZpbmFuY2lhbEZpbGVzXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgbW92ZVRvVHJhc2g6IChpdGVtOiBQcm9qZWN0RmlsZSB8IFByb2plY3RGb2xkZXIsIHR5cGU6ICdmaWxlJyB8ICdmb2xkZXInKSA9PiB7XG4gICAgICAgICAgY29uc3QgeyB0cmFzaEl0ZW1zLCBwcm9qZWN0RmlsZXMsIGZpbmFuY2lhbEZpbGVzLCBwcm9qZWN0Rm9sZGVycywgZmluYW5jaWFsRm9sZGVycywgb3BlblRhYnMgfSA9IGdldCgpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIENyZWF0ZSB0cmFzaCBpdGVtXG4gICAgICAgICAgY29uc3QgdHJhc2hJdGVtOiBUcmFzaEl0ZW0gPSB7XG4gICAgICAgICAgICBpZDogYHRyYXNoXyR7aXRlbS5pZH1fJHtEYXRlLm5vdygpfWAsXG4gICAgICAgICAgICBuYW1lOiBpdGVtLm5hbWUsXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgb3JpZ2luYWxEYXRhOiBpdGVtLFxuICAgICAgICAgICAgZGVsZXRlZEF0OiBuZXcgRGF0ZSgpLFxuICAgICAgICAgICAgY2F0ZWdvcnk6IGl0ZW0uY2F0ZWdvcnlcbiAgICAgICAgICB9O1xuICAgICAgICAgIFxuICAgICAgICAgIGlmICh0eXBlID09PSAnZmlsZScpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpbGUgPSBpdGVtIGFzIFByb2plY3RGaWxlO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBDbG9zZSB0YWIgaWYgaXQncyBvcGVuXG4gICAgICAgICAgICBjb25zdCB0YWJUb0Nsb3NlID0gb3BlblRhYnMuZmluZCgodGFiOiBFZGl0b3JUYWIpID0+IHRhYi5pZCA9PT0gZmlsZS5pZCk7XG4gICAgICAgICAgICBpZiAodGFiVG9DbG9zZSkge1xuICAgICAgICAgICAgICBnZXQoKS5jbG9zZVRhYihmaWxlLmlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gUmVtb3ZlIGZyb20gYXBwcm9wcmlhdGUgZmlsZSBhcnJheVxuICAgICAgICAgICAgY29uc3QgdXBkYXRlZFByb2plY3RGaWxlcyA9IHByb2plY3RGaWxlcy5maWx0ZXIoKGY6IFByb2plY3RGaWxlKSA9PiBmLmlkICE9PSBmaWxlLmlkKTtcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRGaW5hbmNpYWxGaWxlcyA9IGZpbmFuY2lhbEZpbGVzLmZpbHRlcigoZjogUHJvamVjdEZpbGUpID0+IGYuaWQgIT09IGZpbGUuaWQpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBzZXQoe1xuICAgICAgICAgICAgICB0cmFzaEl0ZW1zOiBbLi4udHJhc2hJdGVtcywgdHJhc2hJdGVtXSxcbiAgICAgICAgICAgICAgcHJvamVjdEZpbGVzOiB1cGRhdGVkUHJvamVjdEZpbGVzLFxuICAgICAgICAgICAgICBmaW5hbmNpYWxGaWxlczogdXBkYXRlZEZpbmFuY2lhbEZpbGVzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgZm9sZGVyID0gaXRlbSBhcyBQcm9qZWN0Rm9sZGVyO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBGaW5kIGFsbCBmaWxlcyB0aGF0IHdlcmUgaW4gdGhpcyBmb2xkZXIgYW5kIG1vdmUgdGhlbSB0byB0cmFzaCB0b29cbiAgICAgICAgICAgIGNvbnN0IGZpbGVzVG9UcmFzaCA9IFtcbiAgICAgICAgICAgICAgLi4ucHJvamVjdEZpbGVzLmZpbHRlcigoZmlsZTogUHJvamVjdEZpbGUpID0+IGZpbGUuZm9sZGVySWQgPT09IGZvbGRlci5pZCksXG4gICAgICAgICAgICAgIC4uLmZpbmFuY2lhbEZpbGVzLmZpbHRlcigoZmlsZTogUHJvamVjdEZpbGUpID0+IGZpbGUuZm9sZGVySWQgPT09IGZvbGRlci5pZClcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIENsb3NlIHRhYnMgZm9yIGFsbCBmaWxlcyBpbiB0aGlzIGZvbGRlclxuICAgICAgICAgICAgZmlsZXNUb1RyYXNoLmZvckVhY2goKGZpbGU6IFByb2plY3RGaWxlKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IHRhYlRvQ2xvc2UgPSBvcGVuVGFicy5maW5kKCh0YWI6IEVkaXRvclRhYikgPT4gdGFiLmlkID09PSBmaWxlLmlkKTtcbiAgICAgICAgICAgICAgaWYgKHRhYlRvQ2xvc2UpIHtcbiAgICAgICAgICAgICAgICBnZXQoKS5jbG9zZVRhYihmaWxlLmlkKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIENyZWF0ZSB0cmFzaCBpdGVtcyBmb3IgYWxsIGZpbGVzIGluIHRoZSBmb2xkZXJcbiAgICAgICAgICAgIGNvbnN0IGZpbGVUcmFzaEl0ZW1zID0gZmlsZXNUb1RyYXNoLm1hcCgoZmlsZTogUHJvamVjdEZpbGUpID0+ICh7XG4gICAgICAgICAgICAgIGlkOiBgdHJhc2hfJHtmaWxlLmlkfV8ke0RhdGUubm93KCl9YCxcbiAgICAgICAgICAgICAgbmFtZTogZmlsZS5uYW1lLFxuICAgICAgICAgICAgICB0eXBlOiAnZmlsZScgYXMgY29uc3QsXG4gICAgICAgICAgICAgIG9yaWdpbmFsRGF0YTogZmlsZSxcbiAgICAgICAgICAgICAgZGVsZXRlZEF0OiBuZXcgRGF0ZSgpLFxuICAgICAgICAgICAgICBjYXRlZ29yeTogZmlsZS5jYXRlZ29yeVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBSZW1vdmUgZm9sZGVyIGFuZCBpdHMgZmlsZXMgZnJvbSBhcnJheXNcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRQcm9qZWN0Rm9sZGVycyA9IHByb2plY3RGb2xkZXJzLmZpbHRlcigoZjogUHJvamVjdEZvbGRlcikgPT4gZi5pZCAhPT0gZm9sZGVyLmlkKTtcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRGaW5hbmNpYWxGb2xkZXJzID0gZmluYW5jaWFsRm9sZGVycy5maWx0ZXIoKGY6IFByb2plY3RGb2xkZXIpID0+IGYuaWQgIT09IGZvbGRlci5pZCk7XG4gICAgICAgICAgICBjb25zdCB1cGRhdGVkUHJvamVjdEZpbGVzID0gcHJvamVjdEZpbGVzLmZpbHRlcigoZmlsZTogUHJvamVjdEZpbGUpID0+IGZpbGUuZm9sZGVySWQgIT09IGZvbGRlci5pZCk7XG4gICAgICAgICAgICBjb25zdCB1cGRhdGVkRmluYW5jaWFsRmlsZXMgPSBmaW5hbmNpYWxGaWxlcy5maWx0ZXIoKGZpbGU6IFByb2plY3RGaWxlKSA9PiBmaWxlLmZvbGRlcklkICE9PSBmb2xkZXIuaWQpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBzZXQoe1xuICAgICAgICAgICAgICB0cmFzaEl0ZW1zOiBbLi4udHJhc2hJdGVtcywgdHJhc2hJdGVtLCAuLi5maWxlVHJhc2hJdGVtc10sXG4gICAgICAgICAgICAgIHByb2plY3RGb2xkZXJzOiB1cGRhdGVkUHJvamVjdEZvbGRlcnMsXG4gICAgICAgICAgICAgIGZpbmFuY2lhbEZvbGRlcnM6IHVwZGF0ZWRGaW5hbmNpYWxGb2xkZXJzLFxuICAgICAgICAgICAgICBwcm9qZWN0RmlsZXM6IHVwZGF0ZWRQcm9qZWN0RmlsZXMsXG4gICAgICAgICAgICAgIGZpbmFuY2lhbEZpbGVzOiB1cGRhdGVkRmluYW5jaWFsRmlsZXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICByZXN0b3JlRnJvbVRyYXNoOiAodHJhc2hJdGVtSWQ6IHN0cmluZykgPT4ge1xuICAgICAgICAgIGNvbnN0IHsgdHJhc2hJdGVtcywgcHJvamVjdEZpbGVzLCBmaW5hbmNpYWxGaWxlcywgcHJvamVjdEZvbGRlcnMsIGZpbmFuY2lhbEZvbGRlcnMgfSA9IGdldCgpO1xuICAgICAgICAgIFxuICAgICAgICAgIGNvbnN0IHRyYXNoSXRlbSA9IHRyYXNoSXRlbXMuZmluZChpdGVtID0+IGl0ZW0uaWQgPT09IHRyYXNoSXRlbUlkKTtcbiAgICAgICAgICBpZiAoIXRyYXNoSXRlbSkgcmV0dXJuO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIFJlbW92ZSBmcm9tIHRyYXNoXG4gICAgICAgICAgY29uc3QgdXBkYXRlZFRyYXNoSXRlbXMgPSB0cmFzaEl0ZW1zLmZpbHRlcihpdGVtID0+IGl0ZW0uaWQgIT09IHRyYXNoSXRlbUlkKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBSZXN0b3JlIHRvIGFwcHJvcHJpYXRlIGFycmF5XG4gICAgICAgICAgaWYgKHRyYXNoSXRlbS50eXBlID09PSAnZmlsZScpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpbGUgPSB0cmFzaEl0ZW0ub3JpZ2luYWxEYXRhIGFzIFByb2plY3RGaWxlO1xuICAgICAgICAgICAgaWYgKGZpbGUuY2F0ZWdvcnkgPT09ICdwcm9qZWN0Jykge1xuICAgICAgICAgICAgICBzZXQoe1xuICAgICAgICAgICAgICAgIHRyYXNoSXRlbXM6IHVwZGF0ZWRUcmFzaEl0ZW1zLFxuICAgICAgICAgICAgICAgIHByb2plY3RGaWxlczogWy4uLnByb2plY3RGaWxlcywgeyAuLi5maWxlLCBtb2RpZmllZEF0OiBuZXcgRGF0ZSgpIH1dXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc2V0KHtcbiAgICAgICAgICAgICAgICB0cmFzaEl0ZW1zOiB1cGRhdGVkVHJhc2hJdGVtcyxcbiAgICAgICAgICAgICAgICBmaW5hbmNpYWxGaWxlczogWy4uLmZpbmFuY2lhbEZpbGVzLCB7IC4uLmZpbGUsIG1vZGlmaWVkQXQ6IG5ldyBEYXRlKCkgfV1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGZvbGRlciA9IHRyYXNoSXRlbS5vcmlnaW5hbERhdGEgYXMgUHJvamVjdEZvbGRlcjtcbiAgICAgICAgICAgIGlmIChmb2xkZXIuY2F0ZWdvcnkgPT09ICdwcm9qZWN0Jykge1xuICAgICAgICAgICAgICBzZXQoe1xuICAgICAgICAgICAgICAgIHRyYXNoSXRlbXM6IHVwZGF0ZWRUcmFzaEl0ZW1zLFxuICAgICAgICAgICAgICAgIHByb2plY3RGb2xkZXJzOiBbLi4ucHJvamVjdEZvbGRlcnMsIGZvbGRlcl1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzZXQoe1xuICAgICAgICAgICAgICAgIHRyYXNoSXRlbXM6IHVwZGF0ZWRUcmFzaEl0ZW1zLFxuICAgICAgICAgICAgICAgIGZpbmFuY2lhbEZvbGRlcnM6IFsuLi5maW5hbmNpYWxGb2xkZXJzLCBmb2xkZXJdXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBwZXJtYW5lbnRseURlbGV0ZTogKHRyYXNoSXRlbUlkOiBzdHJpbmcpID0+IHtcbiAgICAgICAgICBjb25zdCB7IHRyYXNoSXRlbXMgfSA9IGdldCgpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIFJlbW92ZSBmcm9tIHRyYXNoIHBlcm1hbmVudGx5XG4gICAgICAgICAgY29uc3QgdXBkYXRlZFRyYXNoSXRlbXMgPSB0cmFzaEl0ZW1zLmZpbHRlcihpdGVtID0+IGl0ZW0uaWQgIT09IHRyYXNoSXRlbUlkKTtcbiAgICAgICAgICBzZXQoeyB0cmFzaEl0ZW1zOiB1cGRhdGVkVHJhc2hJdGVtcyB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBlbXB0eVRyYXNoOiAoKSA9PiB7XG4gICAgICAgICAgc2V0KHsgdHJhc2hJdGVtczogW10gfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY2xlYXJQcm9qZWN0Q2F0ZWdvcnk6ICgpID0+IHtcbiAgICAgICAgICBjb25zdCB7IG9wZW5UYWJzIH0gPSBnZXQoKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBDbG9zZSBhbGwgcHJvamVjdC1yZWxhdGVkIHRhYnNcbiAgICAgICAgICBjb25zdCBwcm9qZWN0VGFiSWRzID0gb3BlblRhYnNcbiAgICAgICAgICAgIC5maWx0ZXIoKHRhYjogRWRpdG9yVGFiKSA9PiB7XG4gICAgICAgICAgICAgIC8vIEZpbmQgdGhlIGNvcnJlc3BvbmRpbmcgZmlsZSB0byBjaGVjayBpdHMgY2F0ZWdvcnlcbiAgICAgICAgICAgICAgY29uc3QgeyBwcm9qZWN0RmlsZXMgfSA9IGdldCgpO1xuICAgICAgICAgICAgICBjb25zdCBmaWxlID0gcHJvamVjdEZpbGVzLmZpbmQoKGY6IFByb2plY3RGaWxlKSA9PiBmLmlkID09PSB0YWIuaWQpO1xuICAgICAgICAgICAgICByZXR1cm4gZmlsZT8uY2F0ZWdvcnkgPT09ICdwcm9qZWN0JztcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAubWFwKCh0YWI6IEVkaXRvclRhYikgPT4gdGFiLmlkKTtcbiAgICAgICAgICBcbiAgICAgICAgICBwcm9qZWN0VGFiSWRzLmZvckVhY2goKHRhYklkOiBzdHJpbmcpID0+IGdldCgpLmNsb3NlVGFiKHRhYklkKSk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQ2xlYXIgYWxsIHByb2plY3QgZmlsZXMgYW5kIGZvbGRlcnNcbiAgICAgICAgICBzZXQoe1xuICAgICAgICAgICAgcHJvamVjdEZpbGVzOiBbXSxcbiAgICAgICAgICAgIHByb2plY3RGb2xkZXJzOiBbXSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBjbGVhckZpbmFuY2lhbENhdGVnb3J5OiAoKSA9PiB7XG4gICAgICAgICAgY29uc3QgeyBvcGVuVGFicyB9ID0gZ2V0KCk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQ2xvc2UgYWxsIGZpbmFuY2lhbC1yZWxhdGVkIHRhYnNcbiAgICAgICAgICBjb25zdCBmaW5hbmNpYWxUYWJJZHMgPSBvcGVuVGFic1xuICAgICAgICAgICAgLmZpbHRlcigodGFiOiBFZGl0b3JUYWIpID0+IHtcbiAgICAgICAgICAgICAgLy8gRmluZCB0aGUgY29ycmVzcG9uZGluZyBmaWxlIHRvIGNoZWNrIGl0cyBjYXRlZ29yeVxuICAgICAgICAgICAgICBjb25zdCB7IGZpbmFuY2lhbEZpbGVzIH0gPSBnZXQoKTtcbiAgICAgICAgICAgICAgY29uc3QgZmlsZSA9IGZpbmFuY2lhbEZpbGVzLmZpbmQoKGY6IFByb2plY3RGaWxlKSA9PiBmLmlkID09PSB0YWIuaWQpO1xuICAgICAgICAgICAgICByZXR1cm4gZmlsZT8uY2F0ZWdvcnkgPT09ICdmaW5hbmNpYWwnO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5tYXAoKHRhYjogRWRpdG9yVGFiKSA9PiB0YWIuaWQpO1xuICAgICAgICAgIFxuICAgICAgICAgIGZpbmFuY2lhbFRhYklkcy5mb3JFYWNoKCh0YWJJZDogc3RyaW5nKSA9PiBnZXQoKS5jbG9zZVRhYih0YWJJZCkpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIENsZWFyIGFsbCBmaW5hbmNpYWwgZmlsZXMgYW5kIGZvbGRlcnNcbiAgICAgICAgICBzZXQoe1xuICAgICAgICAgICAgZmluYW5jaWFsRmlsZXM6IFtdLFxuICAgICAgICAgICAgZmluYW5jaWFsRm9sZGVyczogW10sXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGVsZXRlUHJvamVjdHNDYXRlZ29yeTogKCkgPT4ge1xuICAgICAgICAgIGdldCgpLmNsZWFyUHJvamVjdENhdGVnb3J5KCk7XG4gICAgICAgICAgc2V0KHsgc2hvd1Byb2plY3RzQ2F0ZWdvcnk6IGZhbHNlIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIGRlbGV0ZUZpbmFuY2lhbENhdGVnb3J5OiAoKSA9PiB7XG4gICAgICAgICAgZ2V0KCkuY2xlYXJGaW5hbmNpYWxDYXRlZ29yeSgpO1xuICAgICAgICAgIHNldCh7IHNob3dGaW5hbmNpYWxDYXRlZ29yeTogZmFsc2UgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVvcmRlclByb2plY3RGb2xkZXJzOiAoZnJvbUluZGV4OiBudW1iZXIsIHRvSW5kZXg6IG51bWJlcikgPT4ge1xuICAgICAgICAgIGNvbnN0IHsgcHJvamVjdEZvbGRlcnMgfSA9IGdldCgpO1xuICAgICAgICAgIGNvbnN0IG5ld0ZvbGRlcnMgPSBbLi4ucHJvamVjdEZvbGRlcnNdO1xuICAgICAgICAgIGNvbnN0IFttb3ZlZEZvbGRlcl0gPSBuZXdGb2xkZXJzLnNwbGljZShmcm9tSW5kZXgsIDEpO1xuICAgICAgICAgIG5ld0ZvbGRlcnMuc3BsaWNlKHRvSW5kZXgsIDAsIG1vdmVkRm9sZGVyKTtcbiAgICAgICAgICBcbiAgICAgICAgICBzZXQoeyBwcm9qZWN0Rm9sZGVyczogbmV3Rm9sZGVycyB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICB1cGRhdGVQcm9qZWN0Rm9sZGVyczogKGZvbGRlcnM6IFByb2plY3RGb2xkZXJbXSkgPT4ge1xuICAgICAgICAgIHNldCh7IHByb2plY3RGb2xkZXJzOiBmb2xkZXJzIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlb3JkZXJGaWxlc0luRm9sZGVyOiAoZm9sZGVySWQ6IHN0cmluZywgZnJvbUluZGV4OiBudW1iZXIsIHRvSW5kZXg6IG51bWJlciwgY2F0ZWdvcnk6ICdwcm9qZWN0JyB8ICdmaW5hbmNpYWwnKSA9PiB7XG4gICAgICAgICAgY29uc3QgeyBwcm9qZWN0RmlsZXMsIGZpbmFuY2lhbEZpbGVzIH0gPSBnZXQoKTtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAoY2F0ZWdvcnkgPT09ICdwcm9qZWN0Jykge1xuICAgICAgICAgICAgLy8gRmlsdGVyIGZpbGVzIGluIHRoZSBzcGVjaWZpYyBmb2xkZXJcbiAgICAgICAgICAgIGNvbnN0IGZvbGRlckZpbGVzID0gcHJvamVjdEZpbGVzLmZpbHRlcihmaWxlID0+IGZpbGUuZm9sZGVySWQgPT09IGZvbGRlcklkKTtcbiAgICAgICAgICAgIGNvbnN0IG90aGVyRmlsZXMgPSBwcm9qZWN0RmlsZXMuZmlsdGVyKGZpbGUgPT4gZmlsZS5mb2xkZXJJZCAhPT0gZm9sZGVySWQpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBSZW9yZGVyIGZpbGVzIHdpdGhpbiB0aGUgZm9sZGVyXG4gICAgICAgICAgICBjb25zdCByZW9yZGVyZWRGb2xkZXJGaWxlcyA9IFsuLi5mb2xkZXJGaWxlc107XG4gICAgICAgICAgICBjb25zdCBbbW92ZWRGaWxlXSA9IHJlb3JkZXJlZEZvbGRlckZpbGVzLnNwbGljZShmcm9tSW5kZXgsIDEpO1xuICAgICAgICAgICAgcmVvcmRlcmVkRm9sZGVyRmlsZXMuc3BsaWNlKHRvSW5kZXgsIDAsIG1vdmVkRmlsZSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIENvbWJpbmUgd2l0aCBvdGhlciBmaWxlc1xuICAgICAgICAgICAgY29uc3QgbmV3UHJvamVjdEZpbGVzID0gWy4uLm90aGVyRmlsZXMsIC4uLnJlb3JkZXJlZEZvbGRlckZpbGVzXTtcbiAgICAgICAgICAgIHNldCh7IHByb2plY3RGaWxlczogbmV3UHJvamVjdEZpbGVzIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBTaW1pbGFyIGxvZ2ljIGZvciBmaW5hbmNpYWwgZmlsZXNcbiAgICAgICAgICAgIGNvbnN0IGZvbGRlckZpbGVzID0gZmluYW5jaWFsRmlsZXMuZmlsdGVyKGZpbGUgPT4gZmlsZS5mb2xkZXJJZCA9PT0gZm9sZGVySWQpO1xuICAgICAgICAgICAgY29uc3Qgb3RoZXJGaWxlcyA9IGZpbmFuY2lhbEZpbGVzLmZpbHRlcihmaWxlID0+IGZpbGUuZm9sZGVySWQgIT09IGZvbGRlcklkKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY29uc3QgcmVvcmRlcmVkRm9sZGVyRmlsZXMgPSBbLi4uZm9sZGVyRmlsZXNdO1xuICAgICAgICAgICAgY29uc3QgW21vdmVkRmlsZV0gPSByZW9yZGVyZWRGb2xkZXJGaWxlcy5zcGxpY2UoZnJvbUluZGV4LCAxKTtcbiAgICAgICAgICAgIHJlb3JkZXJlZEZvbGRlckZpbGVzLnNwbGljZSh0b0luZGV4LCAwLCBtb3ZlZEZpbGUpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBjb25zdCBuZXdGaW5hbmNpYWxGaWxlcyA9IFsuLi5vdGhlckZpbGVzLCAuLi5yZW9yZGVyZWRGb2xkZXJGaWxlc107XG4gICAgICAgICAgICBzZXQoeyBmaW5hbmNpYWxGaWxlczogbmV3RmluYW5jaWFsRmlsZXMgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHNhdmVGaWxlOiAodGFiSWQ6IHN0cmluZykgPT4ge1xuICAgICAgICAgIGNvbnN0IHsgb3BlblRhYnMsIHByb2plY3RGaWxlcywgZmluYW5jaWFsRmlsZXMgfSA9IGdldCgpO1xuICAgICAgICAgIGNvbnN0IHRhYiA9IG9wZW5UYWJzLmZpbmQoKHQ6IEVkaXRvclRhYikgPT4gdC5pZCA9PT0gdGFiSWQpO1xuICAgICAgICAgIFxuICAgICAgICAgIGlmICghdGFiKSByZXR1cm47XG5cbiAgICAgICAgICAvLyBVcGRhdGUgdGhlIGZpbGUgY29udGVudCBpbiBhcHByb3ByaWF0ZSBhcnJheVxuICAgICAgICAgIGNvbnN0IHVwZGF0ZWRQcm9qZWN0RmlsZXMgPSBwcm9qZWN0RmlsZXMubWFwKChmaWxlOiBQcm9qZWN0RmlsZSkgPT5cbiAgICAgICAgICAgIGZpbGUuaWQgPT09IHRhYklkXG4gICAgICAgICAgICAgID8geyAuLi5maWxlLCBjb250ZW50OiB0YWIuY29udGVudCwgbW9kaWZpZWRBdDogbmV3IERhdGUoKSB9XG4gICAgICAgICAgICAgIDogZmlsZVxuICAgICAgICAgICk7XG5cbiAgICAgICAgICBjb25zdCB1cGRhdGVkRmluYW5jaWFsRmlsZXMgPSBmaW5hbmNpYWxGaWxlcy5tYXAoKGZpbGU6IFByb2plY3RGaWxlKSA9PlxuICAgICAgICAgICAgZmlsZS5pZCA9PT0gdGFiSWRcbiAgICAgICAgICAgICAgPyB7IC4uLmZpbGUsIGNvbnRlbnQ6IHRhYi5jb250ZW50LCBtb2RpZmllZEF0OiBuZXcgRGF0ZSgpIH1cbiAgICAgICAgICAgICAgOiBmaWxlXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIGNvbnN0IHVwZGF0ZWRUYWJzID0gb3BlblRhYnMubWFwKCh0OiBFZGl0b3JUYWIpID0+XG4gICAgICAgICAgICB0LmlkID09PSB0YWJJZFxuICAgICAgICAgICAgICA/IHsgLi4udCwgbW9kaWZpZWQ6IGZhbHNlIH1cbiAgICAgICAgICAgICAgOiB0XG4gICAgICAgICAgKTtcblxuICAgICAgICAgIHNldCh7XG4gICAgICAgICAgICBwcm9qZWN0RmlsZXM6IHVwZGF0ZWRQcm9qZWN0RmlsZXMsXG4gICAgICAgICAgICBmaW5hbmNpYWxGaWxlczogdXBkYXRlZEZpbmFuY2lhbEZpbGVzLFxuICAgICAgICAgICAgb3BlblRhYnM6IHVwZGF0ZWRUYWJzLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldEVycm9yOiAoZXJyb3I6IHN0cmluZyB8IG51bGwpID0+IHtcbiAgICAgICAgICBzZXQoeyBlcnJvciB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBGaXggZmlsZXMgdGhhdCBkb24ndCBoYXZlIGNvbnRlbnRcbiAgICAgICAgcmVwYWlyRmlsZXNXaXRob3V0Q29udGVudDogKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHsgcHJvamVjdEZpbGVzLCBmaW5hbmNpYWxGaWxlcyB9ID0gZ2V0KCk7XG4gICAgICAgICAgXG4gICAgICAgICAgY29uc3QgcmVwYWlyZWRQcm9qZWN0RmlsZXMgPSBwcm9qZWN0RmlsZXMubWFwKGZpbGUgPT4ge1xuICAgICAgICAgICAgaWYgKCFmaWxlLmNvbnRlbnQgfHwgZmlsZS5jb250ZW50LnRyaW0oKSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAuLi5maWxlLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGdldERlZmF1bHRDb250ZW50KGZpbGUudHlwZSwgZmlsZS5uYW1lKSxcbiAgICAgICAgICAgICAgICBtb2RpZmllZEF0OiBuZXcgRGF0ZSgpXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmlsZTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBcbiAgICAgICAgICBjb25zdCByZXBhaXJlZEZpbmFuY2lhbEZpbGVzID0gZmluYW5jaWFsRmlsZXMubWFwKGZpbGUgPT4ge1xuICAgICAgICAgICAgaWYgKCFmaWxlLmNvbnRlbnQgfHwgZmlsZS5jb250ZW50LnRyaW0oKSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAuLi5maWxlLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGdldERlZmF1bHRDb250ZW50KGZpbGUudHlwZSwgZmlsZS5uYW1lKSxcbiAgICAgICAgICAgICAgICBtb2RpZmllZEF0OiBuZXcgRGF0ZSgpXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmlsZTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBcbiAgICAgICAgICBzZXQoe1xuICAgICAgICAgICAgcHJvamVjdEZpbGVzOiByZXBhaXJlZFByb2plY3RGaWxlcyxcbiAgICAgICAgICAgIGZpbmFuY2lhbEZpbGVzOiByZXBhaXJlZEZpbmFuY2lhbEZpbGVzXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVzZXQ6ICgpID0+IHtcbiAgICAgICAgICBzZXQoe1xuICAgICAgICAgICAgb3BlblRhYnM6IFtdLFxuICAgICAgICAgICAgYWN0aXZlVGFiOiAnJyxcbiAgICAgICAgICAgIHByb2plY3RGaWxlczogaW5pdGlhbFByb2plY3RGaWxlcyxcbiAgICAgICAgICAgIGZpbmFuY2lhbEZpbGVzOiBpbml0aWFsRmluYW5jaWFsRmlsZXMsXG4gICAgICAgICAgICBwcm9qZWN0Rm9sZGVyczogW10sXG4gICAgICAgICAgICBmaW5hbmNpYWxGb2xkZXJzOiBbXSxcbiAgICAgICAgICAgIHNob3dQcm9qZWN0c0NhdGVnb3J5OiB0cnVlLFxuICAgICAgICAgICAgc2hvd0ZpbmFuY2lhbENhdGVnb3J5OiBmYWxzZSwgLy8gRG9uJ3QgYXV0by1zaG93IGZpbmFuY2lhbCBjYXRlZ29yeSBvbiByZXNldFxuICAgICAgICAgICAgaXNMb2FkaW5nOiBmYWxzZSxcbiAgICAgICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIENsZWFyIHVzZXIgZGF0YSB3aGVuIHNpZ25pbmcgb3V0IChidXQga2VlcCBVSSBzdGF0ZSBsaWtlIHRoZW1lLCBldGMuKVxuICAgICAgICBjbGVhclVzZXJEYXRhOiAoKSA9PiB7XG4gICAgICAgICAgc2V0KHtcbiAgICAgICAgICAgIG9wZW5UYWJzOiBbXSxcbiAgICAgICAgICAgIGFjdGl2ZVRhYjogJycsXG4gICAgICAgICAgICBwcm9qZWN0RmlsZXM6IFtdLFxuICAgICAgICAgICAgZmluYW5jaWFsRmlsZXM6IFtdLFxuICAgICAgICAgICAgcHJvamVjdEZvbGRlcnM6IFtdLFxuICAgICAgICAgICAgZmluYW5jaWFsRm9sZGVyczogW10sXG4gICAgICAgICAgICB0cmFzaEl0ZW1zOiBbXSxcbiAgICAgICAgICAgIHNob3dQcm9qZWN0c0NhdGVnb3J5OiB0cnVlLFxuICAgICAgICAgICAgc2hvd0ZpbmFuY2lhbENhdGVnb3J5OiBmYWxzZSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgIH0pLFxuICAgICAge1xuICAgICAgICBuYW1lOiAnZWRpdG9yLXN0b3JhZ2UnLFxuICAgICAgICB2ZXJzaW9uOiAxLCAvLyBBZGQgdmVyc2lvbiBmb3IgdGFiIHBpbm5pbmcgcGVyc2lzdGVuY2VcbiAgICAgICAgLy8gT25seSBwZXJzaXN0IHNwZWNpZmljIGZpZWxkc1xuICAgICAgICBwYXJ0aWFsaXplOiAoc3RhdGUpID0+ICh7IFxuICAgICAgICAgIG9wZW5UYWJzOiBzdGF0ZS5vcGVuVGFicy5tYXAodGFiID0+ICh7XG4gICAgICAgICAgICBpZDogdGFiLmlkLFxuICAgICAgICAgICAgbmFtZTogdGFiLm5hbWUsXG4gICAgICAgICAgICBtb2RpZmllZDogdGFiLm1vZGlmaWVkLFxuICAgICAgICAgICAgY29udGVudDogdGFiLmNvbnRlbnQsXG4gICAgICAgICAgICBmaWxlUGF0aDogdGFiLmZpbGVQYXRoLFxuICAgICAgICAgICAgdHlwZTogdGFiLnR5cGUsXG4gICAgICAgICAgICBwaW5uZWQ6IHRhYi5waW5uZWQsIC8vIFBlcnNpc3QgcGlubmVkIHN0YXRlXG4gICAgICAgICAgICBwaW5uZWRPcmRlcjogdGFiLnBpbm5lZE9yZGVyLCAvLyBQZXJzaXN0IHBpbm5lZCBvcmRlclxuICAgICAgICAgICAgLy8gV2UnbGwgbmVlZCB0byByZXN0b3JlIHRoZSBpY29uIGJhc2VkIG9uIGZpbGUgdHlwZVxuICAgICAgICAgIH0pKSxcbiAgICAgICAgICBhY3RpdmVUYWI6IHN0YXRlLmFjdGl2ZVRhYixcbiAgICAgICAgICBwcm9qZWN0RmlsZXM6IHN0YXRlLnByb2plY3RGaWxlcyxcbiAgICAgICAgICBmaW5hbmNpYWxGaWxlczogc3RhdGUuZmluYW5jaWFsRmlsZXMsXG4gICAgICAgICAgcHJvamVjdEZvbGRlcnM6IHN0YXRlLnByb2plY3RGb2xkZXJzLFxuICAgICAgICAgIGZpbmFuY2lhbEZvbGRlcnM6IHN0YXRlLmZpbmFuY2lhbEZvbGRlcnMsXG4gICAgICAgICAgc2hvd1Byb2plY3RzQ2F0ZWdvcnk6IHN0YXRlLnNob3dQcm9qZWN0c0NhdGVnb3J5LFxuICAgICAgICAgIHNob3dGaW5hbmNpYWxDYXRlZ29yeTogc3RhdGUuc2hvd0ZpbmFuY2lhbENhdGVnb3J5LFxuICAgICAgICB9KSxcbiAgICAgICAgLy8gQ3VzdG9tIHN0b3JhZ2UgdG8gaGFuZGxlIGljb24gcmVzdG9yYXRpb25cbiAgICAgICAgc3RvcmFnZToge1xuICAgICAgICAgIGdldEl0ZW06IChuYW1lKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzdHIgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShuYW1lKTtcbiAgICAgICAgICAgIGlmICghc3RyKSByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGNvbnN0IHsgc3RhdGUgfSA9IEpTT04ucGFyc2Uoc3RyKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gUmVzdG9yZSBpY29ucyBiYXNlZCBvbiBmaWxlIHR5cGVcbiAgICAgICAgICAgIGNvbnN0IHJlc3RvcmVkVGFicyA9IChzdGF0ZS5vcGVuVGFicyB8fCBbXSkubWFwKCh0YWI6IE9taXQ8RWRpdG9yVGFiLCAnaWNvbic+KSA9PiB7XG4gICAgICAgICAgICAgIGxldCBpY29uID0gRmlsZUNvZGU7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICBzd2l0Y2ggKHRhYi50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAndHlwZXNjcmlwdCc6XG4gICAgICAgICAgICAgICAgY2FzZSAnamF2YXNjcmlwdCc6XG4gICAgICAgICAgICAgICAgICBpY29uID0gRmlsZUNvZGU7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdqc29uJzpcbiAgICAgICAgICAgICAgICAgIGljb24gPSBCcmFjZXM7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdleGNlbCc6XG4gICAgICAgICAgICAgICAgICBpY29uID0gRmlsZVNwcmVhZHNoZWV0O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnbWFya2Rvd24nOlxuICAgICAgICAgICAgICAgICAgaWNvbiA9IEZpbGVUZXh0O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAncGRmJzpcbiAgICAgICAgICAgICAgICAgIGljb24gPSBGaWxlVHlwZTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIC4uLnRhYixcbiAgICAgICAgICAgICAgICBpY29uLFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHN0YXRlOiB7XG4gICAgICAgICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgICAgICAgb3BlblRhYnM6IHJlc3RvcmVkVGFicyxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzZXRJdGVtOiAobmFtZSwgdmFsdWUpID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiBsb2NhbFN0b3JhZ2UpIHtcbiAgICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0obmFtZSwgSlNPTi5zdHJpbmdpZnkodmFsdWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHJlbW92ZUl0ZW06IChuYW1lKSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgbG9jYWxTdG9yYWdlKSB7XG4gICAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKG5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIG9uUmVoeWRyYXRlU3RvcmFnZTogKCkgPT4gKHN0YXRlKSA9PiB7XG4gICAgICAgICAgaWYgKHN0YXRlKSB7XG4gICAgICAgICAgICAvLyBSZXBhaXIgYW55IGZpbGVzIHRoYXQgZG9uJ3QgaGF2ZSBjb250ZW50XG4gICAgICAgICAgICBpZiAoc3RhdGUucHJvamVjdEZpbGVzKSB7XG4gICAgICAgICAgICAgIHN0YXRlLnByb2plY3RGaWxlcyA9IHN0YXRlLnByb2plY3RGaWxlcy5tYXAoZmlsZSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFmaWxlLmNvbnRlbnQgfHwgZmlsZS5jb250ZW50LnRyaW0oKSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLmZpbGUsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGdldERlZmF1bHRDb250ZW50KGZpbGUudHlwZSwgZmlsZS5uYW1lKSxcbiAgICAgICAgICAgICAgICAgICAgbW9kaWZpZWRBdDogbmV3IERhdGUoKVxuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpbGU7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoc3RhdGUuZmluYW5jaWFsRmlsZXMpIHtcbiAgICAgICAgICAgICAgc3RhdGUuZmluYW5jaWFsRmlsZXMgPSBzdGF0ZS5maW5hbmNpYWxGaWxlcy5tYXAoZmlsZSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFmaWxlLmNvbnRlbnQgfHwgZmlsZS5jb250ZW50LnRyaW0oKSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLmZpbGUsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGdldERlZmF1bHRDb250ZW50KGZpbGUudHlwZSwgZmlsZS5uYW1lKSxcbiAgICAgICAgICAgICAgICAgICAgbW9kaWZpZWRBdDogbmV3IERhdGUoKVxuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpbGU7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBFbnN1cmUgSW5zdHJ1Y3Rpb25zIGZvbGRlciBleGlzdHMgaWYgdGhlcmUgYXJlIHByb2plY3QgZm9sZGVyc1xuICAgICAgICAgICAgaWYgKHN0YXRlLnByb2plY3RGb2xkZXJzICYmIHN0YXRlLnByb2plY3RGb2xkZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgLy8gT25seSBlbnN1cmUgdGhlIEluc3RydWN0aW9ucyBmb2xkZXIgaWYgdGhlcmUgYXJlIGFscmVhZHkgc29tZSBwcm9qZWN0IGZvbGRlcnNcbiAgICAgICAgICAgICAgLy8gVGhpcyBwcmV2ZW50cyBhdXRvLWNyZWF0aW9uIHdoZW4gc3RvcmFnZSBpcyBpbnRlbnRpb25hbGx5IGNsZWFyZWRcbiAgICAgICAgICAgICAgY29uc3QgaGFzSW5zdHJ1Y3Rpb25zRm9sZGVyID0gc3RhdGUucHJvamVjdEZvbGRlcnMuc29tZShmb2xkZXIgPT5cbiAgICAgICAgICAgICAgICBmb2xkZXIuaWQgPT09ICdpbnN0cnVjdGlvbnMtZm9sZGVyJyAmJiBmb2xkZXIucGlubmVkXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICBpZiAoIWhhc0luc3RydWN0aW9uc0ZvbGRlcikge1xuICAgICAgICAgICAgICAgIHN0YXRlLnByb2plY3RGb2xkZXJzID0gW1xuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBpZDogJ2luc3RydWN0aW9ucy1mb2xkZXInLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnSW5zdHJ1Y3Rpb25zJyxcbiAgICAgICAgICAgICAgICAgICAgY2F0ZWdvcnk6ICdwcm9qZWN0JyxcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLFxuICAgICAgICAgICAgICAgICAgICBwaW5uZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgLi4uc3RhdGUucHJvamVjdEZvbGRlcnNcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIElmIHByb2plY3RGb2xkZXJzIGlzIGVtcHR5LCByZXNwZWN0IHRoYXQgKGRvbid0IGF1dG8tY3JlYXRlIGFueXRoaW5nKVxuICAgICAgICB9LFxuICAgICAgfVxuICAgICksXG4gICAgeyBuYW1lOiAnZWRpdG9yLXN0b3JlJyB9XG4gIClcbik7ICJdLCJuYW1lcyI6WyJBdFNpZ24iLCJCcmFjZXMiLCJDYWxlbmRhciIsIkNhbWVyYSIsIkZpbGVDb2RlIiwiRmlsZVNwcmVhZHNoZWV0IiwiRmlsZVRleHQiLCJGaWxlVHlwZSIsIk1lc3NhZ2VTcXVhcmUiLCJjcmVhdGUiLCJkZXZ0b29scyIsInBlcnNpc3QiLCJnZXRGaWxlSWNvbiIsInR5cGUiLCJnZXRGaWxlRXh0ZW5zaW9uIiwiZ2V0RGVmYXVsdENvbnRlbnQiLCJuYW1lIiwicmVwbGFjZSIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsInRvTG9jYWxlRGF0ZVN0cmluZyIsImluaXRpYWxQcm9qZWN0RmlsZXMiLCJpbml0aWFsRmluYW5jaWFsRmlsZXMiLCJpbml0aWFsUHJvamVjdEZvbGRlcnMiLCJ1c2VFZGl0b3JTdG9yZSIsInNldCIsImdldCIsIm9wZW5UYWJzIiwiYWN0aXZlVGFiIiwicHJvamVjdEZpbGVzIiwiZmluYW5jaWFsRmlsZXMiLCJwcm9qZWN0Rm9sZGVycyIsImZpbmFuY2lhbEZvbGRlcnMiLCJ0cmFzaEl0ZW1zIiwic2hvd1Byb2plY3RzQ2F0ZWdvcnkiLCJzaG93RmluYW5jaWFsQ2F0ZWdvcnkiLCJpc0xvYWRpbmciLCJlcnJvciIsIm9wZW5UYWIiLCJmaWxlIiwiZXhpc3RpbmdUYWIiLCJmaW5kIiwidGFiIiwiaWQiLCJhdXRvUGluRmlsZVR5cGVzIiwic2hvdWxkQXV0b1Bpbm4iLCJpbmNsdWRlcyIsInBpbm5lZE9yZGVyIiwicGlubmVkVGFicyIsImZpbHRlciIsInQiLCJwaW5uZWQiLCJsZW5ndGgiLCJNYXRoIiwibWF4IiwibWFwIiwibmV3VGFiIiwibW9kaWZpZWQiLCJjb250ZW50IiwiZmlsZVBhdGgiLCJ1bmRlZmluZWQiLCJuZXdUYWJzIiwib3RoZXJUYWJzIiwiaW5zZXJ0SW5kZXgiLCJzcGxpY2UiLCJ1bnBpbm5lZFRhYnMiLCJvcGVuU3BlY2lhbFRhYiIsImF1dG9QaW5UeXBlcyIsImNsb3NlVGFiIiwidGFiSWQiLCJ0YWJJbmRleCIsImZpbmRJbmRleCIsIm5ld0FjdGl2ZVRhYiIsIm5leHRJbmRleCIsImNsb3NlQWxsVGFicyIsInNldEFjdGl2ZVRhYiIsInRhYkV4aXN0cyIsInNvbWUiLCJyZW9yZGVyVGFicyIsImZyb21UYWJJZCIsInRvVGFiSWQiLCJmcm9tSW5kZXgiLCJ0b0luZGV4IiwibW92ZWRUYWIiLCJwaW5UYWIiLCJuZXh0UGlubmVkT3JkZXIiLCJ1cGRhdGVkVGFiIiwidW5waW5UYWIiLCJwaW5uZWRDb3VudCIsInVwZGF0ZVRhYkNvbnRlbnQiLCJ1cGRhdGVkVGFicyIsInVwZGF0ZUZpbGVDb250ZW50IiwidXBkYXRlRmlsZUNvbnRlbnRJblN0b3JlIiwiZmlsZUlkIiwidXBkYXRlZFByb2plY3RGaWxlcyIsIm1vZGlmaWVkQXQiLCJ1cGRhdGVkRmluYW5jaWFsRmlsZXMiLCJ1cGRhdGVGaWxlU3RhdHVzIiwic3RhdHVzIiwiY3JlYXRlTmV3RmlsZSIsImNhdGVnb3J5IiwiZm9sZGVySWQiLCJjdXN0b21Db250ZW50IiwidG9Mb3dlckNhc2UiLCJub3ciLCJmaWxlTmFtZSIsImJhc2VQYXRoIiwiZmlsZUNvbnRlbnQiLCJuZXdGaWxlIiwiaWNvbiIsImNyZWF0ZWRBdCIsImNvbnNvbGUiLCJsb2ciLCJ3aW5kb3ciLCJkaXNwYXRjaEV2ZW50IiwiQ3VzdG9tRXZlbnQiLCJkZXRhaWwiLCJwcm9qZWN0SWQiLCJjcmVhdGVGb2xkZXIiLCJjb252ZXhJZCIsImV4aXN0aW5nRm9sZGVycyIsImZvbGRlckV4aXN0cyIsImZvbGRlciIsInVuaXF1ZUlkIiwiY3J5cHRvIiwicmFuZG9tVVVJRCIsInRpbWVzdGFtcCIsInJhbmRvbSIsInRvU3RyaW5nIiwic3Vic3RyaW5nIiwiY291bnRlciIsImZsb29yIiwiYWxsRm9sZGVycyIsInJhbmRvbVN1ZmZpeCIsIm5ld0ZvbGRlciIsImNsZWFudXBEdXBsaWNhdGVGb2xkZXJzIiwiY2xlYW51cEZvbGRlcnMiLCJmb2xkZXJzIiwic2VlbiIsIlNldCIsImNsZWFuZWQiLCJoYXMiLCJhZGQiLCJzdGFydHNXaXRoIiwibmV3SWQiLCJjbGVhbmVkUHJvamVjdEZvbGRlcnMiLCJjbGVhbmVkRmluYW5jaWFsRm9sZGVycyIsImRlbGV0ZUZpbGUiLCJ0YWJUb0Nsb3NlIiwicmVuYW1lRmlsZSIsIm5ld05hbWUiLCJwcm9qZWN0RmlsZSIsImZpbmFuY2lhbEZpbGUiLCJuZXdGaWxlTmFtZSIsIm5ld0ZpbGVQYXRoIiwiZiIsInJlbmFtZUZvbGRlciIsInVwZGF0ZWRQcm9qZWN0Rm9sZGVycyIsInVwZGF0ZWRGaW5hbmNpYWxGb2xkZXJzIiwiZGVsZXRlRm9sZGVyIiwiZmlsZXNUb0RlbGV0ZSIsImZvckVhY2giLCJtb3ZlVG9UcmFzaCIsIml0ZW0iLCJ0cmFzaEl0ZW0iLCJvcmlnaW5hbERhdGEiLCJkZWxldGVkQXQiLCJmaWxlc1RvVHJhc2giLCJmaWxlVHJhc2hJdGVtcyIsInJlc3RvcmVGcm9tVHJhc2giLCJ0cmFzaEl0ZW1JZCIsInVwZGF0ZWRUcmFzaEl0ZW1zIiwicGVybWFuZW50bHlEZWxldGUiLCJlbXB0eVRyYXNoIiwiY2xlYXJQcm9qZWN0Q2F0ZWdvcnkiLCJwcm9qZWN0VGFiSWRzIiwiY2xlYXJGaW5hbmNpYWxDYXRlZ29yeSIsImZpbmFuY2lhbFRhYklkcyIsImRlbGV0ZVByb2plY3RzQ2F0ZWdvcnkiLCJkZWxldGVGaW5hbmNpYWxDYXRlZ29yeSIsInJlb3JkZXJQcm9qZWN0Rm9sZGVycyIsIm5ld0ZvbGRlcnMiLCJtb3ZlZEZvbGRlciIsInVwZGF0ZVByb2plY3RGb2xkZXJzIiwicmVvcmRlckZpbGVzSW5Gb2xkZXIiLCJmb2xkZXJGaWxlcyIsIm90aGVyRmlsZXMiLCJyZW9yZGVyZWRGb2xkZXJGaWxlcyIsIm1vdmVkRmlsZSIsIm5ld1Byb2plY3RGaWxlcyIsIm5ld0ZpbmFuY2lhbEZpbGVzIiwic2F2ZUZpbGUiLCJzZXRFcnJvciIsInJlcGFpckZpbGVzV2l0aG91dENvbnRlbnQiLCJyZXBhaXJlZFByb2plY3RGaWxlcyIsInRyaW0iLCJyZXBhaXJlZEZpbmFuY2lhbEZpbGVzIiwicmVzZXQiLCJjbGVhclVzZXJEYXRhIiwidmVyc2lvbiIsInBhcnRpYWxpemUiLCJzdGF0ZSIsInN0b3JhZ2UiLCJnZXRJdGVtIiwic3RyIiwibG9jYWxTdG9yYWdlIiwiSlNPTiIsInBhcnNlIiwicmVzdG9yZWRUYWJzIiwic2V0SXRlbSIsInZhbHVlIiwic3RyaW5naWZ5IiwicmVtb3ZlSXRlbSIsIm9uUmVoeWRyYXRlU3RvcmFnZSIsImhhc0luc3RydWN0aW9uc0ZvbGRlciJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./store/editor/index.ts\n"));

/***/ })

});