"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./store/editor/index.ts":
/*!*******************************!*\
  !*** ./store/editor/index.ts ***!
  \*******************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useEditorStore: () => (/* binding */ useEditorStore)\n/* harmony export */ });\n/* harmony import */ var _barrel_optimize_names_AtSign_Braces_Camera_FileCode_FileSpreadsheet_FileText_FileType_Hash_MessageSquare_lucide_react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! __barrel_optimize__?names=AtSign,Braces,Camera,FileCode,FileSpreadsheet,FileText,FileType,Hash,MessageSquare!=!lucide-react */ \"(app-pages-browser)/../node_modules/.pnpm/lucide-react@0.525.0_react@18.3.1/node_modules/lucide-react/dist/esm/icons/file-code.js\");\n/* harmony import */ var _barrel_optimize_names_AtSign_Braces_Camera_FileCode_FileSpreadsheet_FileText_FileType_Hash_MessageSquare_lucide_react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! __barrel_optimize__?names=AtSign,Braces,Camera,FileCode,FileSpreadsheet,FileText,FileType,Hash,MessageSquare!=!lucide-react */ \"(app-pages-browser)/../node_modules/.pnpm/lucide-react@0.525.0_react@18.3.1/node_modules/lucide-react/dist/esm/icons/braces.js\");\n/* harmony import */ var _barrel_optimize_names_AtSign_Braces_Camera_FileCode_FileSpreadsheet_FileText_FileType_Hash_MessageSquare_lucide_react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! __barrel_optimize__?names=AtSign,Braces,Camera,FileCode,FileSpreadsheet,FileText,FileType,Hash,MessageSquare!=!lucide-react */ \"(app-pages-browser)/../node_modules/.pnpm/lucide-react@0.525.0_react@18.3.1/node_modules/lucide-react/dist/esm/icons/file-spreadsheet.js\");\n/* harmony import */ var _barrel_optimize_names_AtSign_Braces_Camera_FileCode_FileSpreadsheet_FileText_FileType_Hash_MessageSquare_lucide_react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! __barrel_optimize__?names=AtSign,Braces,Camera,FileCode,FileSpreadsheet,FileText,FileType,Hash,MessageSquare!=!lucide-react */ \"(app-pages-browser)/../node_modules/.pnpm/lucide-react@0.525.0_react@18.3.1/node_modules/lucide-react/dist/esm/icons/file-text.js\");\n/* harmony import */ var _barrel_optimize_names_AtSign_Braces_Camera_FileCode_FileSpreadsheet_FileText_FileType_Hash_MessageSquare_lucide_react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! __barrel_optimize__?names=AtSign,Braces,Camera,FileCode,FileSpreadsheet,FileText,FileType,Hash,MessageSquare!=!lucide-react */ \"(app-pages-browser)/../node_modules/.pnpm/lucide-react@0.525.0_react@18.3.1/node_modules/lucide-react/dist/esm/icons/file-type.js\");\n/* harmony import */ var _barrel_optimize_names_AtSign_Braces_Camera_FileCode_FileSpreadsheet_FileText_FileType_Hash_MessageSquare_lucide_react__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! __barrel_optimize__?names=AtSign,Braces,Camera,FileCode,FileSpreadsheet,FileText,FileType,Hash,MessageSquare!=!lucide-react */ \"(app-pages-browser)/../node_modules/.pnpm/lucide-react@0.525.0_react@18.3.1/node_modules/lucide-react/dist/esm/icons/message-square.js\");\n/* harmony import */ var _barrel_optimize_names_AtSign_Braces_Camera_FileCode_FileSpreadsheet_FileText_FileType_Hash_MessageSquare_lucide_react__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! __barrel_optimize__?names=AtSign,Braces,Camera,FileCode,FileSpreadsheet,FileText,FileType,Hash,MessageSquare!=!lucide-react */ \"(app-pages-browser)/../node_modules/.pnpm/lucide-react@0.525.0_react@18.3.1/node_modules/lucide-react/dist/esm/icons/hash.js\");\n/* harmony import */ var _barrel_optimize_names_AtSign_Braces_Camera_FileCode_FileSpreadsheet_FileText_FileType_Hash_MessageSquare_lucide_react__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! __barrel_optimize__?names=AtSign,Braces,Camera,FileCode,FileSpreadsheet,FileText,FileType,Hash,MessageSquare!=!lucide-react */ \"(app-pages-browser)/../node_modules/.pnpm/lucide-react@0.525.0_react@18.3.1/node_modules/lucide-react/dist/esm/icons/camera.js\");\n/* harmony import */ var _barrel_optimize_names_AtSign_Braces_Camera_FileCode_FileSpreadsheet_FileText_FileType_Hash_MessageSquare_lucide_react__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! __barrel_optimize__?names=AtSign,Braces,Camera,FileCode,FileSpreadsheet,FileText,FileType,Hash,MessageSquare!=!lucide-react */ \"(app-pages-browser)/../node_modules/.pnpm/lucide-react@0.525.0_react@18.3.1/node_modules/lucide-react/dist/esm/icons/at-sign.js\");\n/* harmony import */ var zustand__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! zustand */ \"(app-pages-browser)/../node_modules/.pnpm/zustand@5.0.6_@types+react@19.1.8_react@18.3.1_use-sync-external-store@1.5.0_react@18.3.1_/node_modules/zustand/esm/react.mjs\");\n/* harmony import */ var zustand_middleware__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! zustand/middleware */ \"(app-pages-browser)/../node_modules/.pnpm/zustand@5.0.6_@types+react@19.1.8_react@18.3.1_use-sync-external-store@1.5.0_react@18.3.1_/node_modules/zustand/esm/middleware.mjs\");\n// Editor Store\n// /Users/matthewsimon/Projects/EAC/eac/store/editor/index.ts\n\n\n\n// Helper function to get icon based on file type\nconst getFileIcon = (type)=>{\n    switch(type){\n        case 'typescript':\n            return _barrel_optimize_names_AtSign_Braces_Camera_FileCode_FileSpreadsheet_FileText_FileType_Hash_MessageSquare_lucide_react__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\n        case 'javascript':\n            return _barrel_optimize_names_AtSign_Braces_Camera_FileCode_FileSpreadsheet_FileText_FileType_Hash_MessageSquare_lucide_react__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\n        case 'json':\n            return _barrel_optimize_names_AtSign_Braces_Camera_FileCode_FileSpreadsheet_FileText_FileType_Hash_MessageSquare_lucide_react__WEBPACK_IMPORTED_MODULE_1__[\"default\"];\n        case 'excel':\n            return _barrel_optimize_names_AtSign_Braces_Camera_FileCode_FileSpreadsheet_FileText_FileType_Hash_MessageSquare_lucide_react__WEBPACK_IMPORTED_MODULE_2__[\"default\"];\n        case 'markdown':\n            return _barrel_optimize_names_AtSign_Braces_Camera_FileCode_FileSpreadsheet_FileText_FileType_Hash_MessageSquare_lucide_react__WEBPACK_IMPORTED_MODULE_3__[\"default\"];\n        case 'pdf':\n            return _barrel_optimize_names_AtSign_Braces_Camera_FileCode_FileSpreadsheet_FileText_FileType_Hash_MessageSquare_lucide_react__WEBPACK_IMPORTED_MODULE_4__[\"default\"];\n        case 'generals':\n            return _barrel_optimize_names_AtSign_Braces_Camera_FileCode_FileSpreadsheet_FileText_FileType_Hash_MessageSquare_lucide_react__WEBPACK_IMPORTED_MODULE_3__[\"default\"];\n        case 'percent-complete':\n            return _barrel_optimize_names_AtSign_Braces_Camera_FileCode_FileSpreadsheet_FileText_FileType_Hash_MessageSquare_lucide_react__WEBPACK_IMPORTED_MODULE_2__[\"default\"];\n        case 'schedule':\n            return _barrel_optimize_names_AtSign_Braces_Camera_FileCode_FileSpreadsheet_FileText_FileType_Hash_MessageSquare_lucide_react__WEBPACK_IMPORTED_MODULE_2__[\"default\"];\n        case 'materials':\n            return _barrel_optimize_names_AtSign_Braces_Camera_FileCode_FileSpreadsheet_FileText_FileType_Hash_MessageSquare_lucide_react__WEBPACK_IMPORTED_MODULE_2__[\"default\"];\n        case 'facebook':\n            return _barrel_optimize_names_AtSign_Braces_Camera_FileCode_FileSpreadsheet_FileText_FileType_Hash_MessageSquare_lucide_react__WEBPACK_IMPORTED_MODULE_5__[\"default\"];\n        case 'reddit':\n            return _barrel_optimize_names_AtSign_Braces_Camera_FileCode_FileSpreadsheet_FileText_FileType_Hash_MessageSquare_lucide_react__WEBPACK_IMPORTED_MODULE_6__[\"default\"];\n        case 'instagram':\n            return _barrel_optimize_names_AtSign_Braces_Camera_FileCode_FileSpreadsheet_FileText_FileType_Hash_MessageSquare_lucide_react__WEBPACK_IMPORTED_MODULE_7__[\"default\"];\n        case 'x':\n            return _barrel_optimize_names_AtSign_Braces_Camera_FileCode_FileSpreadsheet_FileText_FileType_Hash_MessageSquare_lucide_react__WEBPACK_IMPORTED_MODULE_8__[\"default\"];\n        default:\n            return _barrel_optimize_names_AtSign_Braces_Camera_FileCode_FileSpreadsheet_FileText_FileType_Hash_MessageSquare_lucide_react__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\n    }\n};\n// Helper function to get file extension\n// Helper function to get file extension\nconst getFileExtension = (type)=>{\n    switch(type){\n        case 'typescript':\n            return '.ts';\n        case 'javascript':\n            return '.js';\n        case 'json':\n            return '.json';\n        case 'excel':\n            return '.xlsx';\n        case 'pdf':\n            return '.pdf';\n        case 'generals':\n            return '.generals';\n        case 'percent-complete':\n            return '.percent';\n        case 'schedule':\n            return '.schedule';\n        case 'materials':\n            return '.materials';\n        case 'facebook':\n            return '.facebook';\n        case 'reddit':\n            return '.reddit';\n        case 'instagram':\n            return '.instagram';\n        case 'x':\n            return '.x';\n        default:\n            return '.txt';\n    }\n};\n// Helper function to generate default content for new files\nconst getDefaultContent = (type, name)=>{\n    switch(type){\n        case 'typescript':\n            return \"// \".concat(name, \"\\n// Auto-generated TypeScript file\\n\\nimport React from 'react';\\n\\ninterface \").concat(name.replace(/[^a-zA-Z0-9]/g, ''), \"Props {\\n  // Define props here\\n}\\n\\nexport function \").concat(name.replace(/[^a-zA-Z0-9]/g, ''), \"({ }: \").concat(name.replace(/[^a-zA-Z0-9]/g, ''), 'Props) {\\n  return (\\n    <div className=\"p-4\">\\n      <h1 className=\"text-xl font-bold\">New Component: ').concat(name, '</h1>\\n      <p className=\"text-gray-600\">Start building your component here...</p>\\n    </div>\\n  );\\n}');\n        case 'javascript':\n            return \"// \".concat(name, \"\\n// Auto-generated JavaScript file\\n\\nexport function \").concat(name.replace(/[^a-zA-Z0-9]/g, ''), \"() {\\n  return {\\n    message: 'Hello from \").concat(name, \"!',\\n    data: []\\n  };\\n}\");\n        case 'json':\n            return '{\\n  \"name\": \"'.concat(name, '\",\\n  \"description\": \"Auto-generated JSON file\",\\n  \"version\": \"1.0.0\",\\n  \"data\": {}\\n}');\n        case 'markdown':\n            return \"Start writing your content here...\";\n        case 'generals':\n            return \"// \".concat(name, \" - Project General Information\\n// This file contains general project details and financial information\\n// Created on: \").concat(new Date().toISOString(), \"\\n\\nProject: \").concat(name, \"\\nStatus: Active\\nCreated: \").concat(new Date().toLocaleDateString(), \"\\n\\n// This file will display the project generals module interface\");\n        case 'percent-complete':\n            return \"// \".concat(name, \" - Percent Complete Tracker\\n// This file contains project completion tracking data\\n// Created on: \").concat(new Date().toISOString(), \"\\n\\nProject: \").concat(name, \"\\nType: Percent Complete Tracker\\nCreated: \").concat(new Date().toLocaleDateString(), \"\\n\\n// This file will display the percent complete tracking interface\");\n        case 'schedule':\n            return \"// \".concat(name, \" - Project Schedule\\n// This file contains project schedule and timeline data\\n// Created on: \").concat(new Date().toISOString(), \"\\n\\nProject: \").concat(name, \"\\nType: Project Schedule\\nCreated: \").concat(new Date().toLocaleDateString(), \"\\n\\n// This file will display the project schedule interface with Gantt chart\");\n        case 'materials':\n            return \"// \".concat(name, \" - Materials Management\\n// This file contains materials tracking and management data\\n// Created on: \").concat(new Date().toISOString(), \"\\n\\nProject: \").concat(name, \"\\nType: Materials Management\\nCreated: \").concat(new Date().toLocaleDateString(), \"\\n\\n// This file will display the materials management interface with manufactured and miscellaneous materials\");\n        case 'facebook':\n            return \"# \".concat(name, \" - Facebook Post\\nPlatform: Facebook\\nCreated: \").concat(new Date().toLocaleDateString(), \"\\n\\n## Post Content\\nWrite your Facebook post content here...\\n\\n## Settings\\n- Audience: Public\\n- Schedule: Now\\n- Hashtags: #example\\n\\n## Media\\n- Images: []\\n- Videos: []\\n\\n## Analytics\\n- Engagement: 0\\n- Reach: 0\\n- Clicks: 0\");\n        case 'reddit':\n            return \"# \".concat(name, \" - Reddit Post\\nPlatform: Reddit\\nCreated: \").concat(new Date().toLocaleDateString(), \"\\n\\n## Post Content\\nWrite your Reddit post content here...\\n\\n## Settings\\n- Subreddit: r/example\\n- Post Type: Text/Link/Image\\n- Flair: Discussion\\n- NSFW: No\\n\\n## Media\\n- Images: []\\n- Links: []\\n\\n## Analytics\\n- Upvotes: 0\\n- Comments: 0\\n- Awards: 0\");\n        case 'instagram':\n            return \"# \".concat(name, \" - Instagram Post\\nPlatform: Instagram\\nCreated: \").concat(new Date().toLocaleDateString(), \"\\n\\n## Post Content\\nWrite your Instagram post content here...\\n\\n## Settings\\n- Post Type: Feed/Story/Reel\\n- Location: City, Country\\n- Alt Text: Describe image\\n- Comment Settings: Public\\n\\n## Media\\n- Images: []\\n- Videos: []\\n\\n## Hashtags\\n#hashtag1 #hashtag2 #hashtag3\\n\\n## Analytics\\n- Likes: 0\\n- Comments: 0\\n- Shares: 0\\n- Reach: 0\");\n        case 'x':\n            return \"# \".concat(name, \" - X/Twitter Post\\nPlatform: X (Twitter)\\nCreated: \").concat(new Date().toLocaleDateString(), \"\\n\\n## Post Content\\nWrite your X post content here... (280 character limit)\\n\\n## Settings\\n- Reply Settings: Everyone\\n- Schedule: Now\\n- Thread: Single Tweet\\n\\n## Media\\n- Images: []\\n- Videos: []\\n- GIFs: []\\n\\n## Analytics\\n- Impressions: 0\\n- Engagements: 0\\n- Retweets: 0\\n- Likes: 0\\n- Replies: 0\");\n        default:\n            return \"# \".concat(name, \"\\n\\nThis is a new file created in the EAC Dashboard.\\nCreated on: \").concat(new Date().toISOString());\n    }\n};\n// Initial project files\nconst initialProjectFiles = [\n    {\n        id: 'project-overview',\n        name: 'Project-Overview.md',\n        icon: _barrel_optimize_names_AtSign_Braces_Camera_FileCode_FileSpreadsheet_FileText_FileType_Hash_MessageSquare_lucide_react__WEBPACK_IMPORTED_MODULE_3__[\"default\"],\n        type: 'markdown',\n        category: 'project',\n        content: \"# Project Overview\\n\\n## Current Projects\\n- Write your project details here...\\n- Track progress and milestones\\n- Document requirements and specifications\\n\\n## Notes\\nStart planning your projects here...\",\n        filePath: '/eac-projects/Project-Overview.md',\n        createdAt: new Date(),\n        modifiedAt: new Date()\n    }\n];\n// Initial financial files\nconst initialFinancialFiles = [\n    {\n        id: 'financial-notes',\n        name: 'Financial-Notes.md',\n        icon: _barrel_optimize_names_AtSign_Braces_Camera_FileCode_FileSpreadsheet_FileText_FileType_Hash_MessageSquare_lucide_react__WEBPACK_IMPORTED_MODULE_3__[\"default\"],\n        type: 'markdown',\n        category: 'financial',\n        content: \"# Financial Notes\\n\\n## Monthly Tracking\\n- Track your revenue and expenses here\\n- Monitor budget allocations\\n- Document financial decisions\\n\\n## Budget Overview\\nStart documenting your financial planning here...\",\n        filePath: '/financial-data/Financial-Notes.md',\n        createdAt: new Date(),\n        modifiedAt: new Date()\n    }\n];\nconst useEditorStore = (0,zustand__WEBPACK_IMPORTED_MODULE_9__.create)()((0,zustand_middleware__WEBPACK_IMPORTED_MODULE_10__.devtools)((0,zustand_middleware__WEBPACK_IMPORTED_MODULE_10__.persist)((set, get)=>({\n        // Initial state\n        openTabs: [],\n        activeTab: '',\n        projectFiles: initialProjectFiles,\n        financialFiles: initialFinancialFiles,\n        projectFolders: [],\n        financialFolders: [],\n        trashItems: [],\n        showProjectsCategory: true,\n        showFinancialCategory: true,\n        isLoading: false,\n        error: null,\n        // Actions\n        openTab: (file)=>{\n            const { openTabs } = get();\n            // Check if tab is already open\n            const existingTab = openTabs.find((tab)=>tab.id === file.id);\n            if (existingTab) {\n                set({\n                    activeTab: existingTab.id\n                });\n                return;\n            }\n            // Create new tab\n            const newTab = {\n                id: file.id,\n                name: file.name,\n                modified: false,\n                content: file.content,\n                filePath: file.filePath,\n                type: file.type\n            };\n            set({\n                openTabs: [\n                    ...openTabs,\n                    newTab\n                ],\n                activeTab: newTab.id\n            });\n        },\n        openSpecialTab: (id, name, type)=>{\n            const { openTabs } = get();\n            // Check if tab is already open\n            const existingTab = openTabs.find((tab)=>tab.id === id);\n            if (existingTab) {\n                set({\n                    activeTab: existingTab.id\n                });\n                return;\n            }\n            // Create new special tab\n            const newTab = {\n                id,\n                name,\n                modified: false,\n                content: '',\n                filePath: \"/\".concat(type),\n                type\n            };\n            set({\n                openTabs: [\n                    ...openTabs,\n                    newTab\n                ],\n                activeTab: newTab.id\n            });\n        },\n        closeTab: (tabId)=>{\n            const { openTabs, activeTab } = get();\n            const tabIndex = openTabs.findIndex((tab)=>tab.id === tabId);\n            if (tabIndex === -1) return;\n            const newTabs = openTabs.filter((tab)=>tab.id !== tabId);\n            let newActiveTab = activeTab;\n            // If closing the active tab, switch to another tab\n            if (activeTab === tabId) {\n                if (newTabs.length > 0) {\n                    // Switch to the tab to the right, or the last tab if closing the last one\n                    const nextIndex = tabIndex < newTabs.length ? tabIndex : newTabs.length - 1;\n                    newActiveTab = newTabs[nextIndex].id;\n                } else {\n                    newActiveTab = '';\n                }\n            }\n            set({\n                openTabs: newTabs,\n                activeTab: newActiveTab\n            });\n        },\n        closeAllTabs: ()=>{\n            set({\n                openTabs: [],\n                activeTab: ''\n            });\n        },\n        setActiveTab: (tabId)=>{\n            const { openTabs } = get();\n            const tabExists = openTabs.some((tab)=>tab.id === tabId);\n            if (tabExists) {\n                set({\n                    activeTab: tabId\n                });\n            }\n        },\n        updateTabContent: (tabId, content)=>{\n            const { openTabs } = get();\n            const updatedTabs = openTabs.map((tab)=>tab.id === tabId ? {\n                    ...tab,\n                    content,\n                    modified: true\n                } : tab);\n            set({\n                openTabs: updatedTabs\n            });\n        },\n        updateFileContent: (tabId, content)=>{\n            const { openTabs } = get();\n            const updatedTabs = openTabs.map((tab)=>tab.id === tabId ? {\n                    ...tab,\n                    content,\n                    modified: true\n                } : tab);\n            set({\n                openTabs: updatedTabs\n            });\n        },\n        updateFileStatus: (fileId, status)=>{\n            const { projectFiles, financialFiles } = get();\n            // Update in project files\n            const updatedProjectFiles = projectFiles.map((file)=>file.id === fileId ? {\n                    ...file,\n                    status,\n                    modifiedAt: new Date()\n                } : file);\n            // Update in financial files\n            const updatedFinancialFiles = financialFiles.map((file)=>file.id === fileId ? {\n                    ...file,\n                    status,\n                    modifiedAt: new Date()\n                } : file);\n            set({\n                projectFiles: updatedProjectFiles,\n                financialFiles: updatedFinancialFiles\n            });\n        },\n        createNewFile: async function(name, type) {\n            let category = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 'project', folderId = arguments.length > 3 ? arguments[3] : void 0;\n            const { projectFiles, financialFiles } = get();\n            // Generate unique ID\n            const id = \"\".concat(name.toLowerCase().replace(/[^a-z0-9]/g, '-'), \"-\").concat(Date.now());\n            const fileName = \"\".concat(name).concat(getFileExtension(type));\n            const basePath = category === 'financial' ? '/financial-data' : '/eac-projects';\n            // Create new file\n            const newFile = {\n                id,\n                name: fileName,\n                icon: getFileIcon(type),\n                type,\n                category,\n                content: getDefaultContent(type, name),\n                filePath: \"\".concat(basePath, \"/\").concat(fileName),\n                createdAt: new Date(),\n                modifiedAt: new Date(),\n                folderId,\n                status: [\n                    'facebook',\n                    'reddit',\n                    'instagram',\n                    'x'\n                ].includes(type) ? 'draft' : undefined\n            };\n            // Add to appropriate file array and ensure category is visible\n            if (category === 'financial') {\n                set({\n                    financialFiles: [\n                        ...financialFiles,\n                        newFile\n                    ],\n                    showFinancialCategory: true\n                });\n            } else {\n                set({\n                    projectFiles: [\n                        ...projectFiles,\n                        newFile\n                    ],\n                    showProjectsCategory: true\n                });\n            }\n            // Automatically open the new file\n            get().openTab(newFile);\n            // Save to Convex database (async - don't block UI)\n            try {\n                // We need to import the Convex hooks here, which isn't ideal\n                // Better to handle this in the component level\n                console.log('File created locally:', newFile);\n                // Dispatch custom event that components can listen to\n                window.dispatchEvent(new CustomEvent('fileCreated', {\n                    detail: {\n                        file: newFile,\n                        projectId: folderId // Using folderId as projectId for now\n                    }\n                }));\n            } catch (error) {\n                console.error('Failed to save file to database:', error);\n            }\n        },\n        createFolder: (name, category)=>{\n            const { projectFolders, financialFolders } = get();\n            // Check if folder with this name already exists to prevent duplicates\n            const existingFolders = category === 'financial' ? financialFolders : projectFolders;\n            const folderExists = existingFolders.some((folder)=>folder.name.toLowerCase() === name.toLowerCase());\n            if (folderExists) {\n                console.log('Folder \"'.concat(name, '\" already exists in ').concat(category, \" category, skipping creation\"));\n                return;\n            }\n            // Generate truly unique ID using crypto if available, otherwise fallback to timestamp + random\n            let uniqueId;\n            if (typeof crypto !== 'undefined' && crypto.randomUUID) {\n                uniqueId = \"folder-\".concat(name.toLowerCase().replace(/[^a-z0-9]/g, '-'), \"-\").concat(crypto.randomUUID());\n            } else {\n                // Fallback for environments without crypto.randomUUID\n                const timestamp = Date.now();\n                const random = Math.random().toString(36).substring(2, 12);\n                const counter = Math.floor(Math.random() * 10000);\n                uniqueId = \"folder-\".concat(name.toLowerCase().replace(/[^a-z0-9]/g, '-'), \"-\").concat(timestamp, \"-\").concat(random, \"-\").concat(counter);\n            }\n            // Double-check uniqueness against all existing folder IDs\n            const allFolders = [\n                ...projectFolders,\n                ...financialFolders\n            ];\n            while(allFolders.some((folder)=>folder.id === uniqueId)){\n                const randomSuffix = Math.random().toString(36).substring(2, 8);\n                uniqueId = \"\".concat(uniqueId, \"-\").concat(randomSuffix);\n            }\n            // Create new folder\n            const newFolder = {\n                id: uniqueId,\n                name,\n                category,\n                createdAt: new Date()\n            };\n            // Add to appropriate folder array and ensure category is visible\n            if (category === 'financial') {\n                set({\n                    financialFolders: [\n                        newFolder,\n                        ...financialFolders\n                    ],\n                    showFinancialCategory: true\n                });\n            } else {\n                set({\n                    projectFolders: [\n                        newFolder,\n                        ...projectFolders\n                    ],\n                    showProjectsCategory: true\n                });\n            }\n        },\n        // Emergency cleanup function for duplicate folder IDs\n        cleanupDuplicateFolders: ()=>{\n            const { projectFolders, financialFolders } = get();\n            // Function to remove duplicates and fix bad IDs\n            const cleanupFolders = (folders)=>{\n                const seen = new Set();\n                const cleaned = folders.filter((folder)=>{\n                    // Remove folders with the problematic key pattern\n                    if (folder.id.includes('folder-index-1753064508939')) {\n                        console.log(\"\\uD83E\\uDDF9 Removing problematic folder: \".concat(folder.id, \" (\").concat(folder.name, \")\"));\n                        return false;\n                    }\n                    // Remove duplicate IDs\n                    if (seen.has(folder.id)) {\n                        console.log(\"\\uD83E\\uDDF9 Removing duplicate folder: \".concat(folder.id, \" (\").concat(folder.name, \")\"));\n                        return false;\n                    }\n                    seen.add(folder.id);\n                    return true;\n                });\n                // Regenerate IDs for any remaining folders with old patterns\n                return cleaned.map((folder)=>{\n                    if (folder.id.startsWith('folder-index-') || folder.id.length < 20) {\n                        const newId = typeof crypto !== 'undefined' && crypto.randomUUID ? \"folder-\".concat(folder.name.toLowerCase().replace(/[^a-z0-9]/g, '-'), \"-\").concat(crypto.randomUUID()) : \"folder-\".concat(folder.name.toLowerCase().replace(/[^a-z0-9]/g, '-'), \"-\").concat(Date.now(), \"-\").concat(Math.random().toString(36).substring(2, 12));\n                        console.log(\"\\uD83D\\uDD04 Regenerating ID for folder: \".concat(folder.id, \" â†’ \").concat(newId, \" (\").concat(folder.name, \")\"));\n                        return {\n                            ...folder,\n                            id: newId\n                        };\n                    }\n                    return folder;\n                });\n            };\n            const cleanedProjectFolders = cleanupFolders(projectFolders);\n            const cleanedFinancialFolders = cleanupFolders(financialFolders);\n            if (cleanedProjectFolders.length !== projectFolders.length || cleanedFinancialFolders.length !== financialFolders.length) {\n                console.log('ðŸ§¹ Cleanup completed, updating store...');\n                set({\n                    projectFolders: cleanedProjectFolders,\n                    financialFolders: cleanedFinancialFolders\n                });\n            }\n        },\n        deleteFile: (fileId)=>{\n            const { projectFiles, financialFiles, openTabs } = get();\n            // Find and remove from appropriate array\n            const updatedProjectFiles = projectFiles.filter((file)=>file.id !== fileId);\n            const updatedFinancialFiles = financialFiles.filter((file)=>file.id !== fileId);\n            // Close tab if it's open\n            const tabToClose = openTabs.find((tab)=>tab.id === fileId);\n            if (tabToClose) {\n                get().closeTab(fileId);\n            }\n            set({\n                projectFiles: updatedProjectFiles,\n                financialFiles: updatedFinancialFiles\n            });\n        },\n        renameFile: (fileId, newName)=>{\n            const { projectFiles, financialFiles, openTabs } = get();\n            // Find the file to get its type and generate new filename with extension\n            const projectFile = projectFiles.find((file)=>file.id === fileId);\n            const financialFile = financialFiles.find((file)=>file.id === fileId);\n            const file = projectFile || financialFile;\n            if (!file) return;\n            // Generate new filename with appropriate extension\n            const newFileName = \"\".concat(newName).concat(getFileExtension(file.type));\n            const basePath = file.category === 'financial' ? '/financial-data' : '/eac-projects';\n            const newFilePath = \"\".concat(basePath, \"/\").concat(newFileName);\n            // Update the file in appropriate array\n            const updatedProjectFiles = projectFiles.map((f)=>f.id === fileId ? {\n                    ...f,\n                    name: newFileName,\n                    filePath: newFilePath,\n                    modifiedAt: new Date()\n                } : f);\n            const updatedFinancialFiles = financialFiles.map((f)=>f.id === fileId ? {\n                    ...f,\n                    name: newFileName,\n                    filePath: newFilePath,\n                    modifiedAt: new Date()\n                } : f);\n            // Update open tabs if the file is open\n            const updatedTabs = openTabs.map((tab)=>tab.id === fileId ? {\n                    ...tab,\n                    name: newFileName,\n                    filePath: newFilePath,\n                    modified: true\n                } : tab);\n            set({\n                projectFiles: updatedProjectFiles,\n                financialFiles: updatedFinancialFiles,\n                openTabs: updatedTabs\n            });\n        },\n        renameFolder: (folderId, newName)=>{\n            const { projectFolders, financialFolders } = get();\n            // Update the folder in appropriate array\n            const updatedProjectFolders = projectFolders.map((folder)=>folder.id === folderId ? {\n                    ...folder,\n                    name: newName\n                } : folder);\n            const updatedFinancialFolders = financialFolders.map((folder)=>folder.id === folderId ? {\n                    ...folder,\n                    name: newName\n                } : folder);\n            set({\n                projectFolders: updatedProjectFolders,\n                financialFolders: updatedFinancialFolders\n            });\n        },\n        deleteFolder: (folderId)=>{\n            const { projectFolders, financialFolders, projectFiles, financialFiles, openTabs } = get();\n            // Find all files that were in this folder\n            const filesToDelete = [\n                ...projectFiles.filter((file)=>file.folderId === folderId),\n                ...financialFiles.filter((file)=>file.folderId === folderId)\n            ];\n            // Close tabs for all files in this folder\n            filesToDelete.forEach((file)=>{\n                const tabToClose = openTabs.find((tab)=>tab.id === file.id);\n                if (tabToClose) {\n                    get().closeTab(file.id);\n                }\n            });\n            // Remove from appropriate folder array\n            const updatedProjectFolders = projectFolders.filter((folder)=>folder.id !== folderId);\n            const updatedFinancialFolders = financialFolders.filter((folder)=>folder.id !== folderId);\n            // Also remove any files that were in this folder\n            const updatedProjectFiles = projectFiles.filter((file)=>file.folderId !== folderId);\n            const updatedFinancialFiles = financialFiles.filter((file)=>file.folderId !== folderId);\n            set({\n                projectFolders: updatedProjectFolders,\n                financialFolders: updatedFinancialFolders,\n                projectFiles: updatedProjectFiles,\n                financialFiles: updatedFinancialFiles\n            });\n        },\n        moveToTrash: (item, type)=>{\n            const { trashItems, projectFiles, financialFiles, projectFolders, financialFolders, openTabs } = get();\n            // Create trash item\n            const trashItem = {\n                id: \"trash_\".concat(item.id, \"_\").concat(Date.now()),\n                name: item.name,\n                type,\n                originalData: item,\n                deletedAt: new Date(),\n                category: item.category\n            };\n            if (type === 'file') {\n                const file = item;\n                // Close tab if it's open\n                const tabToClose = openTabs.find((tab)=>tab.id === file.id);\n                if (tabToClose) {\n                    get().closeTab(file.id);\n                }\n                // Remove from appropriate file array\n                const updatedProjectFiles = projectFiles.filter((f)=>f.id !== file.id);\n                const updatedFinancialFiles = financialFiles.filter((f)=>f.id !== file.id);\n                set({\n                    trashItems: [\n                        ...trashItems,\n                        trashItem\n                    ],\n                    projectFiles: updatedProjectFiles,\n                    financialFiles: updatedFinancialFiles\n                });\n            } else {\n                const folder = item;\n                // Find all files that were in this folder and move them to trash too\n                const filesToTrash = [\n                    ...projectFiles.filter((file)=>file.folderId === folder.id),\n                    ...financialFiles.filter((file)=>file.folderId === folder.id)\n                ];\n                // Close tabs for all files in this folder\n                filesToTrash.forEach((file)=>{\n                    const tabToClose = openTabs.find((tab)=>tab.id === file.id);\n                    if (tabToClose) {\n                        get().closeTab(file.id);\n                    }\n                });\n                // Create trash items for all files in the folder\n                const fileTrashItems = filesToTrash.map((file)=>({\n                        id: \"trash_\".concat(file.id, \"_\").concat(Date.now()),\n                        name: file.name,\n                        type: 'file',\n                        originalData: file,\n                        deletedAt: new Date(),\n                        category: file.category\n                    }));\n                // Remove folder and its files from arrays\n                const updatedProjectFolders = projectFolders.filter((f)=>f.id !== folder.id);\n                const updatedFinancialFolders = financialFolders.filter((f)=>f.id !== folder.id);\n                const updatedProjectFiles = projectFiles.filter((file)=>file.folderId !== folder.id);\n                const updatedFinancialFiles = financialFiles.filter((file)=>file.folderId !== folder.id);\n                set({\n                    trashItems: [\n                        ...trashItems,\n                        trashItem,\n                        ...fileTrashItems\n                    ],\n                    projectFolders: updatedProjectFolders,\n                    financialFolders: updatedFinancialFolders,\n                    projectFiles: updatedProjectFiles,\n                    financialFiles: updatedFinancialFiles\n                });\n            }\n        },\n        restoreFromTrash: (trashItemId)=>{\n            const { trashItems, projectFiles, financialFiles, projectFolders, financialFolders } = get();\n            const trashItem = trashItems.find((item)=>item.id === trashItemId);\n            if (!trashItem) return;\n            // Remove from trash\n            const updatedTrashItems = trashItems.filter((item)=>item.id !== trashItemId);\n            // Restore to appropriate array\n            if (trashItem.type === 'file') {\n                const file = trashItem.originalData;\n                if (file.category === 'project') {\n                    set({\n                        trashItems: updatedTrashItems,\n                        projectFiles: [\n                            ...projectFiles,\n                            {\n                                ...file,\n                                modifiedAt: new Date()\n                            }\n                        ]\n                    });\n                } else {\n                    set({\n                        trashItems: updatedTrashItems,\n                        financialFiles: [\n                            ...financialFiles,\n                            {\n                                ...file,\n                                modifiedAt: new Date()\n                            }\n                        ]\n                    });\n                }\n            } else {\n                const folder = trashItem.originalData;\n                if (folder.category === 'project') {\n                    set({\n                        trashItems: updatedTrashItems,\n                        projectFolders: [\n                            ...projectFolders,\n                            folder\n                        ]\n                    });\n                } else {\n                    set({\n                        trashItems: updatedTrashItems,\n                        financialFolders: [\n                            ...financialFolders,\n                            folder\n                        ]\n                    });\n                }\n            }\n        },\n        permanentlyDelete: (trashItemId)=>{\n            const { trashItems } = get();\n            // Remove from trash permanently\n            const updatedTrashItems = trashItems.filter((item)=>item.id !== trashItemId);\n            set({\n                trashItems: updatedTrashItems\n            });\n        },\n        emptyTrash: ()=>{\n            set({\n                trashItems: []\n            });\n        },\n        clearProjectCategory: ()=>{\n            const { openTabs } = get();\n            // Close all project-related tabs\n            const projectTabIds = openTabs.filter((tab)=>{\n                // Find the corresponding file to check its category\n                const { projectFiles } = get();\n                const file = projectFiles.find((f)=>f.id === tab.id);\n                return (file === null || file === void 0 ? void 0 : file.category) === 'project';\n            }).map((tab)=>tab.id);\n            projectTabIds.forEach((tabId)=>get().closeTab(tabId));\n            // Clear all project files and folders\n            set({\n                projectFiles: [],\n                projectFolders: []\n            });\n        },\n        clearFinancialCategory: ()=>{\n            const { openTabs } = get();\n            // Close all financial-related tabs\n            const financialTabIds = openTabs.filter((tab)=>{\n                // Find the corresponding file to check its category\n                const { financialFiles } = get();\n                const file = financialFiles.find((f)=>f.id === tab.id);\n                return (file === null || file === void 0 ? void 0 : file.category) === 'financial';\n            }).map((tab)=>tab.id);\n            financialTabIds.forEach((tabId)=>get().closeTab(tabId));\n            // Clear all financial files and folders\n            set({\n                financialFiles: [],\n                financialFolders: []\n            });\n        },\n        deleteProjectsCategory: ()=>{\n            get().clearProjectCategory();\n            set({\n                showProjectsCategory: false\n            });\n        },\n        deleteFinancialCategory: ()=>{\n            get().clearFinancialCategory();\n            set({\n                showFinancialCategory: false\n            });\n        },\n        reorderProjectFolders: (fromIndex, toIndex)=>{\n            const { projectFolders } = get();\n            const newFolders = [\n                ...projectFolders\n            ];\n            const [movedFolder] = newFolders.splice(fromIndex, 1);\n            newFolders.splice(toIndex, 0, movedFolder);\n            set({\n                projectFolders: newFolders\n            });\n        },\n        reorderFilesInFolder: (folderId, fromIndex, toIndex, category)=>{\n            const { projectFiles, financialFiles } = get();\n            if (category === 'project') {\n                // Filter files in the specific folder\n                const folderFiles = projectFiles.filter((file)=>file.folderId === folderId);\n                const otherFiles = projectFiles.filter((file)=>file.folderId !== folderId);\n                // Reorder files within the folder\n                const reorderedFolderFiles = [\n                    ...folderFiles\n                ];\n                const [movedFile] = reorderedFolderFiles.splice(fromIndex, 1);\n                reorderedFolderFiles.splice(toIndex, 0, movedFile);\n                // Combine with other files\n                const newProjectFiles = [\n                    ...otherFiles,\n                    ...reorderedFolderFiles\n                ];\n                set({\n                    projectFiles: newProjectFiles\n                });\n            } else {\n                // Similar logic for financial files\n                const folderFiles = financialFiles.filter((file)=>file.folderId === folderId);\n                const otherFiles = financialFiles.filter((file)=>file.folderId !== folderId);\n                const reorderedFolderFiles = [\n                    ...folderFiles\n                ];\n                const [movedFile] = reorderedFolderFiles.splice(fromIndex, 1);\n                reorderedFolderFiles.splice(toIndex, 0, movedFile);\n                const newFinancialFiles = [\n                    ...otherFiles,\n                    ...reorderedFolderFiles\n                ];\n                set({\n                    financialFiles: newFinancialFiles\n                });\n            }\n        },\n        saveFile: (tabId)=>{\n            const { openTabs, projectFiles, financialFiles } = get();\n            const tab = openTabs.find((t)=>t.id === tabId);\n            if (!tab) return;\n            // Update the file content in appropriate array\n            const updatedProjectFiles = projectFiles.map((file)=>file.id === tabId ? {\n                    ...file,\n                    content: tab.content,\n                    modifiedAt: new Date()\n                } : file);\n            const updatedFinancialFiles = financialFiles.map((file)=>file.id === tabId ? {\n                    ...file,\n                    content: tab.content,\n                    modifiedAt: new Date()\n                } : file);\n            const updatedTabs = openTabs.map((t)=>t.id === tabId ? {\n                    ...t,\n                    modified: false\n                } : t);\n            set({\n                projectFiles: updatedProjectFiles,\n                financialFiles: updatedFinancialFiles,\n                openTabs: updatedTabs\n            });\n        },\n        setError: (error)=>{\n            set({\n                error\n            });\n        },\n        reset: ()=>{\n            set({\n                openTabs: [],\n                activeTab: '',\n                projectFiles: initialProjectFiles,\n                financialFiles: initialFinancialFiles,\n                projectFolders: [],\n                financialFolders: [],\n                showProjectsCategory: true,\n                showFinancialCategory: true,\n                isLoading: false,\n                error: null\n            });\n        }\n    }), {\n    name: 'editor-storage',\n    // Only persist specific fields\n    partialize: (state)=>({\n            openTabs: state.openTabs.map((tab)=>({\n                    id: tab.id,\n                    name: tab.name,\n                    modified: tab.modified,\n                    content: tab.content,\n                    filePath: tab.filePath,\n                    type: tab.type\n                })),\n            activeTab: state.activeTab,\n            projectFiles: state.projectFiles,\n            financialFiles: state.financialFiles,\n            projectFolders: state.projectFolders,\n            financialFolders: state.financialFolders,\n            showProjectsCategory: state.showProjectsCategory,\n            showFinancialCategory: state.showFinancialCategory\n        }),\n    // Custom storage to handle icon restoration\n    storage: {\n        getItem: (name)=>{\n            const str = localStorage.getItem(name);\n            if (!str) return null;\n            const { state } = JSON.parse(str);\n            // Restore icons based on file type\n            const restoredTabs = (state.openTabs || []).map((tab)=>{\n                let icon = _barrel_optimize_names_AtSign_Braces_Camera_FileCode_FileSpreadsheet_FileText_FileType_Hash_MessageSquare_lucide_react__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\n                switch(tab.type){\n                    case 'typescript':\n                    case 'javascript':\n                        icon = _barrel_optimize_names_AtSign_Braces_Camera_FileCode_FileSpreadsheet_FileText_FileType_Hash_MessageSquare_lucide_react__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\n                        break;\n                    case 'json':\n                        icon = _barrel_optimize_names_AtSign_Braces_Camera_FileCode_FileSpreadsheet_FileText_FileType_Hash_MessageSquare_lucide_react__WEBPACK_IMPORTED_MODULE_1__[\"default\"];\n                        break;\n                    case 'excel':\n                        icon = _barrel_optimize_names_AtSign_Braces_Camera_FileCode_FileSpreadsheet_FileText_FileType_Hash_MessageSquare_lucide_react__WEBPACK_IMPORTED_MODULE_2__[\"default\"];\n                        break;\n                    case 'markdown':\n                        icon = _barrel_optimize_names_AtSign_Braces_Camera_FileCode_FileSpreadsheet_FileText_FileType_Hash_MessageSquare_lucide_react__WEBPACK_IMPORTED_MODULE_3__[\"default\"];\n                        break;\n                    case 'pdf':\n                        icon = _barrel_optimize_names_AtSign_Braces_Camera_FileCode_FileSpreadsheet_FileText_FileType_Hash_MessageSquare_lucide_react__WEBPACK_IMPORTED_MODULE_4__[\"default\"];\n                        break;\n                }\n                return {\n                    ...tab,\n                    icon\n                };\n            });\n            return {\n                state: {\n                    ...state,\n                    openTabs: restoredTabs\n                }\n            };\n        },\n        setItem: (name, value)=>{\n            localStorage.setItem(name, JSON.stringify(value));\n        },\n        removeItem: (name)=>localStorage.removeItem(name)\n    }\n}), {\n    name: 'editor-store'\n}));\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3N0b3JlL2VkaXRvci9pbmRleC50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBQSxlQUFlO0FBQ2YsNkRBQTZEO0FBRXVFO0FBQ25HO0FBQ3NCO0FBR3ZELGlEQUFpRDtBQUNqRCxNQUFNWSxjQUFjLENBQUNDO0lBQ25CLE9BQVFBO1FBQ04sS0FBSztZQUNILE9BQU9WLDhKQUFRQTtRQUNqQixLQUFLO1lBQ0gsT0FBT0EsOEpBQVFBO1FBQ2pCLEtBQUs7WUFDSCxPQUFPRiw4SkFBTUE7UUFDZixLQUFLO1lBQ0gsT0FBT0csOEpBQWVBO1FBQ3hCLEtBQUs7WUFDSCxPQUFPQyw4SkFBUUE7UUFDakIsS0FBSztZQUNILE9BQU9DLDhKQUFRQTtRQUNqQixLQUFLO1lBQ0gsT0FBT0QsOEpBQVFBO1FBQ2pCLEtBQUs7WUFDSCxPQUFPRCw4SkFBZUE7UUFDeEIsS0FBSztZQUNILE9BQU9BLDhKQUFlQTtRQUN4QixLQUFLO1lBQ0gsT0FBT0EsOEpBQWVBO1FBQ3hCLEtBQUs7WUFDSCxPQUFPSSw4SkFBYUE7UUFDdEIsS0FBSztZQUNILE9BQU9ELDhKQUFJQTtRQUNiLEtBQUs7WUFDSCxPQUFPTCw4SkFBTUE7UUFDZixLQUFLO1lBQ0gsT0FBT0YsOEpBQU1BO1FBQ2Y7WUFDRSxPQUFPRyw4SkFBUUE7SUFDbkI7QUFDRjtBQUVBLHdDQUF3QztBQUN4Qyx3Q0FBd0M7QUFDeEMsTUFBTVcsbUJBQW1CLENBQUNEO0lBQ3hCLE9BQVFBO1FBQ04sS0FBSztZQUNILE9BQU87UUFDVCxLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7WUFDSCxPQUFPO1FBQ1QsS0FBSztZQUNILE9BQU87UUFDVCxLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7WUFDSCxPQUFPO1FBQ1QsS0FBSztZQUNILE9BQU87UUFDVCxLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7WUFDSCxPQUFPO1FBQ1QsS0FBSztZQUNILE9BQU87UUFDVCxLQUFLO1lBQ0gsT0FBTztR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LEdBQUcwQyxHQUFHO29CQUNOekI7Z0JBQ0Y7WUFDRjtZQUVBLE9BQU87Z0JBQ0xtSixPQUFPO29CQUNMLEdBQUdBLEtBQUs7b0JBQ1J6SSxVQUFVZ0o7Z0JBQ1o7WUFDRjtRQUNGO1FBQ0FDLFNBQVMsQ0FBQ2xLLE1BQU1tSztZQUNkTCxhQUFhSSxPQUFPLENBQUNsSyxNQUFNK0osS0FBS0ssU0FBUyxDQUFDRDtRQUM1QztRQUNBRSxZQUFZLENBQUNySyxPQUFTOEosYUFBYU8sVUFBVSxDQUFDcks7SUFDaEQ7QUFDRixJQUVGO0lBQUVBLE1BQU07QUFBZSxJQUV6QiIsInNvdXJjZXMiOlsiL1VzZXJzL21hdHRoZXdzaW1vbi9Qcm9qZWN0cy9lYWMvZWFjL3N0b3JlL2VkaXRvci9pbmRleC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBFZGl0b3IgU3RvcmVcbi8vIC9Vc2Vycy9tYXR0aGV3c2ltb24vUHJvamVjdHMvRUFDL2VhYy9zdG9yZS9lZGl0b3IvaW5kZXgudHNcblxuaW1wb3J0IHsgQXRTaWduLCBCcmFjZXMsIENhbGVuZGFyLCBDYW1lcmEsIEZpbGVDb2RlLCBGaWxlU3ByZWFkc2hlZXQsIEZpbGVUZXh0LCBGaWxlVHlwZSwgSGFzaCwgTWVzc2FnZVNxdWFyZSB9IGZyb20gJ2x1Y2lkZS1yZWFjdCc7XG5pbXBvcnQgeyBjcmVhdGUgfSBmcm9tICd6dXN0YW5kJztcbmltcG9ydCB7IGRldnRvb2xzLCBwZXJzaXN0IH0gZnJvbSAnenVzdGFuZC9taWRkbGV3YXJlJztcbmltcG9ydCB7IEVkaXRvclN0YXRlLCBFZGl0b3JUYWIsIFByb2plY3RGaWxlLCBQcm9qZWN0Rm9sZGVyLCBUcmFzaEl0ZW0gfSBmcm9tICcuL3R5cGVzJztcblxuLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGdldCBpY29uIGJhc2VkIG9uIGZpbGUgdHlwZVxuY29uc3QgZ2V0RmlsZUljb24gPSAodHlwZTogUHJvamVjdEZpbGVbJ3R5cGUnXSkgPT4ge1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICd0eXBlc2NyaXB0JzpcbiAgICAgIHJldHVybiBGaWxlQ29kZTtcbiAgICBjYXNlICdqYXZhc2NyaXB0JzpcbiAgICAgIHJldHVybiBGaWxlQ29kZTtcbiAgICBjYXNlICdqc29uJzpcbiAgICAgIHJldHVybiBCcmFjZXM7XG4gICAgY2FzZSAnZXhjZWwnOlxuICAgICAgcmV0dXJuIEZpbGVTcHJlYWRzaGVldDtcbiAgICBjYXNlICdtYXJrZG93bic6XG4gICAgICByZXR1cm4gRmlsZVRleHQ7XG4gICAgY2FzZSAncGRmJzpcbiAgICAgIHJldHVybiBGaWxlVHlwZTtcbiAgICBjYXNlICdnZW5lcmFscyc6XG4gICAgICByZXR1cm4gRmlsZVRleHQ7XG4gICAgY2FzZSAncGVyY2VudC1jb21wbGV0ZSc6XG4gICAgICByZXR1cm4gRmlsZVNwcmVhZHNoZWV0O1xuICAgIGNhc2UgJ3NjaGVkdWxlJzpcbiAgICAgIHJldHVybiBGaWxlU3ByZWFkc2hlZXQ7XG4gICAgY2FzZSAnbWF0ZXJpYWxzJzpcbiAgICAgIHJldHVybiBGaWxlU3ByZWFkc2hlZXQ7XG4gICAgY2FzZSAnZmFjZWJvb2snOlxuICAgICAgcmV0dXJuIE1lc3NhZ2VTcXVhcmU7XG4gICAgY2FzZSAncmVkZGl0JzpcbiAgICAgIHJldHVybiBIYXNoO1xuICAgIGNhc2UgJ2luc3RhZ3JhbSc6XG4gICAgICByZXR1cm4gQ2FtZXJhO1xuICAgIGNhc2UgJ3gnOlxuICAgICAgcmV0dXJuIEF0U2lnbjtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIEZpbGVDb2RlO1xuICB9XG59O1xuXG4vLyBIZWxwZXIgZnVuY3Rpb24gdG8gZ2V0IGZpbGUgZXh0ZW5zaW9uXG4vLyBIZWxwZXIgZnVuY3Rpb24gdG8gZ2V0IGZpbGUgZXh0ZW5zaW9uXG5jb25zdCBnZXRGaWxlRXh0ZW5zaW9uID0gKHR5cGU6IFByb2plY3RGaWxlWyd0eXBlJ10pOiBzdHJpbmcgPT4ge1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICd0eXBlc2NyaXB0JzpcbiAgICAgIHJldHVybiAnLnRzJztcbiAgICBjYXNlICdqYXZhc2NyaXB0JzpcbiAgICAgIHJldHVybiAnLmpzJztcbiAgICBjYXNlICdqc29uJzpcbiAgICAgIHJldHVybiAnLmpzb24nO1xuICAgIGNhc2UgJ2V4Y2VsJzpcbiAgICAgIHJldHVybiAnLnhsc3gnO1xuICAgIGNhc2UgJ3BkZic6XG4gICAgICByZXR1cm4gJy5wZGYnO1xuICAgIGNhc2UgJ2dlbmVyYWxzJzpcbiAgICAgIHJldHVybiAnLmdlbmVyYWxzJztcbiAgICBjYXNlICdwZXJjZW50LWNvbXBsZXRlJzpcbiAgICAgIHJldHVybiAnLnBlcmNlbnQnO1xuICAgIGNhc2UgJ3NjaGVkdWxlJzpcbiAgICAgIHJldHVybiAnLnNjaGVkdWxlJztcbiAgICBjYXNlICdtYXRlcmlhbHMnOlxuICAgICAgcmV0dXJuICcubWF0ZXJpYWxzJztcbiAgICBjYXNlICdmYWNlYm9vayc6XG4gICAgICByZXR1cm4gJy5mYWNlYm9vayc7XG4gICAgY2FzZSAncmVkZGl0JzpcbiAgICAgIHJldHVybiAnLnJlZGRpdCc7XG4gICAgY2FzZSAnaW5zdGFncmFtJzpcbiAgICAgIHJldHVybiAnLmluc3RhZ3JhbSc7XG4gICAgY2FzZSAneCc6XG4gICAgICByZXR1cm4gJy54JztcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuICcudHh0JztcbiAgfVxufTtcblxuLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGdlbmVyYXRlIGRlZmF1bHQgY29udGVudCBmb3IgbmV3IGZpbGVzXG5jb25zdCBnZXREZWZhdWx0Q29udGVudCA9ICh0eXBlOiBQcm9qZWN0RmlsZVsndHlwZSddLCBuYW1lOiBzdHJpbmcpID0+IHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAndHlwZXNjcmlwdCc6XG4gICAgICByZXR1cm4gYC8vICR7bmFtZX1cbi8vIEF1dG8tZ2VuZXJhdGVkIFR5cGVTY3JpcHQgZmlsZVxuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5pbnRlcmZhY2UgJHtuYW1lLnJlcGxhY2UoL1teYS16QS1aMC05XS9nLCAnJyl9UHJvcHMge1xuICAvLyBEZWZpbmUgcHJvcHMgaGVyZVxufVxuXG5leHBvcnQgZnVuY3Rpb24gJHtuYW1lLnJlcGxhY2UoL1teYS16QS1aMC05XS9nLCAnJyl9KHsgfTogJHtuYW1lLnJlcGxhY2UoL1teYS16QS1aMC05XS9nLCAnJyl9UHJvcHMpIHtcbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT1cInAtNFwiPlxuICAgICAgPGgxIGNsYXNzTmFtZT1cInRleHQteGwgZm9udC1ib2xkXCI+TmV3IENvbXBvbmVudDogJHtuYW1lfTwvaDE+XG4gICAgICA8cCBjbGFzc05hbWU9XCJ0ZXh0LWdyYXktNjAwXCI+U3RhcnQgYnVpbGRpbmcgeW91ciBjb21wb25lbnQgaGVyZS4uLjwvcD5cbiAgICA8L2Rpdj5cbiAgKTtcbn1gO1xuICAgIGNhc2UgJ2phdmFzY3JpcHQnOlxuICAgICAgcmV0dXJuIGAvLyAke25hbWV9XG4vLyBBdXRvLWdlbmVyYXRlZCBKYXZhU2NyaXB0IGZpbGVcblxuZXhwb3J0IGZ1bmN0aW9uICR7bmFtZS5yZXBsYWNlKC9bXmEtekEtWjAtOV0vZywgJycpfSgpIHtcbiAgcmV0dXJuIHtcbiAgICBtZXNzYWdlOiAnSGVsbG8gZnJvbSAke25hbWV9IScsXG4gICAgZGF0YTogW11cbiAgfTtcbn1gO1xuICAgIGNhc2UgJ2pzb24nOlxuICAgICAgcmV0dXJuIGB7XG4gIFwibmFtZVwiOiBcIiR7bmFtZX1cIixcbiAgXCJkZXNjcmlwdGlvblwiOiBcIkF1dG8tZ2VuZXJhdGVkIEpTT04gZmlsZVwiLFxuICBcInZlcnNpb25cIjogXCIxLjAuMFwiLFxuICBcImRhdGFcIjoge31cbn1gO1xuICAgIGNhc2UgJ21hcmtkb3duJzpcbiAgICAgIHJldHVybiBgU3RhcnQgd3JpdGluZyB5b3VyIGNvbnRlbnQgaGVyZS4uLmA7XG4gICAgY2FzZSAnZ2VuZXJhbHMnOlxuICAgICAgcmV0dXJuIGAvLyAke25hbWV9IC0gUHJvamVjdCBHZW5lcmFsIEluZm9ybWF0aW9uXG4vLyBUaGlzIGZpbGUgY29udGFpbnMgZ2VuZXJhbCBwcm9qZWN0IGRldGFpbHMgYW5kIGZpbmFuY2lhbCBpbmZvcm1hdGlvblxuLy8gQ3JlYXRlZCBvbjogJHtuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCl9XG5cblByb2plY3Q6ICR7bmFtZX1cblN0YXR1czogQWN0aXZlXG5DcmVhdGVkOiAke25ldyBEYXRlKCkudG9Mb2NhbGVEYXRlU3RyaW5nKCl9XG5cbi8vIFRoaXMgZmlsZSB3aWxsIGRpc3BsYXkgdGhlIHByb2plY3QgZ2VuZXJhbHMgbW9kdWxlIGludGVyZmFjZWA7XG4gICAgY2FzZSAncGVyY2VudC1jb21wbGV0ZSc6XG4gICAgICByZXR1cm4gYC8vICR7bmFtZX0gLSBQZXJjZW50IENvbXBsZXRlIFRyYWNrZXJcbi8vIFRoaXMgZmlsZSBjb250YWlucyBwcm9qZWN0IGNvbXBsZXRpb24gdHJhY2tpbmcgZGF0YVxuLy8gQ3JlYXRlZCBvbjogJHtuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCl9XG5cblByb2plY3Q6ICR7bmFtZX1cblR5cGU6IFBlcmNlbnQgQ29tcGxldGUgVHJhY2tlclxuQ3JlYXRlZDogJHtuZXcgRGF0ZSgpLnRvTG9jYWxlRGF0ZVN0cmluZygpfVxuXG4vLyBUaGlzIGZpbGUgd2lsbCBkaXNwbGF5IHRoZSBwZXJjZW50IGNvbXBsZXRlIHRyYWNraW5nIGludGVyZmFjZWA7XG4gICAgY2FzZSAnc2NoZWR1bGUnOlxuICAgICAgcmV0dXJuIGAvLyAke25hbWV9IC0gUHJvamVjdCBTY2hlZHVsZVxuLy8gVGhpcyBmaWxlIGNvbnRhaW5zIHByb2plY3Qgc2NoZWR1bGUgYW5kIHRpbWVsaW5lIGRhdGFcbi8vIENyZWF0ZWQgb246ICR7bmV3IERhdGUoKS50b0lTT1N0cmluZygpfVxuXG5Qcm9qZWN0OiAke25hbWV9XG5UeXBlOiBQcm9qZWN0IFNjaGVkdWxlXG5DcmVhdGVkOiAke25ldyBEYXRlKCkudG9Mb2NhbGVEYXRlU3RyaW5nKCl9XG5cbi8vIFRoaXMgZmlsZSB3aWxsIGRpc3BsYXkgdGhlIHByb2plY3Qgc2NoZWR1bGUgaW50ZXJmYWNlIHdpdGggR2FudHQgY2hhcnRgO1xuICAgIGNhc2UgJ21hdGVyaWFscyc6XG4gICAgICByZXR1cm4gYC8vICR7bmFtZX0gLSBNYXRlcmlhbHMgTWFuYWdlbWVudFxuLy8gVGhpcyBmaWxlIGNvbnRhaW5zIG1hdGVyaWFscyB0cmFja2luZyBhbmQgbWFuYWdlbWVudCBkYXRhXG4vLyBDcmVhdGVkIG9uOiAke25ldyBEYXRlKCkudG9JU09TdHJpbmcoKX1cblxuUHJvamVjdDogJHtuYW1lfVxuVHlwZTogTWF0ZXJpYWxzIE1hbmFnZW1lbnRcbkNyZWF0ZWQ6ICR7bmV3IERhdGUoKS50b0xvY2FsZURhdGVTdHJpbmcoKX1cblxuLy8gVGhpcyBmaWxlIHdpbGwgZGlzcGxheSB0aGUgbWF0ZXJpYWxzIG1hbmFnZW1lbnQgaW50ZXJmYWNlIHdpdGggbWFudWZhY3R1cmVkIGFuZCBtaXNjZWxsYW5lb3VzIG1hdGVyaWFsc2A7XG4gICAgY2FzZSAnZmFjZWJvb2snOlxuICAgICAgcmV0dXJuIGAjICR7bmFtZX0gLSBGYWNlYm9vayBQb3N0XG5QbGF0Zm9ybTogRmFjZWJvb2tcbkNyZWF0ZWQ6ICR7bmV3IERhdGUoKS50b0xvY2FsZURhdGVTdHJpbmcoKX1cblxuIyMgUG9zdCBDb250ZW50XG5Xcml0ZSB5b3VyIEZhY2Vib29rIHBvc3QgY29udGVudCBoZXJlLi4uXG5cbiMjIFNldHRpbmdzXG4tIEF1ZGllbmNlOiBQdWJsaWNcbi0gU2NoZWR1bGU6IE5vd1xuLSBIYXNodGFnczogI2V4YW1wbGVcblxuIyMgTWVkaWFcbi0gSW1hZ2VzOiBbXVxuLSBWaWRlb3M6IFtdXG5cbiMjIEFuYWx5dGljc1xuLSBFbmdhZ2VtZW50OiAwXG4tIFJlYWNoOiAwXG4tIENsaWNrczogMGA7XG4gICAgY2FzZSAncmVkZGl0JzpcbiAgICAgIHJldHVybiBgIyAke25hbWV9IC0gUmVkZGl0IFBvc3RcblBsYXRmb3JtOiBSZWRkaXRcbkNyZWF0ZWQ6ICR7bmV3IERhdGUoKS50b0xvY2FsZURhdGVTdHJpbmcoKX1cblxuIyMgUG9zdCBDb250ZW50XG5Xcml0ZSB5b3VyIFJlZGRpdCBwb3N0IGNvbnRlbnQgaGVyZS4uLlxuXG4jIyBTZXR0aW5nc1xuLSBTdWJyZWRkaXQ6IHIvZXhhbXBsZVxuLSBQb3N0IFR5cGU6IFRleHQvTGluay9JbWFnZVxuLSBGbGFpcjogRGlzY3Vzc2lvblxuLSBOU0ZXOiBOb1xuXG4jIyBNZWRpYVxuLSBJbWFnZXM6IFtdXG4tIExpbmtzOiBbXVxuXG4jIyBBbmFseXRpY3Ncbi0gVXB2b3RlczogMFxuLSBDb21tZW50czogMFxuLSBBd2FyZHM6IDBgO1xuICAgIGNhc2UgJ2luc3RhZ3JhbSc6XG4gICAgICByZXR1cm4gYCMgJHtuYW1lfSAtIEluc3RhZ3JhbSBQb3N0XG5QbGF0Zm9ybTogSW5zdGFncmFtXG5DcmVhdGVkOiAke25ldyBEYXRlKCkudG9Mb2NhbGVEYXRlU3RyaW5nKCl9XG5cbiMjIFBvc3QgQ29udGVudFxuV3JpdGUgeW91ciBJbnN0YWdyYW0gcG9zdCBjb250ZW50IGhlcmUuLi5cblxuIyMgU2V0dGluZ3Ncbi0gUG9zdCBUeXBlOiBGZWVkL1N0b3J5L1JlZWxcbi0gTG9jYXRpb246IENpdHksIENvdW50cnlcbi0gQWx0IFRleHQ6IERlc2NyaWJlIGltYWdlXG4tIENvbW1lbnQgU2V0dGluZ3M6IFB1YmxpY1xuXG4jIyBNZWRpYVxuLSBJbWFnZXM6IFtdXG4tIFZpZGVvczogW11cblxuIyMgSGFzaHRhZ3NcbiNoYXNodGFnMSAjaGFzaHRhZzIgI2hhc2h0YWczXG5cbiMjIEFuYWx5dGljc1xuLSBMaWtlczogMFxuLSBDb21tZW50czogMFxuLSBTaGFyZXM6IDBcbi0gUmVhY2g6IDBgO1xuICAgIGNhc2UgJ3gnOlxuICAgICAgcmV0dXJuIGAjICR7bmFtZX0gLSBYL1R3aXR0ZXIgUG9zdFxuUGxhdGZvcm06IFggKFR3aXR0ZXIpXG5DcmVhdGVkOiAke25ldyBEYXRlKCkudG9Mb2NhbGVEYXRlU3RyaW5nKCl9XG5cbiMjIFBvc3QgQ29udGVudFxuV3JpdGUgeW91ciBYIHBvc3QgY29udGVudCBoZXJlLi4uICgyODAgY2hhcmFjdGVyIGxpbWl0KVxuXG4jIyBTZXR0aW5nc1xuLSBSZXBseSBTZXR0aW5nczogRXZlcnlvbmVcbi0gU2NoZWR1bGU6IE5vd1xuLSBUaHJlYWQ6IFNpbmdsZSBUd2VldFxuXG4jIyBNZWRpYVxuLSBJbWFnZXM6IFtdXG4tIFZpZGVvczogW11cbi0gR0lGczogW11cblxuIyMgQW5hbHl0aWNzXG4tIEltcHJlc3Npb25zOiAwXG4tIEVuZ2FnZW1lbnRzOiAwXG4tIFJldHdlZXRzOiAwXG4tIExpa2VzOiAwXG4tIFJlcGxpZXM6IDBgO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gYCMgJHtuYW1lfVxuXG5UaGlzIGlzIGEgbmV3IGZpbGUgY3JlYXRlZCBpbiB0aGUgRUFDIERhc2hib2FyZC5cbkNyZWF0ZWQgb246ICR7bmV3IERhdGUoKS50b0lTT1N0cmluZygpfWA7XG4gIH1cbn07XG5cbi8vIEluaXRpYWwgcHJvamVjdCBmaWxlc1xuY29uc3QgaW5pdGlhbFByb2plY3RGaWxlczogUHJvamVjdEZpbGVbXSA9IFtcbiAge1xuICAgIGlkOiAncHJvamVjdC1vdmVydmlldycsXG4gICAgbmFtZTogJ1Byb2plY3QtT3ZlcnZpZXcubWQnLFxuICAgIGljb246IEZpbGVUZXh0LFxuICAgIHR5cGU6ICdtYXJrZG93bicsXG4gICAgY2F0ZWdvcnk6ICdwcm9qZWN0JyxcbiAgICBjb250ZW50OiBgIyBQcm9qZWN0IE92ZXJ2aWV3XG5cbiMjIEN1cnJlbnQgUHJvamVjdHNcbi0gV3JpdGUgeW91ciBwcm9qZWN0IGRldGFpbHMgaGVyZS4uLlxuLSBUcmFjayBwcm9ncmVzcyBhbmQgbWlsZXN0b25lc1xuLSBEb2N1bWVudCByZXF1aXJlbWVudHMgYW5kIHNwZWNpZmljYXRpb25zXG5cbiMjIE5vdGVzXG5TdGFydCBwbGFubmluZyB5b3VyIHByb2plY3RzIGhlcmUuLi5gLFxuICAgIGZpbGVQYXRoOiAnL2VhYy1wcm9qZWN0cy9Qcm9qZWN0LU92ZXJ2aWV3Lm1kJyxcbiAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCksXG4gICAgbW9kaWZpZWRBdDogbmV3IERhdGUoKSxcbiAgfSxcbl07XG5cbi8vIEluaXRpYWwgZmluYW5jaWFsIGZpbGVzXG5jb25zdCBpbml0aWFsRmluYW5jaWFsRmlsZXM6IFByb2plY3RGaWxlW10gPSBbXG4gIHtcbiAgICBpZDogJ2ZpbmFuY2lhbC1ub3RlcycsXG4gICAgbmFtZTogJ0ZpbmFuY2lhbC1Ob3Rlcy5tZCcsXG4gICAgaWNvbjogRmlsZVRleHQsXG4gICAgdHlwZTogJ21hcmtkb3duJyxcbiAgICBjYXRlZ29yeTogJ2ZpbmFuY2lhbCcsXG4gICAgY29udGVudDogYCMgRmluYW5jaWFsIE5vdGVzXG5cbiMjIE1vbnRobHkgVHJhY2tpbmdcbi0gVHJhY2sgeW91ciByZXZlbnVlIGFuZCBleHBlbnNlcyBoZXJlXG4tIE1vbml0b3IgYnVkZ2V0IGFsbG9jYXRpb25zXG4tIERvY3VtZW50IGZpbmFuY2lhbCBkZWNpc2lvbnNcblxuIyMgQnVkZ2V0IE92ZXJ2aWV3XG5TdGFydCBkb2N1bWVudGluZyB5b3VyIGZpbmFuY2lhbCBwbGFubmluZyBoZXJlLi4uYCxcbiAgICBmaWxlUGF0aDogJy9maW5hbmNpYWwtZGF0YS9GaW5hbmNpYWwtTm90ZXMubWQnLFxuICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKSxcbiAgICBtb2RpZmllZEF0OiBuZXcgRGF0ZSgpLFxuICB9LFxuXTtcblxuZXhwb3J0IGNvbnN0IHVzZUVkaXRvclN0b3JlID0gY3JlYXRlPEVkaXRvclN0YXRlPigpKFxuICBkZXZ0b29scyhcbiAgICBwZXJzaXN0KFxuICAgICAgKHNldCwgZ2V0KSA9PiAoe1xuICAgICAgICAvLyBJbml0aWFsIHN0YXRlXG4gICAgICAgIG9wZW5UYWJzOiBbXSxcbiAgICAgICAgYWN0aXZlVGFiOiAnJyxcbiAgICAgICAgcHJvamVjdEZpbGVzOiBpbml0aWFsUHJvamVjdEZpbGVzLFxuICAgICAgICBmaW5hbmNpYWxGaWxlczogaW5pdGlhbEZpbmFuY2lhbEZpbGVzLFxuICAgICAgICBwcm9qZWN0Rm9sZGVyczogW10sXG4gICAgICAgIGZpbmFuY2lhbEZvbGRlcnM6IFtdLFxuICAgICAgICB0cmFzaEl0ZW1zOiBbXSxcbiAgICAgICAgc2hvd1Byb2plY3RzQ2F0ZWdvcnk6IHRydWUsXG4gICAgICAgIHNob3dGaW5hbmNpYWxDYXRlZ29yeTogdHJ1ZSxcbiAgICAgICAgaXNMb2FkaW5nOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6IG51bGwsXG5cbiAgICAgICAgLy8gQWN0aW9uc1xuICAgICAgICBvcGVuVGFiOiAoZmlsZTogUHJvamVjdEZpbGUpID0+IHtcbiAgICAgICAgICBjb25zdCB7IG9wZW5UYWJzIH0gPSBnZXQoKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBDaGVjayBpZiB0YWIgaXMgYWxyZWFkeSBvcGVuXG4gICAgICAgICAgY29uc3QgZXhpc3RpbmdUYWIgPSBvcGVuVGFicy5maW5kKHRhYiA9PiB0YWIuaWQgPT09IGZpbGUuaWQpO1xuICAgICAgICAgIGlmIChleGlzdGluZ1RhYikge1xuICAgICAgICAgICAgc2V0KHsgYWN0aXZlVGFiOiBleGlzdGluZ1RhYi5pZCB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBDcmVhdGUgbmV3IHRhYlxuICAgICAgICAgIGNvbnN0IG5ld1RhYjogRWRpdG9yVGFiID0ge1xuICAgICAgICAgICAgaWQ6IGZpbGUuaWQsXG4gICAgICAgICAgICBuYW1lOiBmaWxlLm5hbWUsXG4gICAgICAgICAgICBtb2RpZmllZDogZmFsc2UsXG4gICAgICAgICAgICBjb250ZW50OiBmaWxlLmNvbnRlbnQsXG4gICAgICAgICAgICBmaWxlUGF0aDogZmlsZS5maWxlUGF0aCxcbiAgICAgICAgICAgIHR5cGU6IGZpbGUudHlwZSxcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgc2V0KHtcbiAgICAgICAgICAgIG9wZW5UYWJzOiBbLi4ub3BlblRhYnMsIG5ld1RhYl0sXG4gICAgICAgICAgICBhY3RpdmVUYWI6IG5ld1RhYi5pZCxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBvcGVuU3BlY2lhbFRhYjogKGlkOiBzdHJpbmcsIG5hbWU6IHN0cmluZywgdHlwZTogJ3NvY2lhbC1jb25uZWN0JyB8ICdwb3N0LWNyZWF0b3InKSA9PiB7XG4gICAgICAgICAgY29uc3QgeyBvcGVuVGFicyB9ID0gZ2V0KCk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQ2hlY2sgaWYgdGFiIGlzIGFscmVhZHkgb3BlblxuICAgICAgICAgIGNvbnN0IGV4aXN0aW5nVGFiID0gb3BlblRhYnMuZmluZCh0YWIgPT4gdGFiLmlkID09PSBpZCk7XG4gICAgICAgICAgaWYgKGV4aXN0aW5nVGFiKSB7XG4gICAgICAgICAgICBzZXQoeyBhY3RpdmVUYWI6IGV4aXN0aW5nVGFiLmlkIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIENyZWF0ZSBuZXcgc3BlY2lhbCB0YWJcbiAgICAgICAgICBjb25zdCBuZXdUYWI6IEVkaXRvclRhYiA9IHtcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIG1vZGlmaWVkOiBmYWxzZSxcbiAgICAgICAgICAgIGNvbnRlbnQ6ICcnLFxuICAgICAgICAgICAgZmlsZVBhdGg6IGAvJHt0eXBlfWAsXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBzZXQoe1xuICAgICAgICAgICAgb3BlblRhYnM6IFsuLi5vcGVuVGFicywgbmV3VGFiXSxcbiAgICAgICAgICAgIGFjdGl2ZVRhYjogbmV3VGFiLmlkLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNsb3NlVGFiOiAodGFiSWQ6IHN0cmluZykgPT4ge1xuICAgICAgICAgIGNvbnN0IHsgb3BlblRhYnMsIGFjdGl2ZVRhYiB9ID0gZ2V0KCk7XG4gICAgICAgICAgY29uc3QgdGFiSW5kZXggPSBvcGVuVGFicy5maW5kSW5kZXgodGFiID0+IHRhYi5pZCA9PT0gdGFiSWQpO1xuICAgICAgICAgIFxuICAgICAgICAgIGlmICh0YWJJbmRleCA9PT0gLTEpIHJldHVybjtcblxuICAgICAgICAgIGNvbnN0IG5ld1RhYnMgPSBvcGVuVGFicy5maWx0ZXIodGFiID0+IHRhYi5pZCAhPT0gdGFiSWQpO1xuICAgICAgICAgIGxldCBuZXdBY3RpdmVUYWIgPSBhY3RpdmVUYWI7XG5cbiAgICAgICAgICAvLyBJZiBjbG9zaW5nIHRoZSBhY3RpdmUgdGFiLCBzd2l0Y2ggdG8gYW5vdGhlciB0YWJcbiAgICAgICAgICBpZiAoYWN0aXZlVGFiID09PSB0YWJJZCkge1xuICAgICAgICAgICAgaWYgKG5ld1RhYnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAvLyBTd2l0Y2ggdG8gdGhlIHRhYiB0byB0aGUgcmlnaHQsIG9yIHRoZSBsYXN0IHRhYiBpZiBjbG9zaW5nIHRoZSBsYXN0IG9uZVxuICAgICAgICAgICAgICBjb25zdCBuZXh0SW5kZXggPSB0YWJJbmRleCA8IG5ld1RhYnMubGVuZ3RoID8gdGFiSW5kZXggOiBuZXdUYWJzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgIG5ld0FjdGl2ZVRhYiA9IG5ld1RhYnNbbmV4dEluZGV4XS5pZDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5ld0FjdGl2ZVRhYiA9ICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHNldCh7XG4gICAgICAgICAgICBvcGVuVGFiczogbmV3VGFicyxcbiAgICAgICAgICAgIGFjdGl2ZVRhYjogbmV3QWN0aXZlVGFiLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNsb3NlQWxsVGFiczogKCkgPT4ge1xuICAgICAgICAgIHNldCh7XG4gICAgICAgICAgICBvcGVuVGFiczogW10sXG4gICAgICAgICAgICBhY3RpdmVUYWI6ICcnLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldEFjdGl2ZVRhYjogKHRhYklkOiBzdHJpbmcpID0+IHtcbiAgICAgICAgICBjb25zdCB7IG9wZW5UYWJzIH0gPSBnZXQoKTtcbiAgICAgICAgICBjb25zdCB0YWJFeGlzdHMgPSBvcGVuVGFicy5zb21lKHRhYiA9PiB0YWIuaWQgPT09IHRhYklkKTtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAodGFiRXhpc3RzKSB7XG4gICAgICAgICAgICBzZXQoeyBhY3RpdmVUYWI6IHRhYklkIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICB1cGRhdGVUYWJDb250ZW50OiAodGFiSWQ6IHN0cmluZywgY29udGVudDogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgY29uc3QgeyBvcGVuVGFicyB9ID0gZ2V0KCk7XG4gICAgICAgICAgY29uc3QgdXBkYXRlZFRhYnMgPSBvcGVuVGFicy5tYXAoKHRhYjogRWRpdG9yVGFiKSA9PiBcbiAgICAgICAgICAgIHRhYi5pZCA9PT0gdGFiSWQgXG4gICAgICAgICAgICAgID8geyAuLi50YWIsIGNvbnRlbnQsIG1vZGlmaWVkOiB0cnVlIH1cbiAgICAgICAgICAgICAgOiB0YWJcbiAgICAgICAgICApO1xuICAgICAgICAgIFxuICAgICAgICAgIHNldCh7IG9wZW5UYWJzOiB1cGRhdGVkVGFicyB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICB1cGRhdGVGaWxlQ29udGVudDogKHRhYklkOiBzdHJpbmcsIGNvbnRlbnQ6IHN0cmluZykgPT4ge1xuICAgICAgICAgIGNvbnN0IHsgb3BlblRhYnMgfSA9IGdldCgpO1xuICAgICAgICAgIGNvbnN0IHVwZGF0ZWRUYWJzID0gb3BlblRhYnMubWFwKCh0YWI6IEVkaXRvclRhYikgPT4gXG4gICAgICAgICAgICB0YWIuaWQgPT09IHRhYklkIFxuICAgICAgICAgICAgICA/IHsgLi4udGFiLCBjb250ZW50LCBtb2RpZmllZDogdHJ1ZSB9XG4gICAgICAgICAgICAgIDogdGFiXG4gICAgICAgICAgKTtcbiAgICAgICAgICBcbiAgICAgICAgICBzZXQoeyBvcGVuVGFiczogdXBkYXRlZFRhYnMgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdXBkYXRlRmlsZVN0YXR1czogKGZpbGVJZDogc3RyaW5nLCBzdGF0dXM6ICdkcmFmdCcgfCAnc2NoZWR1bGVkJyB8ICdjb21wbGV0ZScpID0+IHtcbiAgICAgICAgICBjb25zdCB7IHByb2plY3RGaWxlcywgZmluYW5jaWFsRmlsZXMgfSA9IGdldCgpO1xuXG4gICAgICAgICAgLy8gVXBkYXRlIGluIHByb2plY3QgZmlsZXNcbiAgICAgICAgICBjb25zdCB1cGRhdGVkUHJvamVjdEZpbGVzID0gcHJvamVjdEZpbGVzLm1hcChmaWxlID0+XG4gICAgICAgICAgICBmaWxlLmlkID09PSBmaWxlSWQgPyB7IC4uLmZpbGUsIHN0YXR1cywgbW9kaWZpZWRBdDogbmV3IERhdGUoKSB9IDogZmlsZVxuICAgICAgICAgICk7XG5cbiAgICAgICAgICAvLyBVcGRhdGUgaW4gZmluYW5jaWFsIGZpbGVzXG4gICAgICAgICAgY29uc3QgdXBkYXRlZEZpbmFuY2lhbEZpbGVzID0gZmluYW5jaWFsRmlsZXMubWFwKGZpbGUgPT5cbiAgICAgICAgICAgIGZpbGUuaWQgPT09IGZpbGVJZCA/IHsgLi4uZmlsZSwgc3RhdHVzLCBtb2RpZmllZEF0OiBuZXcgRGF0ZSgpIH0gOiBmaWxlXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIHNldCh7XG4gICAgICAgICAgICBwcm9qZWN0RmlsZXM6IHVwZGF0ZWRQcm9qZWN0RmlsZXMsXG4gICAgICAgICAgICBmaW5hbmNpYWxGaWxlczogdXBkYXRlZEZpbmFuY2lhbEZpbGVzXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY3JlYXRlTmV3RmlsZTogYXN5bmMgKG5hbWU6IHN0cmluZywgdHlwZTogUHJvamVjdEZpbGVbJ3R5cGUnXSwgY2F0ZWdvcnk6IFByb2plY3RGaWxlWydjYXRlZ29yeSddID0gJ3Byb2plY3QnLCBmb2xkZXJJZD86IHN0cmluZykgPT4ge1xuICAgICAgICAgIGNvbnN0IHsgcHJvamVjdEZpbGVzLCBmaW5hbmNpYWxGaWxlcyB9ID0gZ2V0KCk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gR2VuZXJhdGUgdW5pcXVlIElEXG4gICAgICAgICAgY29uc3QgaWQgPSBgJHtuYW1lLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvW15hLXowLTldL2csICctJyl9LSR7RGF0ZS5ub3coKX1gO1xuICAgICAgICAgIGNvbnN0IGZpbGVOYW1lID0gYCR7bmFtZX0ke2dldEZpbGVFeHRlbnNpb24odHlwZSl9YDtcbiAgICAgICAgICBjb25zdCBiYXNlUGF0aCA9IGNhdGVnb3J5ID09PSAnZmluYW5jaWFsJyA/ICcvZmluYW5jaWFsLWRhdGEnIDogJy9lYWMtcHJvamVjdHMnO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIENyZWF0ZSBuZXcgZmlsZVxuICAgICAgICAgIGNvbnN0IG5ld0ZpbGU6IFByb2plY3RGaWxlID0ge1xuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBuYW1lOiBmaWxlTmFtZSxcbiAgICAgICAgICAgIGljb246IGdldEZpbGVJY29uKHR5cGUpLFxuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgIGNhdGVnb3J5LFxuICAgICAgICAgICAgY29udGVudDogZ2V0RGVmYXVsdENvbnRlbnQodHlwZSwgbmFtZSksXG4gICAgICAgICAgICBmaWxlUGF0aDogYCR7YmFzZVBhdGh9LyR7ZmlsZU5hbWV9YCxcbiAgICAgICAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKSxcbiAgICAgICAgICAgIG1vZGlmaWVkQXQ6IG5ldyBEYXRlKCksXG4gICAgICAgICAgICBmb2xkZXJJZCwgLy8gQWRkIGZvbGRlciBhc3NpZ25tZW50XG4gICAgICAgICAgICBzdGF0dXM6IFsnZmFjZWJvb2snLCAncmVkZGl0JywgJ2luc3RhZ3JhbScsICd4J10uaW5jbHVkZXModHlwZSkgPyAnZHJhZnQnIDogdW5kZWZpbmVkLCAvLyBEZWZhdWx0IHNvY2lhbCBtZWRpYSBmaWxlcyB0byBkcmFmdFxuICAgICAgICAgIH07XG5cbiAgICAgICAgICAvLyBBZGQgdG8gYXBwcm9wcmlhdGUgZmlsZSBhcnJheSBhbmQgZW5zdXJlIGNhdGVnb3J5IGlzIHZpc2libGVcbiAgICAgICAgICBpZiAoY2F0ZWdvcnkgPT09ICdmaW5hbmNpYWwnKSB7XG4gICAgICAgICAgICBzZXQoe1xuICAgICAgICAgICAgICBmaW5hbmNpYWxGaWxlczogWy4uLmZpbmFuY2lhbEZpbGVzLCBuZXdGaWxlXSxcbiAgICAgICAgICAgICAgc2hvd0ZpbmFuY2lhbENhdGVnb3J5OiB0cnVlLCAvLyBFbnN1cmUgZmluYW5jaWFsIGNhdGVnb3J5IGlzIHZpc2libGVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZXQoe1xuICAgICAgICAgICAgICBwcm9qZWN0RmlsZXM6IFsuLi5wcm9qZWN0RmlsZXMsIG5ld0ZpbGVdLFxuICAgICAgICAgICAgICBzaG93UHJvamVjdHNDYXRlZ29yeTogdHJ1ZSwgLy8gRW5zdXJlIHByb2plY3RzIGNhdGVnb3J5IGlzIHZpc2libGVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIEF1dG9tYXRpY2FsbHkgb3BlbiB0aGUgbmV3IGZpbGVcbiAgICAgICAgICBnZXQoKS5vcGVuVGFiKG5ld0ZpbGUpO1xuXG4gICAgICAgICAgLy8gU2F2ZSB0byBDb252ZXggZGF0YWJhc2UgKGFzeW5jIC0gZG9uJ3QgYmxvY2sgVUkpXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gaW1wb3J0IHRoZSBDb252ZXggaG9va3MgaGVyZSwgd2hpY2ggaXNuJ3QgaWRlYWxcbiAgICAgICAgICAgIC8vIEJldHRlciB0byBoYW5kbGUgdGhpcyBpbiB0aGUgY29tcG9uZW50IGxldmVsXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnRmlsZSBjcmVhdGVkIGxvY2FsbHk6JywgbmV3RmlsZSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIERpc3BhdGNoIGN1c3RvbSBldmVudCB0aGF0IGNvbXBvbmVudHMgY2FuIGxpc3RlbiB0b1xuICAgICAgICAgICAgd2luZG93LmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KCdmaWxlQ3JlYXRlZCcsIHsgXG4gICAgICAgICAgICAgIGRldGFpbDogeyBcbiAgICAgICAgICAgICAgICBmaWxlOiBuZXdGaWxlLFxuICAgICAgICAgICAgICAgIHByb2plY3RJZDogZm9sZGVySWQgLy8gVXNpbmcgZm9sZGVySWQgYXMgcHJvamVjdElkIGZvciBub3dcbiAgICAgICAgICAgICAgfSBcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gc2F2ZSBmaWxlIHRvIGRhdGFiYXNlOicsIGVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgY3JlYXRlRm9sZGVyOiAobmFtZTogc3RyaW5nLCBjYXRlZ29yeTogJ3Byb2plY3QnIHwgJ2ZpbmFuY2lhbCcpID0+IHtcbiAgICAgICAgICBjb25zdCB7IHByb2plY3RGb2xkZXJzLCBmaW5hbmNpYWxGb2xkZXJzIH0gPSBnZXQoKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBDaGVjayBpZiBmb2xkZXIgd2l0aCB0aGlzIG5hbWUgYWxyZWFkeSBleGlzdHMgdG8gcHJldmVudCBkdXBsaWNhdGVzXG4gICAgICAgICAgY29uc3QgZXhpc3RpbmdGb2xkZXJzID0gY2F0ZWdvcnkgPT09ICdmaW5hbmNpYWwnID8gZmluYW5jaWFsRm9sZGVycyA6IHByb2plY3RGb2xkZXJzO1xuICAgICAgICAgIGNvbnN0IGZvbGRlckV4aXN0cyA9IGV4aXN0aW5nRm9sZGVycy5zb21lKGZvbGRlciA9PiBcbiAgICAgICAgICAgIGZvbGRlci5uYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUudG9Mb3dlckNhc2UoKVxuICAgICAgICAgICk7XG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKGZvbGRlckV4aXN0cykge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYEZvbGRlciBcIiR7bmFtZX1cIiBhbHJlYWR5IGV4aXN0cyBpbiAke2NhdGVnb3J5fSBjYXRlZ29yeSwgc2tpcHBpbmcgY3JlYXRpb25gKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gR2VuZXJhdGUgdHJ1bHkgdW5pcXVlIElEIHVzaW5nIGNyeXB0byBpZiBhdmFpbGFibGUsIG90aGVyd2lzZSBmYWxsYmFjayB0byB0aW1lc3RhbXAgKyByYW5kb21cbiAgICAgICAgICBsZXQgdW5pcXVlSWQ6IHN0cmluZztcbiAgICAgICAgICBpZiAodHlwZW9mIGNyeXB0byAhPT0gJ3VuZGVmaW5lZCcgJiYgY3J5cHRvLnJhbmRvbVVVSUQpIHtcbiAgICAgICAgICAgIHVuaXF1ZUlkID0gYGZvbGRlci0ke25hbWUudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9bXmEtejAtOV0vZywgJy0nKX0tJHtjcnlwdG8ucmFuZG9tVVVJRCgpfWA7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEZhbGxiYWNrIGZvciBlbnZpcm9ubWVudHMgd2l0aG91dCBjcnlwdG8ucmFuZG9tVVVJRFxuICAgICAgICAgICAgY29uc3QgdGltZXN0YW1wID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgIGNvbnN0IHJhbmRvbSA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygyLCAxMik7XG4gICAgICAgICAgICBjb25zdCBjb3VudGVyID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMDApO1xuICAgICAgICAgICAgdW5pcXVlSWQgPSBgZm9sZGVyLSR7bmFtZS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1teYS16MC05XS9nLCAnLScpfS0ke3RpbWVzdGFtcH0tJHtyYW5kb219LSR7Y291bnRlcn1gO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBEb3VibGUtY2hlY2sgdW5pcXVlbmVzcyBhZ2FpbnN0IGFsbCBleGlzdGluZyBmb2xkZXIgSURzXG4gICAgICAgICAgY29uc3QgYWxsRm9sZGVycyA9IFsuLi5wcm9qZWN0Rm9sZGVycywgLi4uZmluYW5jaWFsRm9sZGVyc107XG4gICAgICAgICAgd2hpbGUgKGFsbEZvbGRlcnMuc29tZShmb2xkZXIgPT4gZm9sZGVyLmlkID09PSB1bmlxdWVJZCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHJhbmRvbVN1ZmZpeCA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygyLCA4KTtcbiAgICAgICAgICAgIHVuaXF1ZUlkID0gYCR7dW5pcXVlSWR9LSR7cmFuZG9tU3VmZml4fWA7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIENyZWF0ZSBuZXcgZm9sZGVyXG4gICAgICAgICAgY29uc3QgbmV3Rm9sZGVyOiBQcm9qZWN0Rm9sZGVyID0ge1xuICAgICAgICAgICAgaWQ6IHVuaXF1ZUlkLFxuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIGNhdGVnb3J5LFxuICAgICAgICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLFxuICAgICAgICAgIH07XG5cbiAgICAgICAgICAvLyBBZGQgdG8gYXBwcm9wcmlhdGUgZm9sZGVyIGFycmF5IGFuZCBlbnN1cmUgY2F0ZWdvcnkgaXMgdmlzaWJsZVxuICAgICAgICAgIGlmIChjYXRlZ29yeSA9PT0gJ2ZpbmFuY2lhbCcpIHtcbiAgICAgICAgICAgIHNldCh7XG4gICAgICAgICAgICAgIGZpbmFuY2lhbEZvbGRlcnM6IFtuZXdGb2xkZXIsIC4uLmZpbmFuY2lhbEZvbGRlcnNdLFxuICAgICAgICAgICAgICBzaG93RmluYW5jaWFsQ2F0ZWdvcnk6IHRydWUsIC8vIEVuc3VyZSBmaW5hbmNpYWwgY2F0ZWdvcnkgaXMgdmlzaWJsZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNldCh7XG4gICAgICAgICAgICAgIHByb2plY3RGb2xkZXJzOiBbbmV3Rm9sZGVyLCAuLi5wcm9qZWN0Rm9sZGVyc10sXG4gICAgICAgICAgICAgIHNob3dQcm9qZWN0c0NhdGVnb3J5OiB0cnVlLCAvLyBFbnN1cmUgcHJvamVjdHMgY2F0ZWdvcnkgaXMgdmlzaWJsZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIEVtZXJnZW5jeSBjbGVhbnVwIGZ1bmN0aW9uIGZvciBkdXBsaWNhdGUgZm9sZGVyIElEc1xuICAgICAgICBjbGVhbnVwRHVwbGljYXRlRm9sZGVyczogKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHsgcHJvamVjdEZvbGRlcnMsIGZpbmFuY2lhbEZvbGRlcnMgfSA9IGdldCgpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIEZ1bmN0aW9uIHRvIHJlbW92ZSBkdXBsaWNhdGVzIGFuZCBmaXggYmFkIElEc1xuICAgICAgICAgIGNvbnN0IGNsZWFudXBGb2xkZXJzID0gKGZvbGRlcnM6IFByb2plY3RGb2xkZXJbXSkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc2VlbiA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICAgICAgICAgICAgY29uc3QgY2xlYW5lZCA9IGZvbGRlcnMuZmlsdGVyKGZvbGRlciA9PiB7XG4gICAgICAgICAgICAgIC8vIFJlbW92ZSBmb2xkZXJzIHdpdGggdGhlIHByb2JsZW1hdGljIGtleSBwYXR0ZXJuXG4gICAgICAgICAgICAgIGlmIChmb2xkZXIuaWQuaW5jbHVkZXMoJ2ZvbGRlci1pbmRleC0xNzUzMDY0NTA4OTM5JykpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhg8J+nuSBSZW1vdmluZyBwcm9ibGVtYXRpYyBmb2xkZXI6ICR7Zm9sZGVyLmlkfSAoJHtmb2xkZXIubmFtZX0pYCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAvLyBSZW1vdmUgZHVwbGljYXRlIElEc1xuICAgICAgICAgICAgICBpZiAoc2Vlbi5oYXMoZm9sZGVyLmlkKSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGDwn6e5IFJlbW92aW5nIGR1cGxpY2F0ZSBmb2xkZXI6ICR7Zm9sZGVyLmlkfSAoJHtmb2xkZXIubmFtZX0pYCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICBzZWVuLmFkZChmb2xkZXIuaWQpO1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBSZWdlbmVyYXRlIElEcyBmb3IgYW55IHJlbWFpbmluZyBmb2xkZXJzIHdpdGggb2xkIHBhdHRlcm5zXG4gICAgICAgICAgICByZXR1cm4gY2xlYW5lZC5tYXAoZm9sZGVyID0+IHtcbiAgICAgICAgICAgICAgaWYgKGZvbGRlci5pZC5zdGFydHNXaXRoKCdmb2xkZXItaW5kZXgtJykgfHwgZm9sZGVyLmlkLmxlbmd0aCA8IDIwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3SWQgPSB0eXBlb2YgY3J5cHRvICE9PSAndW5kZWZpbmVkJyAmJiBjcnlwdG8ucmFuZG9tVVVJRFxuICAgICAgICAgICAgICAgICAgPyBgZm9sZGVyLSR7Zm9sZGVyLm5hbWUudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9bXmEtejAtOV0vZywgJy0nKX0tJHtjcnlwdG8ucmFuZG9tVVVJRCgpfWBcbiAgICAgICAgICAgICAgICAgIDogYGZvbGRlci0ke2ZvbGRlci5uYW1lLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvW15hLXowLTldL2csICctJyl9LSR7RGF0ZS5ub3coKX0tJHtNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMiwgMTIpfWA7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYPCflIQgUmVnZW5lcmF0aW5nIElEIGZvciBmb2xkZXI6ICR7Zm9sZGVyLmlkfSDihpIgJHtuZXdJZH0gKCR7Zm9sZGVyLm5hbWV9KWApO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHJldHVybiB7IC4uLmZvbGRlciwgaWQ6IG5ld0lkIH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGZvbGRlcjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH07XG4gICAgICAgICAgXG4gICAgICAgICAgY29uc3QgY2xlYW5lZFByb2plY3RGb2xkZXJzID0gY2xlYW51cEZvbGRlcnMocHJvamVjdEZvbGRlcnMpO1xuICAgICAgICAgIGNvbnN0IGNsZWFuZWRGaW5hbmNpYWxGb2xkZXJzID0gY2xlYW51cEZvbGRlcnMoZmluYW5jaWFsRm9sZGVycyk7XG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKGNsZWFuZWRQcm9qZWN0Rm9sZGVycy5sZW5ndGggIT09IHByb2plY3RGb2xkZXJzLmxlbmd0aCB8fCBcbiAgICAgICAgICAgICAgY2xlYW5lZEZpbmFuY2lhbEZvbGRlcnMubGVuZ3RoICE9PSBmaW5hbmNpYWxGb2xkZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ/Cfp7kgQ2xlYW51cCBjb21wbGV0ZWQsIHVwZGF0aW5nIHN0b3JlLi4uJyk7XG4gICAgICAgICAgICBzZXQoe1xuICAgICAgICAgICAgICBwcm9qZWN0Rm9sZGVyczogY2xlYW5lZFByb2plY3RGb2xkZXJzLFxuICAgICAgICAgICAgICBmaW5hbmNpYWxGb2xkZXJzOiBjbGVhbmVkRmluYW5jaWFsRm9sZGVyc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGRlbGV0ZUZpbGU6IChmaWxlSWQ6IHN0cmluZykgPT4ge1xuICAgICAgICAgIGNvbnN0IHsgcHJvamVjdEZpbGVzLCBmaW5hbmNpYWxGaWxlcywgb3BlblRhYnMgfSA9IGdldCgpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIEZpbmQgYW5kIHJlbW92ZSBmcm9tIGFwcHJvcHJpYXRlIGFycmF5XG4gICAgICAgICAgY29uc3QgdXBkYXRlZFByb2plY3RGaWxlcyA9IHByb2plY3RGaWxlcy5maWx0ZXIoKGZpbGU6IFByb2plY3RGaWxlKSA9PiBmaWxlLmlkICE9PSBmaWxlSWQpO1xuICAgICAgICAgIGNvbnN0IHVwZGF0ZWRGaW5hbmNpYWxGaWxlcyA9IGZpbmFuY2lhbEZpbGVzLmZpbHRlcigoZmlsZTogUHJvamVjdEZpbGUpID0+IGZpbGUuaWQgIT09IGZpbGVJZCk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQ2xvc2UgdGFiIGlmIGl0J3Mgb3BlblxuICAgICAgICAgIGNvbnN0IHRhYlRvQ2xvc2UgPSBvcGVuVGFicy5maW5kKCh0YWI6IEVkaXRvclRhYikgPT4gdGFiLmlkID09PSBmaWxlSWQpO1xuICAgICAgICAgIGlmICh0YWJUb0Nsb3NlKSB7XG4gICAgICAgICAgICBnZXQoKS5jbG9zZVRhYihmaWxlSWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICBzZXQoeyBcbiAgICAgICAgICAgIHByb2plY3RGaWxlczogdXBkYXRlZFByb2plY3RGaWxlcyxcbiAgICAgICAgICAgIGZpbmFuY2lhbEZpbGVzOiB1cGRhdGVkRmluYW5jaWFsRmlsZXMgXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVuYW1lRmlsZTogKGZpbGVJZDogc3RyaW5nLCBuZXdOYW1lOiBzdHJpbmcpID0+IHtcbiAgICAgICAgICBjb25zdCB7IHByb2plY3RGaWxlcywgZmluYW5jaWFsRmlsZXMsIG9wZW5UYWJzIH0gPSBnZXQoKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBGaW5kIHRoZSBmaWxlIHRvIGdldCBpdHMgdHlwZSBhbmQgZ2VuZXJhdGUgbmV3IGZpbGVuYW1lIHdpdGggZXh0ZW5zaW9uXG4gICAgICAgICAgY29uc3QgcHJvamVjdEZpbGUgPSBwcm9qZWN0RmlsZXMuZmluZCgoZmlsZTogUHJvamVjdEZpbGUpID0+IGZpbGUuaWQgPT09IGZpbGVJZCk7XG4gICAgICAgICAgY29uc3QgZmluYW5jaWFsRmlsZSA9IGZpbmFuY2lhbEZpbGVzLmZpbmQoKGZpbGU6IFByb2plY3RGaWxlKSA9PiBmaWxlLmlkID09PSBmaWxlSWQpO1xuICAgICAgICAgIGNvbnN0IGZpbGUgPSBwcm9qZWN0RmlsZSB8fCBmaW5hbmNpYWxGaWxlO1xuICAgICAgICAgIFxuICAgICAgICAgIGlmICghZmlsZSkgcmV0dXJuO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIEdlbmVyYXRlIG5ldyBmaWxlbmFtZSB3aXRoIGFwcHJvcHJpYXRlIGV4dGVuc2lvblxuICAgICAgICAgIGNvbnN0IG5ld0ZpbGVOYW1lID0gYCR7bmV3TmFtZX0ke2dldEZpbGVFeHRlbnNpb24oZmlsZS50eXBlKX1gO1xuICAgICAgICAgIGNvbnN0IGJhc2VQYXRoID0gZmlsZS5jYXRlZ29yeSA9PT0gJ2ZpbmFuY2lhbCcgPyAnL2ZpbmFuY2lhbC1kYXRhJyA6ICcvZWFjLXByb2plY3RzJztcbiAgICAgICAgICBjb25zdCBuZXdGaWxlUGF0aCA9IGAke2Jhc2VQYXRofS8ke25ld0ZpbGVOYW1lfWA7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gVXBkYXRlIHRoZSBmaWxlIGluIGFwcHJvcHJpYXRlIGFycmF5XG4gICAgICAgICAgY29uc3QgdXBkYXRlZFByb2plY3RGaWxlcyA9IHByb2plY3RGaWxlcy5tYXAoKGY6IFByb2plY3RGaWxlKSA9PlxuICAgICAgICAgICAgZi5pZCA9PT0gZmlsZUlkXG4gICAgICAgICAgICAgID8geyAuLi5mLCBuYW1lOiBuZXdGaWxlTmFtZSwgZmlsZVBhdGg6IG5ld0ZpbGVQYXRoLCBtb2RpZmllZEF0OiBuZXcgRGF0ZSgpIH1cbiAgICAgICAgICAgICAgOiBmXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIGNvbnN0IHVwZGF0ZWRGaW5hbmNpYWxGaWxlcyA9IGZpbmFuY2lhbEZpbGVzLm1hcCgoZjogUHJvamVjdEZpbGUpID0+XG4gICAgICAgICAgICBmLmlkID09PSBmaWxlSWRcbiAgICAgICAgICAgICAgPyB7IC4uLmYsIG5hbWU6IG5ld0ZpbGVOYW1lLCBmaWxlUGF0aDogbmV3RmlsZVBhdGgsIG1vZGlmaWVkQXQ6IG5ldyBEYXRlKCkgfVxuICAgICAgICAgICAgICA6IGZcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgLy8gVXBkYXRlIG9wZW4gdGFicyBpZiB0aGUgZmlsZSBpcyBvcGVuXG4gICAgICAgICAgY29uc3QgdXBkYXRlZFRhYnMgPSBvcGVuVGFicy5tYXAoKHRhYjogRWRpdG9yVGFiKSA9PlxuICAgICAgICAgICAgdGFiLmlkID09PSBmaWxlSWRcbiAgICAgICAgICAgICAgPyB7IC4uLnRhYiwgbmFtZTogbmV3RmlsZU5hbWUsIGZpbGVQYXRoOiBuZXdGaWxlUGF0aCwgbW9kaWZpZWQ6IHRydWUgfVxuICAgICAgICAgICAgICA6IHRhYlxuICAgICAgICAgICk7XG5cbiAgICAgICAgICBzZXQoe1xuICAgICAgICAgICAgcHJvamVjdEZpbGVzOiB1cGRhdGVkUHJvamVjdEZpbGVzLFxuICAgICAgICAgICAgZmluYW5jaWFsRmlsZXM6IHVwZGF0ZWRGaW5hbmNpYWxGaWxlcyxcbiAgICAgICAgICAgIG9wZW5UYWJzOiB1cGRhdGVkVGFicyxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICByZW5hbWVGb2xkZXI6IChmb2xkZXJJZDogc3RyaW5nLCBuZXdOYW1lOiBzdHJpbmcpID0+IHtcbiAgICAgICAgICBjb25zdCB7IHByb2plY3RGb2xkZXJzLCBmaW5hbmNpYWxGb2xkZXJzIH0gPSBnZXQoKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBVcGRhdGUgdGhlIGZvbGRlciBpbiBhcHByb3ByaWF0ZSBhcnJheVxuICAgICAgICAgIGNvbnN0IHVwZGF0ZWRQcm9qZWN0Rm9sZGVycyA9IHByb2plY3RGb2xkZXJzLm1hcCgoZm9sZGVyOiBQcm9qZWN0Rm9sZGVyKSA9PlxuICAgICAgICAgICAgZm9sZGVyLmlkID09PSBmb2xkZXJJZFxuICAgICAgICAgICAgICA/IHsgLi4uZm9sZGVyLCBuYW1lOiBuZXdOYW1lIH1cbiAgICAgICAgICAgICAgOiBmb2xkZXJcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgY29uc3QgdXBkYXRlZEZpbmFuY2lhbEZvbGRlcnMgPSBmaW5hbmNpYWxGb2xkZXJzLm1hcCgoZm9sZGVyOiBQcm9qZWN0Rm9sZGVyKSA9PlxuICAgICAgICAgICAgZm9sZGVyLmlkID09PSBmb2xkZXJJZFxuICAgICAgICAgICAgICA/IHsgLi4uZm9sZGVyLCBuYW1lOiBuZXdOYW1lIH1cbiAgICAgICAgICAgICAgOiBmb2xkZXJcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgc2V0KHtcbiAgICAgICAgICAgIHByb2plY3RGb2xkZXJzOiB1cGRhdGVkUHJvamVjdEZvbGRlcnMsXG4gICAgICAgICAgICBmaW5hbmNpYWxGb2xkZXJzOiB1cGRhdGVkRmluYW5jaWFsRm9sZGVycyxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBkZWxldGVGb2xkZXI6IChmb2xkZXJJZDogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgY29uc3QgeyBwcm9qZWN0Rm9sZGVycywgZmluYW5jaWFsRm9sZGVycywgcHJvamVjdEZpbGVzLCBmaW5hbmNpYWxGaWxlcywgb3BlblRhYnMgfSA9IGdldCgpO1xuXG4gICAgICAgICAgLy8gRmluZCBhbGwgZmlsZXMgdGhhdCB3ZXJlIGluIHRoaXMgZm9sZGVyXG4gICAgICAgICAgY29uc3QgZmlsZXNUb0RlbGV0ZSA9IFtcbiAgICAgICAgICAgIC4uLnByb2plY3RGaWxlcy5maWx0ZXIoKGZpbGU6IFByb2plY3RGaWxlKSA9PiBmaWxlLmZvbGRlcklkID09PSBmb2xkZXJJZCksXG4gICAgICAgICAgICAuLi5maW5hbmNpYWxGaWxlcy5maWx0ZXIoKGZpbGU6IFByb2plY3RGaWxlKSA9PiBmaWxlLmZvbGRlcklkID09PSBmb2xkZXJJZClcbiAgICAgICAgICBdO1xuXG4gICAgICAgICAgLy8gQ2xvc2UgdGFicyBmb3IgYWxsIGZpbGVzIGluIHRoaXMgZm9sZGVyXG4gICAgICAgICAgZmlsZXNUb0RlbGV0ZS5mb3JFYWNoKChmaWxlOiBQcm9qZWN0RmlsZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdGFiVG9DbG9zZSA9IG9wZW5UYWJzLmZpbmQoKHRhYjogRWRpdG9yVGFiKSA9PiB0YWIuaWQgPT09IGZpbGUuaWQpO1xuICAgICAgICAgICAgaWYgKHRhYlRvQ2xvc2UpIHtcbiAgICAgICAgICAgICAgZ2V0KCkuY2xvc2VUYWIoZmlsZS5pZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gUmVtb3ZlIGZyb20gYXBwcm9wcmlhdGUgZm9sZGVyIGFycmF5XG4gICAgICAgICAgY29uc3QgdXBkYXRlZFByb2plY3RGb2xkZXJzID0gcHJvamVjdEZvbGRlcnMuZmlsdGVyKChmb2xkZXI6IFByb2plY3RGb2xkZXIpID0+IGZvbGRlci5pZCAhPT0gZm9sZGVySWQpO1xuICAgICAgICAgIGNvbnN0IHVwZGF0ZWRGaW5hbmNpYWxGb2xkZXJzID0gZmluYW5jaWFsRm9sZGVycy5maWx0ZXIoKGZvbGRlcjogUHJvamVjdEZvbGRlcikgPT4gZm9sZGVyLmlkICE9PSBmb2xkZXJJZCk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQWxzbyByZW1vdmUgYW55IGZpbGVzIHRoYXQgd2VyZSBpbiB0aGlzIGZvbGRlclxuICAgICAgICAgIGNvbnN0IHVwZGF0ZWRQcm9qZWN0RmlsZXMgPSBwcm9qZWN0RmlsZXMuZmlsdGVyKChmaWxlOiBQcm9qZWN0RmlsZSkgPT4gZmlsZS5mb2xkZXJJZCAhPT0gZm9sZGVySWQpO1xuICAgICAgICAgIGNvbnN0IHVwZGF0ZWRGaW5hbmNpYWxGaWxlcyA9IGZpbmFuY2lhbEZpbGVzLmZpbHRlcigoZmlsZTogUHJvamVjdEZpbGUpID0+IGZpbGUuZm9sZGVySWQgIT09IGZvbGRlcklkKTtcbiAgICAgICAgICBcbiAgICAgICAgICBzZXQoeyBcbiAgICAgICAgICAgIHByb2plY3RGb2xkZXJzOiB1cGRhdGVkUHJvamVjdEZvbGRlcnMsXG4gICAgICAgICAgICBmaW5hbmNpYWxGb2xkZXJzOiB1cGRhdGVkRmluYW5jaWFsRm9sZGVycyxcbiAgICAgICAgICAgIHByb2plY3RGaWxlczogdXBkYXRlZFByb2plY3RGaWxlcyxcbiAgICAgICAgICAgIGZpbmFuY2lhbEZpbGVzOiB1cGRhdGVkRmluYW5jaWFsRmlsZXNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBtb3ZlVG9UcmFzaDogKGl0ZW06IFByb2plY3RGaWxlIHwgUHJvamVjdEZvbGRlciwgdHlwZTogJ2ZpbGUnIHwgJ2ZvbGRlcicpID0+IHtcbiAgICAgICAgICBjb25zdCB7IHRyYXNoSXRlbXMsIHByb2plY3RGaWxlcywgZmluYW5jaWFsRmlsZXMsIHByb2plY3RGb2xkZXJzLCBmaW5hbmNpYWxGb2xkZXJzLCBvcGVuVGFicyB9ID0gZ2V0KCk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQ3JlYXRlIHRyYXNoIGl0ZW1cbiAgICAgICAgICBjb25zdCB0cmFzaEl0ZW06IFRyYXNoSXRlbSA9IHtcbiAgICAgICAgICAgIGlkOiBgdHJhc2hfJHtpdGVtLmlkfV8ke0RhdGUubm93KCl9YCxcbiAgICAgICAgICAgIG5hbWU6IGl0ZW0ubmFtZSxcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICBvcmlnaW5hbERhdGE6IGl0ZW0sXG4gICAgICAgICAgICBkZWxldGVkQXQ6IG5ldyBEYXRlKCksXG4gICAgICAgICAgICBjYXRlZ29yeTogaXRlbS5jYXRlZ29yeVxuICAgICAgICAgIH07XG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKHR5cGUgPT09ICdmaWxlJykge1xuICAgICAgICAgICAgY29uc3QgZmlsZSA9IGl0ZW0gYXMgUHJvamVjdEZpbGU7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIENsb3NlIHRhYiBpZiBpdCdzIG9wZW5cbiAgICAgICAgICAgIGNvbnN0IHRhYlRvQ2xvc2UgPSBvcGVuVGFicy5maW5kKCh0YWI6IEVkaXRvclRhYikgPT4gdGFiLmlkID09PSBmaWxlLmlkKTtcbiAgICAgICAgICAgIGlmICh0YWJUb0Nsb3NlKSB7XG4gICAgICAgICAgICAgIGdldCgpLmNsb3NlVGFiKGZpbGUuaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBSZW1vdmUgZnJvbSBhcHByb3ByaWF0ZSBmaWxlIGFycmF5XG4gICAgICAgICAgICBjb25zdCB1cGRhdGVkUHJvamVjdEZpbGVzID0gcHJvamVjdEZpbGVzLmZpbHRlcigoZjogUHJvamVjdEZpbGUpID0+IGYuaWQgIT09IGZpbGUuaWQpO1xuICAgICAgICAgICAgY29uc3QgdXBkYXRlZEZpbmFuY2lhbEZpbGVzID0gZmluYW5jaWFsRmlsZXMuZmlsdGVyKChmOiBQcm9qZWN0RmlsZSkgPT4gZi5pZCAhPT0gZmlsZS5pZCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHNldCh7XG4gICAgICAgICAgICAgIHRyYXNoSXRlbXM6IFsuLi50cmFzaEl0ZW1zLCB0cmFzaEl0ZW1dLFxuICAgICAgICAgICAgICBwcm9qZWN0RmlsZXM6IHVwZGF0ZWRQcm9qZWN0RmlsZXMsXG4gICAgICAgICAgICAgIGZpbmFuY2lhbEZpbGVzOiB1cGRhdGVkRmluYW5jaWFsRmlsZXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBmb2xkZXIgPSBpdGVtIGFzIFByb2plY3RGb2xkZXI7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIEZpbmQgYWxsIGZpbGVzIHRoYXQgd2VyZSBpbiB0aGlzIGZvbGRlciBhbmQgbW92ZSB0aGVtIHRvIHRyYXNoIHRvb1xuICAgICAgICAgICAgY29uc3QgZmlsZXNUb1RyYXNoID0gW1xuICAgICAgICAgICAgICAuLi5wcm9qZWN0RmlsZXMuZmlsdGVyKChmaWxlOiBQcm9qZWN0RmlsZSkgPT4gZmlsZS5mb2xkZXJJZCA9PT0gZm9sZGVyLmlkKSxcbiAgICAgICAgICAgICAgLi4uZmluYW5jaWFsRmlsZXMuZmlsdGVyKChmaWxlOiBQcm9qZWN0RmlsZSkgPT4gZmlsZS5mb2xkZXJJZCA9PT0gZm9sZGVyLmlkKVxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gQ2xvc2UgdGFicyBmb3IgYWxsIGZpbGVzIGluIHRoaXMgZm9sZGVyXG4gICAgICAgICAgICBmaWxlc1RvVHJhc2guZm9yRWFjaCgoZmlsZTogUHJvamVjdEZpbGUpID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgdGFiVG9DbG9zZSA9IG9wZW5UYWJzLmZpbmQoKHRhYjogRWRpdG9yVGFiKSA9PiB0YWIuaWQgPT09IGZpbGUuaWQpO1xuICAgICAgICAgICAgICBpZiAodGFiVG9DbG9zZSkge1xuICAgICAgICAgICAgICAgIGdldCgpLmNsb3NlVGFiKGZpbGUuaWQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gQ3JlYXRlIHRyYXNoIGl0ZW1zIGZvciBhbGwgZmlsZXMgaW4gdGhlIGZvbGRlclxuICAgICAgICAgICAgY29uc3QgZmlsZVRyYXNoSXRlbXMgPSBmaWxlc1RvVHJhc2gubWFwKChmaWxlOiBQcm9qZWN0RmlsZSkgPT4gKHtcbiAgICAgICAgICAgICAgaWQ6IGB0cmFzaF8ke2ZpbGUuaWR9XyR7RGF0ZS5ub3coKX1gLFxuICAgICAgICAgICAgICBuYW1lOiBmaWxlLm5hbWUsXG4gICAgICAgICAgICAgIHR5cGU6ICdmaWxlJyBhcyBjb25zdCxcbiAgICAgICAgICAgICAgb3JpZ2luYWxEYXRhOiBmaWxlLFxuICAgICAgICAgICAgICBkZWxldGVkQXQ6IG5ldyBEYXRlKCksXG4gICAgICAgICAgICAgIGNhdGVnb3J5OiBmaWxlLmNhdGVnb3J5XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIFJlbW92ZSBmb2xkZXIgYW5kIGl0cyBmaWxlcyBmcm9tIGFycmF5c1xuICAgICAgICAgICAgY29uc3QgdXBkYXRlZFByb2plY3RGb2xkZXJzID0gcHJvamVjdEZvbGRlcnMuZmlsdGVyKChmOiBQcm9qZWN0Rm9sZGVyKSA9PiBmLmlkICE9PSBmb2xkZXIuaWQpO1xuICAgICAgICAgICAgY29uc3QgdXBkYXRlZEZpbmFuY2lhbEZvbGRlcnMgPSBmaW5hbmNpYWxGb2xkZXJzLmZpbHRlcigoZjogUHJvamVjdEZvbGRlcikgPT4gZi5pZCAhPT0gZm9sZGVyLmlkKTtcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRQcm9qZWN0RmlsZXMgPSBwcm9qZWN0RmlsZXMuZmlsdGVyKChmaWxlOiBQcm9qZWN0RmlsZSkgPT4gZmlsZS5mb2xkZXJJZCAhPT0gZm9sZGVyLmlkKTtcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRGaW5hbmNpYWxGaWxlcyA9IGZpbmFuY2lhbEZpbGVzLmZpbHRlcigoZmlsZTogUHJvamVjdEZpbGUpID0+IGZpbGUuZm9sZGVySWQgIT09IGZvbGRlci5pZCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHNldCh7XG4gICAgICAgICAgICAgIHRyYXNoSXRlbXM6IFsuLi50cmFzaEl0ZW1zLCB0cmFzaEl0ZW0sIC4uLmZpbGVUcmFzaEl0ZW1zXSxcbiAgICAgICAgICAgICAgcHJvamVjdEZvbGRlcnM6IHVwZGF0ZWRQcm9qZWN0Rm9sZGVycyxcbiAgICAgICAgICAgICAgZmluYW5jaWFsRm9sZGVyczogdXBkYXRlZEZpbmFuY2lhbEZvbGRlcnMsXG4gICAgICAgICAgICAgIHByb2plY3RGaWxlczogdXBkYXRlZFByb2plY3RGaWxlcyxcbiAgICAgICAgICAgICAgZmluYW5jaWFsRmlsZXM6IHVwZGF0ZWRGaW5hbmNpYWxGaWxlc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHJlc3RvcmVGcm9tVHJhc2g6ICh0cmFzaEl0ZW1JZDogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgY29uc3QgeyB0cmFzaEl0ZW1zLCBwcm9qZWN0RmlsZXMsIGZpbmFuY2lhbEZpbGVzLCBwcm9qZWN0Rm9sZGVycywgZmluYW5jaWFsRm9sZGVycyB9ID0gZ2V0KCk7XG4gICAgICAgICAgXG4gICAgICAgICAgY29uc3QgdHJhc2hJdGVtID0gdHJhc2hJdGVtcy5maW5kKGl0ZW0gPT4gaXRlbS5pZCA9PT0gdHJhc2hJdGVtSWQpO1xuICAgICAgICAgIGlmICghdHJhc2hJdGVtKSByZXR1cm47XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gUmVtb3ZlIGZyb20gdHJhc2hcbiAgICAgICAgICBjb25zdCB1cGRhdGVkVHJhc2hJdGVtcyA9IHRyYXNoSXRlbXMuZmlsdGVyKGl0ZW0gPT4gaXRlbS5pZCAhPT0gdHJhc2hJdGVtSWQpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIFJlc3RvcmUgdG8gYXBwcm9wcmlhdGUgYXJyYXlcbiAgICAgICAgICBpZiAodHJhc2hJdGVtLnR5cGUgPT09ICdmaWxlJykge1xuICAgICAgICAgICAgY29uc3QgZmlsZSA9IHRyYXNoSXRlbS5vcmlnaW5hbERhdGEgYXMgUHJvamVjdEZpbGU7XG4gICAgICAgICAgICBpZiAoZmlsZS5jYXRlZ29yeSA9PT0gJ3Byb2plY3QnKSB7XG4gICAgICAgICAgICAgIHNldCh7XG4gICAgICAgICAgICAgICAgdHJhc2hJdGVtczogdXBkYXRlZFRyYXNoSXRlbXMsXG4gICAgICAgICAgICAgICAgcHJvamVjdEZpbGVzOiBbLi4ucHJvamVjdEZpbGVzLCB7IC4uLmZpbGUsIG1vZGlmaWVkQXQ6IG5ldyBEYXRlKCkgfV1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzZXQoe1xuICAgICAgICAgICAgICAgIHRyYXNoSXRlbXM6IHVwZGF0ZWRUcmFzaEl0ZW1zLFxuICAgICAgICAgICAgICAgIGZpbmFuY2lhbEZpbGVzOiBbLi4uZmluYW5jaWFsRmlsZXMsIHsgLi4uZmlsZSwgbW9kaWZpZWRBdDogbmV3IERhdGUoKSB9XVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgZm9sZGVyID0gdHJhc2hJdGVtLm9yaWdpbmFsRGF0YSBhcyBQcm9qZWN0Rm9sZGVyO1xuICAgICAgICAgICAgaWYgKGZvbGRlci5jYXRlZ29yeSA9PT0gJ3Byb2plY3QnKSB7XG4gICAgICAgICAgICAgIHNldCh7XG4gICAgICAgICAgICAgICAgdHJhc2hJdGVtczogdXBkYXRlZFRyYXNoSXRlbXMsXG4gICAgICAgICAgICAgICAgcHJvamVjdEZvbGRlcnM6IFsuLi5wcm9qZWN0Rm9sZGVycywgZm9sZGVyXVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHNldCh7XG4gICAgICAgICAgICAgICAgdHJhc2hJdGVtczogdXBkYXRlZFRyYXNoSXRlbXMsXG4gICAgICAgICAgICAgICAgZmluYW5jaWFsRm9sZGVyczogWy4uLmZpbmFuY2lhbEZvbGRlcnMsIGZvbGRlcl1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHBlcm1hbmVudGx5RGVsZXRlOiAodHJhc2hJdGVtSWQ6IHN0cmluZykgPT4ge1xuICAgICAgICAgIGNvbnN0IHsgdHJhc2hJdGVtcyB9ID0gZ2V0KCk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gUmVtb3ZlIGZyb20gdHJhc2ggcGVybWFuZW50bHlcbiAgICAgICAgICBjb25zdCB1cGRhdGVkVHJhc2hJdGVtcyA9IHRyYXNoSXRlbXMuZmlsdGVyKGl0ZW0gPT4gaXRlbS5pZCAhPT0gdHJhc2hJdGVtSWQpO1xuICAgICAgICAgIHNldCh7IHRyYXNoSXRlbXM6IHVwZGF0ZWRUcmFzaEl0ZW1zIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIGVtcHR5VHJhc2g6ICgpID0+IHtcbiAgICAgICAgICBzZXQoeyB0cmFzaEl0ZW1zOiBbXSB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBjbGVhclByb2plY3RDYXRlZ29yeTogKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHsgb3BlblRhYnMgfSA9IGdldCgpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIENsb3NlIGFsbCBwcm9qZWN0LXJlbGF0ZWQgdGFic1xuICAgICAgICAgIGNvbnN0IHByb2plY3RUYWJJZHMgPSBvcGVuVGFic1xuICAgICAgICAgICAgLmZpbHRlcigodGFiOiBFZGl0b3JUYWIpID0+IHtcbiAgICAgICAgICAgICAgLy8gRmluZCB0aGUgY29ycmVzcG9uZGluZyBmaWxlIHRvIGNoZWNrIGl0cyBjYXRlZ29yeVxuICAgICAgICAgICAgICBjb25zdCB7IHByb2plY3RGaWxlcyB9ID0gZ2V0KCk7XG4gICAgICAgICAgICAgIGNvbnN0IGZpbGUgPSBwcm9qZWN0RmlsZXMuZmluZCgoZjogUHJvamVjdEZpbGUpID0+IGYuaWQgPT09IHRhYi5pZCk7XG4gICAgICAgICAgICAgIHJldHVybiBmaWxlPy5jYXRlZ29yeSA9PT0gJ3Byb2plY3QnO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5tYXAoKHRhYjogRWRpdG9yVGFiKSA9PiB0YWIuaWQpO1xuICAgICAgICAgIFxuICAgICAgICAgIHByb2plY3RUYWJJZHMuZm9yRWFjaCgodGFiSWQ6IHN0cmluZykgPT4gZ2V0KCkuY2xvc2VUYWIodGFiSWQpKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBDbGVhciBhbGwgcHJvamVjdCBmaWxlcyBhbmQgZm9sZGVyc1xuICAgICAgICAgIHNldCh7XG4gICAgICAgICAgICBwcm9qZWN0RmlsZXM6IFtdLFxuICAgICAgICAgICAgcHJvamVjdEZvbGRlcnM6IFtdLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNsZWFyRmluYW5jaWFsQ2F0ZWdvcnk6ICgpID0+IHtcbiAgICAgICAgICBjb25zdCB7IG9wZW5UYWJzIH0gPSBnZXQoKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBDbG9zZSBhbGwgZmluYW5jaWFsLXJlbGF0ZWQgdGFic1xuICAgICAgICAgIGNvbnN0IGZpbmFuY2lhbFRhYklkcyA9IG9wZW5UYWJzXG4gICAgICAgICAgICAuZmlsdGVyKCh0YWI6IEVkaXRvclRhYikgPT4ge1xuICAgICAgICAgICAgICAvLyBGaW5kIHRoZSBjb3JyZXNwb25kaW5nIGZpbGUgdG8gY2hlY2sgaXRzIGNhdGVnb3J5XG4gICAgICAgICAgICAgIGNvbnN0IHsgZmluYW5jaWFsRmlsZXMgfSA9IGdldCgpO1xuICAgICAgICAgICAgICBjb25zdCBmaWxlID0gZmluYW5jaWFsRmlsZXMuZmluZCgoZjogUHJvamVjdEZpbGUpID0+IGYuaWQgPT09IHRhYi5pZCk7XG4gICAgICAgICAgICAgIHJldHVybiBmaWxlPy5jYXRlZ29yeSA9PT0gJ2ZpbmFuY2lhbCc7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLm1hcCgodGFiOiBFZGl0b3JUYWIpID0+IHRhYi5pZCk7XG4gICAgICAgICAgXG4gICAgICAgICAgZmluYW5jaWFsVGFiSWRzLmZvckVhY2goKHRhYklkOiBzdHJpbmcpID0+IGdldCgpLmNsb3NlVGFiKHRhYklkKSk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQ2xlYXIgYWxsIGZpbmFuY2lhbCBmaWxlcyBhbmQgZm9sZGVyc1xuICAgICAgICAgIHNldCh7XG4gICAgICAgICAgICBmaW5hbmNpYWxGaWxlczogW10sXG4gICAgICAgICAgICBmaW5hbmNpYWxGb2xkZXJzOiBbXSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBkZWxldGVQcm9qZWN0c0NhdGVnb3J5OiAoKSA9PiB7XG4gICAgICAgICAgZ2V0KCkuY2xlYXJQcm9qZWN0Q2F0ZWdvcnkoKTtcbiAgICAgICAgICBzZXQoeyBzaG93UHJvamVjdHNDYXRlZ29yeTogZmFsc2UgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGVsZXRlRmluYW5jaWFsQ2F0ZWdvcnk6ICgpID0+IHtcbiAgICAgICAgICBnZXQoKS5jbGVhckZpbmFuY2lhbENhdGVnb3J5KCk7XG4gICAgICAgICAgc2V0KHsgc2hvd0ZpbmFuY2lhbENhdGVnb3J5OiBmYWxzZSB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICByZW9yZGVyUHJvamVjdEZvbGRlcnM6IChmcm9tSW5kZXg6IG51bWJlciwgdG9JbmRleDogbnVtYmVyKSA9PiB7XG4gICAgICAgICAgY29uc3QgeyBwcm9qZWN0Rm9sZGVycyB9ID0gZ2V0KCk7XG4gICAgICAgICAgY29uc3QgbmV3Rm9sZGVycyA9IFsuLi5wcm9qZWN0Rm9sZGVyc107XG4gICAgICAgICAgY29uc3QgW21vdmVkRm9sZGVyXSA9IG5ld0ZvbGRlcnMuc3BsaWNlKGZyb21JbmRleCwgMSk7XG4gICAgICAgICAgbmV3Rm9sZGVycy5zcGxpY2UodG9JbmRleCwgMCwgbW92ZWRGb2xkZXIpO1xuICAgICAgICAgIFxuICAgICAgICAgIHNldCh7IHByb2plY3RGb2xkZXJzOiBuZXdGb2xkZXJzIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlb3JkZXJGaWxlc0luRm9sZGVyOiAoZm9sZGVySWQ6IHN0cmluZywgZnJvbUluZGV4OiBudW1iZXIsIHRvSW5kZXg6IG51bWJlciwgY2F0ZWdvcnk6ICdwcm9qZWN0JyB8ICdmaW5hbmNpYWwnKSA9PiB7XG4gICAgICAgICAgY29uc3QgeyBwcm9qZWN0RmlsZXMsIGZpbmFuY2lhbEZpbGVzIH0gPSBnZXQoKTtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAoY2F0ZWdvcnkgPT09ICdwcm9qZWN0Jykge1xuICAgICAgICAgICAgLy8gRmlsdGVyIGZpbGVzIGluIHRoZSBzcGVjaWZpYyBmb2xkZXJcbiAgICAgICAgICAgIGNvbnN0IGZvbGRlckZpbGVzID0gcHJvamVjdEZpbGVzLmZpbHRlcihmaWxlID0+IGZpbGUuZm9sZGVySWQgPT09IGZvbGRlcklkKTtcbiAgICAgICAgICAgIGNvbnN0IG90aGVyRmlsZXMgPSBwcm9qZWN0RmlsZXMuZmlsdGVyKGZpbGUgPT4gZmlsZS5mb2xkZXJJZCAhPT0gZm9sZGVySWQpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBSZW9yZGVyIGZpbGVzIHdpdGhpbiB0aGUgZm9sZGVyXG4gICAgICAgICAgICBjb25zdCByZW9yZGVyZWRGb2xkZXJGaWxlcyA9IFsuLi5mb2xkZXJGaWxlc107XG4gICAgICAgICAgICBjb25zdCBbbW92ZWRGaWxlXSA9IHJlb3JkZXJlZEZvbGRlckZpbGVzLnNwbGljZShmcm9tSW5kZXgsIDEpO1xuICAgICAgICAgICAgcmVvcmRlcmVkRm9sZGVyRmlsZXMuc3BsaWNlKHRvSW5kZXgsIDAsIG1vdmVkRmlsZSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIENvbWJpbmUgd2l0aCBvdGhlciBmaWxlc1xuICAgICAgICAgICAgY29uc3QgbmV3UHJvamVjdEZpbGVzID0gWy4uLm90aGVyRmlsZXMsIC4uLnJlb3JkZXJlZEZvbGRlckZpbGVzXTtcbiAgICAgICAgICAgIHNldCh7IHByb2plY3RGaWxlczogbmV3UHJvamVjdEZpbGVzIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBTaW1pbGFyIGxvZ2ljIGZvciBmaW5hbmNpYWwgZmlsZXNcbiAgICAgICAgICAgIGNvbnN0IGZvbGRlckZpbGVzID0gZmluYW5jaWFsRmlsZXMuZmlsdGVyKGZpbGUgPT4gZmlsZS5mb2xkZXJJZCA9PT0gZm9sZGVySWQpO1xuICAgICAgICAgICAgY29uc3Qgb3RoZXJGaWxlcyA9IGZpbmFuY2lhbEZpbGVzLmZpbHRlcihmaWxlID0+IGZpbGUuZm9sZGVySWQgIT09IGZvbGRlcklkKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY29uc3QgcmVvcmRlcmVkRm9sZGVyRmlsZXMgPSBbLi4uZm9sZGVyRmlsZXNdO1xuICAgICAgICAgICAgY29uc3QgW21vdmVkRmlsZV0gPSByZW9yZGVyZWRGb2xkZXJGaWxlcy5zcGxpY2UoZnJvbUluZGV4LCAxKTtcbiAgICAgICAgICAgIHJlb3JkZXJlZEZvbGRlckZpbGVzLnNwbGljZSh0b0luZGV4LCAwLCBtb3ZlZEZpbGUpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBjb25zdCBuZXdGaW5hbmNpYWxGaWxlcyA9IFsuLi5vdGhlckZpbGVzLCAuLi5yZW9yZGVyZWRGb2xkZXJGaWxlc107XG4gICAgICAgICAgICBzZXQoeyBmaW5hbmNpYWxGaWxlczogbmV3RmluYW5jaWFsRmlsZXMgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHNhdmVGaWxlOiAodGFiSWQ6IHN0cmluZykgPT4ge1xuICAgICAgICAgIGNvbnN0IHsgb3BlblRhYnMsIHByb2plY3RGaWxlcywgZmluYW5jaWFsRmlsZXMgfSA9IGdldCgpO1xuICAgICAgICAgIGNvbnN0IHRhYiA9IG9wZW5UYWJzLmZpbmQoKHQ6IEVkaXRvclRhYikgPT4gdC5pZCA9PT0gdGFiSWQpO1xuICAgICAgICAgIFxuICAgICAgICAgIGlmICghdGFiKSByZXR1cm47XG5cbiAgICAgICAgICAvLyBVcGRhdGUgdGhlIGZpbGUgY29udGVudCBpbiBhcHByb3ByaWF0ZSBhcnJheVxuICAgICAgICAgIGNvbnN0IHVwZGF0ZWRQcm9qZWN0RmlsZXMgPSBwcm9qZWN0RmlsZXMubWFwKChmaWxlOiBQcm9qZWN0RmlsZSkgPT5cbiAgICAgICAgICAgIGZpbGUuaWQgPT09IHRhYklkXG4gICAgICAgICAgICAgID8geyAuLi5maWxlLCBjb250ZW50OiB0YWIuY29udGVudCwgbW9kaWZpZWRBdDogbmV3IERhdGUoKSB9XG4gICAgICAgICAgICAgIDogZmlsZVxuICAgICAgICAgICk7XG5cbiAgICAgICAgICBjb25zdCB1cGRhdGVkRmluYW5jaWFsRmlsZXMgPSBmaW5hbmNpYWxGaWxlcy5tYXAoKGZpbGU6IFByb2plY3RGaWxlKSA9PlxuICAgICAgICAgICAgZmlsZS5pZCA9PT0gdGFiSWRcbiAgICAgICAgICAgICAgPyB7IC4uLmZpbGUsIGNvbnRlbnQ6IHRhYi5jb250ZW50LCBtb2RpZmllZEF0OiBuZXcgRGF0ZSgpIH1cbiAgICAgICAgICAgICAgOiBmaWxlXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIGNvbnN0IHVwZGF0ZWRUYWJzID0gb3BlblRhYnMubWFwKCh0OiBFZGl0b3JUYWIpID0+XG4gICAgICAgICAgICB0LmlkID09PSB0YWJJZFxuICAgICAgICAgICAgICA/IHsgLi4udCwgbW9kaWZpZWQ6IGZhbHNlIH1cbiAgICAgICAgICAgICAgOiB0XG4gICAgICAgICAgKTtcblxuICAgICAgICAgIHNldCh7XG4gICAgICAgICAgICBwcm9qZWN0RmlsZXM6IHVwZGF0ZWRQcm9qZWN0RmlsZXMsXG4gICAgICAgICAgICBmaW5hbmNpYWxGaWxlczogdXBkYXRlZEZpbmFuY2lhbEZpbGVzLFxuICAgICAgICAgICAgb3BlblRhYnM6IHVwZGF0ZWRUYWJzLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldEVycm9yOiAoZXJyb3I6IHN0cmluZyB8IG51bGwpID0+IHtcbiAgICAgICAgICBzZXQoeyBlcnJvciB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICByZXNldDogKCkgPT4ge1xuICAgICAgICAgIHNldCh7XG4gICAgICAgICAgICBvcGVuVGFiczogW10sXG4gICAgICAgICAgICBhY3RpdmVUYWI6ICcnLFxuICAgICAgICAgICAgcHJvamVjdEZpbGVzOiBpbml0aWFsUHJvamVjdEZpbGVzLFxuICAgICAgICAgICAgZmluYW5jaWFsRmlsZXM6IGluaXRpYWxGaW5hbmNpYWxGaWxlcyxcbiAgICAgICAgICAgIHByb2plY3RGb2xkZXJzOiBbXSxcbiAgICAgICAgICAgIGZpbmFuY2lhbEZvbGRlcnM6IFtdLFxuICAgICAgICAgICAgc2hvd1Byb2plY3RzQ2F0ZWdvcnk6IHRydWUsXG4gICAgICAgICAgICBzaG93RmluYW5jaWFsQ2F0ZWdvcnk6IHRydWUsXG4gICAgICAgICAgICBpc0xvYWRpbmc6IGZhbHNlLFxuICAgICAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICB9KSxcbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ2VkaXRvci1zdG9yYWdlJyxcbiAgICAgICAgLy8gT25seSBwZXJzaXN0IHNwZWNpZmljIGZpZWxkc1xuICAgICAgICBwYXJ0aWFsaXplOiAoc3RhdGUpID0+ICh7IFxuICAgICAgICAgIG9wZW5UYWJzOiBzdGF0ZS5vcGVuVGFicy5tYXAodGFiID0+ICh7XG4gICAgICAgICAgICBpZDogdGFiLmlkLFxuICAgICAgICAgICAgbmFtZTogdGFiLm5hbWUsXG4gICAgICAgICAgICBtb2RpZmllZDogdGFiLm1vZGlmaWVkLFxuICAgICAgICAgICAgY29udGVudDogdGFiLmNvbnRlbnQsXG4gICAgICAgICAgICBmaWxlUGF0aDogdGFiLmZpbGVQYXRoLFxuICAgICAgICAgICAgdHlwZTogdGFiLnR5cGUsXG4gICAgICAgICAgICAvLyBXZSdsbCBuZWVkIHRvIHJlc3RvcmUgdGhlIGljb24gYmFzZWQgb24gZmlsZSB0eXBlXG4gICAgICAgICAgfSkpLFxuICAgICAgICAgIGFjdGl2ZVRhYjogc3RhdGUuYWN0aXZlVGFiLFxuICAgICAgICAgIHByb2plY3RGaWxlczogc3RhdGUucHJvamVjdEZpbGVzLFxuICAgICAgICAgIGZpbmFuY2lhbEZpbGVzOiBzdGF0ZS5maW5hbmNpYWxGaWxlcyxcbiAgICAgICAgICBwcm9qZWN0Rm9sZGVyczogc3RhdGUucHJvamVjdEZvbGRlcnMsXG4gICAgICAgICAgZmluYW5jaWFsRm9sZGVyczogc3RhdGUuZmluYW5jaWFsRm9sZGVycyxcbiAgICAgICAgICBzaG93UHJvamVjdHNDYXRlZ29yeTogc3RhdGUuc2hvd1Byb2plY3RzQ2F0ZWdvcnksXG4gICAgICAgICAgc2hvd0ZpbmFuY2lhbENhdGVnb3J5OiBzdGF0ZS5zaG93RmluYW5jaWFsQ2F0ZWdvcnksXG4gICAgICAgIH0pLFxuICAgICAgICAvLyBDdXN0b20gc3RvcmFnZSB0byBoYW5kbGUgaWNvbiByZXN0b3JhdGlvblxuICAgICAgICBzdG9yYWdlOiB7XG4gICAgICAgICAgZ2V0SXRlbTogKG5hbWUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHN0ciA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKG5hbWUpO1xuICAgICAgICAgICAgaWYgKCFzdHIpIHJldHVybiBudWxsO1xuICAgICAgICAgICAgY29uc3QgeyBzdGF0ZSB9ID0gSlNPTi5wYXJzZShzdHIpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBSZXN0b3JlIGljb25zIGJhc2VkIG9uIGZpbGUgdHlwZVxuICAgICAgICAgICAgY29uc3QgcmVzdG9yZWRUYWJzID0gKHN0YXRlLm9wZW5UYWJzIHx8IFtdKS5tYXAoKHRhYjogT21pdDxFZGl0b3JUYWIsICdpY29uJz4pID0+IHtcbiAgICAgICAgICAgICAgbGV0IGljb24gPSBGaWxlQ29kZTtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIHN3aXRjaCAodGFiLnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICd0eXBlc2NyaXB0JzpcbiAgICAgICAgICAgICAgICBjYXNlICdqYXZhc2NyaXB0JzpcbiAgICAgICAgICAgICAgICAgIGljb24gPSBGaWxlQ29kZTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2pzb24nOlxuICAgICAgICAgICAgICAgICAgaWNvbiA9IEJyYWNlcztcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2V4Y2VsJzpcbiAgICAgICAgICAgICAgICAgIGljb24gPSBGaWxlU3ByZWFkc2hlZXQ7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdtYXJrZG93bic6XG4gICAgICAgICAgICAgICAgICBpY29uID0gRmlsZVRleHQ7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdwZGYnOlxuICAgICAgICAgICAgICAgICAgaWNvbiA9IEZpbGVUeXBlO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgLi4udGFiLFxuICAgICAgICAgICAgICAgIGljb24sXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgc3RhdGU6IHtcbiAgICAgICAgICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgICAgICAgICBvcGVuVGFiczogcmVzdG9yZWRUYWJzLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNldEl0ZW06IChuYW1lLCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0obmFtZSwgSlNPTi5zdHJpbmdpZnkodmFsdWUpKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHJlbW92ZUl0ZW06IChuYW1lKSA9PiBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShuYW1lKSxcbiAgICAgICAgfSxcbiAgICAgIH1cbiAgICApLFxuICAgIHsgbmFtZTogJ2VkaXRvci1zdG9yZScgfVxuICApXG4pOyAiXSwibmFtZXMiOlsiQXRTaWduIiwiQnJhY2VzIiwiQ2FtZXJhIiwiRmlsZUNvZGUiLCJGaWxlU3ByZWFkc2hlZXQiLCJGaWxlVGV4dCIsIkZpbGVUeXBlIiwiSGFzaCIsIk1lc3NhZ2VTcXVhcmUiLCJjcmVhdGUiLCJkZXZ0b29scyIsInBlcnNpc3QiLCJnZXRGaWxlSWNvbiIsInR5cGUiLCJnZXRGaWxlRXh0ZW5zaW9uIiwiZ2V0RGVmYXVsdENvbnRlbnQiLCJuYW1lIiwicmVwbGFjZSIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsInRvTG9jYWxlRGF0ZVN0cmluZyIsImluaXRpYWxQcm9qZWN0RmlsZXMiLCJpZCIsImljb24iLCJjYXRlZ29yeSIsImNvbnRlbnQiLCJmaWxlUGF0aCIsImNyZWF0ZWRBdCIsIm1vZGlmaWVkQXQiLCJpbml0aWFsRmluYW5jaWFsRmlsZXMiLCJ1c2VFZGl0b3JTdG9yZSIsInNldCIsImdldCIsIm9wZW5UYWJzIiwiYWN0aXZlVGFiIiwicHJvamVjdEZpbGVzIiwiZmluYW5jaWFsRmlsZXMiLCJwcm9qZWN0Rm9sZGVycyIsImZpbmFuY2lhbEZvbGRlcnMiLCJ0cmFzaEl0ZW1zIiwic2hvd1Byb2plY3RzQ2F0ZWdvcnkiLCJzaG93RmluYW5jaWFsQ2F0ZWdvcnkiLCJpc0xvYWRpbmciLCJlcnJvciIsIm9wZW5UYWIiLCJmaWxlIiwiZXhpc3RpbmdUYWIiLCJmaW5kIiwidGFiIiwibmV3VGFiIiwibW9kaWZpZWQiLCJvcGVuU3BlY2lhbFRhYiIsImNsb3NlVGFiIiwidGFiSWQiLCJ0YWJJbmRleCIsImZpbmRJbmRleCIsIm5ld1RhYnMiLCJmaWx0ZXIiLCJuZXdBY3RpdmVUYWIiLCJsZW5ndGgiLCJuZXh0SW5kZXgiLCJjbG9zZUFsbFRhYnMiLCJzZXRBY3RpdmVUYWIiLCJ0YWJFeGlzdHMiLCJzb21lIiwidXBkYXRlVGFiQ29udGVudCIsInVwZGF0ZWRUYWJzIiwibWFwIiwidXBkYXRlRmlsZUNvbnRlbnQiLCJ1cGRhdGVGaWxlU3RhdHVzIiwiZmlsZUlkIiwic3RhdHVzIiwidXBkYXRlZFByb2plY3RGaWxlcyIsInVwZGF0ZWRGaW5hbmNpYWxGaWxlcyIsImNyZWF0ZU5ld0ZpbGUiLCJmb2xkZXJJZCIsInRvTG93ZXJDYXNlIiwibm93IiwiZmlsZU5hbWUiLCJiYXNlUGF0aCIsIm5ld0ZpbGUiLCJpbmNsdWRlcyIsInVuZGVmaW5lZCIsImNvbnNvbGUiLCJsb2ciLCJ3aW5kb3ciLCJkaXNwYXRjaEV2ZW50IiwiQ3VzdG9tRXZlbnQiLCJkZXRhaWwiLCJwcm9qZWN0SWQiLCJjcmVhdGVGb2xkZXIiLCJleGlzdGluZ0ZvbGRlcnMiLCJmb2xkZXJFeGlzdHMiLCJmb2xkZXIiLCJ1bmlxdWVJZCIsImNyeXB0byIsInJhbmRvbVVVSUQiLCJ0aW1lc3RhbXAiLCJyYW5kb20iLCJNYXRoIiwidG9TdHJpbmciLCJzdWJzdHJpbmciLCJjb3VudGVyIiwiZmxvb3IiLCJhbGxGb2xkZXJzIiwicmFuZG9tU3VmZml4IiwibmV3Rm9sZGVyIiwiY2xlYW51cER1cGxpY2F0ZUZvbGRlcnMiLCJjbGVhbnVwRm9sZGVycyIsImZvbGRlcnMiLCJzZWVuIiwiU2V0IiwiY2xlYW5lZCIsImhhcyIsImFkZCIsInN0YXJ0c1dpdGgiLCJuZXdJZCIsImNsZWFuZWRQcm9qZWN0Rm9sZGVycyIsImNsZWFuZWRGaW5hbmNpYWxGb2xkZXJzIiwiZGVsZXRlRmlsZSIsInRhYlRvQ2xvc2UiLCJyZW5hbWVGaWxlIiwibmV3TmFtZSIsInByb2plY3RGaWxlIiwiZmluYW5jaWFsRmlsZSIsIm5ld0ZpbGVOYW1lIiwibmV3RmlsZVBhdGgiLCJmIiwicmVuYW1lRm9sZGVyIiwidXBkYXRlZFByb2plY3RGb2xkZXJzIiwidXBkYXRlZEZpbmFuY2lhbEZvbGRlcnMiLCJkZWxldGVGb2xkZXIiLCJmaWxlc1RvRGVsZXRlIiwiZm9yRWFjaCIsIm1vdmVUb1RyYXNoIiwiaXRlbSIsInRyYXNoSXRlbSIsIm9yaWdpbmFsRGF0YSIsImRlbGV0ZWRBdCIsImZpbGVzVG9UcmFzaCIsImZpbGVUcmFzaEl0ZW1zIiwicmVzdG9yZUZyb21UcmFzaCIsInRyYXNoSXRlbUlkIiwidXBkYXRlZFRyYXNoSXRlbXMiLCJwZXJtYW5lbnRseURlbGV0ZSIsImVtcHR5VHJhc2giLCJjbGVhclByb2plY3RDYXRlZ29yeSIsInByb2plY3RUYWJJZHMiLCJjbGVhckZpbmFuY2lhbENhdGVnb3J5IiwiZmluYW5jaWFsVGFiSWRzIiwiZGVsZXRlUHJvamVjdHNDYXRlZ29yeSIsImRlbGV0ZUZpbmFuY2lhbENhdGVnb3J5IiwicmVvcmRlclByb2plY3RGb2xkZXJzIiwiZnJvbUluZGV4IiwidG9JbmRleCIsIm5ld0ZvbGRlcnMiLCJtb3ZlZEZvbGRlciIsInNwbGljZSIsInJlb3JkZXJGaWxlc0luRm9sZGVyIiwiZm9sZGVyRmlsZXMiLCJvdGhlckZpbGVzIiwicmVvcmRlcmVkRm9sZGVyRmlsZXMiLCJtb3ZlZEZpbGUiLCJuZXdQcm9qZWN0RmlsZXMiLCJuZXdGaW5hbmNpYWxGaWxlcyIsInNhdmVGaWxlIiwidCIsInNldEVycm9yIiwicmVzZXQiLCJwYXJ0aWFsaXplIiwic3RhdGUiLCJzdG9yYWdlIiwiZ2V0SXRlbSIsInN0ciIsImxvY2FsU3RvcmFnZSIsIkpTT04iLCJwYXJzZSIsInJlc3RvcmVkVGFicyIsInNldEl0ZW0iLCJ2YWx1ZSIsInN0cmluZ2lmeSIsInJlbW92ZUl0ZW0iXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./store/editor/index.ts\n"));

/***/ })

});