"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./store/agents/twitterAgent.ts":
/*!**************************************!*\
  !*** ./store/agents/twitterAgent.ts ***!
  \**************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TwitterAgent: () => (/* binding */ TwitterAgent),\n/* harmony export */   twitterAgent: () => (/* binding */ twitterAgent)\n/* harmony export */ });\n/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ \"(app-pages-browser)/./store/agents/base.ts\");\n// Twitter Agent\n// /Users/matthewsimon/Projects/eac/eac/store/agents/twitterAgent.ts\n\nclass TwitterAgent extends _base__WEBPACK_IMPORTED_MODULE_0__.BaseAgent {\n    async execute(tool, input, convexMutations) {\n        if (tool.id === \"create-twitter-post\") {\n            return await this.createTwitterPost(input, convexMutations);\n        }\n        throw new Error(\"Unknown tool: \".concat(tool.id));\n    }\n    async createTwitterPost(input, convexMutations) {\n        try {\n            console.log('\\uD83D\\uDC26 Twitter Agent: Processing request: \"'.concat(input, '\"'));\n            // IMPORTANT: Twitter agent should NEVER create instruction files\n            if (convexMutations.createInstructionFile) {\n                console.warn(\"üö® WARNING: Twitter agent received createInstructionFile function - removing it to prevent accidental calls\");\n                // Remove it to prevent accidental calls\n                delete convexMutations.createInstructionFile;\n            }\n            // Clean the input by removing the command\n            let cleanInput = input.trim();\n            // Remove the /twitter command if present\n            if (cleanInput.startsWith(\"/twitter\")) {\n                cleanInput = cleanInput.replace(\"/twitter\", \"\").trim();\n            }\n            if (!cleanInput) {\n                return \"‚ùå Please provide content for your Twitter post. Example: /twitter Check out our new dashboard!\";\n            }\n            try {\n                // Parse parameters from input first\n                const params = this.parseTwitterParameters(cleanInput);\n                // Try to import the modular tools first\n                let processTwitterRequest;\n                let useEditorStore;\n                console.log(\"üîç Attempting to import advanced Twitter tools...\");\n                try {\n                    console.log(\"ÔøΩ Trying multiple import paths for Twitter tools...\");\n                    let twitterTools;\n                    try {\n                        console.log(\"ÔøΩüîó Attempt 1: ../../lib/twitter-tools/index.mjs\");\n                        twitterTools = await __webpack_require__.e(/*! import() */ \"_app-pages-browser_lib_twitter-tools_index_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ../../lib/twitter-tools/index.mjs */ \"(app-pages-browser)/./lib/twitter-tools/index.mjs\"));\n                    } catch (e1) {\n                        console.log(\"‚ùå Attempt 1 failed:\", e1 instanceof Error ? e1.message : String(e1));\n                        try {\n                            console.log(\"üîó Attempt 2: ../../lib/twitter-tools/index.js\");\n                            twitterTools = await __webpack_require__.e(/*! import() */ \"_app-pages-browser_lib_twitter-tools_index_js\").then(__webpack_require__.t.bind(__webpack_require__, /*! ../../lib/twitter-tools/index.js */ \"(app-pages-browser)/./lib/twitter-tools/index.js\", 23));\n                        } catch (e2) {\n                            console.log(\"‚ùå Attempt 2 failed:\", e2 instanceof Error ? e2.message : String(e2));\n                            try {\n                                console.log(\"üîó Attempt 3: ../../lib/twitter-tools\");\n                                twitterTools = await __webpack_require__.e(/*! import() */ \"_app-pages-browser_lib_twitter-tools_index_js\").then(__webpack_require__.t.bind(__webpack_require__, /*! ../../lib/twitter-tools */ \"(app-pages-browser)/./lib/twitter-tools/index.js\", 23));\n                            } catch (e3) {\n                                console.log(\"‚ùå Attempt 3 failed:\", e3 instanceof Error ? e3.message : String(e3));\n                                const e1Msg = e1 instanceof Error ? e1.message : String(e1);\n                                const e2Msg = e2 instanceof Error ? e2.message : String(e2);\n                                const e3Msg = e3 instanceof Error ? e3.message : String(e3);\n                                throw new Error(\"All import attempts failed: \".concat(e1Msg, \", \").concat(e2Msg, \", \").concat(e3Msg));\n                            }\n                        }\n                    }\n                    console.log(\"‚úÖ Twitter tools imported successfully:\", Object.keys(twitterTools));\n                    processTwitterRequest = twitterTools.processTwitterRequest;\n                    console.log(\"üîó Importing editor store...\");\n                    const editorModule = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ../ */ \"(app-pages-browser)/./store/index.ts\"));\n                    useEditorStore = editorModule.useEditorStore;\n                    console.log(\"‚úÖ Editor store imported successfully\");\n                } catch (importError) {\n                    console.warn(\"‚ö†Ô∏è Could not import advanced Twitter tools, using simplified implementation:\", importError);\n                    // Fallback to create a basic implementation\n                    return await this.createSimpleTwitterPost(cleanInput, params);\n                }\n                console.log(\"üöÄ Using advanced Twitter tools to process request...\");\n                // Use the modular tools processor\n                const result = await processTwitterRequest({\n                    userInput: params.content,\n                    suggestedProject: params.project,\n                    schedule: params.schedule,\n                    settings: params.settings\n                }, useEditorStore.getState() // Pass the store state, not the hook\n                );\n                console.log(\"üìã Advanced tools result:\", result);\n                if (!result.success) {\n                    return \"‚ùå Error processing Twitter request: \".concat(result.message);\n                }\n                // Step 1: Ensure Content Creation system folder exists and use it\n                const editorStore = useEditorStore.getState();\n                // Find or create the Content Creation system folder\n                let contentCreationFolder = editorStore.projectFolders.find((folder)=>folder.id === 'content-creation-folder' || folder.name === 'Content Creation');\n                if (!contentCreationFolder) {\n                    // Create the Content Creation system folder if it doesn't exist\n                    await editorStore.createFolder('Content Creation', 'project');\n                    contentCreationFolder = editorStore.projectFolders.find((folder)=>folder.name === 'Content Creation');\n                }\n                // Override the project result to always use Content Creation\n                const projectName = 'Content Creation';\n                // Step 2: Create the .x file in the Content Creation system folder ONLY\n                const fileName = await this.createTwitterFile(result.content.content, projectName, convexMutations);\n                // Step 3: Fill form fields and apply default settings\n                const formData = this.prepareTwitterFormData({\n                    content: result.content.content,\n                    project: projectName,\n                    schedule: params.schedule,\n                    settings: params.settings\n                });\n                // Step 3.1: Actually populate the form fields with the processed data\n                await this.fillTwitterFormFieldsWithData(fileName, result.content.content, formData);\n                // Step 4: Handle scheduling if requested\n                let schedulingResult = \"\";\n                if (params.schedule) {\n                    schedulingResult = await this.handleTwitterScheduling(params.schedule, result.content.content, projectName);\n                }\n                // Success response\n                return '\\uD83D\\uDC26 **Twitter Post Created Successfully!**\\n\\n**Content:** \"'.concat(result.content.content.substring(0, 100)).concat(result.content.content.length > 100 ? '...' : '', '\"\\n**Project:** ').concat(projectName, \"\\n**File:** `\").concat(fileName, \"`\\n**Topic:** \").concat(result.content.detectedTopic, \"\\n**Style:** \").concat(result.content.style, \"\\n\\n**Form Status:** ‚úÖ Pre-filled and ready to post\\n**Reply Settings:** Applied (\").concat(formData.replySettings, \")\\n\\n\").concat(schedulingResult, \"\\n\\n*The Twitter post form has been populated and is ready for review. Open the file to make any final edits before posting.*\");\n            } catch (error) {\n                console.error(\"‚ùå Twitter post creation failed:\", error);\n                return '‚ùå **Error Creating Twitter Post**\\n\\nFailed to process: \"'.concat(input, '\"\\n\\nError: ').concat(error instanceof Error ? error.message : 'Unknown error', \"\\n\\nPlease try again or check if:\\n- The content is appropriate for Twitter\\n- The project name is valid\\n- The scheduling format is correct (e.g., 'tomorrow 2pm', 'Dec 25 9am')\");\n            }\n        } catch (error) {\n            console.error(\"‚ùå Twitter agent execution failed:\", error);\n            return '‚ùå **Twitter Agent Error**\\n\\nFailed to execute Twitter agent for: \"'.concat(input, '\"\\n\\nError: ').concat(error instanceof Error ? error.message : 'Unknown error', \"\\n\\nPlease try again with a different approach or contact support.\");\n        }\n    }\n    parseTwitterParameters(input) {\n        const params = {\n            content: input,\n            project: undefined,\n            schedule: undefined,\n            settings: undefined\n        };\n        // Extract project parameter\n        const projectMatch = input.match(/--project[=\\s]+([^\\s]+)/i);\n        if (projectMatch) {\n            params.project = projectMatch[1];\n            params.content = params.content.replace(projectMatch[0], '').trim();\n        }\n        // Extract schedule parameter\n        const scheduleMatch = input.match(/--schedule[=\\s]+\"([^\"]+)\"|--schedule[=\\s]+([^\\s]+)/i);\n        if (scheduleMatch) {\n            params.schedule = scheduleMatch[1] || scheduleMatch[2];\n            params.content = params.content.replace(scheduleMatch[0], '').trim();\n        }\n        // Extract settings parameter\n        const settingsMatch = input.match(/--settings[=\\s]+([^\\s]+)/i);\n        if (settingsMatch) {\n            params.settings = settingsMatch[1];\n            params.content = params.content.replace(settingsMatch[0], '').trim();\n        }\n        return params;\n    }\n    async createTwitterFile(content, projectName, convexMutations) {\n        try {\n            const { useEditorStore } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ../ */ \"(app-pages-browser)/./store/index.ts\"));\n            const editorStore = useEditorStore.getState();\n            // Import the intelligent file namer\n            const { fileNamer } = await __webpack_require__.e(/*! import() */ \"_app-pages-browser_lib_twitter-tools_fileNamer_ts\").then(__webpack_require__.bind(__webpack_require__, /*! ../../lib/twitter-tools/fileNamer */ \"(app-pages-browser)/./lib/twitter-tools/fileNamer.ts\"));\n            // Generate meaningful filename based on content\n            const fileNameResult = fileNamer.generateFileName({\n                content,\n                maxWords: 3\n            });\n            const fileName = fileNameResult.name;\n            console.log(\"\\uD83C\\uDFF7Ô∏è  Generated intelligent filename: \".concat(fileName, ' (from content: \"').concat(content.substring(0, 50), '...\")'));\n            console.log('\\uD83D\\uDCC1 Looking for project folder: \"'.concat(projectName, '\"'));\n            console.log(\"\\uD83D\\uDCC2 Available folders:\", editorStore.projectFolders.map((f)=>({\n                    id: f.id,\n                    name: f.name\n                })));\n            // Find the project folder (case-insensitive search)\n            const projectFolder = editorStore.projectFolders.find((folder)=>folder.name.toLowerCase() === projectName.toLowerCase());\n            if (projectFolder) {\n                console.log(\"‚úÖ Found project folder:\", {\n                    id: projectFolder.id,\n                    name: projectFolder.name\n                });\n            } else {\n                console.warn('‚ö†Ô∏è Project folder \"'.concat(projectName, '\" not found! Available folders:'), editorStore.projectFolders.map((f)=>f.name));\n            }\n            // Generate rich content for the .x file with unique content\n            const today = new Date().toLocaleDateString();\n            const timeStamp = new Date().toLocaleTimeString();\n            const richContent = \"# \".concat(fileName, \".x - X/Twitter Post\\nPlatform: X (Twitter)\\nCreated: \").concat(today, \" at \").concat(timeStamp, \"\\nProject: \").concat(projectName, \"\\nUnique Hash: \").concat(hash, \"\\n\\n## Post Content\\n\").concat(content, \"\\n\\n## Settings\\n- Reply Settings: Following\\n- Schedule: Now\\n- Thread: Single Tweet\\n\\n## Media\\n- Images: []\\n- Videos: []\\n- GIFs: []\\n\\n## Analytics\\n- Impressions: 0\\n- Engagements: 0\\n- Retweets: 0\\n- Likes: 0\\n- Replies: 0\\n\\n## File Details\\n- Created: \").concat(today, \" at \").concat(timeStamp, \"\\n- Status: Draft\\n- Type: Twitter Post\\n- Unique Content ID: \").concat(hash);\n            console.log(\"\\uD83D\\uDCDD Creating file \".concat(fileName, \" with unique content directly\"));\n            console.log(\"\\uD83D\\uDCC4 Rich content preview:\", richContent.substring(0, 200) + \"...\");\n            console.log(\"\\uD83D\\uDCC4 Rich content length:\", richContent.length);\n            console.log(\"\\uD83D\\uDCC1 Target folder ID:\", (projectFolder === null || projectFolder === void 0 ? void 0 : projectFolder.id) || 'NO FOLDER');\n            // Create the file with the unique content directly (no separate update needed)\n            const fileId = editorStore.createNewFile(fileName, \"x\", \"project\", projectFolder === null || projectFolder === void 0 ? void 0 : projectFolder.id, richContent);\n            console.log(\"‚úÖ File created with unique content: \".concat(fileName, \".x (ID: \").concat(fileId, \")\"));\n            // Save to database\n            try {\n                await convexMutations.upsertPost({\n                    fileName: fileName + \".x\",\n                    fileType: 'twitter',\n                    content: content,\n                    title: \"Twitter Post - \".concat(projectName),\n                    status: 'draft'\n                });\n                console.log(\"‚úÖ Twitter post saved to database:\", fileName + \".x\");\n            } catch (dbError) {\n                console.warn(\"‚ö†Ô∏è Failed to save to database:\", dbError);\n            // Continue anyway - file was created locally\n            }\n            return fileName + \".x\";\n        } catch (error) {\n            console.error(\"‚ùå Failed to create Twitter file:\", error);\n            throw new Error(\"Failed to create Twitter file: \".concat(error instanceof Error ? error.message : 'Unknown error'));\n        }\n    }\n    async createTwitterFileSimple(content, projectName) {\n        try {\n            const { useEditorStore } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ../ */ \"(app-pages-browser)/./store/index.ts\"));\n            const editorStore = useEditorStore.getState();\n            // Import the intelligent file namer\n            const { fileNamer } = await __webpack_require__.e(/*! import() */ \"_app-pages-browser_lib_twitter-tools_fileNamer_ts\").then(__webpack_require__.bind(__webpack_require__, /*! ../../lib/twitter-tools/fileNamer */ \"(app-pages-browser)/./lib/twitter-tools/fileNamer.ts\"));\n            // Generate meaningful filename based on content\n            const fileNameResult = fileNamer.generateFileName({\n                content,\n                maxWords: 3\n            });\n            const fileName = \"\".concat(fileNameResult.name, \".x\");\n            console.log(\"\\uD83C\\uDFF7Ô∏è  Generated intelligent filename: \".concat(fileName, ' (from content: \"').concat(content.substring(0, 50), '...\")'));\n            // Find the project folder\n            const projectFolder = editorStore.projectFolders.find((folder)=>folder.name === projectName);\n            if (projectFolder) {\n                // Create file in the project\n                editorStore.createNewFile(fileName, \"x\", \"project\", projectFolder.id);\n            } else {\n                // Create file at root level if project not found\n                editorStore.createNewFile(fileName, \"x\", \"project\");\n            }\n            return fileName;\n        } catch (error) {\n            console.error(\"‚ùå Failed to create Twitter file:\", error);\n            throw new Error(\"Failed to create Twitter file: \".concat(error instanceof Error ? error.message : 'Unknown error'));\n        }\n    }\n    prepareTwitterFormData(params) {\n        return {\n            replySettings: this.mapTwitterSettingsToAPI(params.settings),\n            scheduledDate: params.schedule ? this.parseScheduleDateComponent(params.schedule) : \"\",\n            scheduledTime: params.schedule ? this.parseScheduleTimeComponent(params.schedule) : \"\",\n            isThread: this.detectThreadIntent(params.content),\n            threadTweets: this.splitIntoThreadTweets(params.content),\n            hasPoll: false,\n            pollOptions: [\n                \"\",\n                \"\"\n            ],\n            pollDuration: 1440\n        };\n    }\n    async fillTwitterFormFieldsWithData(fileName, content, preparedFormData) {\n        try {\n            // Use the already prepared platform data\n            const platformData = {\n                replySettings: preparedFormData.replySettings,\n                scheduledDate: \"\",\n                scheduledTime: \"\",\n                isThread: preparedFormData.isThread,\n                threadTweets: preparedFormData.threadTweets,\n                hasPoll: preparedFormData.hasPoll,\n                pollOptions: preparedFormData.pollOptions,\n                pollDuration: preparedFormData.pollDuration\n            };\n            // Log what we're doing for debugging\n            console.log(\"\\uD83D\\uDCDD Filling Twitter form fields for \".concat(fileName, \":\"), {\n                content: content.substring(0, 50) + \"...\",\n                replySettings: platformData.replySettings,\n                status: \"draft\"\n            });\n            // Instead of trying to use Convex directly (which fails in server context),\n            // let's create a temporary storage mechanism that the client can pick up\n            try {\n                // Store the form data in localStorage for the client to pick up\n                if (true) {\n                    const formDataKey = \"twitter-form-\".concat(fileName);\n                    const formDataToStore = {\n                        content: content,\n                        platformData: platformData,\n                        timestamp: Date.now(),\n                        status: 'draft'\n                    };\n                    localStorage.setItem(formDataKey, JSON.stringify(formDataToStore));\n                    console.log(\"‚úÖ Twitter form data stored in localStorage for \".concat(fileName));\n                } else {}\n            } catch (storageError) {\n                console.warn(\"‚ö†Ô∏è Could not store form data:\", storageError);\n                console.log(\"üìù Form data will be loaded from file content when editor opens\");\n            }\n        } catch (error) {\n            console.error(\"‚ùå Failed to prepare Twitter form fields:\", error);\n        }\n    }\n    // Helper methods\n    mapTwitterSettingsToAPI(settings) {\n        if (!settings) return \"following\";\n        switch(settings.toLowerCase()){\n            case \"everyone\":\n                return \"following\";\n            case \"followers\":\n                return \"following\";\n            case \"mentioned-users\":\n                return \"mentionedUsers\";\n            case \"verified-accounts\":\n                return \"verified\";\n            default:\n                return \"following\";\n        }\n    }\n    parseScheduleDateComponent(schedule) {\n        const date = this.parseScheduleString(schedule);\n        if (!date) return \"\";\n        // Return YYYY-MM-DD format for HTML date input\n        return date.toISOString().split(\"T\")[0];\n    }\n    parseScheduleTimeComponent(schedule) {\n        const date = this.parseScheduleString(schedule);\n        if (!date) return \"\";\n        // Return HH:MM format for HTML time input\n        return date.toTimeString().slice(0, 5);\n    }\n    parseScheduleString(schedule) {\n        // Implementation would parse natural language dates\n        // For now, return null to indicate no valid date\n        return null;\n    }\n    detectThreadIntent(content) {\n        // Simple thread detection logic\n        return content.length > 280 || content.includes('\\n\\n') || content.includes('1/');\n    }\n    splitIntoThreadTweets(content) {\n        if (!this.detectThreadIntent(content)) {\n            return [\n                content\n            ];\n        }\n        // Simple thread splitting logic\n        const parts = content.split('\\n\\n').filter((part)=>part.trim());\n        return parts.length > 1 ? parts : [\n            content\n        ];\n    }\n    async handleTwitterScheduling(schedule, content, projectName) {\n        // Placeholder for scheduling logic\n        return '\\uD83D\\uDCC5 **Scheduling:** Post will be scheduled for \"'.concat(schedule, '\" (feature coming soon)');\n    }\n    async createSimpleTwitterPost(content, params) {\n        try {\n            // Simple implementation when advanced tools can't be loaded\n            const { useEditorStore } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ../ */ \"(app-pages-browser)/./store/index.ts\"));\n            const editorStore = useEditorStore.getState();\n            const projectName = params.project || \"Twitter Posts\";\n            // Create project folder if needed\n            const existingProject = editorStore.projectFolders.find((folder)=>folder.name === projectName);\n            if (!existingProject) {\n                await editorStore.createFolder(projectName, \"project\");\n            }\n            // Create the file (simple version without database save)\n            const fileName = await this.createTwitterFileSimple(content, projectName);\n            return '\\uD83D\\uDC26 **Twitter Post Created Successfully!**\\n\\n**Content:** \"'.concat(content.substring(0, 100)).concat(content.length > 100 ? '...' : '', '\"\\n**Project:** ').concat(projectName, \"\\n**File:** `\").concat(fileName, \"`\\n**Status:** Draft\\n\\n*This is a basic implementation. The full Twitter agent with form population will be available when you're signed in and using the editor interface.*\\n\\n**Next Steps:**\\n1. Sign in to access the full editor\\n2. Open the Twitter post file to edit and publish\\n3. Use the form interface for advanced scheduling and settings\");\n        } catch (error) {\n            console.error(\"‚ùå Simple Twitter post creation failed:\", error);\n            return '‚ùå **Error Creating Twitter Post**\\n\\nFailed to process: \"'.concat(content, '\"\\n\\nError: ').concat(error instanceof Error ? error.message : 'Unknown error', \"\\n\\nPlease try again or contact support.\");\n        }\n    }\n    constructor(...args){\n        super(...args), this.id = \"twitter-post\", this.name = \"Twitter Post\", this.description = \"Create, schedule, and post Twitter/X content with full workflow automation\", this.icon = \"AtSign\", this.tools = [\n            {\n                id: \"create-twitter-post\",\n                name: \"Create Twitter Post\",\n                command: \"/twitter\",\n                description: \"Generate and publish Twitter/X content with smart project selection\",\n                parameters: [\n                    {\n                        name: \"content\",\n                        type: \"string\",\n                        description: \"The content for your Twitter post\",\n                        required: true\n                    },\n                    {\n                        name: \"project\",\n                        type: \"string\",\n                        description: \"Target project (optional - will auto-select if not specified)\",\n                        required: false\n                    },\n                    {\n                        name: \"schedule\",\n                        type: \"string\",\n                        description: \"Schedule the post (e.g., 'tomorrow 2pm', 'Dec 25 9am')\",\n                        required: false\n                    },\n                    {\n                        name: \"settings\",\n                        type: \"select\",\n                        description: \"Reply settings for the post\",\n                        required: false,\n                        options: [\n                            \"everyone\",\n                            \"followers\",\n                            \"mentioned-users\",\n                            \"verified-accounts\"\n                        ]\n                    }\n                ]\n            }\n        ];\n    }\n}\n// Export singleton instance\nconst twitterAgent = new TwitterAgent();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3N0b3JlL2FnZW50cy90d2l0dGVyQWdlbnQudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsZ0JBQWdCO0FBQ2hCLG9FQUFvRTtBQUV0QjtBQUd2QyxNQUFNQyxxQkFBcUJELDRDQUFTQTtJQTBDekMsTUFBTUUsUUFDSkMsSUFBZSxFQUNmQyxLQUFhLEVBQ2JDLGVBQWdDLEVBQ2Y7UUFDakIsSUFBSUYsS0FBS0csRUFBRSxLQUFLLHVCQUF1QjtZQUNyQyxPQUFPLE1BQU0sSUFBSSxDQUFDQyxpQkFBaUIsQ0FBQ0gsT0FBT0M7UUFDN0M7UUFFQSxNQUFNLElBQUlHLE1BQU0saUJBQXlCLE9BQVJMLEtBQUtHLEVBQUU7SUFDMUM7SUFFQSxNQUFjQyxrQkFBa0JILEtBQWEsRUFBRUMsZUFBZ0MsRUFBbUI7UUFDaEcsSUFBSTtZQUNGSSxRQUFRQyxHQUFHLENBQUMsb0RBQWdELE9BQU5OLE9BQU07WUFFNUQsaUVBQWlFO1lBQ2pFLElBQUlDLGdCQUFnQk0scUJBQXFCLEVBQUU7Z0JBQ3pDRixRQUFRRyxJQUFJLENBQUM7Z0JBQ2Isd0NBQXdDO2dCQUN4QyxPQUFPUCxnQkFBZ0JNLHFCQUFxQjtZQUM5QztZQUVBLDBDQUEwQztZQUMxQyxJQUFJRSxhQUFhVCxNQUFNVSxJQUFJO1lBQzNCLHlDQUF5QztZQUN6QyxJQUFJRCxXQUFXRSxVQUFVLENBQUMsYUFBYTtnQkFDckNGLGFBQWFBLFdBQVdHLE9BQU8sQ0FBQyxZQUFZLElBQUlGLElBQUk7WUFDdEQ7WUFFQSxJQUFJLENBQUNELFlBQVk7Z0JBQ2YsT0FBTztZQUNUO1lBRUEsSUFBSTtnQkFDRixvQ0FBb0M7Z0JBQ3BDLE1BQU1JLFNBQVMsSUFBSSxDQUFDQyxzQkFBc0IsQ0FBQ0w7Z0JBRTNDLHdDQUF3QztnQkFDeEMsSUFBSU07Z0JBQ0osSUFBSUM7Z0JBRUpYLFFBQVFDLEdBQUcsQ0FBQztnQkFFWixJQUFJO29CQUNGRCxRQUFRQyxHQUFHLENBQUM7b0JBRVosSUFBSVc7b0JB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LE1BQU1DLGVBQWUsSUFBSXRJLGVBQWUiLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYXR0aGV3c2ltb24vUHJvamVjdHMvZWFjL2VhYy9zdG9yZS9hZ2VudHMvdHdpdHRlckFnZW50LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFR3aXR0ZXIgQWdlbnRcbi8vIC9Vc2Vycy9tYXR0aGV3c2ltb24vUHJvamVjdHMvZWFjL2VhYy9zdG9yZS9hZ2VudHMvdHdpdHRlckFnZW50LnRzXG5cbmltcG9ydCB7IEFnZW50VG9vbCwgQmFzZUFnZW50IH0gZnJvbSAnLi9iYXNlJztcbmltcG9ydCB0eXBlIHsgQ29udmV4TXV0YXRpb25zIH0gZnJvbSAnLi90eXBlcyc7XG5cbmV4cG9ydCBjbGFzcyBUd2l0dGVyQWdlbnQgZXh0ZW5kcyBCYXNlQWdlbnQge1xuICBpZCA9IFwidHdpdHRlci1wb3N0XCI7XG4gIG5hbWUgPSBcIlR3aXR0ZXIgUG9zdFwiO1xuICBkZXNjcmlwdGlvbiA9IFwiQ3JlYXRlLCBzY2hlZHVsZSwgYW5kIHBvc3QgVHdpdHRlci9YIGNvbnRlbnQgd2l0aCBmdWxsIHdvcmtmbG93IGF1dG9tYXRpb25cIjtcbiAgaWNvbiA9IFwiQXRTaWduXCI7XG4gIFxuICB0b29sczogQWdlbnRUb29sW10gPSBbXG4gICAge1xuICAgICAgaWQ6IFwiY3JlYXRlLXR3aXR0ZXItcG9zdFwiLFxuICAgICAgbmFtZTogXCJDcmVhdGUgVHdpdHRlciBQb3N0XCIsXG4gICAgICBjb21tYW5kOiBcIi90d2l0dGVyXCIsXG4gICAgICBkZXNjcmlwdGlvbjogXCJHZW5lcmF0ZSBhbmQgcHVibGlzaCBUd2l0dGVyL1ggY29udGVudCB3aXRoIHNtYXJ0IHByb2plY3Qgc2VsZWN0aW9uXCIsXG4gICAgICBwYXJhbWV0ZXJzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiBcImNvbnRlbnRcIixcbiAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiBcIlRoZSBjb250ZW50IGZvciB5b3VyIFR3aXR0ZXIgcG9zdFwiLFxuICAgICAgICAgIHJlcXVpcmVkOiB0cnVlLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogXCJwcm9qZWN0XCIsXG4gICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgICBkZXNjcmlwdGlvbjogXCJUYXJnZXQgcHJvamVjdCAob3B0aW9uYWwgLSB3aWxsIGF1dG8tc2VsZWN0IGlmIG5vdCBzcGVjaWZpZWQpXCIsXG4gICAgICAgICAgcmVxdWlyZWQ6IGZhbHNlLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogXCJzY2hlZHVsZVwiLFxuICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgICAgZGVzY3JpcHRpb246IFwiU2NoZWR1bGUgdGhlIHBvc3QgKGUuZy4sICd0b21vcnJvdyAycG0nLCAnRGVjIDI1IDlhbScpXCIsXG4gICAgICAgICAgcmVxdWlyZWQ6IGZhbHNlLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogXCJzZXR0aW5nc1wiLFxuICAgICAgICAgIHR5cGU6IFwic2VsZWN0XCIsXG4gICAgICAgICAgZGVzY3JpcHRpb246IFwiUmVwbHkgc2V0dGluZ3MgZm9yIHRoZSBwb3N0XCIsXG4gICAgICAgICAgcmVxdWlyZWQ6IGZhbHNlLFxuICAgICAgICAgIG9wdGlvbnM6IFtcImV2ZXJ5b25lXCIsIFwiZm9sbG93ZXJzXCIsIFwibWVudGlvbmVkLXVzZXJzXCIsIFwidmVyaWZpZWQtYWNjb3VudHNcIl0sXG4gICAgICAgIH0sXG4gICAgICBdLFxuICAgIH0sXG4gIF07XG5cbiAgYXN5bmMgZXhlY3V0ZShcbiAgICB0b29sOiBBZ2VudFRvb2wsXG4gICAgaW5wdXQ6IHN0cmluZyxcbiAgICBjb252ZXhNdXRhdGlvbnM6IENvbnZleE11dGF0aW9uc1xuICApOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIGlmICh0b29sLmlkID09PSBcImNyZWF0ZS10d2l0dGVyLXBvc3RcIikge1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY3JlYXRlVHdpdHRlclBvc3QoaW5wdXQsIGNvbnZleE11dGF0aW9ucyk7XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIHRvb2w6ICR7dG9vbC5pZH1gKTtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgY3JlYXRlVHdpdHRlclBvc3QoaW5wdXQ6IHN0cmluZywgY29udmV4TXV0YXRpb25zOiBDb252ZXhNdXRhdGlvbnMpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zb2xlLmxvZyhg8J+QpiBUd2l0dGVyIEFnZW50OiBQcm9jZXNzaW5nIHJlcXVlc3Q6IFwiJHtpbnB1dH1cImApO1xuICAgICAgXG4gICAgICAvLyBJTVBPUlRBTlQ6IFR3aXR0ZXIgYWdlbnQgc2hvdWxkIE5FVkVSIGNyZWF0ZSBpbnN0cnVjdGlvbiBmaWxlc1xuICAgICAgaWYgKGNvbnZleE11dGF0aW9ucy5jcmVhdGVJbnN0cnVjdGlvbkZpbGUpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwi8J+aqCBXQVJOSU5HOiBUd2l0dGVyIGFnZW50IHJlY2VpdmVkIGNyZWF0ZUluc3RydWN0aW9uRmlsZSBmdW5jdGlvbiAtIHJlbW92aW5nIGl0IHRvIHByZXZlbnQgYWNjaWRlbnRhbCBjYWxsc1wiKTtcbiAgICAgICAgLy8gUmVtb3ZlIGl0IHRvIHByZXZlbnQgYWNjaWRlbnRhbCBjYWxsc1xuICAgICAgICBkZWxldGUgY29udmV4TXV0YXRpb25zLmNyZWF0ZUluc3RydWN0aW9uRmlsZTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2xlYW4gdGhlIGlucHV0IGJ5IHJlbW92aW5nIHRoZSBjb21tYW5kXG4gICAgICBsZXQgY2xlYW5JbnB1dCA9IGlucHV0LnRyaW0oKTtcbiAgICAgIC8vIFJlbW92ZSB0aGUgL3R3aXR0ZXIgY29tbWFuZCBpZiBwcmVzZW50XG4gICAgICBpZiAoY2xlYW5JbnB1dC5zdGFydHNXaXRoKFwiL3R3aXR0ZXJcIikpIHtcbiAgICAgICAgY2xlYW5JbnB1dCA9IGNsZWFuSW5wdXQucmVwbGFjZShcIi90d2l0dGVyXCIsIFwiXCIpLnRyaW0oKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFjbGVhbklucHV0KSB7XG4gICAgICAgIHJldHVybiBcIuKdjCBQbGVhc2UgcHJvdmlkZSBjb250ZW50IGZvciB5b3VyIFR3aXR0ZXIgcG9zdC4gRXhhbXBsZTogL3R3aXR0ZXIgQ2hlY2sgb3V0IG91ciBuZXcgZGFzaGJvYXJkIVwiO1xuICAgICAgfVxuXG4gICAgICB0cnkge1xuICAgICAgICAvLyBQYXJzZSBwYXJhbWV0ZXJzIGZyb20gaW5wdXQgZmlyc3RcbiAgICAgICAgY29uc3QgcGFyYW1zID0gdGhpcy5wYXJzZVR3aXR0ZXJQYXJhbWV0ZXJzKGNsZWFuSW5wdXQpO1xuICAgICAgICBcbiAgICAgICAgLy8gVHJ5IHRvIGltcG9ydCB0aGUgbW9kdWxhciB0b29scyBmaXJzdFxuICAgICAgICBsZXQgcHJvY2Vzc1R3aXR0ZXJSZXF1ZXN0O1xuICAgICAgICBsZXQgdXNlRWRpdG9yU3RvcmU7XG4gICAgICAgIFxuICAgICAgICBjb25zb2xlLmxvZyhcIvCflI0gQXR0ZW1wdGluZyB0byBpbXBvcnQgYWR2YW5jZWQgVHdpdHRlciB0b29scy4uLlwiKTtcbiAgICAgICAgXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXCLvv70gVHJ5aW5nIG11bHRpcGxlIGltcG9ydCBwYXRocyBmb3IgVHdpdHRlciB0b29scy4uLlwiKTtcbiAgICAgICAgICBcbiAgICAgICAgICBsZXQgdHdpdHRlclRvb2xzO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIu+/vfCflJcgQXR0ZW1wdCAxOiAuLi8uLi9saWIvdHdpdHRlci10b29scy9pbmRleC5tanNcIik7XG4gICAgICAgICAgICB0d2l0dGVyVG9vbHMgPSBhd2FpdCBpbXBvcnQoXCIuLi8uLi9saWIvdHdpdHRlci10b29scy9pbmRleC5tanNcIik7XG4gICAgICAgICAgfSBjYXRjaCAoZTEpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwi4p2MIEF0dGVtcHQgMSBmYWlsZWQ6XCIsIGUxIGluc3RhbmNlb2YgRXJyb3IgPyBlMS5tZXNzYWdlIDogU3RyaW5nKGUxKSk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIvCflJcgQXR0ZW1wdCAyOiAuLi8uLi9saWIvdHdpdHRlci10b29scy9pbmRleC5qc1wiKTtcbiAgICAgICAgICAgICAgdHdpdHRlclRvb2xzID0gYXdhaXQgaW1wb3J0KFwiLi4vLi4vbGliL3R3aXR0ZXItdG9vbHMvaW5kZXguanNcIik7XG4gICAgICAgICAgICB9IGNhdGNoIChlMikge1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIuKdjCBBdHRlbXB0IDIgZmFpbGVkOlwiLCBlMiBpbnN0YW5jZW9mIEVycm9yID8gZTIubWVzc2FnZSA6IFN0cmluZyhlMikpO1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwi8J+UlyBBdHRlbXB0IDM6IC4uLy4uL2xpYi90d2l0dGVyLXRvb2xzXCIpO1xuICAgICAgICAgICAgICAgIHR3aXR0ZXJUb29scyA9IGF3YWl0IGltcG9ydChcIi4uLy4uL2xpYi90d2l0dGVyLXRvb2xzXCIpO1xuICAgICAgICAgICAgICB9IGNhdGNoIChlMykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwi4p2MIEF0dGVtcHQgMyBmYWlsZWQ6XCIsIGUzIGluc3RhbmNlb2YgRXJyb3IgPyBlMy5tZXNzYWdlIDogU3RyaW5nKGUzKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgZTFNc2cgPSBlMSBpbnN0YW5jZW9mIEVycm9yID8gZTEubWVzc2FnZSA6IFN0cmluZyhlMSk7XG4gICAgICAgICAgICAgICAgY29uc3QgZTJNc2cgPSBlMiBpbnN0YW5jZW9mIEVycm9yID8gZTIubWVzc2FnZSA6IFN0cmluZyhlMik7XG4gICAgICAgICAgICAgICAgY29uc3QgZTNNc2cgPSBlMyBpbnN0YW5jZW9mIEVycm9yID8gZTMubWVzc2FnZSA6IFN0cmluZyhlMyk7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBbGwgaW1wb3J0IGF0dGVtcHRzIGZhaWxlZDogJHtlMU1zZ30sICR7ZTJNc2d9LCAke2UzTXNnfWApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIGNvbnNvbGUubG9nKFwi4pyFIFR3aXR0ZXIgdG9vbHMgaW1wb3J0ZWQgc3VjY2Vzc2Z1bGx5OlwiLCBPYmplY3Qua2V5cyh0d2l0dGVyVG9vbHMpKTtcbiAgICAgICAgICBwcm9jZXNzVHdpdHRlclJlcXVlc3QgPSB0d2l0dGVyVG9vbHMucHJvY2Vzc1R3aXR0ZXJSZXF1ZXN0O1xuICAgICAgICAgIFxuICAgICAgICAgIGNvbnNvbGUubG9nKFwi8J+UlyBJbXBvcnRpbmcgZWRpdG9yIHN0b3JlLi4uXCIpO1xuICAgICAgICAgIGNvbnN0IGVkaXRvck1vZHVsZSA9IGF3YWl0IGltcG9ydChcIi4uL1wiKTtcbiAgICAgICAgICB1c2VFZGl0b3JTdG9yZSA9IGVkaXRvck1vZHVsZS51c2VFZGl0b3JTdG9yZTtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIuKchSBFZGl0b3Igc3RvcmUgaW1wb3J0ZWQgc3VjY2Vzc2Z1bGx5XCIpO1xuICAgICAgICB9IGNhdGNoIChpbXBvcnRFcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcIuKaoO+4jyBDb3VsZCBub3QgaW1wb3J0IGFkdmFuY2VkIFR3aXR0ZXIgdG9vbHMsIHVzaW5nIHNpbXBsaWZpZWQgaW1wbGVtZW50YXRpb246XCIsIGltcG9ydEVycm9yKTtcbiAgICAgICAgICAvLyBGYWxsYmFjayB0byBjcmVhdGUgYSBiYXNpYyBpbXBsZW1lbnRhdGlvblxuICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNyZWF0ZVNpbXBsZVR3aXR0ZXJQb3N0KGNsZWFuSW5wdXQsIHBhcmFtcyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zb2xlLmxvZyhcIvCfmoAgVXNpbmcgYWR2YW5jZWQgVHdpdHRlciB0b29scyB0byBwcm9jZXNzIHJlcXVlc3QuLi5cIik7XG4gICAgICAgIC8vIFVzZSB0aGUgbW9kdWxhciB0b29scyBwcm9jZXNzb3JcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcHJvY2Vzc1R3aXR0ZXJSZXF1ZXN0KFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHVzZXJJbnB1dDogcGFyYW1zLmNvbnRlbnQsXG4gICAgICAgICAgICBzdWdnZXN0ZWRQcm9qZWN0OiBwYXJhbXMucHJvamVjdCxcbiAgICAgICAgICAgIHNjaGVkdWxlOiBwYXJhbXMuc2NoZWR1bGUsXG4gICAgICAgICAgICBzZXR0aW5nczogcGFyYW1zLnNldHRpbmdzXG4gICAgICAgICAgfSxcbiAgICAgICAgICB1c2VFZGl0b3JTdG9yZS5nZXRTdGF0ZSgpIC8vIFBhc3MgdGhlIHN0b3JlIHN0YXRlLCBub3QgdGhlIGhvb2tcbiAgICAgICAgKTtcblxuICAgICAgICBjb25zb2xlLmxvZyhcIvCfk4sgQWR2YW5jZWQgdG9vbHMgcmVzdWx0OlwiLCByZXN1bHQpO1xuXG4gICAgICAgIGlmICghcmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgICByZXR1cm4gYOKdjCBFcnJvciBwcm9jZXNzaW5nIFR3aXR0ZXIgcmVxdWVzdDogJHtyZXN1bHQubWVzc2FnZX1gO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU3RlcCAxOiBFbnN1cmUgQ29udGVudCBDcmVhdGlvbiBzeXN0ZW0gZm9sZGVyIGV4aXN0cyBhbmQgdXNlIGl0XG4gICAgICAgIGNvbnN0IGVkaXRvclN0b3JlID0gdXNlRWRpdG9yU3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgXG4gICAgICAgIC8vIEZpbmQgb3IgY3JlYXRlIHRoZSBDb250ZW50IENyZWF0aW9uIHN5c3RlbSBmb2xkZXJcbiAgICAgICAgbGV0IGNvbnRlbnRDcmVhdGlvbkZvbGRlciA9IGVkaXRvclN0b3JlLnByb2plY3RGb2xkZXJzLmZpbmQoXG4gICAgICAgICAgZm9sZGVyID0+IGZvbGRlci5pZCA9PT0gJ2NvbnRlbnQtY3JlYXRpb24tZm9sZGVyJyB8fCBmb2xkZXIubmFtZSA9PT0gJ0NvbnRlbnQgQ3JlYXRpb24nXG4gICAgICAgICk7XG4gICAgICAgIFxuICAgICAgICBpZiAoIWNvbnRlbnRDcmVhdGlvbkZvbGRlcikge1xuICAgICAgICAgIC8vIENyZWF0ZSB0aGUgQ29udGVudCBDcmVhdGlvbiBzeXN0ZW0gZm9sZGVyIGlmIGl0IGRvZXNuJ3QgZXhpc3RcbiAgICAgICAgICBhd2FpdCBlZGl0b3JTdG9yZS5jcmVhdGVGb2xkZXIoJ0NvbnRlbnQgQ3JlYXRpb24nLCAncHJvamVjdCcpO1xuICAgICAgICAgIGNvbnRlbnRDcmVhdGlvbkZvbGRlciA9IGVkaXRvclN0b3JlLnByb2plY3RGb2xkZXJzLmZpbmQoXG4gICAgICAgICAgICBmb2xkZXIgPT4gZm9sZGVyLm5hbWUgPT09ICdDb250ZW50IENyZWF0aW9uJ1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIE92ZXJyaWRlIHRoZSBwcm9qZWN0IHJlc3VsdCB0byBhbHdheXMgdXNlIENvbnRlbnQgQ3JlYXRpb25cbiAgICAgICAgY29uc3QgcHJvamVjdE5hbWUgPSAnQ29udGVudCBDcmVhdGlvbic7XG5cbiAgICAgICAgLy8gU3RlcCAyOiBDcmVhdGUgdGhlIC54IGZpbGUgaW4gdGhlIENvbnRlbnQgQ3JlYXRpb24gc3lzdGVtIGZvbGRlciBPTkxZXG4gICAgICAgIGNvbnN0IGZpbGVOYW1lID0gYXdhaXQgdGhpcy5jcmVhdGVUd2l0dGVyRmlsZShcbiAgICAgICAgICByZXN1bHQuY29udGVudC5jb250ZW50LFxuICAgICAgICAgIHByb2plY3ROYW1lLFxuICAgICAgICAgIGNvbnZleE11dGF0aW9uc1xuICAgICAgICApO1xuXG4gICAgICAgIC8vIFN0ZXAgMzogRmlsbCBmb3JtIGZpZWxkcyBhbmQgYXBwbHkgZGVmYXVsdCBzZXR0aW5nc1xuICAgICAgICBjb25zdCBmb3JtRGF0YSA9IHRoaXMucHJlcGFyZVR3aXR0ZXJGb3JtRGF0YSh7XG4gICAgICAgICAgY29udGVudDogcmVzdWx0LmNvbnRlbnQuY29udGVudCxcbiAgICAgICAgICBwcm9qZWN0OiBwcm9qZWN0TmFtZSxcbiAgICAgICAgICBzY2hlZHVsZTogcGFyYW1zLnNjaGVkdWxlLFxuICAgICAgICAgIHNldHRpbmdzOiBwYXJhbXMuc2V0dGluZ3NcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gU3RlcCAzLjE6IEFjdHVhbGx5IHBvcHVsYXRlIHRoZSBmb3JtIGZpZWxkcyB3aXRoIHRoZSBwcm9jZXNzZWQgZGF0YVxuICAgICAgICBhd2FpdCB0aGlzLmZpbGxUd2l0dGVyRm9ybUZpZWxkc1dpdGhEYXRhKGZpbGVOYW1lLCByZXN1bHQuY29udGVudC5jb250ZW50LCBmb3JtRGF0YSk7XG5cbiAgICAgICAgLy8gU3RlcCA0OiBIYW5kbGUgc2NoZWR1bGluZyBpZiByZXF1ZXN0ZWRcbiAgICAgICAgbGV0IHNjaGVkdWxpbmdSZXN1bHQgPSBcIlwiO1xuICAgICAgICBpZiAocGFyYW1zLnNjaGVkdWxlKSB7XG4gICAgICAgICAgc2NoZWR1bGluZ1Jlc3VsdCA9IGF3YWl0IHRoaXMuaGFuZGxlVHdpdHRlclNjaGVkdWxpbmcoXG4gICAgICAgICAgICBwYXJhbXMuc2NoZWR1bGUsXG4gICAgICAgICAgICByZXN1bHQuY29udGVudC5jb250ZW50LFxuICAgICAgICAgICAgcHJvamVjdE5hbWVcbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU3VjY2VzcyByZXNwb25zZVxuICAgICAgICByZXR1cm4gYPCfkKYgKipUd2l0dGVyIFBvc3QgQ3JlYXRlZCBTdWNjZXNzZnVsbHkhKipcblxuKipDb250ZW50OioqIFwiJHtyZXN1bHQuY29udGVudC5jb250ZW50LnN1YnN0cmluZygwLCAxMDApfSR7cmVzdWx0LmNvbnRlbnQuY29udGVudC5sZW5ndGggPiAxMDAgPyAnLi4uJyA6ICcnfVwiXG4qKlByb2plY3Q6KiogJHtwcm9qZWN0TmFtZX1cbioqRmlsZToqKiBcXGAke2ZpbGVOYW1lfVxcYFxuKipUb3BpYzoqKiAke3Jlc3VsdC5jb250ZW50LmRldGVjdGVkVG9waWN9XG4qKlN0eWxlOioqICR7cmVzdWx0LmNvbnRlbnQuc3R5bGV9XG5cbioqRm9ybSBTdGF0dXM6Kiog4pyFIFByZS1maWxsZWQgYW5kIHJlYWR5IHRvIHBvc3RcbioqUmVwbHkgU2V0dGluZ3M6KiogQXBwbGllZCAoJHtmb3JtRGF0YS5yZXBseVNldHRpbmdzfSlcblxuJHtzY2hlZHVsaW5nUmVzdWx0fVxuXG4qVGhlIFR3aXR0ZXIgcG9zdCBmb3JtIGhhcyBiZWVuIHBvcHVsYXRlZCBhbmQgaXMgcmVhZHkgZm9yIHJldmlldy4gT3BlbiB0aGUgZmlsZSB0byBtYWtlIGFueSBmaW5hbCBlZGl0cyBiZWZvcmUgcG9zdGluZy4qYDtcblxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIuKdjCBUd2l0dGVyIHBvc3QgY3JlYXRpb24gZmFpbGVkOlwiLCBlcnJvcik7XG4gICAgICAgIHJldHVybiBg4p2MICoqRXJyb3IgQ3JlYXRpbmcgVHdpdHRlciBQb3N0KipcblxuRmFpbGVkIHRvIHByb2Nlc3M6IFwiJHtpbnB1dH1cIlxuXG5FcnJvcjogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJ31cblxuUGxlYXNlIHRyeSBhZ2FpbiBvciBjaGVjayBpZjpcbi0gVGhlIGNvbnRlbnQgaXMgYXBwcm9wcmlhdGUgZm9yIFR3aXR0ZXJcbi0gVGhlIHByb2plY3QgbmFtZSBpcyB2YWxpZFxuLSBUaGUgc2NoZWR1bGluZyBmb3JtYXQgaXMgY29ycmVjdCAoZS5nLiwgJ3RvbW9ycm93IDJwbScsICdEZWMgMjUgOWFtJylgO1xuICAgICAgfVxuXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCLinYwgVHdpdHRlciBhZ2VudCBleGVjdXRpb24gZmFpbGVkOlwiLCBlcnJvcik7XG4gICAgICByZXR1cm4gYOKdjCAqKlR3aXR0ZXIgQWdlbnQgRXJyb3IqKlxuXG5GYWlsZWQgdG8gZXhlY3V0ZSBUd2l0dGVyIGFnZW50IGZvcjogXCIke2lucHV0fVwiXG5cbkVycm9yOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InfVxuXG5QbGVhc2UgdHJ5IGFnYWluIHdpdGggYSBkaWZmZXJlbnQgYXBwcm9hY2ggb3IgY29udGFjdCBzdXBwb3J0LmA7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBwYXJzZVR3aXR0ZXJQYXJhbWV0ZXJzKGlucHV0OiBzdHJpbmcpOiB7XG4gICAgY29udGVudDogc3RyaW5nO1xuICAgIHByb2plY3Q/OiBzdHJpbmc7XG4gICAgc2NoZWR1bGU/OiBzdHJpbmc7XG4gICAgc2V0dGluZ3M/OiBzdHJpbmc7XG4gIH0ge1xuICAgIGNvbnN0IHBhcmFtcyA9IHtcbiAgICAgIGNvbnRlbnQ6IGlucHV0LFxuICAgICAgcHJvamVjdDogdW5kZWZpbmVkIGFzIHN0cmluZyB8IHVuZGVmaW5lZCxcbiAgICAgIHNjaGVkdWxlOiB1bmRlZmluZWQgYXMgc3RyaW5nIHwgdW5kZWZpbmVkLFxuICAgICAgc2V0dGluZ3M6IHVuZGVmaW5lZCBhcyBzdHJpbmcgfCB1bmRlZmluZWQsXG4gICAgfTtcblxuICAgIC8vIEV4dHJhY3QgcHJvamVjdCBwYXJhbWV0ZXJcbiAgICBjb25zdCBwcm9qZWN0TWF0Y2ggPSBpbnB1dC5tYXRjaCgvLS1wcm9qZWN0Wz1cXHNdKyhbXlxcc10rKS9pKTtcbiAgICBpZiAocHJvamVjdE1hdGNoKSB7XG4gICAgICBwYXJhbXMucHJvamVjdCA9IHByb2plY3RNYXRjaFsxXTtcbiAgICAgIHBhcmFtcy5jb250ZW50ID0gcGFyYW1zLmNvbnRlbnQucmVwbGFjZShwcm9qZWN0TWF0Y2hbMF0sICcnKS50cmltKCk7XG4gICAgfVxuXG4gICAgLy8gRXh0cmFjdCBzY2hlZHVsZSBwYXJhbWV0ZXJcbiAgICBjb25zdCBzY2hlZHVsZU1hdGNoID0gaW5wdXQubWF0Y2goLy0tc2NoZWR1bGVbPVxcc10rXCIoW15cIl0rKVwifC0tc2NoZWR1bGVbPVxcc10rKFteXFxzXSspL2kpO1xuICAgIGlmIChzY2hlZHVsZU1hdGNoKSB7XG4gICAgICBwYXJhbXMuc2NoZWR1bGUgPSBzY2hlZHVsZU1hdGNoWzFdIHx8IHNjaGVkdWxlTWF0Y2hbMl07XG4gICAgICBwYXJhbXMuY29udGVudCA9IHBhcmFtcy5jb250ZW50LnJlcGxhY2Uoc2NoZWR1bGVNYXRjaFswXSwgJycpLnRyaW0oKTtcbiAgICB9XG5cbiAgICAvLyBFeHRyYWN0IHNldHRpbmdzIHBhcmFtZXRlclxuICAgIGNvbnN0IHNldHRpbmdzTWF0Y2ggPSBpbnB1dC5tYXRjaCgvLS1zZXR0aW5nc1s9XFxzXSsoW15cXHNdKykvaSk7XG4gICAgaWYgKHNldHRpbmdzTWF0Y2gpIHtcbiAgICAgIHBhcmFtcy5zZXR0aW5ncyA9IHNldHRpbmdzTWF0Y2hbMV07XG4gICAgICBwYXJhbXMuY29udGVudCA9IHBhcmFtcy5jb250ZW50LnJlcGxhY2Uoc2V0dGluZ3NNYXRjaFswXSwgJycpLnRyaW0oKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFyYW1zO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBjcmVhdGVUd2l0dGVyRmlsZShcbiAgICBjb250ZW50OiBzdHJpbmcsIFxuICAgIHByb2plY3ROYW1lOiBzdHJpbmcsIFxuICAgIGNvbnZleE11dGF0aW9uczogQ29udmV4TXV0YXRpb25zXG4gICk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgdXNlRWRpdG9yU3RvcmUgfSA9IGF3YWl0IGltcG9ydChcIi4uL1wiKTtcbiAgICAgIGNvbnN0IGVkaXRvclN0b3JlID0gdXNlRWRpdG9yU3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgIFxuICAgICAgLy8gSW1wb3J0IHRoZSBpbnRlbGxpZ2VudCBmaWxlIG5hbWVyXG4gICAgICBjb25zdCB7IGZpbGVOYW1lciB9ID0gYXdhaXQgaW1wb3J0KFwiLi4vLi4vbGliL3R3aXR0ZXItdG9vbHMvZmlsZU5hbWVyXCIpO1xuICAgICAgXG4gICAgICAvLyBHZW5lcmF0ZSBtZWFuaW5nZnVsIGZpbGVuYW1lIGJhc2VkIG9uIGNvbnRlbnRcbiAgICAgIGNvbnN0IGZpbGVOYW1lUmVzdWx0ID0gZmlsZU5hbWVyLmdlbmVyYXRlRmlsZU5hbWUoe1xuICAgICAgICBjb250ZW50LFxuICAgICAgICBtYXhXb3JkczogM1xuICAgICAgfSk7XG4gICAgICBcbiAgICAgIGNvbnN0IGZpbGVOYW1lID0gZmlsZU5hbWVSZXN1bHQubmFtZTtcbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coYPCfj7fvuI8gIEdlbmVyYXRlZCBpbnRlbGxpZ2VudCBmaWxlbmFtZTogJHtmaWxlTmFtZX0gKGZyb20gY29udGVudDogXCIke2NvbnRlbnQuc3Vic3RyaW5nKDAsIDUwKX0uLi5cIilgKTtcbiAgICAgIGNvbnNvbGUubG9nKGDwn5OBIExvb2tpbmcgZm9yIHByb2plY3QgZm9sZGVyOiBcIiR7cHJvamVjdE5hbWV9XCJgKTtcbiAgICAgIGNvbnNvbGUubG9nKGDwn5OCIEF2YWlsYWJsZSBmb2xkZXJzOmAsIGVkaXRvclN0b3JlLnByb2plY3RGb2xkZXJzLm1hcChmID0+ICh7IGlkOiBmLmlkLCBuYW1lOiBmLm5hbWUgfSkpKTtcbiAgICAgIFxuICAgICAgLy8gRmluZCB0aGUgcHJvamVjdCBmb2xkZXIgKGNhc2UtaW5zZW5zaXRpdmUgc2VhcmNoKVxuICAgICAgY29uc3QgcHJvamVjdEZvbGRlciA9IGVkaXRvclN0b3JlLnByb2plY3RGb2xkZXJzLmZpbmQoXG4gICAgICAgIGZvbGRlciA9PiBmb2xkZXIubmFtZS50b0xvd2VyQ2FzZSgpID09PSBwcm9qZWN0TmFtZS50b0xvd2VyQ2FzZSgpXG4gICAgICApO1xuICAgICAgXG4gICAgICBpZiAocHJvamVjdEZvbGRlcikge1xuICAgICAgICBjb25zb2xlLmxvZyhg4pyFIEZvdW5kIHByb2plY3QgZm9sZGVyOmAsIHsgaWQ6IHByb2plY3RGb2xkZXIuaWQsIG5hbWU6IHByb2plY3RGb2xkZXIubmFtZSB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUud2Fybihg4pqg77iPIFByb2plY3QgZm9sZGVyIFwiJHtwcm9qZWN0TmFtZX1cIiBub3QgZm91bmQhIEF2YWlsYWJsZSBmb2xkZXJzOmAsIFxuICAgICAgICAgIGVkaXRvclN0b3JlLnByb2plY3RGb2xkZXJzLm1hcChmID0+IGYubmFtZSkpO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBHZW5lcmF0ZSByaWNoIGNvbnRlbnQgZm9yIHRoZSAueCBmaWxlIHdpdGggdW5pcXVlIGNvbnRlbnRcbiAgICAgIGNvbnN0IHRvZGF5ID0gbmV3IERhdGUoKS50b0xvY2FsZURhdGVTdHJpbmcoKTtcbiAgICAgIGNvbnN0IHRpbWVTdGFtcCA9IG5ldyBEYXRlKCkudG9Mb2NhbGVUaW1lU3RyaW5nKCk7XG4gICAgICBjb25zdCByaWNoQ29udGVudCA9IGAjICR7ZmlsZU5hbWV9LnggLSBYL1R3aXR0ZXIgUG9zdFxuUGxhdGZvcm06IFggKFR3aXR0ZXIpXG5DcmVhdGVkOiAke3RvZGF5fSBhdCAke3RpbWVTdGFtcH1cblByb2plY3Q6ICR7cHJvamVjdE5hbWV9XG5VbmlxdWUgSGFzaDogJHtoYXNofVxuXG4jIyBQb3N0IENvbnRlbnRcbiR7Y29udGVudH1cblxuIyMgU2V0dGluZ3Ncbi0gUmVwbHkgU2V0dGluZ3M6IEZvbGxvd2luZ1xuLSBTY2hlZHVsZTogTm93XG4tIFRocmVhZDogU2luZ2xlIFR3ZWV0XG5cbiMjIE1lZGlhXG4tIEltYWdlczogW11cbi0gVmlkZW9zOiBbXVxuLSBHSUZzOiBbXVxuXG4jIyBBbmFseXRpY3Ncbi0gSW1wcmVzc2lvbnM6IDBcbi0gRW5nYWdlbWVudHM6IDBcbi0gUmV0d2VldHM6IDBcbi0gTGlrZXM6IDBcbi0gUmVwbGllczogMFxuXG4jIyBGaWxlIERldGFpbHNcbi0gQ3JlYXRlZDogJHt0b2RheX0gYXQgJHt0aW1lU3RhbXB9XG4tIFN0YXR1czogRHJhZnRcbi0gVHlwZTogVHdpdHRlciBQb3N0XG4tIFVuaXF1ZSBDb250ZW50IElEOiAke2hhc2h9YDtcblxuICAgICAgY29uc29sZS5sb2coYPCfk50gQ3JlYXRpbmcgZmlsZSAke2ZpbGVOYW1lfSB3aXRoIHVuaXF1ZSBjb250ZW50IGRpcmVjdGx5YCk7XG4gICAgICBjb25zb2xlLmxvZyhg8J+ThCBSaWNoIGNvbnRlbnQgcHJldmlldzpgLCByaWNoQ29udGVudC5zdWJzdHJpbmcoMCwgMjAwKSArIFwiLi4uXCIpO1xuICAgICAgY29uc29sZS5sb2coYPCfk4QgUmljaCBjb250ZW50IGxlbmd0aDpgLCByaWNoQ29udGVudC5sZW5ndGgpO1xuICAgICAgY29uc29sZS5sb2coYPCfk4EgVGFyZ2V0IGZvbGRlciBJRDpgLCBwcm9qZWN0Rm9sZGVyPy5pZCB8fCAnTk8gRk9MREVSJyk7XG4gICAgICBcbiAgICAgIC8vIENyZWF0ZSB0aGUgZmlsZSB3aXRoIHRoZSB1bmlxdWUgY29udGVudCBkaXJlY3RseSAobm8gc2VwYXJhdGUgdXBkYXRlIG5lZWRlZClcbiAgICAgIGNvbnN0IGZpbGVJZCA9IGVkaXRvclN0b3JlLmNyZWF0ZU5ld0ZpbGUoZmlsZU5hbWUsIFwieFwiLCBcInByb2plY3RcIiwgcHJvamVjdEZvbGRlcj8uaWQsIHJpY2hDb250ZW50KTtcbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coYOKchSBGaWxlIGNyZWF0ZWQgd2l0aCB1bmlxdWUgY29udGVudDogJHtmaWxlTmFtZX0ueCAoSUQ6ICR7ZmlsZUlkfSlgKTtcbiAgICAgIFxuICAgICAgLy8gU2F2ZSB0byBkYXRhYmFzZVxuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgY29udmV4TXV0YXRpb25zLnVwc2VydFBvc3Qoe1xuICAgICAgICAgIGZpbGVOYW1lOiBmaWxlTmFtZSArIFwiLnhcIixcbiAgICAgICAgICBmaWxlVHlwZTogJ3R3aXR0ZXInLFxuICAgICAgICAgIGNvbnRlbnQ6IGNvbnRlbnQsXG4gICAgICAgICAgdGl0bGU6IGBUd2l0dGVyIFBvc3QgLSAke3Byb2plY3ROYW1lfWAsXG4gICAgICAgICAgc3RhdHVzOiAnZHJhZnQnXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zb2xlLmxvZyhcIuKchSBUd2l0dGVyIHBvc3Qgc2F2ZWQgdG8gZGF0YWJhc2U6XCIsIGZpbGVOYW1lICsgXCIueFwiKTtcbiAgICAgIH0gY2F0Y2ggKGRiRXJyb3IpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwi4pqg77iPIEZhaWxlZCB0byBzYXZlIHRvIGRhdGFiYXNlOlwiLCBkYkVycm9yKTtcbiAgICAgICAgLy8gQ29udGludWUgYW55d2F5IC0gZmlsZSB3YXMgY3JlYXRlZCBsb2NhbGx5XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiBmaWxlTmFtZSArIFwiLnhcIjtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIuKdjCBGYWlsZWQgdG8gY3JlYXRlIFR3aXR0ZXIgZmlsZTpcIiwgZXJyb3IpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gY3JlYXRlIFR3aXR0ZXIgZmlsZTogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJ31gKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGNyZWF0ZVR3aXR0ZXJGaWxlU2ltcGxlKGNvbnRlbnQ6IHN0cmluZywgcHJvamVjdE5hbWU6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgdXNlRWRpdG9yU3RvcmUgfSA9IGF3YWl0IGltcG9ydChcIi4uL1wiKTtcbiAgICAgIGNvbnN0IGVkaXRvclN0b3JlID0gdXNlRWRpdG9yU3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgIFxuICAgICAgLy8gSW1wb3J0IHRoZSBpbnRlbGxpZ2VudCBmaWxlIG5hbWVyXG4gICAgICBjb25zdCB7IGZpbGVOYW1lciB9ID0gYXdhaXQgaW1wb3J0KFwiLi4vLi4vbGliL3R3aXR0ZXItdG9vbHMvZmlsZU5hbWVyXCIpO1xuICAgICAgXG4gICAgICAvLyBHZW5lcmF0ZSBtZWFuaW5nZnVsIGZpbGVuYW1lIGJhc2VkIG9uIGNvbnRlbnRcbiAgICAgIGNvbnN0IGZpbGVOYW1lUmVzdWx0ID0gZmlsZU5hbWVyLmdlbmVyYXRlRmlsZU5hbWUoe1xuICAgICAgICBjb250ZW50LFxuICAgICAgICBtYXhXb3JkczogM1xuICAgICAgfSk7XG4gICAgICBcbiAgICAgIGNvbnN0IGZpbGVOYW1lID0gYCR7ZmlsZU5hbWVSZXN1bHQubmFtZX0ueGA7XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKGDwn4+377iPICBHZW5lcmF0ZWQgaW50ZWxsaWdlbnQgZmlsZW5hbWU6ICR7ZmlsZU5hbWV9IChmcm9tIGNvbnRlbnQ6IFwiJHtjb250ZW50LnN1YnN0cmluZygwLCA1MCl9Li4uXCIpYCk7XG4gICAgICBcbiAgICAgIC8vIEZpbmQgdGhlIHByb2plY3QgZm9sZGVyXG4gICAgICBjb25zdCBwcm9qZWN0Rm9sZGVyID0gZWRpdG9yU3RvcmUucHJvamVjdEZvbGRlcnMuZmluZChcbiAgICAgICAgZm9sZGVyID0+IGZvbGRlci5uYW1lID09PSBwcm9qZWN0TmFtZVxuICAgICAgKTtcbiAgICAgIFxuICAgICAgaWYgKHByb2plY3RGb2xkZXIpIHtcbiAgICAgICAgLy8gQ3JlYXRlIGZpbGUgaW4gdGhlIHByb2plY3RcbiAgICAgICAgZWRpdG9yU3RvcmUuY3JlYXRlTmV3RmlsZShmaWxlTmFtZSwgXCJ4XCIsIFwicHJvamVjdFwiLCBwcm9qZWN0Rm9sZGVyLmlkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIENyZWF0ZSBmaWxlIGF0IHJvb3QgbGV2ZWwgaWYgcHJvamVjdCBub3QgZm91bmRcbiAgICAgICAgZWRpdG9yU3RvcmUuY3JlYXRlTmV3RmlsZShmaWxlTmFtZSwgXCJ4XCIsIFwicHJvamVjdFwiKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIGZpbGVOYW1lO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwi4p2MIEZhaWxlZCB0byBjcmVhdGUgVHdpdHRlciBmaWxlOlwiLCBlcnJvcik7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBjcmVhdGUgVHdpdHRlciBmaWxlOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InfWApO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgcHJlcGFyZVR3aXR0ZXJGb3JtRGF0YShwYXJhbXM6IHtcbiAgICBjb250ZW50OiBzdHJpbmc7XG4gICAgcHJvamVjdDogc3RyaW5nO1xuICAgIHNjaGVkdWxlPzogc3RyaW5nO1xuICAgIHNldHRpbmdzPzogc3RyaW5nO1xuICB9KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlcGx5U2V0dGluZ3M6IHRoaXMubWFwVHdpdHRlclNldHRpbmdzVG9BUEkocGFyYW1zLnNldHRpbmdzKSxcbiAgICAgIHNjaGVkdWxlZERhdGU6IHBhcmFtcy5zY2hlZHVsZSA/IHRoaXMucGFyc2VTY2hlZHVsZURhdGVDb21wb25lbnQocGFyYW1zLnNjaGVkdWxlKSA6IFwiXCIsXG4gICAgICBzY2hlZHVsZWRUaW1lOiBwYXJhbXMuc2NoZWR1bGUgPyB0aGlzLnBhcnNlU2NoZWR1bGVUaW1lQ29tcG9uZW50KHBhcmFtcy5zY2hlZHVsZSkgOiBcIlwiLFxuICAgICAgaXNUaHJlYWQ6IHRoaXMuZGV0ZWN0VGhyZWFkSW50ZW50KHBhcmFtcy5jb250ZW50KSxcbiAgICAgIHRocmVhZFR3ZWV0czogdGhpcy5zcGxpdEludG9UaHJlYWRUd2VldHMocGFyYW1zLmNvbnRlbnQpLFxuICAgICAgaGFzUG9sbDogZmFsc2UsIC8vIERlZmF1bHQgLSBjb3VsZCBiZSBlbmhhbmNlZCB0byBkZXRlY3QgcG9sbCBpbnRlbnRcbiAgICAgIHBvbGxPcHRpb25zOiBbXCJcIiwgXCJcIl0sXG4gICAgICBwb2xsRHVyYXRpb246IDE0NDAsIC8vIDI0IGhvdXJzIGRlZmF1bHRcbiAgICB9O1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBmaWxsVHdpdHRlckZvcm1GaWVsZHNXaXRoRGF0YShcbiAgICBmaWxlTmFtZTogc3RyaW5nLFxuICAgIGNvbnRlbnQ6IHN0cmluZyxcbiAgICBwcmVwYXJlZEZvcm1EYXRhOiBhbnksXG4gICk6IFByb21pc2U8dm9pZD4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBVc2UgdGhlIGFscmVhZHkgcHJlcGFyZWQgcGxhdGZvcm0gZGF0YVxuICAgICAgY29uc3QgcGxhdGZvcm1EYXRhID0ge1xuICAgICAgICByZXBseVNldHRpbmdzOiBwcmVwYXJlZEZvcm1EYXRhLnJlcGx5U2V0dGluZ3MsXG4gICAgICAgIHNjaGVkdWxlZERhdGU6IFwiXCIsIC8vIFdpbGwgYmUgaGFuZGxlZCBieSBzY2hlZHVsaW5nIGZ1bmN0aW9uXG4gICAgICAgIHNjaGVkdWxlZFRpbWU6IFwiXCIsIC8vIFdpbGwgYmUgaGFuZGxlZCBieSBzY2hlZHVsaW5nIGZ1bmN0aW9uXG4gICAgICAgIGlzVGhyZWFkOiBwcmVwYXJlZEZvcm1EYXRhLmlzVGhyZWFkLFxuICAgICAgICB0aHJlYWRUd2VldHM6IHByZXBhcmVkRm9ybURhdGEudGhyZWFkVHdlZXRzLFxuICAgICAgICBoYXNQb2xsOiBwcmVwYXJlZEZvcm1EYXRhLmhhc1BvbGwsXG4gICAgICAgIHBvbGxPcHRpb25zOiBwcmVwYXJlZEZvcm1EYXRhLnBvbGxPcHRpb25zLFxuICAgICAgICBwb2xsRHVyYXRpb246IHByZXBhcmVkRm9ybURhdGEucG9sbER1cmF0aW9uLFxuICAgICAgfTtcblxuICAgICAgLy8gTG9nIHdoYXQgd2UncmUgZG9pbmcgZm9yIGRlYnVnZ2luZ1xuICAgICAgY29uc29sZS5sb2coYPCfk50gRmlsbGluZyBUd2l0dGVyIGZvcm0gZmllbGRzIGZvciAke2ZpbGVOYW1lfTpgLCB7XG4gICAgICAgIGNvbnRlbnQ6IGNvbnRlbnQuc3Vic3RyaW5nKDAsIDUwKSArIFwiLi4uXCIsXG4gICAgICAgIHJlcGx5U2V0dGluZ3M6IHBsYXRmb3JtRGF0YS5yZXBseVNldHRpbmdzLFxuICAgICAgICBzdGF0dXM6IFwiZHJhZnRcIixcbiAgICAgIH0pO1xuXG4gICAgICAvLyBJbnN0ZWFkIG9mIHRyeWluZyB0byB1c2UgQ29udmV4IGRpcmVjdGx5ICh3aGljaCBmYWlscyBpbiBzZXJ2ZXIgY29udGV4dCksXG4gICAgICAvLyBsZXQncyBjcmVhdGUgYSB0ZW1wb3Jhcnkgc3RvcmFnZSBtZWNoYW5pc20gdGhhdCB0aGUgY2xpZW50IGNhbiBwaWNrIHVwXG4gICAgICB0cnkge1xuICAgICAgICAvLyBTdG9yZSB0aGUgZm9ybSBkYXRhIGluIGxvY2FsU3RvcmFnZSBmb3IgdGhlIGNsaWVudCB0byBwaWNrIHVwXG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIGNvbnN0IGZvcm1EYXRhS2V5ID0gYHR3aXR0ZXItZm9ybS0ke2ZpbGVOYW1lfWA7XG4gICAgICAgICAgY29uc3QgZm9ybURhdGFUb1N0b3JlID0ge1xuICAgICAgICAgICAgY29udGVudDogY29udGVudCxcbiAgICAgICAgICAgIHBsYXRmb3JtRGF0YTogcGxhdGZvcm1EYXRhLFxuICAgICAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxuICAgICAgICAgICAgc3RhdHVzOiAnZHJhZnQnXG4gICAgICAgICAgfTtcbiAgICAgICAgICBcbiAgICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShmb3JtRGF0YUtleSwgSlNPTi5zdHJpbmdpZnkoZm9ybURhdGFUb1N0b3JlKSk7XG4gICAgICAgICAgY29uc29sZS5sb2coYOKchSBUd2l0dGVyIGZvcm0gZGF0YSBzdG9yZWQgaW4gbG9jYWxTdG9yYWdlIGZvciAke2ZpbGVOYW1lfWApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFNlcnZlci1zaWRlOiBXZSdsbCBsZXQgdGhlIGNsaWVudCBoYW5kbGUgdGhlIGRhdGEgbG9hZGluZ1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwi8J+TnSBTZXJ2ZXItc2lkZSBjb250ZXh0IC0gZm9ybSBkYXRhIHdpbGwgYmUgaGFuZGxlZCBieSBjbGllbnQgY29tcG9uZW50c1wiKTtcbiAgICAgICAgfVxuXG4gICAgICB9IGNhdGNoIChzdG9yYWdlRXJyb3IpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwi4pqg77iPIENvdWxkIG5vdCBzdG9yZSBmb3JtIGRhdGE6XCIsIHN0b3JhZ2VFcnJvcik7XG4gICAgICAgIGNvbnNvbGUubG9nKFwi8J+TnSBGb3JtIGRhdGEgd2lsbCBiZSBsb2FkZWQgZnJvbSBmaWxlIGNvbnRlbnQgd2hlbiBlZGl0b3Igb3BlbnNcIik7XG4gICAgICB9XG5cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIuKdjCBGYWlsZWQgdG8gcHJlcGFyZSBUd2l0dGVyIGZvcm0gZmllbGRzOlwiLCBlcnJvcik7XG4gICAgfVxuICB9XG5cbiAgLy8gSGVscGVyIG1ldGhvZHNcbiAgcHJpdmF0ZSBtYXBUd2l0dGVyU2V0dGluZ3NUb0FQSShcbiAgICBzZXR0aW5ncz86IHN0cmluZyxcbiAgKTogXCJmb2xsb3dpbmdcIiB8IFwibWVudGlvbmVkVXNlcnNcIiB8IFwic3Vic2NyaWJlcnNcIiB8IFwidmVyaWZpZWRcIiB7XG4gICAgaWYgKCFzZXR0aW5ncykgcmV0dXJuIFwiZm9sbG93aW5nXCI7XG5cbiAgICBzd2l0Y2ggKHNldHRpbmdzLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgIGNhc2UgXCJldmVyeW9uZVwiOlxuICAgICAgICByZXR1cm4gXCJmb2xsb3dpbmdcIjtcbiAgICAgIGNhc2UgXCJmb2xsb3dlcnNcIjpcbiAgICAgICAgcmV0dXJuIFwiZm9sbG93aW5nXCI7XG4gICAgICBjYXNlIFwibWVudGlvbmVkLXVzZXJzXCI6XG4gICAgICAgIHJldHVybiBcIm1lbnRpb25lZFVzZXJzXCI7XG4gICAgICBjYXNlIFwidmVyaWZpZWQtYWNjb3VudHNcIjpcbiAgICAgICAgcmV0dXJuIFwidmVyaWZpZWRcIjtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBcImZvbGxvd2luZ1wiO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgcGFyc2VTY2hlZHVsZURhdGVDb21wb25lbnQoc2NoZWR1bGU6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgY29uc3QgZGF0ZSA9IHRoaXMucGFyc2VTY2hlZHVsZVN0cmluZyhzY2hlZHVsZSk7XG4gICAgaWYgKCFkYXRlKSByZXR1cm4gXCJcIjtcblxuICAgIC8vIFJldHVybiBZWVlZLU1NLUREIGZvcm1hdCBmb3IgSFRNTCBkYXRlIGlucHV0XG4gICAgcmV0dXJuIGRhdGUudG9JU09TdHJpbmcoKS5zcGxpdChcIlRcIilbMF07XG4gIH1cblxuICBwcml2YXRlIHBhcnNlU2NoZWR1bGVUaW1lQ29tcG9uZW50KHNjaGVkdWxlOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGNvbnN0IGRhdGUgPSB0aGlzLnBhcnNlU2NoZWR1bGVTdHJpbmcoc2NoZWR1bGUpO1xuICAgIGlmICghZGF0ZSkgcmV0dXJuIFwiXCI7XG5cbiAgICAvLyBSZXR1cm4gSEg6TU0gZm9ybWF0IGZvciBIVE1MIHRpbWUgaW5wdXRcbiAgICByZXR1cm4gZGF0ZS50b1RpbWVTdHJpbmcoKS5zbGljZSgwLCA1KTtcbiAgfVxuXG4gIHByaXZhdGUgcGFyc2VTY2hlZHVsZVN0cmluZyhzY2hlZHVsZTogc3RyaW5nKTogRGF0ZSB8IG51bGwge1xuICAgIC8vIEltcGxlbWVudGF0aW9uIHdvdWxkIHBhcnNlIG5hdHVyYWwgbGFuZ3VhZ2UgZGF0ZXNcbiAgICAvLyBGb3Igbm93LCByZXR1cm4gbnVsbCB0byBpbmRpY2F0ZSBubyB2YWxpZCBkYXRlXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBwcml2YXRlIGRldGVjdFRocmVhZEludGVudChjb250ZW50OiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICAvLyBTaW1wbGUgdGhyZWFkIGRldGVjdGlvbiBsb2dpY1xuICAgIHJldHVybiBjb250ZW50Lmxlbmd0aCA+IDI4MCB8fCBjb250ZW50LmluY2x1ZGVzKCdcXG5cXG4nKSB8fCBjb250ZW50LmluY2x1ZGVzKCcxLycpO1xuICB9XG5cbiAgcHJpdmF0ZSBzcGxpdEludG9UaHJlYWRUd2VldHMoY29udGVudDogc3RyaW5nKTogc3RyaW5nW10ge1xuICAgIGlmICghdGhpcy5kZXRlY3RUaHJlYWRJbnRlbnQoY29udGVudCkpIHtcbiAgICAgIHJldHVybiBbY29udGVudF07XG4gICAgfVxuXG4gICAgLy8gU2ltcGxlIHRocmVhZCBzcGxpdHRpbmcgbG9naWNcbiAgICBjb25zdCBwYXJ0cyA9IGNvbnRlbnQuc3BsaXQoJ1xcblxcbicpLmZpbHRlcihwYXJ0ID0+IHBhcnQudHJpbSgpKTtcbiAgICByZXR1cm4gcGFydHMubGVuZ3RoID4gMSA/IHBhcnRzIDogW2NvbnRlbnRdO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBoYW5kbGVUd2l0dGVyU2NoZWR1bGluZyhcbiAgICBzY2hlZHVsZTogc3RyaW5nLFxuICAgIGNvbnRlbnQ6IHN0cmluZyxcbiAgICBwcm9qZWN0TmFtZTogc3RyaW5nXG4gICk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgLy8gUGxhY2Vob2xkZXIgZm9yIHNjaGVkdWxpbmcgbG9naWNcbiAgICByZXR1cm4gYPCfk4UgKipTY2hlZHVsaW5nOioqIFBvc3Qgd2lsbCBiZSBzY2hlZHVsZWQgZm9yIFwiJHtzY2hlZHVsZX1cIiAoZmVhdHVyZSBjb21pbmcgc29vbilgO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBjcmVhdGVTaW1wbGVUd2l0dGVyUG9zdChcbiAgICBjb250ZW50OiBzdHJpbmcsXG4gICAgcGFyYW1zOiB7XG4gICAgICBjb250ZW50OiBzdHJpbmc7XG4gICAgICBwcm9qZWN0Pzogc3RyaW5nO1xuICAgICAgc2NoZWR1bGU/OiBzdHJpbmc7XG4gICAgICBzZXR0aW5ncz86IHN0cmluZztcbiAgICB9XG4gICk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIFNpbXBsZSBpbXBsZW1lbnRhdGlvbiB3aGVuIGFkdmFuY2VkIHRvb2xzIGNhbid0IGJlIGxvYWRlZFxuICAgICAgY29uc3QgeyB1c2VFZGl0b3JTdG9yZSB9ID0gYXdhaXQgaW1wb3J0KFwiLi4vXCIpO1xuICAgICAgY29uc3QgZWRpdG9yU3RvcmUgPSB1c2VFZGl0b3JTdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgXG4gICAgICBjb25zdCBwcm9qZWN0TmFtZSA9IHBhcmFtcy5wcm9qZWN0IHx8IFwiVHdpdHRlciBQb3N0c1wiO1xuICAgICAgXG4gICAgICAvLyBDcmVhdGUgcHJvamVjdCBmb2xkZXIgaWYgbmVlZGVkXG4gICAgICBjb25zdCBleGlzdGluZ1Byb2plY3QgPSBlZGl0b3JTdG9yZS5wcm9qZWN0Rm9sZGVycy5maW5kKFxuICAgICAgICBmb2xkZXIgPT4gZm9sZGVyLm5hbWUgPT09IHByb2plY3ROYW1lXG4gICAgICApO1xuICAgICAgXG4gICAgICBpZiAoIWV4aXN0aW5nUHJvamVjdCkge1xuICAgICAgICBhd2FpdCBlZGl0b3JTdG9yZS5jcmVhdGVGb2xkZXIocHJvamVjdE5hbWUsIFwicHJvamVjdFwiKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQ3JlYXRlIHRoZSBmaWxlIChzaW1wbGUgdmVyc2lvbiB3aXRob3V0IGRhdGFiYXNlIHNhdmUpXG4gICAgICBjb25zdCBmaWxlTmFtZSA9IGF3YWl0IHRoaXMuY3JlYXRlVHdpdHRlckZpbGVTaW1wbGUoY29udGVudCwgcHJvamVjdE5hbWUpO1xuICAgICAgXG4gICAgICByZXR1cm4gYPCfkKYgKipUd2l0dGVyIFBvc3QgQ3JlYXRlZCBTdWNjZXNzZnVsbHkhKipcblxuKipDb250ZW50OioqIFwiJHtjb250ZW50LnN1YnN0cmluZygwLCAxMDApfSR7Y29udGVudC5sZW5ndGggPiAxMDAgPyAnLi4uJyA6ICcnfVwiXG4qKlByb2plY3Q6KiogJHtwcm9qZWN0TmFtZX1cbioqRmlsZToqKiBcXGAke2ZpbGVOYW1lfVxcYFxuKipTdGF0dXM6KiogRHJhZnRcblxuKlRoaXMgaXMgYSBiYXNpYyBpbXBsZW1lbnRhdGlvbi4gVGhlIGZ1bGwgVHdpdHRlciBhZ2VudCB3aXRoIGZvcm0gcG9wdWxhdGlvbiB3aWxsIGJlIGF2YWlsYWJsZSB3aGVuIHlvdSdyZSBzaWduZWQgaW4gYW5kIHVzaW5nIHRoZSBlZGl0b3IgaW50ZXJmYWNlLipcblxuKipOZXh0IFN0ZXBzOioqXG4xLiBTaWduIGluIHRvIGFjY2VzcyB0aGUgZnVsbCBlZGl0b3JcbjIuIE9wZW4gdGhlIFR3aXR0ZXIgcG9zdCBmaWxlIHRvIGVkaXQgYW5kIHB1Ymxpc2hcbjMuIFVzZSB0aGUgZm9ybSBpbnRlcmZhY2UgZm9yIGFkdmFuY2VkIHNjaGVkdWxpbmcgYW5kIHNldHRpbmdzYDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIuKdjCBTaW1wbGUgVHdpdHRlciBwb3N0IGNyZWF0aW9uIGZhaWxlZDpcIiwgZXJyb3IpO1xuICAgICAgcmV0dXJuIGDinYwgKipFcnJvciBDcmVhdGluZyBUd2l0dGVyIFBvc3QqKlxuXG5GYWlsZWQgdG8gcHJvY2VzczogXCIke2NvbnRlbnR9XCJcblxuRXJyb3I6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcid9XG5cblBsZWFzZSB0cnkgYWdhaW4gb3IgY29udGFjdCBzdXBwb3J0LmA7XG4gICAgfVxuICB9XG59XG5cbi8vIEV4cG9ydCBzaW5nbGV0b24gaW5zdGFuY2VcbmV4cG9ydCBjb25zdCB0d2l0dGVyQWdlbnQgPSBuZXcgVHdpdHRlckFnZW50KCk7XG4iXSwibmFtZXMiOlsiQmFzZUFnZW50IiwiVHdpdHRlckFnZW50IiwiZXhlY3V0ZSIsInRvb2wiLCJpbnB1dCIsImNvbnZleE11dGF0aW9ucyIsImlkIiwiY3JlYXRlVHdpdHRlclBvc3QiLCJFcnJvciIsImNvbnNvbGUiLCJsb2ciLCJjcmVhdGVJbnN0cnVjdGlvbkZpbGUiLCJ3YXJuIiwiY2xlYW5JbnB1dCIsInRyaW0iLCJzdGFydHNXaXRoIiwicmVwbGFjZSIsInBhcmFtcyIsInBhcnNlVHdpdHRlclBhcmFtZXRlcnMiLCJwcm9jZXNzVHdpdHRlclJlcXVlc3QiLCJ1c2VFZGl0b3JTdG9yZSIsInR3aXR0ZXJUb29scyIsImUxIiwibWVzc2FnZSIsIlN0cmluZyIsImUyIiwiZTMiLCJlMU1zZyIsImUyTXNnIiwiZTNNc2ciLCJPYmplY3QiLCJrZXlzIiwiZWRpdG9yTW9kdWxlIiwiaW1wb3J0RXJyb3IiLCJjcmVhdGVTaW1wbGVUd2l0dGVyUG9zdCIsInJlc3VsdCIsInVzZXJJbnB1dCIsImNvbnRlbnQiLCJzdWdnZXN0ZWRQcm9qZWN0IiwicHJvamVjdCIsInNjaGVkdWxlIiwic2V0dGluZ3MiLCJnZXRTdGF0ZSIsInN1Y2Nlc3MiLCJlZGl0b3JTdG9yZSIsImNvbnRlbnRDcmVhdGlvbkZvbGRlciIsInByb2plY3RGb2xkZXJzIiwiZmluZCIsImZvbGRlciIsIm5hbWUiLCJjcmVhdGVGb2xkZXIiLCJwcm9qZWN0TmFtZSIsImZpbGVOYW1lIiwiY3JlYXRlVHdpdHRlckZpbGUiLCJmb3JtRGF0YSIsInByZXBhcmVUd2l0dGVyRm9ybURhdGEiLCJmaWxsVHdpdHRlckZvcm1GaWVsZHNXaXRoRGF0YSIsInNjaGVkdWxpbmdSZXN1bHQiLCJoYW5kbGVUd2l0dGVyU2NoZWR1bGluZyIsInN1YnN0cmluZyIsImxlbmd0aCIsImRldGVjdGVkVG9waWMiLCJzdHlsZSIsInJlcGx5U2V0dGluZ3MiLCJlcnJvciIsInVuZGVmaW5lZCIsInByb2plY3RNYXRjaCIsIm1hdGNoIiwic2NoZWR1bGVNYXRjaCIsInNldHRpbmdzTWF0Y2giLCJmaWxlTmFtZXIiLCJmaWxlTmFtZVJlc3VsdCIsImdlbmVyYXRlRmlsZU5hbWUiLCJtYXhXb3JkcyIsIm1hcCIsImYiLCJwcm9qZWN0Rm9sZGVyIiwidG9Mb3dlckNhc2UiLCJ0b2RheSIsIkRhdGUiLCJ0b0xvY2FsZURhdGVTdHJpbmciLCJ0aW1lU3RhbXAiLCJ0b0xvY2FsZVRpbWVTdHJpbmciLCJyaWNoQ29udGVudCIsImhhc2giLCJmaWxlSWQiLCJjcmVhdGVOZXdGaWxlIiwidXBzZXJ0UG9zdCIsImZpbGVUeXBlIiwidGl0bGUiLCJzdGF0dXMiLCJkYkVycm9yIiwiY3JlYXRlVHdpdHRlckZpbGVTaW1wbGUiLCJtYXBUd2l0dGVyU2V0dGluZ3NUb0FQSSIsInNjaGVkdWxlZERhdGUiLCJwYXJzZVNjaGVkdWxlRGF0ZUNvbXBvbmVudCIsInNjaGVkdWxlZFRpbWUiLCJwYXJzZVNjaGVkdWxlVGltZUNvbXBvbmVudCIsImlzVGhyZWFkIiwiZGV0ZWN0VGhyZWFkSW50ZW50IiwidGhyZWFkVHdlZXRzIiwic3BsaXRJbnRvVGhyZWFkVHdlZXRzIiwiaGFzUG9sbCIsInBvbGxPcHRpb25zIiwicG9sbER1cmF0aW9uIiwicHJlcGFyZWRGb3JtRGF0YSIsInBsYXRmb3JtRGF0YSIsImZvcm1EYXRhS2V5IiwiZm9ybURhdGFUb1N0b3JlIiwidGltZXN0YW1wIiwibm93IiwibG9jYWxTdG9yYWdlIiwic2V0SXRlbSIsIkpTT04iLCJzdHJpbmdpZnkiLCJzdG9yYWdlRXJyb3IiLCJkYXRlIiwicGFyc2VTY2hlZHVsZVN0cmluZyIsInRvSVNPU3RyaW5nIiwic3BsaXQiLCJ0b1RpbWVTdHJpbmciLCJzbGljZSIsImluY2x1ZGVzIiwicGFydHMiLCJmaWx0ZXIiLCJwYXJ0IiwiZXhpc3RpbmdQcm9qZWN0IiwiZGVzY3JpcHRpb24iLCJpY29uIiwidG9vbHMiLCJjb21tYW5kIiwicGFyYW1ldGVycyIsInR5cGUiLCJyZXF1aXJlZCIsIm9wdGlvbnMiLCJ0d2l0dGVyQWdlbnQiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./store/agents/twitterAgent.ts\n"));

/***/ })

});