"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./store/agents/logoGeneratorAgent.ts":
/*!********************************************!*\
  !*** ./store/agents/logoGeneratorAgent.ts ***!
  \********************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LogoGeneratorAgent: () => (/* binding */ LogoGeneratorAgent),\n/* harmony export */   logoGeneratorAgent: () => (/* binding */ logoGeneratorAgent)\n/* harmony export */ });\n/* harmony import */ var _lib_api_openai_images__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/lib/api/openai-images */ \"(app-pages-browser)/./lib/api/openai-images.ts\");\n/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base */ \"(app-pages-browser)/./store/agents/base.ts\");\n// Logo Generator Agent - OpenAI DALL-E Integration\n// /Users/matthewsimon/Projects/eac/eac/store/agents/logoGeneratorAgent.ts\n\n\nclass LogoGeneratorAgent extends _base__WEBPACK_IMPORTED_MODULE_1__.BaseAgent {\n    async execute(tool, input, convexMutations, sessionId) {\n        try {\n            // For the logo generator, we always use the conversational flow\n            // The slash command '/logo' is handled within processInput\n            return await this.processInput(input, convexMutations, sessionId || '');\n        } catch (error) {\n            console.error('Logo Generator Agent error:', error);\n            return \"‚ùå **Error in Logo Generation**\\n\\nSomething went wrong: \".concat(error instanceof Error ? error.message : 'Unknown error');\n        }\n    }\n    getInitialPrompt() {\n        this.currentStep = 'welcome';\n        return \"\\uD83C\\uDFA8 **Welcome to the Logo Generator!**\\n\\nI'll help you create a professional logo using Google's Imagen AI. Let's start by learning about your business.\\n\\n**What's the name of your company or brand?**\\n\\n(This will be the primary text in your logo)\";\n    }\n    async processInput(input, convexMutations, sessionId) {\n        var _this_currentBrief;\n        const normalizedInput = input.toLowerCase().trim();\n        // Debug logging\n        console.log('üé® LogoGenerator processInput:', {\n            input: normalizedInput,\n            currentStep: this.currentStep,\n            briefExists: !!this.currentBrief,\n            companyName: (_this_currentBrief = this.currentBrief) === null || _this_currentBrief === void 0 ? void 0 : _this_currentBrief.companyName\n        });\n        // Handle slash commands first\n        if (normalizedInput.startsWith('/logo')) {\n            return this.handleLogoGeneration(input, convexMutations, sessionId);\n        }\n        // Handle conversation flow based on current step\n        switch(this.currentStep){\n            case 'welcome':\n                return this.handleWelcomeStep(input, convexMutations, sessionId);\n            case 'company':\n                return this.handleCompanyStep(input, convexMutations, sessionId);\n            case 'business':\n                return this.handleBusinessStep(input, convexMutations, sessionId);\n            case 'style':\n                return this.handleStyleStep(input, convexMutations, sessionId);\n            case 'colors':\n                return this.handleColorsStep(input, convexMutations, sessionId);\n            case 'type':\n                return this.handleTypeStep(input, convexMutations, sessionId);\n            case 'audience':\n                return this.handleAudienceStep(input, convexMutations, sessionId);\n            case 'instructions':\n                return this.handleInstructionsStep(input, convexMutations, sessionId);\n            case 'generate':\n                return this.handleGenerateStep(input, convexMutations, sessionId);\n            default:\n                return this.getInitialPrompt();\n        }\n    }\n    async handleWelcomeStep(input, convexMutations, sessionId) {\n        if (!this.currentBrief) {\n            this.currentBrief = {};\n        }\n        this.currentBrief.companyName = input.trim();\n        this.currentStep = 'business';\n        return \"Great! **\".concat(input.trim(), \"** is a wonderful name.\\n\\nNow, tell me about your business:\\n\\n**What industry are you in and what does \").concat(input.trim(), ' do?**\\n\\n(For example: \"We\\'re a sustainable fashion brand that creates eco-friendly clothing\" or \"We provide cloud-based accounting software for small businesses\")');\n    }\n    async handleCompanyStep(input, convexMutations, sessionId) {\n        this.currentBrief.companyName = input.trim();\n        this.currentStep = 'business';\n        return \"Perfect! Now let's learn about **\".concat(input.trim(), \"**.\\n\\n**What industry are you in and what does your business do?**\\n\\n(Be specific about your products, services, or mission. This helps me understand the right visual direction for your logo.)\");\n    }\n    async handleBusinessStep(input, convexMutations, sessionId) {\n        this.currentBrief.businessDescription = input.trim();\n        // Try to extract industry from the description\n        const businessDesc = input.toLowerCase();\n        let suggestedIndustry = '';\n        if (businessDesc.includes('tech') || businessDesc.includes('software') || businessDesc.includes('app')) {\n            suggestedIndustry = 'Technology';\n        } else if (businessDesc.includes('fashion') || businessDesc.includes('clothing') || businessDesc.includes('apparel')) {\n            suggestedIndustry = 'Fashion & Retail';\n        } else if (businessDesc.includes('food') || businessDesc.includes('restaurant') || businessDesc.includes('culinary')) {\n            suggestedIndustry = 'Food & Beverage';\n        } else if (businessDesc.includes('health') || businessDesc.includes('medical') || businessDesc.includes('wellness')) {\n            suggestedIndustry = 'Healthcare';\n        } else if (businessDesc.includes('finance') || businessDesc.includes('accounting') || businessDesc.includes('banking')) {\n            suggestedIndustry = 'Financial Services';\n        } else {\n            suggestedIndustry = 'Professional Services';\n        }\n        this.currentBrief.industry = suggestedIndustry;\n        this.currentStep = 'style';\n        return \"Excellent! I understand that \".concat(this.currentBrief.companyName, \" \").concat(input.trim().toLowerCase(), \".\\n\\nNow, what style direction appeals to you? Choose one:\\n\\n1. **Minimalist** - Clean, simple, timeless\\n2. **Modern** - Contemporary, sleek, geometric\\n3. **Traditional** - Classic, established, trustworthy\\n4. **Playful** - Fun, creative, approachable\\n5. **Elegant** - Sophisticated, refined, luxury\\n6. **Bold** - Strong, impactful, confident\\n\\n**Type the number or style name you prefer:**\");\n    }\n    async handleStyleStep(input, convexMutations, sessionId) {\n        const normalizedInput = input.toLowerCase().trim();\n        let selectedStyle;\n        // Map input to style preference\n        if (normalizedInput.includes('1') || normalizedInput.includes('minimalist')) {\n            selectedStyle = 'minimalist';\n        } else if (normalizedInput.includes('2') || normalizedInput.includes('modern')) {\n            selectedStyle = 'modern';\n        } else if (normalizedInput.includes('3') || normalizedInput.includes('traditional')) {\n            selectedStyle = 'traditional';\n        } else if (normalizedInput.includes('4') || normalizedInput.includes('playful')) {\n            selectedStyle = 'playful';\n        } else if (normalizedInput.includes('5') || normalizedInput.includes('elegant')) {\n            selectedStyle = 'elegant';\n        } else if (normalizedInput.includes('6') || normalizedInput.includes('bold')) {\n            selectedStyle = 'bold';\n        } else {\n            return \"I didn't understand that style choice. Please choose:\\n\\n1. **Minimalist** 2. **Modern** 3. **Traditional** 4. **Playful** 5. **Elegant** 6. **Bold**\\n\\n**Type the number or style name:**\";\n        }\n        this.currentBrief.stylePreference = selectedStyle;\n        this.currentStep = 'colors';\n        return \"Perfect! A **\".concat(selectedStyle, \"** style will work great for \").concat(this.currentBrief.companyName, '.\\n\\n**What color preferences do you have?**\\n\\nYou can mention:\\n- Specific colors (blue, green, red, etc.)\\n- Color themes (corporate, vibrant, earthy, etc.)  \\n- \"No preference\" if you want me to suggest colors based on your industry\\n\\n**Your color preference:**');\n    }\n    async handleColorsStep(input, convexMutations, sessionId) {\n        const colorInput = input.trim();\n        this.currentBrief.colorPreferences = [\n            colorInput\n        ];\n        this.currentStep = 'type';\n        return \"Great color choice! Now, what type of logo do you prefer?\\n\\n1. **Text-only** - Company name styled beautifully (like Google, Coca-Cola)\\n2. **Icon-only** - A symbol that represents your brand (like Apple, Nike swoosh)\\n3. **Combination** - Both text and icon together (like Adidas, McDonald's)\\n\\n**Type the number or logo type you prefer:**\";\n    }\n    async handleTypeStep(input, convexMutations, sessionId) {\n        const normalizedInput = input.toLowerCase().trim();\n        let logoType;\n        if (normalizedInput.includes('1') || normalizedInput.includes('text')) {\n            logoType = 'text';\n        } else if (normalizedInput.includes('2') || normalizedInput.includes('icon')) {\n            logoType = 'icon';\n        } else if (normalizedInput.includes('3') || normalizedInput.includes('combination')) {\n            logoType = 'combination';\n        } else {\n            return \"Please choose a logo type:\\n\\n1. **Text-only** 2. **Icon-only** 3. **Combination**\\n\\n**Type the number or logo type:**\";\n        }\n        this.currentBrief.logoType = logoType;\n        this.currentStep = 'audience';\n        return \"Excellent! A **\".concat(logoType, '** logo will be perfect.\\n\\n**Who is your target audience?**\\n\\n(For example: \"Young professionals\", \"Families with children\", \"Small business owners\", \"Tech startups\", etc. This helps inform the design approach.)');\n    }\n    async handleAudienceStep(input, convexMutations, sessionId) {\n        this.currentBrief.targetAudience = input.trim();\n        this.currentStep = 'instructions';\n        return 'Perfect! Understanding your audience helps create the right visual impact.\\n\\n**Any additional instructions or specific elements you\\'d like included?**\\n\\n(Optional - you can mention specific symbols, avoid certain elements, or say \"none\" to proceed)\\n\\n**Additional instructions:**';\n    }\n    async handleInstructionsStep(input, convexMutations, sessionId) {\n        var _brief_colorPreferences;\n        const instructions = input.trim();\n        if (instructions.toLowerCase() !== 'none') {\n            this.currentBrief.additionalInstructions = instructions;\n        }\n        this.currentStep = 'generate';\n        const brief = this.currentBrief;\n        return \"\\uD83C\\uDFAF **Logo Brief Complete!**\\n\\nHere's what I'll create for you:\\n\\n‚Ä¢ **Company:** \".concat(brief.companyName, \"\\n‚Ä¢ **Business:** \").concat(brief.businessDescription, \"\\n‚Ä¢ **Industry:** \").concat(brief.industry, \"\\n‚Ä¢ **Style:** \").concat(brief.stylePreference, \"\\n‚Ä¢ **Colors:** \").concat((_brief_colorPreferences = brief.colorPreferences) === null || _brief_colorPreferences === void 0 ? void 0 : _brief_colorPreferences[0], \"\\n‚Ä¢ **Type:** \").concat(brief.logoType, \"\\n‚Ä¢ **Audience:** \").concat(brief.targetAudience, \"\\n\").concat(brief.additionalInstructions ? \"‚Ä¢ **Special Instructions:** \".concat(brief.additionalInstructions) : '', '\\n\\n**Ready to generate your logo?**\\n\\nType \"yes\" to start generation or \"edit\" if you want to modify anything.');\n    }\n    async handleGenerateStep(input, convexMutations, sessionId) {\n        const normalizedInput = input.toLowerCase().trim();\n        if (normalizedInput.includes('edit') || normalizedInput.includes('modify')) {\n            this.currentStep = 'welcome';\n            this.currentBrief = {};\n            return \"No problem! Let's start over with any changes you'd like to make.\\n\\n**What's the name of your company or brand?**\";\n        }\n        if (normalizedInput.includes('yes') || normalizedInput.includes('generate') || normalizedInput.includes('create')) {\n            return this.handleLogoGeneration(input, convexMutations, sessionId);\n        }\n        return 'Please type \"yes\" to generate your logo or \"edit\" to make changes to your brief.';\n    }\n    async handleLogoGeneration(input, convexMutations, sessionId) {\n        const brief = this.currentBrief;\n        if (!brief || !brief.companyName) {\n            this.currentStep = 'welcome';\n            return \"I need more information to generate your logo. Let's start with your company name.\\n\\n**What's the name of your company or brand?**\";\n        }\n        try {\n            var _generationResult_imageUrl, _generationResult_imageUrl1;\n            // Create consolidated prompt from the brief using the new OpenAI system\n            const logoPrompt = this.createConsolidatedLogoPrompt(brief);\n            // Call our API route instead of direct OpenAI call (for server-side execution)\n            const response = await fetch('/api/generate-logo', {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json'\n                },\n                body: JSON.stringify({\n                    prompt: logoPrompt,\n                    style: 'vivid',\n                    size: '1024x1024',\n                    quality: 'hd',\n                    numberOfImages: 1\n                })\n            });\n            const generationResult = await response.json();\n            console.log('üé® Logo generation result:', {\n                success: generationResult.success,\n                hasImageUrl: !!generationResult.imageUrl,\n                imageUrlLength: (_generationResult_imageUrl = generationResult.imageUrl) === null || _generationResult_imageUrl === void 0 ? void 0 : _generationResult_imageUrl.length,\n                imageUrlPreview: (_generationResult_imageUrl1 = generationResult.imageUrl) === null || _generationResult_imageUrl1 === void 0 ? void 0 : _generationResult_imageUrl1.substring(0, 50),\n                revisedPrompt: generationResult.revisedPrompt,\n                error: generationResult.error\n            });\n            if (generationResult.success && generationResult.imageUrl) {\n                var _brief_colorPreferences;\n                // Store the generated logo in Convex database for persistence\n                if (sessionId && convexMutations.createLogoGeneration) {\n                    await convexMutations.createLogoGeneration({\n                        sessionId,\n                        logoSvg: generationResult.imageUrl,\n                        prompt: logoPrompt,\n                        brief: {\n                            companyName: brief.companyName || 'Unknown',\n                            business: brief.businessDescription || 'Unknown',\n                            stylePreference: brief.stylePreference || 'modern',\n                            colorPreferences: brief.colorPreferences || [\n                                'blue'\n                            ],\n                            logoType: brief.logoType || 'combination',\n                            targetAudience: brief.targetAudience || 'general',\n                            specialInstructions: brief.additionalInstructions\n                        },\n                        status: 'completed'\n                    });\n                }\n                // Store the generated logo in chat messages for display\n                if (sessionId && convexMutations.storeChatMessage) {\n                    var _brief_colorPreferences1;\n                    await convexMutations.storeChatMessage({\n                        role: \"assistant\",\n                        content: \"\\uD83C\\uDFA8 **Logo Generated Successfully!**\\n\\nHere's your custom logo for **\".concat(brief.companyName, \"**:\\n\\n![Generated Logo](\").concat(generationResult.imageUrl, \")\\n\\n**Generation Details:**\\n‚Ä¢ **Style:** \").concat(brief.stylePreference, \"\\n‚Ä¢ **Type:** \").concat(brief.logoType, \"\\n‚Ä¢ **Colors:** \").concat((_brief_colorPreferences1 = brief.colorPreferences) === null || _brief_colorPreferences1 === void 0 ? void 0 : _brief_colorPreferences1[0], \"\\n‚Ä¢ **Target Audience:** \").concat(brief.targetAudience, \"\\n\\n**OpenAI DALL-E Prompt Used:**\\n`\").concat(logoPrompt, \"`\\n\\n\").concat(generationResult.revisedPrompt && generationResult.revisedPrompt !== logoPrompt ? \"\\n**AI-Revised Prompt:**\\n`\".concat(generationResult.revisedPrompt, \"`\") : '', \"\\n\\n**What's Next?**\\n1. **Generate Variation** - Create another version\\n2. **Export Logo** - Download in different formats\\n3. **Start New Project** - Create another logo\\n\\nType your choice to continue!\"),\n                        sessionId,\n                        operation: {\n                            type: \"tool_executed\",\n                            details: {\n                                tool: \"logo_generation\",\n                                imageUrl: generationResult.imageUrl,\n                                imageData: generationResult.imageData,\n                                prompt: logoPrompt,\n                                brief: brief\n                            }\n                        }\n                    });\n                }\n                // Reset for next generation\n                this.reset();\n                return \"\\uD83C\\uDFA8 **Logo Generated Successfully!**\\n\\nYour custom logo for **\".concat(brief.companyName, \"** has been created and will appear in the Logo Generator tab.\\n\\n**Generation Details:**\\n‚Ä¢ **Style:** \").concat(brief.stylePreference, \"\\n‚Ä¢ **Type:** \").concat(brief.logoType, \"\\n‚Ä¢ **Colors:** \").concat((_brief_colorPreferences = brief.colorPreferences) === null || _brief_colorPreferences === void 0 ? void 0 : _brief_colorPreferences[0], \"\\n‚Ä¢ **Target Audience:** \").concat(brief.targetAudience, \"\\n\\nThe logo is now available in the preview panel. You can:\\n\\n1. **Generate Variation** - Create another version\\n2. **Export Logo** - Download in different formats  \\n3. **Start New Project** - Create another logo\\n\\nType your choice to continue!\");\n            } else {\n                return \"‚ùå **Logo Generation Failed**\\n\\nSorry, there was an issue generating your logo: \".concat(generationResult.error || 'Unknown error', '\\n\\nPlease try again or modify your requirements. Type \"restart\" to begin with a new brief.');\n            }\n        } catch (error) {\n            console.error('‚ùå Logo generation error:', error);\n            return \"‚ùå **Logo Generation Error**\\n\\nAn unexpected error occurred during logo generation. Please try again.\\n\\nError: \".concat(error instanceof Error ? error.message : 'Unknown error', '\\n\\nType \"restart\" to begin with a new brief.');\n        }\n    }\n    createImagenPrompt(brief) {\n        const { companyName, businessDescription, stylePreference, colorPreferences, logoType, targetAudience, additionalInstructions } = brief;\n        let prompt = 'Create a professional logo design for \"'.concat(companyName, '\"');\n        if (businessDescription) {\n            prompt += \", a company that \".concat(businessDescription.toLowerCase());\n        }\n        if (stylePreference) {\n            prompt += \". Style: \".concat(stylePreference);\n        }\n        if (logoType) {\n            if (logoType === 'text') {\n                prompt += '. Text-only logo with stylized typography';\n            } else if (logoType === 'icon') {\n                prompt += '. Icon-only logo, no text, symbolic design';\n            } else {\n                prompt += '. Combination logo with both text and icon elements';\n            }\n        }\n        if (colorPreferences && colorPreferences[0] && colorPreferences[0].toLowerCase() !== 'no preference') {\n            prompt += \". Color scheme: \".concat(colorPreferences[0]);\n        }\n        if (targetAudience) {\n            prompt += \". Target audience: \".concat(targetAudience);\n        }\n        if (additionalInstructions) {\n            prompt += \". Special requirements: \".concat(additionalInstructions);\n        }\n        prompt += '. High quality, professional, scalable vector design, clean background, suitable for business use.';\n        return prompt;\n    }\n    // Reset the agent state\n    reset() {\n        this.currentBrief = {};\n        this.currentStep = 'welcome';\n    }\n    /**\n   * Create consolidated logo prompt using the unified OpenAI system\n   * Combines all brief elements into a single optimized prompt\n   */ createConsolidatedLogoPrompt(brief) {\n        let basePrompt = \"Professional logo design for \".concat(brief.companyName);\n        if (brief.businessDescription) {\n            basePrompt += \", a \".concat(brief.businessDescription);\n        }\n        if (brief.industry) {\n            basePrompt += \" in the \".concat(brief.industry, \" industry\");\n        }\n        // Style preferences\n        if (brief.stylePreference && brief.stylePreference !== 'modern') {\n            basePrompt += \", \".concat(brief.stylePreference, \" style\");\n        }\n        // Logo type\n        if (brief.logoType && brief.logoType !== 'combination') {\n            if (brief.logoType === 'text') {\n                basePrompt += \", text-based logo\";\n            } else if (brief.logoType === 'icon') {\n                basePrompt += \", icon-only logo\";\n            }\n        }\n        // Color preferences\n        if (brief.colorPreferences && brief.colorPreferences[0] && brief.colorPreferences[0].toLowerCase() !== 'no preference') {\n            basePrompt += \", using \".concat(brief.colorPreferences[0], \" color scheme\");\n        }\n        // Target audience\n        if (brief.targetAudience) {\n            basePrompt += \", appealing to \".concat(brief.targetAudience);\n        }\n        // Additional instructions\n        if (brief.additionalInstructions) {\n            basePrompt += \", \".concat(brief.additionalInstructions);\n        }\n        // Use the OpenAI prompt optimizer for consistency\n        return (0,_lib_api_openai_images__WEBPACK_IMPORTED_MODULE_0__.optimizeLogoPrompt)(basePrompt);\n    }\n    constructor(){\n        super(), this.id = 'logo-generator', this.name = 'Logo Generator', this.description = 'AI-powered logo creation and brand identity generation using OpenAI DALL-E', this.icon = 'Puzzle', // Instance state to track the logo generation process\n        this.currentBrief = {}, this.currentStep = 'welcome', this.tools = [\n            {\n                id: 'logo-generation',\n                name: 'Logo Generation',\n                command: '/logo',\n                description: 'Generate professional logos with OpenAI DALL-E AI',\n                parameters: []\n            }\n        ];\n        // Initialize the brief when agent is created\n        this.currentBrief = {};\n        this.currentStep = 'welcome';\n    }\n}\n// Export the instantiated agent for registry\nconst logoGeneratorAgent = new LogoGeneratorAgent();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3N0b3JlL2FnZW50cy9sb2dvR2VuZXJhdG9yQWdlbnQudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBLG1EQUFtRDtBQUNuRCwwRUFBMEU7QUFNekM7QUFDYTtBQWV2QyxNQUFNRSwyQkFBMkJELDRDQUFTQTtJQTJCL0MsTUFBTUUsUUFDSkMsSUFBZSxFQUNmQyxLQUFhLEVBQ2JDLGVBQWdDLEVBQ2hDQyxTQUFrQixFQUNEO1FBQ2pCLElBQUk7WUFDRixnRUFBZ0U7WUFDaEUsMkRBQTJEO1lBQzNELE9BQU8sTUFBTSxJQUFJLENBQUNDLFlBQVksQ0FBQ0gsT0FBT0MsaUJBQWlCQyxhQUFhO1FBQ3RFLEVBQUUsT0FBT0UsT0FBTztZQUNkQyxRQUFRRCxLQUFLLENBQUMsK0JBQStCQTtZQUM3QyxPQUFPLDJEQUFvSCxPQUF6REEsaUJBQWlCRSxRQUFRRixNQUFNRyxPQUFPLEdBQUc7UUFDN0c7SUFDRjtJQUVBQyxtQkFBMkI7UUFDekIsSUFBSSxDQUFDQyxXQUFXLEdBQUc7UUFDbkIsT0FBUTtJQU9WO0lBRUEsTUFBTU4sYUFBYUgsS0FBYSxFQUFFQyxlQUFnQyxFQUFFQyxTQUFpQixFQUFtQjtZQVF2RjtRQVBmLE1BQU1RLGtCQUFrQlYsTUFBTVcsV0FBVyxHQUFHQyxJQUFJO1FBRWhELGdCQUFnQjtRQUNoQlAsUUFBUVEsR0FBRyxDQUFDLGtDQUFrQztZQUM1Q2IsT0FBT1U7WUFDUEQsYUFBYSxJQUFJLENBQUNBLFdBQVc7WUFDN0JLLGFBQWEsQ0FBQyxDQUFDLElBQUksQ0FBQ0MsWUFBWTtZQUNoQ0MsV0FBVyxHQUFFLHlCQUFJLENBQUNELFlBQVksY0FBakIsNERBQW1CQyxXQUFXO1FBQzdDO1FBRUEsOEJBQThCO1FBQzlCLElBQUlOLGdCQUFnQk8sVUFBVSxDQUFDLFVBQVU7WUFDdkMsT0FBTyxJQUFJLENBQUNDLG9CQUFvQixDQUFDbEIsT0FBT0MsaUJBQWlCQztRQUMzRDtRQUVBLGlEQUFpRDtRQUNqRCxPQUFRLElB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QUFlO1lBQ2pCO1FBQ0Y7UUFFQSxvQkFBb0I7UUFDcEIsSUFBSXpDLE1BQU1ILGdCQUFnQixJQUFJRyxNQUFNSCxnQkFBZ0IsQ0FBQyxFQUFFLElBQ25ERyxNQUFNSCxnQkFBZ0IsQ0FBQyxFQUFFLENBQUN6QixXQUFXLE9BQU8saUJBQWlCO1lBQy9EcUUsY0FBYyxXQUFxQyxPQUExQnpDLE1BQU1ILGdCQUFnQixDQUFDLEVBQUUsRUFBQztRQUNyRDtRQUVBLGtCQUFrQjtRQUNsQixJQUFJRyxNQUFNRCxjQUFjLEVBQUU7WUFDeEIwQyxjQUFjLGtCQUF1QyxPQUFyQnpDLE1BQU1ELGNBQWM7UUFDdEQ7UUFFQSwwQkFBMEI7UUFDMUIsSUFBSUMsTUFBTUUsc0JBQXNCLEVBQUU7WUFDaEN1QyxjQUFjLEtBQWtDLE9BQTdCekMsTUFBTUUsc0JBQXNCO1FBQ2pEO1FBRUEsa0RBQWtEO1FBQ2xELE9BQU85QywwRUFBa0JBLENBQUNxRjtJQUM1QjtJQXZoQkFDLGFBQWM7UUFDWixLQUFLLFNBcEJQQyxLQUFLLHVCQUNMQyxPQUFPLHVCQUNQQyxjQUFjLG1GQUNkQyxPQUFPLFVBRVAsc0RBQXNEO2FBQzlDdEUsZUFBbUMsQ0FBQyxRQUNwQ04sY0FBMkgsZ0JBRW5JNkUsUUFBcUI7WUFDbkI7Z0JBQ0VKLElBQUk7Z0JBQ0pDLE1BQU07Z0JBQ05JLFNBQVM7Z0JBQ1RILGFBQWE7Z0JBQ2JJLFlBQVksRUFBRTtZQUNoQjtTQUNEO1FBSUMsNkNBQTZDO1FBQzdDLElBQUksQ0FBQ3pFLFlBQVksR0FBRyxDQUFDO1FBQ3JCLElBQUksQ0FBQ04sV0FBVyxHQUFHO0lBQ3JCO0FBbWhCRjtBQUVBLDZDQUE2QztBQUN0QyxNQUFNZ0YscUJBQXFCLElBQUk1RixxQkFBcUIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYXR0aGV3c2ltb24vUHJvamVjdHMvZWFjL2VhYy9zdG9yZS9hZ2VudHMvbG9nb0dlbmVyYXRvckFnZW50LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIExvZ28gR2VuZXJhdG9yIEFnZW50IC0gT3BlbkFJIERBTEwtRSBJbnRlZ3JhdGlvblxuLy8gL1VzZXJzL21hdHRoZXdzaW1vbi9Qcm9qZWN0cy9lYWMvZWFjL3N0b3JlL2FnZW50cy9sb2dvR2VuZXJhdG9yQWdlbnQudHNcblxuaW1wb3J0IHtcbiAgZ2VuZXJhdGVMb2dvV2l0aE9wZW5BSSxcbiAgb3B0aW1pemVMb2dvUHJvbXB0LFxuICB0eXBlIExvZ29HZW5lcmF0aW9uT3B0aW9uc1xufSBmcm9tICdAL2xpYi9hcGkvb3BlbmFpLWltYWdlcyc7XG5pbXBvcnQgeyBBZ2VudFRvb2wsIEJhc2VBZ2VudCB9IGZyb20gJy4vYmFzZSc7XG5pbXBvcnQgeyBDb252ZXhNdXRhdGlvbnMgfSBmcm9tICcuL3R5cGVzJztcblxuaW50ZXJmYWNlIExvZ29CcmllZiB7XG4gIGNvbXBhbnlOYW1lOiBzdHJpbmc7XG4gIHByb2R1Y3ROYW1lPzogc3RyaW5nO1xuICBpbmR1c3RyeTogc3RyaW5nO1xuICBidXNpbmVzc0Rlc2NyaXB0aW9uOiBzdHJpbmc7XG4gIHN0eWxlUHJlZmVyZW5jZTogJ21pbmltYWxpc3QnIHwgJ21vZGVybicgfCAndHJhZGl0aW9uYWwnIHwgJ3BsYXlmdWwnIHwgJ2VsZWdhbnQnIHwgJ2JvbGQnO1xuICBjb2xvclByZWZlcmVuY2VzOiBzdHJpbmdbXTtcbiAgbG9nb1R5cGU6ICd0ZXh0JyB8ICdpY29uJyB8ICdjb21iaW5hdGlvbic7XG4gIHRhcmdldEF1ZGllbmNlOiBzdHJpbmc7XG4gIGFkZGl0aW9uYWxJbnN0cnVjdGlvbnM/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBjbGFzcyBMb2dvR2VuZXJhdG9yQWdlbnQgZXh0ZW5kcyBCYXNlQWdlbnQge1xuICBpZCA9ICdsb2dvLWdlbmVyYXRvcic7XG4gIG5hbWUgPSAnTG9nbyBHZW5lcmF0b3InO1xuICBkZXNjcmlwdGlvbiA9ICdBSS1wb3dlcmVkIGxvZ28gY3JlYXRpb24gYW5kIGJyYW5kIGlkZW50aXR5IGdlbmVyYXRpb24gdXNpbmcgT3BlbkFJIERBTEwtRSc7XG4gIGljb24gPSAnUHV6emxlJztcblxuICAvLyBJbnN0YW5jZSBzdGF0ZSB0byB0cmFjayB0aGUgbG9nbyBnZW5lcmF0aW9uIHByb2Nlc3NcbiAgcHJpdmF0ZSBjdXJyZW50QnJpZWY6IFBhcnRpYWw8TG9nb0JyaWVmPiA9IHt9O1xuICBwcml2YXRlIGN1cnJlbnRTdGVwOiAnd2VsY29tZScgfCAnY29tcGFueScgfCAnYnVzaW5lc3MnIHwgJ3N0eWxlJyB8ICdjb2xvcnMnIHwgJ3R5cGUnIHwgJ2F1ZGllbmNlJyB8ICdpbnN0cnVjdGlvbnMnIHwgJ2dlbmVyYXRlJyA9ICd3ZWxjb21lJztcblxuICB0b29sczogQWdlbnRUb29sW10gPSBbXG4gICAge1xuICAgICAgaWQ6ICdsb2dvLWdlbmVyYXRpb24nLFxuICAgICAgbmFtZTogJ0xvZ28gR2VuZXJhdGlvbicsXG4gICAgICBjb21tYW5kOiAnL2xvZ28nLFxuICAgICAgZGVzY3JpcHRpb246ICdHZW5lcmF0ZSBwcm9mZXNzaW9uYWwgbG9nb3Mgd2l0aCBPcGVuQUkgREFMTC1FIEFJJyxcbiAgICAgIHBhcmFtZXRlcnM6IFtdXG4gICAgfVxuICBdO1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gICAgLy8gSW5pdGlhbGl6ZSB0aGUgYnJpZWYgd2hlbiBhZ2VudCBpcyBjcmVhdGVkXG4gICAgdGhpcy5jdXJyZW50QnJpZWYgPSB7fTtcbiAgICB0aGlzLmN1cnJlbnRTdGVwID0gJ3dlbGNvbWUnO1xuICB9XG5cbiAgYXN5bmMgZXhlY3V0ZShcbiAgICB0b29sOiBBZ2VudFRvb2wsXG4gICAgaW5wdXQ6IHN0cmluZyxcbiAgICBjb252ZXhNdXRhdGlvbnM6IENvbnZleE11dGF0aW9ucyxcbiAgICBzZXNzaW9uSWQ/OiBzdHJpbmdcbiAgKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICB0cnkge1xuICAgICAgLy8gRm9yIHRoZSBsb2dvIGdlbmVyYXRvciwgd2UgYWx3YXlzIHVzZSB0aGUgY29udmVyc2F0aW9uYWwgZmxvd1xuICAgICAgLy8gVGhlIHNsYXNoIGNvbW1hbmQgJy9sb2dvJyBpcyBoYW5kbGVkIHdpdGhpbiBwcm9jZXNzSW5wdXRcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLnByb2Nlc3NJbnB1dChpbnB1dCwgY29udmV4TXV0YXRpb25zLCBzZXNzaW9uSWQgfHwgJycpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdMb2dvIEdlbmVyYXRvciBBZ2VudCBlcnJvcjonLCBlcnJvcik7XG4gICAgICByZXR1cm4gYOKdjCAqKkVycm9yIGluIExvZ28gR2VuZXJhdGlvbioqXFxuXFxuU29tZXRoaW5nIHdlbnQgd3Jvbmc6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcid9YDtcbiAgICB9XG4gIH1cblxuICBnZXRJbml0aWFsUHJvbXB0KCk6IHN0cmluZyB7XG4gICAgdGhpcy5jdXJyZW50U3RlcCA9ICd3ZWxjb21lJztcbiAgICByZXR1cm4gYPCfjqggKipXZWxjb21lIHRvIHRoZSBMb2dvIEdlbmVyYXRvciEqKlxuXG5JJ2xsIGhlbHAgeW91IGNyZWF0ZSBhIHByb2Zlc3Npb25hbCBsb2dvIHVzaW5nIEdvb2dsZSdzIEltYWdlbiBBSS4gTGV0J3Mgc3RhcnQgYnkgbGVhcm5pbmcgYWJvdXQgeW91ciBidXNpbmVzcy5cblxuKipXaGF0J3MgdGhlIG5hbWUgb2YgeW91ciBjb21wYW55IG9yIGJyYW5kPyoqXG5cbihUaGlzIHdpbGwgYmUgdGhlIHByaW1hcnkgdGV4dCBpbiB5b3VyIGxvZ28pYDtcbiAgfVxuXG4gIGFzeW5jIHByb2Nlc3NJbnB1dChpbnB1dDogc3RyaW5nLCBjb252ZXhNdXRhdGlvbnM6IENvbnZleE11dGF0aW9ucywgc2Vzc2lvbklkOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRJbnB1dCA9IGlucHV0LnRvTG93ZXJDYXNlKCkudHJpbSgpO1xuICAgIFxuICAgIC8vIERlYnVnIGxvZ2dpbmdcbiAgICBjb25zb2xlLmxvZygn8J+OqCBMb2dvR2VuZXJhdG9yIHByb2Nlc3NJbnB1dDonLCB7XG4gICAgICBpbnB1dDogbm9ybWFsaXplZElucHV0LFxuICAgICAgY3VycmVudFN0ZXA6IHRoaXMuY3VycmVudFN0ZXAsXG4gICAgICBicmllZkV4aXN0czogISF0aGlzLmN1cnJlbnRCcmllZixcbiAgICAgIGNvbXBhbnlOYW1lOiB0aGlzLmN1cnJlbnRCcmllZj8uY29tcGFueU5hbWVcbiAgICB9KTtcbiAgICBcbiAgICAvLyBIYW5kbGUgc2xhc2ggY29tbWFuZHMgZmlyc3RcbiAgICBpZiAobm9ybWFsaXplZElucHV0LnN0YXJ0c1dpdGgoJy9sb2dvJykpIHtcbiAgICAgIHJldHVybiB0aGlzLmhhbmRsZUxvZ29HZW5lcmF0aW9uKGlucHV0LCBjb252ZXhNdXRhdGlvbnMsIHNlc3Npb25JZCk7XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIGNvbnZlcnNhdGlvbiBmbG93IGJhc2VkIG9uIGN1cnJlbnQgc3RlcFxuICAgIHN3aXRjaCAodGhpcy5jdXJyZW50U3RlcCkge1xuICAgICAgY2FzZSAnd2VsY29tZSc6XG4gICAgICAgIHJldHVybiB0aGlzLmhhbmRsZVdlbGNvbWVTdGVwKGlucHV0LCBjb252ZXhNdXRhdGlvbnMsIHNlc3Npb25JZCk7XG4gICAgICBcbiAgICAgIGNhc2UgJ2NvbXBhbnknOlxuICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVDb21wYW55U3RlcChpbnB1dCwgY29udmV4TXV0YXRpb25zLCBzZXNzaW9uSWQpO1xuICAgICAgXG4gICAgICBjYXNlICdidXNpbmVzcyc6XG4gICAgICAgIHJldHVybiB0aGlzLmhhbmRsZUJ1c2luZXNzU3RlcChpbnB1dCwgY29udmV4TXV0YXRpb25zLCBzZXNzaW9uSWQpO1xuICAgICAgXG4gICAgICBjYXNlICdzdHlsZSc6XG4gICAgICAgIHJldHVybiB0aGlzLmhhbmRsZVN0eWxlU3RlcChpbnB1dCwgY29udmV4TXV0YXRpb25zLCBzZXNzaW9uSWQpO1xuICAgICAgXG4gICAgICBjYXNlICdjb2xvcnMnOlxuICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVDb2xvcnNTdGVwKGlucHV0LCBjb252ZXhNdXRhdGlvbnMsIHNlc3Npb25JZCk7XG4gICAgICBcbiAgICAgIGNhc2UgJ3R5cGUnOlxuICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVUeXBlU3RlcChpbnB1dCwgY29udmV4TXV0YXRpb25zLCBzZXNzaW9uSWQpO1xuICAgICAgXG4gICAgICBjYXNlICdhdWRpZW5jZSc6XG4gICAgICAgIHJldHVybiB0aGlzLmhhbmRsZUF1ZGllbmNlU3RlcChpbnB1dCwgY29udmV4TXV0YXRpb25zLCBzZXNzaW9uSWQpO1xuICAgICAgXG4gICAgICBjYXNlICdpbnN0cnVjdGlvbnMnOlxuICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVJbnN0cnVjdGlvbnNTdGVwKGlucHV0LCBjb252ZXhNdXRhdGlvbnMsIHNlc3Npb25JZCk7XG4gICAgICBcbiAgICAgIGNhc2UgJ2dlbmVyYXRlJzpcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlR2VuZXJhdGVTdGVwKGlucHV0LCBjb252ZXhNdXRhdGlvbnMsIHNlc3Npb25JZCk7XG4gICAgICBcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB0aGlzLmdldEluaXRpYWxQcm9tcHQoKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGhhbmRsZVdlbGNvbWVTdGVwKGlucHV0OiBzdHJpbmcsIGNvbnZleE11dGF0aW9uczogQ29udmV4TXV0YXRpb25zLCBzZXNzaW9uSWQ6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgaWYgKCF0aGlzLmN1cnJlbnRCcmllZikge1xuICAgICAgdGhpcy5jdXJyZW50QnJpZWYgPSB7fTtcbiAgICB9XG4gICAgXG4gICAgdGhpcy5jdXJyZW50QnJpZWYuY29tcGFueU5hbWUgPSBpbnB1dC50cmltKCk7XG4gICAgdGhpcy5jdXJyZW50U3RlcCA9ICdidXNpbmVzcyc7XG4gICAgXG4gICAgcmV0dXJuIGBHcmVhdCEgKioke2lucHV0LnRyaW0oKX0qKiBpcyBhIHdvbmRlcmZ1bCBuYW1lLlxuXG5Ob3csIHRlbGwgbWUgYWJvdXQgeW91ciBidXNpbmVzczpcblxuKipXaGF0IGluZHVzdHJ5IGFyZSB5b3UgaW4gYW5kIHdoYXQgZG9lcyAke2lucHV0LnRyaW0oKX0gZG8/KipcblxuKEZvciBleGFtcGxlOiBcIldlJ3JlIGEgc3VzdGFpbmFibGUgZmFzaGlvbiBicmFuZCB0aGF0IGNyZWF0ZXMgZWNvLWZyaWVuZGx5IGNsb3RoaW5nXCIgb3IgXCJXZSBwcm92aWRlIGNsb3VkLWJhc2VkIGFjY291bnRpbmcgc29mdHdhcmUgZm9yIHNtYWxsIGJ1c2luZXNzZXNcIilgO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBoYW5kbGVDb21wYW55U3RlcChpbnB1dDogc3RyaW5nLCBjb252ZXhNdXRhdGlvbnM6IENvbnZleE11dGF0aW9ucywgc2Vzc2lvbklkOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIHRoaXMuY3VycmVudEJyaWVmIS5jb21wYW55TmFtZSA9IGlucHV0LnRyaW0oKTtcbiAgICB0aGlzLmN1cnJlbnRTdGVwID0gJ2J1c2luZXNzJztcbiAgICBcbiAgICByZXR1cm4gYFBlcmZlY3QhIE5vdyBsZXQncyBsZWFybiBhYm91dCAqKiR7aW5wdXQudHJpbSgpfSoqLlxuXG4qKldoYXQgaW5kdXN0cnkgYXJlIHlvdSBpbiBhbmQgd2hhdCBkb2VzIHlvdXIgYnVzaW5lc3MgZG8/KipcblxuKEJlIHNwZWNpZmljIGFib3V0IHlvdXIgcHJvZHVjdHMsIHNlcnZpY2VzLCBvciBtaXNzaW9uLiBUaGlzIGhlbHBzIG1lIHVuZGVyc3RhbmQgdGhlIHJpZ2h0IHZpc3VhbCBkaXJlY3Rpb24gZm9yIHlvdXIgbG9nby4pYDtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgaGFuZGxlQnVzaW5lc3NTdGVwKGlucHV0OiBzdHJpbmcsIGNvbnZleE11dGF0aW9uczogQ29udmV4TXV0YXRpb25zLCBzZXNzaW9uSWQ6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgdGhpcy5jdXJyZW50QnJpZWYhLmJ1c2luZXNzRGVzY3JpcHRpb24gPSBpbnB1dC50cmltKCk7XG4gICAgXG4gICAgLy8gVHJ5IHRvIGV4dHJhY3QgaW5kdXN0cnkgZnJvbSB0aGUgZGVzY3JpcHRpb25cbiAgICBjb25zdCBidXNpbmVzc0Rlc2MgPSBpbnB1dC50b0xvd2VyQ2FzZSgpO1xuICAgIGxldCBzdWdnZXN0ZWRJbmR1c3RyeSA9ICcnO1xuICAgIFxuICAgIGlmIChidXNpbmVzc0Rlc2MuaW5jbHVkZXMoJ3RlY2gnKSB8fCBidXNpbmVzc0Rlc2MuaW5jbHVkZXMoJ3NvZnR3YXJlJykgfHwgYnVzaW5lc3NEZXNjLmluY2x1ZGVzKCdhcHAnKSkge1xuICAgICAgc3VnZ2VzdGVkSW5kdXN0cnkgPSAnVGVjaG5vbG9neSc7XG4gICAgfSBlbHNlIGlmIChidXNpbmVzc0Rlc2MuaW5jbHVkZXMoJ2Zhc2hpb24nKSB8fCBidXNpbmVzc0Rlc2MuaW5jbHVkZXMoJ2Nsb3RoaW5nJykgfHwgYnVzaW5lc3NEZXNjLmluY2x1ZGVzKCdhcHBhcmVsJykpIHtcbiAgICAgIHN1Z2dlc3RlZEluZHVzdHJ5ID0gJ0Zhc2hpb24gJiBSZXRhaWwnO1xuICAgIH0gZWxzZSBpZiAoYnVzaW5lc3NEZXNjLmluY2x1ZGVzKCdmb29kJykgfHwgYnVzaW5lc3NEZXNjLmluY2x1ZGVzKCdyZXN0YXVyYW50JykgfHwgYnVzaW5lc3NEZXNjLmluY2x1ZGVzKCdjdWxpbmFyeScpKSB7XG4gICAgICBzdWdnZXN0ZWRJbmR1c3RyeSA9ICdGb29kICYgQmV2ZXJhZ2UnO1xuICAgIH0gZWxzZSBpZiAoYnVzaW5lc3NEZXNjLmluY2x1ZGVzKCdoZWFsdGgnKSB8fCBidXNpbmVzc0Rlc2MuaW5jbHVkZXMoJ21lZGljYWwnKSB8fCBidXNpbmVzc0Rlc2MuaW5jbHVkZXMoJ3dlbGxuZXNzJykpIHtcbiAgICAgIHN1Z2dlc3RlZEluZHVzdHJ5ID0gJ0hlYWx0aGNhcmUnO1xuICAgIH0gZWxzZSBpZiAoYnVzaW5lc3NEZXNjLmluY2x1ZGVzKCdmaW5hbmNlJykgfHwgYnVzaW5lc3NEZXNjLmluY2x1ZGVzKCdhY2NvdW50aW5nJykgfHwgYnVzaW5lc3NEZXNjLmluY2x1ZGVzKCdiYW5raW5nJykpIHtcbiAgICAgIHN1Z2dlc3RlZEluZHVzdHJ5ID0gJ0ZpbmFuY2lhbCBTZXJ2aWNlcyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN1Z2dlc3RlZEluZHVzdHJ5ID0gJ1Byb2Zlc3Npb25hbCBTZXJ2aWNlcyc7XG4gICAgfVxuICAgIFxuICAgIHRoaXMuY3VycmVudEJyaWVmIS5pbmR1c3RyeSA9IHN1Z2dlc3RlZEluZHVzdHJ5O1xuICAgIHRoaXMuY3VycmVudFN0ZXAgPSAnc3R5bGUnO1xuICAgIFxuICAgIHJldHVybiBgRXhjZWxsZW50ISBJIHVuZGVyc3RhbmQgdGhhdCAke3RoaXMuY3VycmVudEJyaWVmIS5jb21wYW55TmFtZX0gJHtpbnB1dC50cmltKCkudG9Mb3dlckNhc2UoKX0uXG5cbk5vdywgd2hhdCBzdHlsZSBkaXJlY3Rpb24gYXBwZWFscyB0byB5b3U/IENob29zZSBvbmU6XG5cbjEuICoqTWluaW1hbGlzdCoqIC0gQ2xlYW4sIHNpbXBsZSwgdGltZWxlc3NcbjIuICoqTW9kZXJuKiogLSBDb250ZW1wb3JhcnksIHNsZWVrLCBnZW9tZXRyaWNcbjMuICoqVHJhZGl0aW9uYWwqKiAtIENsYXNzaWMsIGVzdGFibGlzaGVkLCB0cnVzdHdvcnRoeVxuNC4gKipQbGF5ZnVsKiogLSBGdW4sIGNyZWF0aXZlLCBhcHByb2FjaGFibGVcbjUuICoqRWxlZ2FudCoqIC0gU29waGlzdGljYXRlZCwgcmVmaW5lZCwgbHV4dXJ5XG42LiAqKkJvbGQqKiAtIFN0cm9uZywgaW1wYWN0ZnVsLCBjb25maWRlbnRcblxuKipUeXBlIHRoZSBudW1iZXIgb3Igc3R5bGUgbmFtZSB5b3UgcHJlZmVyOioqYDtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgaGFuZGxlU3R5bGVTdGVwKGlucHV0OiBzdHJpbmcsIGNvbnZleE11dGF0aW9uczogQ29udmV4TXV0YXRpb25zLCBzZXNzaW9uSWQ6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgY29uc3Qgbm9ybWFsaXplZElucHV0ID0gaW5wdXQudG9Mb3dlckNhc2UoKS50cmltKCk7XG4gICAgbGV0IHNlbGVjdGVkU3R5bGU6IExvZ29CcmllZlsnc3R5bGVQcmVmZXJlbmNlJ107XG4gICAgXG4gICAgLy8gTWFwIGlucHV0IHRvIHN0eWxlIHByZWZlcmVuY2VcbiAgICBpZiAobm9ybWFsaXplZElucHV0LmluY2x1ZGVzKCcxJykgfHwgbm9ybWFsaXplZElucHV0LmluY2x1ZGVzKCdtaW5pbWFsaXN0JykpIHtcbiAgICAgIHNlbGVjdGVkU3R5bGUgPSAnbWluaW1hbGlzdCc7XG4gICAgfSBlbHNlIGlmIChub3JtYWxpemVkSW5wdXQuaW5jbHVkZXMoJzInKSB8fCBub3JtYWxpemVkSW5wdXQuaW5jbHVkZXMoJ21vZGVybicpKSB7XG4gICAgICBzZWxlY3RlZFN0eWxlID0gJ21vZGVybic7XG4gICAgfSBlbHNlIGlmIChub3JtYWxpemVkSW5wdXQuaW5jbHVkZXMoJzMnKSB8fCBub3JtYWxpemVkSW5wdXQuaW5jbHVkZXMoJ3RyYWRpdGlvbmFsJykpIHtcbiAgICAgIHNlbGVjdGVkU3R5bGUgPSAndHJhZGl0aW9uYWwnO1xuICAgIH0gZWxzZSBpZiAobm9ybWFsaXplZElucHV0LmluY2x1ZGVzKCc0JykgfHwgbm9ybWFsaXplZElucHV0LmluY2x1ZGVzKCdwbGF5ZnVsJykpIHtcbiAgICAgIHNlbGVjdGVkU3R5bGUgPSAncGxheWZ1bCc7XG4gICAgfSBlbHNlIGlmIChub3JtYWxpemVkSW5wdXQuaW5jbHVkZXMoJzUnKSB8fCBub3JtYWxpemVkSW5wdXQuaW5jbHVkZXMoJ2VsZWdhbnQnKSkge1xuICAgICAgc2VsZWN0ZWRTdHlsZSA9ICdlbGVnYW50JztcbiAgICB9IGVsc2UgaWYgKG5vcm1hbGl6ZWRJbnB1dC5pbmNsdWRlcygnNicpIHx8IG5vcm1hbGl6ZWRJbnB1dC5pbmNsdWRlcygnYm9sZCcpKSB7XG4gICAgICBzZWxlY3RlZFN0eWxlID0gJ2JvbGQnO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYEkgZGlkbid0IHVuZGVyc3RhbmQgdGhhdCBzdHlsZSBjaG9pY2UuIFBsZWFzZSBjaG9vc2U6XG5cbjEuICoqTWluaW1hbGlzdCoqIDIuICoqTW9kZXJuKiogMy4gKipUcmFkaXRpb25hbCoqIDQuICoqUGxheWZ1bCoqIDUuICoqRWxlZ2FudCoqIDYuICoqQm9sZCoqXG5cbioqVHlwZSB0aGUgbnVtYmVyIG9yIHN0eWxlIG5hbWU6KipgO1xuICAgIH1cbiAgICBcbiAgICB0aGlzLmN1cnJlbnRCcmllZiEuc3R5bGVQcmVmZXJlbmNlID0gc2VsZWN0ZWRTdHlsZTtcbiAgICB0aGlzLmN1cnJlbnRTdGVwID0gJ2NvbG9ycyc7XG4gICAgXG4gICAgcmV0dXJuIGBQZXJmZWN0ISBBICoqJHtzZWxlY3RlZFN0eWxlfSoqIHN0eWxlIHdpbGwgd29yayBncmVhdCBmb3IgJHt0aGlzLmN1cnJlbnRCcmllZiEuY29tcGFueU5hbWV9LlxuXG4qKldoYXQgY29sb3IgcHJlZmVyZW5jZXMgZG8geW91IGhhdmU/KipcblxuWW91IGNhbiBtZW50aW9uOlxuLSBTcGVjaWZpYyBjb2xvcnMgKGJsdWUsIGdyZWVuLCByZWQsIGV0Yy4pXG4tIENvbG9yIHRoZW1lcyAoY29ycG9yYXRlLCB2aWJyYW50LCBlYXJ0aHksIGV0Yy4pICBcbi0gXCJObyBwcmVmZXJlbmNlXCIgaWYgeW91IHdhbnQgbWUgdG8gc3VnZ2VzdCBjb2xvcnMgYmFzZWQgb24geW91ciBpbmR1c3RyeVxuXG4qKllvdXIgY29sb3IgcHJlZmVyZW5jZToqKmA7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGhhbmRsZUNvbG9yc1N0ZXAoaW5wdXQ6IHN0cmluZywgY29udmV4TXV0YXRpb25zOiBDb252ZXhNdXRhdGlvbnMsIHNlc3Npb25JZDogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICBjb25zdCBjb2xvcklucHV0ID0gaW5wdXQudHJpbSgpO1xuICAgIHRoaXMuY3VycmVudEJyaWVmIS5jb2xvclByZWZlcmVuY2VzID0gW2NvbG9ySW5wdXRdO1xuICAgIHRoaXMuY3VycmVudFN0ZXAgPSAndHlwZSc7XG4gICAgXG4gICAgcmV0dXJuIGBHcmVhdCBjb2xvciBjaG9pY2UhIE5vdywgd2hhdCB0eXBlIG9mIGxvZ28gZG8geW91IHByZWZlcj9cblxuMS4gKipUZXh0LW9ubHkqKiAtIENvbXBhbnkgbmFtZSBzdHlsZWQgYmVhdXRpZnVsbHkgKGxpa2UgR29vZ2xlLCBDb2NhLUNvbGEpXG4yLiAqKkljb24tb25seSoqIC0gQSBzeW1ib2wgdGhhdCByZXByZXNlbnRzIHlvdXIgYnJhbmQgKGxpa2UgQXBwbGUsIE5pa2Ugc3dvb3NoKVxuMy4gKipDb21iaW5hdGlvbioqIC0gQm90aCB0ZXh0IGFuZCBpY29uIHRvZ2V0aGVyIChsaWtlIEFkaWRhcywgTWNEb25hbGQncylcblxuKipUeXBlIHRoZSBudW1iZXIgb3IgbG9nbyB0eXBlIHlvdSBwcmVmZXI6KipgO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBoYW5kbGVUeXBlU3RlcChpbnB1dDogc3RyaW5nLCBjb252ZXhNdXRhdGlvbnM6IENvbnZleE11dGF0aW9ucywgc2Vzc2lvbklkOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRJbnB1dCA9IGlucHV0LnRvTG93ZXJDYXNlKCkudHJpbSgpO1xuICAgIGxldCBsb2dvVHlwZTogTG9nb0JyaWVmWydsb2dvVHlwZSddO1xuICAgIFxuICAgIGlmIChub3JtYWxpemVkSW5wdXQuaW5jbHVkZXMoJzEnKSB8fCBub3JtYWxpemVkSW5wdXQuaW5jbHVkZXMoJ3RleHQnKSkge1xuICAgICAgbG9nb1R5cGUgPSAndGV4dCc7XG4gICAgfSBlbHNlIGlmIChub3JtYWxpemVkSW5wdXQuaW5jbHVkZXMoJzInKSB8fCBub3JtYWxpemVkSW5wdXQuaW5jbHVkZXMoJ2ljb24nKSkge1xuICAgICAgbG9nb1R5cGUgPSAnaWNvbic7XG4gICAgfSBlbHNlIGlmIChub3JtYWxpemVkSW5wdXQuaW5jbHVkZXMoJzMnKSB8fCBub3JtYWxpemVkSW5wdXQuaW5jbHVkZXMoJ2NvbWJpbmF0aW9uJykpIHtcbiAgICAgIGxvZ29UeXBlID0gJ2NvbWJpbmF0aW9uJztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGBQbGVhc2UgY2hvb3NlIGEgbG9nbyB0eXBlOlxuXG4xLiAqKlRleHQtb25seSoqIDIuICoqSWNvbi1vbmx5KiogMy4gKipDb21iaW5hdGlvbioqXG5cbioqVHlwZSB0aGUgbnVtYmVyIG9yIGxvZ28gdHlwZToqKmA7XG4gICAgfVxuICAgIFxuICAgIHRoaXMuY3VycmVudEJyaWVmIS5sb2dvVHlwZSA9IGxvZ29UeXBlO1xuICAgIHRoaXMuY3VycmVudFN0ZXAgPSAnYXVkaWVuY2UnO1xuICAgIFxuICAgIHJldHVybiBgRXhjZWxsZW50ISBBICoqJHtsb2dvVHlwZX0qKiBsb2dvIHdpbGwgYmUgcGVyZmVjdC5cblxuKipXaG8gaXMgeW91ciB0YXJnZXQgYXVkaWVuY2U/KipcblxuKEZvciBleGFtcGxlOiBcIllvdW5nIHByb2Zlc3Npb25hbHNcIiwgXCJGYW1pbGllcyB3aXRoIGNoaWxkcmVuXCIsIFwiU21hbGwgYnVzaW5lc3Mgb3duZXJzXCIsIFwiVGVjaCBzdGFydHVwc1wiLCBldGMuIFRoaXMgaGVscHMgaW5mb3JtIHRoZSBkZXNpZ24gYXBwcm9hY2guKWA7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGhhbmRsZUF1ZGllbmNlU3RlcChpbnB1dDogc3RyaW5nLCBjb252ZXhNdXRhdGlvbnM6IENvbnZleE11dGF0aW9ucywgc2Vzc2lvbklkOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIHRoaXMuY3VycmVudEJyaWVmIS50YXJnZXRBdWRpZW5jZSA9IGlucHV0LnRyaW0oKTtcbiAgICB0aGlzLmN1cnJlbnRTdGVwID0gJ2luc3RydWN0aW9ucyc7XG4gICAgXG4gICAgcmV0dXJuIGBQZXJmZWN0ISBVbmRlcnN0YW5kaW5nIHlvdXIgYXVkaWVuY2UgaGVscHMgY3JlYXRlIHRoZSByaWdodCB2aXN1YWwgaW1wYWN0LlxuXG4qKkFueSBhZGRpdGlvbmFsIGluc3RydWN0aW9ucyBvciBzcGVjaWZpYyBlbGVtZW50cyB5b3UnZCBsaWtlIGluY2x1ZGVkPyoqXG5cbihPcHRpb25hbCAtIHlvdSBjYW4gbWVudGlvbiBzcGVjaWZpYyBzeW1ib2xzLCBhdm9pZCBjZXJ0YWluIGVsZW1lbnRzLCBvciBzYXkgXCJub25lXCIgdG8gcHJvY2VlZClcblxuKipBZGRpdGlvbmFsIGluc3RydWN0aW9uczoqKmA7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGhhbmRsZUluc3RydWN0aW9uc1N0ZXAoaW5wdXQ6IHN0cmluZywgY29udmV4TXV0YXRpb25zOiBDb252ZXhNdXRhdGlvbnMsIHNlc3Npb25JZDogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICBjb25zdCBpbnN0cnVjdGlvbnMgPSBpbnB1dC50cmltKCk7XG4gICAgaWYgKGluc3RydWN0aW9ucy50b0xvd2VyQ2FzZSgpICE9PSAnbm9uZScpIHtcbiAgICAgIHRoaXMuY3VycmVudEJyaWVmIS5hZGRpdGlvbmFsSW5zdHJ1Y3Rpb25zID0gaW5zdHJ1Y3Rpb25zO1xuICAgIH1cbiAgICBcbiAgICB0aGlzLmN1cnJlbnRTdGVwID0gJ2dlbmVyYXRlJztcbiAgICBcbiAgICBjb25zdCBicmllZiA9IHRoaXMuY3VycmVudEJyaWVmITtcbiAgICBcbiAgICByZXR1cm4gYPCfjq8gKipMb2dvIEJyaWVmIENvbXBsZXRlISoqXG5cbkhlcmUncyB3aGF0IEknbGwgY3JlYXRlIGZvciB5b3U6XG5cbuKAoiAqKkNvbXBhbnk6KiogJHticmllZi5jb21wYW55TmFtZX1cbuKAoiAqKkJ1c2luZXNzOioqICR7YnJpZWYuYnVzaW5lc3NEZXNjcmlwdGlvbn1cbuKAoiAqKkluZHVzdHJ5OioqICR7YnJpZWYuaW5kdXN0cnl9XG7igKIgKipTdHlsZToqKiAke2JyaWVmLnN0eWxlUHJlZmVyZW5jZX1cbuKAoiAqKkNvbG9yczoqKiAke2JyaWVmLmNvbG9yUHJlZmVyZW5jZXM/LlswXX1cbuKAoiAqKlR5cGU6KiogJHticmllZi5sb2dvVHlwZX1cbuKAoiAqKkF1ZGllbmNlOioqICR7YnJpZWYudGFyZ2V0QXVkaWVuY2V9XG4ke2JyaWVmLmFkZGl0aW9uYWxJbnN0cnVjdGlvbnMgPyBg4oCiICoqU3BlY2lhbCBJbnN0cnVjdGlvbnM6KiogJHticmllZi5hZGRpdGlvbmFsSW5zdHJ1Y3Rpb25zfWAgOiAnJ31cblxuKipSZWFkeSB0byBnZW5lcmF0ZSB5b3VyIGxvZ28/KipcblxuVHlwZSBcInllc1wiIHRvIHN0YXJ0IGdlbmVyYXRpb24gb3IgXCJlZGl0XCIgaWYgeW91IHdhbnQgdG8gbW9kaWZ5IGFueXRoaW5nLmA7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGhhbmRsZUdlbmVyYXRlU3RlcChpbnB1dDogc3RyaW5nLCBjb252ZXhNdXRhdGlvbnM6IENvbnZleE11dGF0aW9ucywgc2Vzc2lvbklkOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRJbnB1dCA9IGlucHV0LnRvTG93ZXJDYXNlKCkudHJpbSgpO1xuICAgIFxuICAgIGlmIChub3JtYWxpemVkSW5wdXQuaW5jbHVkZXMoJ2VkaXQnKSB8fCBub3JtYWxpemVkSW5wdXQuaW5jbHVkZXMoJ21vZGlmeScpKSB7XG4gICAgICB0aGlzLmN1cnJlbnRTdGVwID0gJ3dlbGNvbWUnO1xuICAgICAgdGhpcy5jdXJyZW50QnJpZWYgPSB7fTtcbiAgICAgIHJldHVybiBgTm8gcHJvYmxlbSEgTGV0J3Mgc3RhcnQgb3ZlciB3aXRoIGFueSBjaGFuZ2VzIHlvdSdkIGxpa2UgdG8gbWFrZS5cblxuKipXaGF0J3MgdGhlIG5hbWUgb2YgeW91ciBjb21wYW55IG9yIGJyYW5kPyoqYDtcbiAgICB9XG4gICAgXG4gICAgaWYgKG5vcm1hbGl6ZWRJbnB1dC5pbmNsdWRlcygneWVzJykgfHwgbm9ybWFsaXplZElucHV0LmluY2x1ZGVzKCdnZW5lcmF0ZScpIHx8IG5vcm1hbGl6ZWRJbnB1dC5pbmNsdWRlcygnY3JlYXRlJykpIHtcbiAgICAgIHJldHVybiB0aGlzLmhhbmRsZUxvZ29HZW5lcmF0aW9uKGlucHV0LCBjb252ZXhNdXRhdGlvbnMsIHNlc3Npb25JZCk7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBgUGxlYXNlIHR5cGUgXCJ5ZXNcIiB0byBnZW5lcmF0ZSB5b3VyIGxvZ28gb3IgXCJlZGl0XCIgdG8gbWFrZSBjaGFuZ2VzIHRvIHlvdXIgYnJpZWYuYDtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgaGFuZGxlTG9nb0dlbmVyYXRpb24oaW5wdXQ6IHN0cmluZywgY29udmV4TXV0YXRpb25zOiBDb252ZXhNdXRhdGlvbnMsIHNlc3Npb25JZD86IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgY29uc3QgYnJpZWYgPSB0aGlzLmN1cnJlbnRCcmllZjtcbiAgICBcbiAgICBpZiAoIWJyaWVmIHx8ICFicmllZi5jb21wYW55TmFtZSkge1xuICAgICAgdGhpcy5jdXJyZW50U3RlcCA9ICd3ZWxjb21lJztcbiAgICAgIHJldHVybiBgSSBuZWVkIG1vcmUgaW5mb3JtYXRpb24gdG8gZ2VuZXJhdGUgeW91ciBsb2dvLiBMZXQncyBzdGFydCB3aXRoIHlvdXIgY29tcGFueSBuYW1lLlxuXG4qKldoYXQncyB0aGUgbmFtZSBvZiB5b3VyIGNvbXBhbnkgb3IgYnJhbmQ/KipgO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICAvLyBDcmVhdGUgY29uc29saWRhdGVkIHByb21wdCBmcm9tIHRoZSBicmllZiB1c2luZyB0aGUgbmV3IE9wZW5BSSBzeXN0ZW1cbiAgICAgIGNvbnN0IGxvZ29Qcm9tcHQgPSB0aGlzLmNyZWF0ZUNvbnNvbGlkYXRlZExvZ29Qcm9tcHQoYnJpZWYpO1xuICAgICAgXG4gICAgICAvLyBDYWxsIG91ciBBUEkgcm91dGUgaW5zdGVhZCBvZiBkaXJlY3QgT3BlbkFJIGNhbGwgKGZvciBzZXJ2ZXItc2lkZSBleGVjdXRpb24pXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCcvYXBpL2dlbmVyYXRlLWxvZ28nLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIHByb21wdDogbG9nb1Byb21wdCxcbiAgICAgICAgICBzdHlsZTogJ3ZpdmlkJywgLy8gUHJvZmVzc2lvbmFsIGxvZ28gc3R5bGVcbiAgICAgICAgICBzaXplOiAnMTAyNHgxMDI0JywgLy8gU3F1YXJlIGZvcm1hdCB3b3JrcyBiZXN0IGZvciBsb2dvc1xuICAgICAgICAgIHF1YWxpdHk6ICdoZCcsIC8vIEhpZ2ggcXVhbGl0eSBmb3IgcHJvZmVzc2lvbmFsIHJlc3VsdHNcbiAgICAgICAgICBudW1iZXJPZkltYWdlczogMVxuICAgICAgICB9KSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBnZW5lcmF0aW9uUmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgXG4gICAgICBjb25zb2xlLmxvZygn8J+OqCBMb2dvIGdlbmVyYXRpb24gcmVzdWx0OicsIHtcbiAgICAgICAgc3VjY2VzczogZ2VuZXJhdGlvblJlc3VsdC5zdWNjZXNzLFxuICAgICAgICBoYXNJbWFnZVVybDogISFnZW5lcmF0aW9uUmVzdWx0LmltYWdlVXJsLFxuICAgICAgICBpbWFnZVVybExlbmd0aDogZ2VuZXJhdGlvblJlc3VsdC5pbWFnZVVybD8ubGVuZ3RoLFxuICAgICAgICBpbWFnZVVybFByZXZpZXc6IGdlbmVyYXRpb25SZXN1bHQuaW1hZ2VVcmw/LnN1YnN0cmluZygwLCA1MCksXG4gICAgICAgIHJldmlzZWRQcm9tcHQ6IGdlbmVyYXRpb25SZXN1bHQucmV2aXNlZFByb21wdCxcbiAgICAgICAgZXJyb3I6IGdlbmVyYXRpb25SZXN1bHQuZXJyb3JcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBpZiAoZ2VuZXJhdGlvblJlc3VsdC5zdWNjZXNzICYmIGdlbmVyYXRpb25SZXN1bHQuaW1hZ2VVcmwpIHtcbiAgICAgICAgLy8gU3RvcmUgdGhlIGdlbmVyYXRlZCBsb2dvIGluIENvbnZleCBkYXRhYmFzZSBmb3IgcGVyc2lzdGVuY2VcbiAgICAgICAgaWYgKHNlc3Npb25JZCAmJiBjb252ZXhNdXRhdGlvbnMuY3JlYXRlTG9nb0dlbmVyYXRpb24pIHtcbiAgICAgICAgICBhd2FpdCBjb252ZXhNdXRhdGlvbnMuY3JlYXRlTG9nb0dlbmVyYXRpb24oe1xuICAgICAgICAgICAgc2Vzc2lvbklkLFxuICAgICAgICAgICAgbG9nb1N2ZzogZ2VuZXJhdGlvblJlc3VsdC5pbWFnZVVybCwgLy8gU3RvcmUgYWN0dWFsIGltYWdlIGRhdGEgaW5zdGVhZCBvZiBlbXB0eSBzdHJpbmdcbiAgICAgICAgICAgIHByb21wdDogbG9nb1Byb21wdCxcbiAgICAgICAgICAgIGJyaWVmOiB7XG4gICAgICAgICAgICAgIGNvbXBhbnlOYW1lOiBicmllZi5jb21wYW55TmFtZSB8fCAnVW5rbm93bicsXG4gICAgICAgICAgICAgIGJ1c2luZXNzOiBicmllZi5idXNpbmVzc0Rlc2NyaXB0aW9uIHx8ICdVbmtub3duJyxcbiAgICAgICAgICAgICAgc3R5bGVQcmVmZXJlbmNlOiBicmllZi5zdHlsZVByZWZlcmVuY2UgfHwgJ21vZGVybicsXG4gICAgICAgICAgICAgIGNvbG9yUHJlZmVyZW5jZXM6IGJyaWVmLmNvbG9yUHJlZmVyZW5jZXMgfHwgWydibHVlJ10sXG4gICAgICAgICAgICAgIGxvZ29UeXBlOiBicmllZi5sb2dvVHlwZSB8fCAnY29tYmluYXRpb24nLFxuICAgICAgICAgICAgICB0YXJnZXRBdWRpZW5jZTogYnJpZWYudGFyZ2V0QXVkaWVuY2UgfHwgJ2dlbmVyYWwnLFxuICAgICAgICAgICAgICBzcGVjaWFsSW5zdHJ1Y3Rpb25zOiBicmllZi5hZGRpdGlvbmFsSW5zdHJ1Y3Rpb25zXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3RhdHVzOiAnY29tcGxldGVkJ1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU3RvcmUgdGhlIGdlbmVyYXRlZCBsb2dvIGluIGNoYXQgbWVzc2FnZXMgZm9yIGRpc3BsYXlcbiAgICAgICAgaWYgKHNlc3Npb25JZCAmJiBjb252ZXhNdXRhdGlvbnMuc3RvcmVDaGF0TWVzc2FnZSkge1xuICAgICAgICAgIGF3YWl0IGNvbnZleE11dGF0aW9ucy5zdG9yZUNoYXRNZXNzYWdlKHtcbiAgICAgICAgICAgIHJvbGU6IFwiYXNzaXN0YW50XCIsXG4gICAgICAgICAgICBjb250ZW50OiBg8J+OqCAqKkxvZ28gR2VuZXJhdGVkIFN1Y2Nlc3NmdWxseSEqKlxuXG5IZXJlJ3MgeW91ciBjdXN0b20gbG9nbyBmb3IgKioke2JyaWVmLmNvbXBhbnlOYW1lfSoqOlxuXG4hW0dlbmVyYXRlZCBMb2dvXSgke2dlbmVyYXRpb25SZXN1bHQuaW1hZ2VVcmx9KVxuXG4qKkdlbmVyYXRpb24gRGV0YWlsczoqKlxu4oCiICoqU3R5bGU6KiogJHticmllZi5zdHlsZVByZWZlcmVuY2V9XG7igKIgKipUeXBlOioqICR7YnJpZWYubG9nb1R5cGV9XG7igKIgKipDb2xvcnM6KiogJHticmllZi5jb2xvclByZWZlcmVuY2VzPy5bMF19XG7igKIgKipUYXJnZXQgQXVkaWVuY2U6KiogJHticmllZi50YXJnZXRBdWRpZW5jZX1cblxuKipPcGVuQUkgREFMTC1FIFByb21wdCBVc2VkOioqXG5cXGAke2xvZ29Qcm9tcHR9XFxgXG5cbiR7Z2VuZXJhdGlvblJlc3VsdC5yZXZpc2VkUHJvbXB0ICYmIGdlbmVyYXRpb25SZXN1bHQucmV2aXNlZFByb21wdCAhPT0gbG9nb1Byb21wdCA/IGBcbioqQUktUmV2aXNlZCBQcm9tcHQ6KipcblxcYCR7Z2VuZXJhdGlvblJlc3VsdC5yZXZpc2VkUHJvbXB0fVxcYGAgOiAnJ31cblxuKipXaGF0J3MgTmV4dD8qKlxuMS4gKipHZW5lcmF0ZSBWYXJpYXRpb24qKiAtIENyZWF0ZSBhbm90aGVyIHZlcnNpb25cbjIuICoqRXhwb3J0IExvZ28qKiAtIERvd25sb2FkIGluIGRpZmZlcmVudCBmb3JtYXRzXG4zLiAqKlN0YXJ0IE5ldyBQcm9qZWN0KiogLSBDcmVhdGUgYW5vdGhlciBsb2dvXG5cblR5cGUgeW91ciBjaG9pY2UgdG8gY29udGludWUhYCxcbiAgICAgICAgICAgIHNlc3Npb25JZCxcbiAgICAgICAgICAgIG9wZXJhdGlvbjoge1xuICAgICAgICAgICAgICB0eXBlOiBcInRvb2xfZXhlY3V0ZWRcIixcbiAgICAgICAgICAgICAgZGV0YWlsczoge1xuICAgICAgICAgICAgICAgIHRvb2w6IFwibG9nb19nZW5lcmF0aW9uXCIsXG4gICAgICAgICAgICAgICAgaW1hZ2VVcmw6IGdlbmVyYXRpb25SZXN1bHQuaW1hZ2VVcmwsXG4gICAgICAgICAgICAgICAgaW1hZ2VEYXRhOiBnZW5lcmF0aW9uUmVzdWx0LmltYWdlRGF0YSxcbiAgICAgICAgICAgICAgICBwcm9tcHQ6IGxvZ29Qcm9tcHQsXG4gICAgICAgICAgICAgICAgYnJpZWY6IGJyaWVmXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gUmVzZXQgZm9yIG5leHQgZ2VuZXJhdGlvblxuICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gYPCfjqggKipMb2dvIEdlbmVyYXRlZCBTdWNjZXNzZnVsbHkhKipcblxuWW91ciBjdXN0b20gbG9nbyBmb3IgKioke2JyaWVmLmNvbXBhbnlOYW1lfSoqIGhhcyBiZWVuIGNyZWF0ZWQgYW5kIHdpbGwgYXBwZWFyIGluIHRoZSBMb2dvIEdlbmVyYXRvciB0YWIuXG5cbioqR2VuZXJhdGlvbiBEZXRhaWxzOioqXG7igKIgKipTdHlsZToqKiAke2JyaWVmLnN0eWxlUHJlZmVyZW5jZX1cbuKAoiAqKlR5cGU6KiogJHticmllZi5sb2dvVHlwZX1cbuKAoiAqKkNvbG9yczoqKiAke2JyaWVmLmNvbG9yUHJlZmVyZW5jZXM/LlswXX1cbuKAoiAqKlRhcmdldCBBdWRpZW5jZToqKiAke2JyaWVmLnRhcmdldEF1ZGllbmNlfVxuXG5UaGUgbG9nbyBpcyBub3cgYXZhaWxhYmxlIGluIHRoZSBwcmV2aWV3IHBhbmVsLiBZb3UgY2FuOlxuXG4xLiAqKkdlbmVyYXRlIFZhcmlhdGlvbioqIC0gQ3JlYXRlIGFub3RoZXIgdmVyc2lvblxuMi4gKipFeHBvcnQgTG9nbyoqIC0gRG93bmxvYWQgaW4gZGlmZmVyZW50IGZvcm1hdHMgIFxuMy4gKipTdGFydCBOZXcgUHJvamVjdCoqIC0gQ3JlYXRlIGFub3RoZXIgbG9nb1xuXG5UeXBlIHlvdXIgY2hvaWNlIHRvIGNvbnRpbnVlIWA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gYOKdjCAqKkxvZ28gR2VuZXJhdGlvbiBGYWlsZWQqKlxuXG5Tb3JyeSwgdGhlcmUgd2FzIGFuIGlzc3VlIGdlbmVyYXRpbmcgeW91ciBsb2dvOiAke2dlbmVyYXRpb25SZXN1bHQuZXJyb3IgfHwgJ1Vua25vd24gZXJyb3InfVxuXG5QbGVhc2UgdHJ5IGFnYWluIG9yIG1vZGlmeSB5b3VyIHJlcXVpcmVtZW50cy4gVHlwZSBcInJlc3RhcnRcIiB0byBiZWdpbiB3aXRoIGEgbmV3IGJyaWVmLmA7XG4gICAgICB9XG4gICAgICBcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcign4p2MIExvZ28gZ2VuZXJhdGlvbiBlcnJvcjonLCBlcnJvcik7XG4gICAgICByZXR1cm4gYOKdjCAqKkxvZ28gR2VuZXJhdGlvbiBFcnJvcioqXG5cbkFuIHVuZXhwZWN0ZWQgZXJyb3Igb2NjdXJyZWQgZHVyaW5nIGxvZ28gZ2VuZXJhdGlvbi4gUGxlYXNlIHRyeSBhZ2Fpbi5cblxuRXJyb3I6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcid9XG5cblR5cGUgXCJyZXN0YXJ0XCIgdG8gYmVnaW4gd2l0aCBhIG5ldyBicmllZi5gO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgY3JlYXRlSW1hZ2VuUHJvbXB0KGJyaWVmOiBQYXJ0aWFsPExvZ29CcmllZj4pOiBzdHJpbmcge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbXBhbnlOYW1lLFxuICAgICAgYnVzaW5lc3NEZXNjcmlwdGlvbixcbiAgICAgIHN0eWxlUHJlZmVyZW5jZSxcbiAgICAgIGNvbG9yUHJlZmVyZW5jZXMsXG4gICAgICBsb2dvVHlwZSxcbiAgICAgIHRhcmdldEF1ZGllbmNlLFxuICAgICAgYWRkaXRpb25hbEluc3RydWN0aW9uc1xuICAgIH0gPSBicmllZjtcblxuICAgIGxldCBwcm9tcHQgPSBgQ3JlYXRlIGEgcHJvZmVzc2lvbmFsIGxvZ28gZGVzaWduIGZvciBcIiR7Y29tcGFueU5hbWV9XCJgO1xuICAgIFxuICAgIGlmIChidXNpbmVzc0Rlc2NyaXB0aW9uKSB7XG4gICAgICBwcm9tcHQgKz0gYCwgYSBjb21wYW55IHRoYXQgJHtidXNpbmVzc0Rlc2NyaXB0aW9uLnRvTG93ZXJDYXNlKCl9YDtcbiAgICB9XG4gICAgXG4gICAgaWYgKHN0eWxlUHJlZmVyZW5jZSkge1xuICAgICAgcHJvbXB0ICs9IGAuIFN0eWxlOiAke3N0eWxlUHJlZmVyZW5jZX1gO1xuICAgIH1cbiAgICBcbiAgICBpZiAobG9nb1R5cGUpIHtcbiAgICAgIGlmIChsb2dvVHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgIHByb21wdCArPSAnLiBUZXh0LW9ubHkgbG9nbyB3aXRoIHN0eWxpemVkIHR5cG9ncmFwaHknO1xuICAgICAgfSBlbHNlIGlmIChsb2dvVHlwZSA9PT0gJ2ljb24nKSB7XG4gICAgICAgIHByb21wdCArPSAnLiBJY29uLW9ubHkgbG9nbywgbm8gdGV4dCwgc3ltYm9saWMgZGVzaWduJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb21wdCArPSAnLiBDb21iaW5hdGlvbiBsb2dvIHdpdGggYm90aCB0ZXh0IGFuZCBpY29uIGVsZW1lbnRzJztcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgaWYgKGNvbG9yUHJlZmVyZW5jZXMgJiYgY29sb3JQcmVmZXJlbmNlc1swXSAmJiBjb2xvclByZWZlcmVuY2VzWzBdLnRvTG93ZXJDYXNlKCkgIT09ICdubyBwcmVmZXJlbmNlJykge1xuICAgICAgcHJvbXB0ICs9IGAuIENvbG9yIHNjaGVtZTogJHtjb2xvclByZWZlcmVuY2VzWzBdfWA7XG4gICAgfVxuICAgIFxuICAgIGlmICh0YXJnZXRBdWRpZW5jZSkge1xuICAgICAgcHJvbXB0ICs9IGAuIFRhcmdldCBhdWRpZW5jZTogJHt0YXJnZXRBdWRpZW5jZX1gO1xuICAgIH1cbiAgICBcbiAgICBpZiAoYWRkaXRpb25hbEluc3RydWN0aW9ucykge1xuICAgICAgcHJvbXB0ICs9IGAuIFNwZWNpYWwgcmVxdWlyZW1lbnRzOiAke2FkZGl0aW9uYWxJbnN0cnVjdGlvbnN9YDtcbiAgICB9XG4gICAgXG4gICAgcHJvbXB0ICs9ICcuIEhpZ2ggcXVhbGl0eSwgcHJvZmVzc2lvbmFsLCBzY2FsYWJsZSB2ZWN0b3IgZGVzaWduLCBjbGVhbiBiYWNrZ3JvdW5kLCBzdWl0YWJsZSBmb3IgYnVzaW5lc3MgdXNlLic7XG4gICAgXG4gICAgcmV0dXJuIHByb21wdDtcbiAgfVxuXG4gIC8vIFJlc2V0IHRoZSBhZ2VudCBzdGF0ZVxuICByZXNldCgpOiB2b2lkIHtcbiAgICB0aGlzLmN1cnJlbnRCcmllZiA9IHt9O1xuICAgIHRoaXMuY3VycmVudFN0ZXAgPSAnd2VsY29tZSc7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGNvbnNvbGlkYXRlZCBsb2dvIHByb21wdCB1c2luZyB0aGUgdW5pZmllZCBPcGVuQUkgc3lzdGVtXG4gICAqIENvbWJpbmVzIGFsbCBicmllZiBlbGVtZW50cyBpbnRvIGEgc2luZ2xlIG9wdGltaXplZCBwcm9tcHRcbiAgICovXG4gIHByaXZhdGUgY3JlYXRlQ29uc29saWRhdGVkTG9nb1Byb21wdChicmllZjogUGFydGlhbDxMb2dvQnJpZWY+KTogc3RyaW5nIHtcbiAgICBsZXQgYmFzZVByb21wdCA9IGBQcm9mZXNzaW9uYWwgbG9nbyBkZXNpZ24gZm9yICR7YnJpZWYuY29tcGFueU5hbWV9YDtcbiAgICBcbiAgICBpZiAoYnJpZWYuYnVzaW5lc3NEZXNjcmlwdGlvbikge1xuICAgICAgYmFzZVByb21wdCArPSBgLCBhICR7YnJpZWYuYnVzaW5lc3NEZXNjcmlwdGlvbn1gO1xuICAgIH1cbiAgICBcbiAgICBpZiAoYnJpZWYuaW5kdXN0cnkpIHtcbiAgICAgIGJhc2VQcm9tcHQgKz0gYCBpbiB0aGUgJHticmllZi5pbmR1c3RyeX0gaW5kdXN0cnlgO1xuICAgIH1cbiAgICBcbiAgICAvLyBTdHlsZSBwcmVmZXJlbmNlc1xuICAgIGlmIChicmllZi5zdHlsZVByZWZlcmVuY2UgJiYgYnJpZWYuc3R5bGVQcmVmZXJlbmNlICE9PSAnbW9kZXJuJykge1xuICAgICAgYmFzZVByb21wdCArPSBgLCAke2JyaWVmLnN0eWxlUHJlZmVyZW5jZX0gc3R5bGVgO1xuICAgIH1cbiAgICBcbiAgICAvLyBMb2dvIHR5cGVcbiAgICBpZiAoYnJpZWYubG9nb1R5cGUgJiYgYnJpZWYubG9nb1R5cGUgIT09ICdjb21iaW5hdGlvbicpIHtcbiAgICAgIGlmIChicmllZi5sb2dvVHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgIGJhc2VQcm9tcHQgKz0gYCwgdGV4dC1iYXNlZCBsb2dvYDtcbiAgICAgIH0gZWxzZSBpZiAoYnJpZWYubG9nb1R5cGUgPT09ICdpY29uJykge1xuICAgICAgICBiYXNlUHJvbXB0ICs9IGAsIGljb24tb25seSBsb2dvYDtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gQ29sb3IgcHJlZmVyZW5jZXNcbiAgICBpZiAoYnJpZWYuY29sb3JQcmVmZXJlbmNlcyAmJiBicmllZi5jb2xvclByZWZlcmVuY2VzWzBdICYmIFxuICAgICAgICBicmllZi5jb2xvclByZWZlcmVuY2VzWzBdLnRvTG93ZXJDYXNlKCkgIT09ICdubyBwcmVmZXJlbmNlJykge1xuICAgICAgYmFzZVByb21wdCArPSBgLCB1c2luZyAke2JyaWVmLmNvbG9yUHJlZmVyZW5jZXNbMF19IGNvbG9yIHNjaGVtZWA7XG4gICAgfVxuICAgIFxuICAgIC8vIFRhcmdldCBhdWRpZW5jZVxuICAgIGlmIChicmllZi50YXJnZXRBdWRpZW5jZSkge1xuICAgICAgYmFzZVByb21wdCArPSBgLCBhcHBlYWxpbmcgdG8gJHticmllZi50YXJnZXRBdWRpZW5jZX1gO1xuICAgIH1cbiAgICBcbiAgICAvLyBBZGRpdGlvbmFsIGluc3RydWN0aW9uc1xuICAgIGlmIChicmllZi5hZGRpdGlvbmFsSW5zdHJ1Y3Rpb25zKSB7XG4gICAgICBiYXNlUHJvbXB0ICs9IGAsICR7YnJpZWYuYWRkaXRpb25hbEluc3RydWN0aW9uc31gO1xuICAgIH1cbiAgICBcbiAgICAvLyBVc2UgdGhlIE9wZW5BSSBwcm9tcHQgb3B0aW1pemVyIGZvciBjb25zaXN0ZW5jeVxuICAgIHJldHVybiBvcHRpbWl6ZUxvZ29Qcm9tcHQoYmFzZVByb21wdCk7XG4gIH1cbn1cblxuLy8gRXhwb3J0IHRoZSBpbnN0YW50aWF0ZWQgYWdlbnQgZm9yIHJlZ2lzdHJ5XG5leHBvcnQgY29uc3QgbG9nb0dlbmVyYXRvckFnZW50ID0gbmV3IExvZ29HZW5lcmF0b3JBZ2VudCgpO1xuIl0sIm5hbWVzIjpbIm9wdGltaXplTG9nb1Byb21wdCIsIkJhc2VBZ2VudCIsIkxvZ29HZW5lcmF0b3JBZ2VudCIsImV4ZWN1dGUiLCJ0b29sIiwiaW5wdXQiLCJjb252ZXhNdXRhdGlvbnMiLCJzZXNzaW9uSWQiLCJwcm9jZXNzSW5wdXQiLCJlcnJvciIsImNvbnNvbGUiLCJFcnJvciIsIm1lc3NhZ2UiLCJnZXRJbml0aWFsUHJvbXB0IiwiY3VycmVudFN0ZXAiLCJub3JtYWxpemVkSW5wdXQiLCJ0b0xvd2VyQ2FzZSIsInRyaW0iLCJsb2ciLCJicmllZkV4aXN0cyIsImN1cnJlbnRCcmllZiIsImNvbXBhbnlOYW1lIiwic3RhcnRzV2l0aCIsImhhbmRsZUxvZ29HZW5lcmF0aW9uIiwiaGFuZGxlV2VsY29tZVN0ZXAiLCJoYW5kbGVDb21wYW55U3RlcCIsImhhbmRsZUJ1c2luZXNzU3RlcCIsImhhbmRsZVN0eWxlU3RlcCIsImhhbmRsZUNvbG9yc1N0ZXAiLCJoYW5kbGVUeXBlU3RlcCIsImhhbmRsZUF1ZGllbmNlU3RlcCIsImhhbmRsZUluc3RydWN0aW9uc1N0ZXAiLCJoYW5kbGVHZW5lcmF0ZVN0ZXAiLCJidXNpbmVzc0Rlc2NyaXB0aW9uIiwiYnVzaW5lc3NEZXNjIiwic3VnZ2VzdGVkSW5kdXN0cnkiLCJpbmNsdWRlcyIsImluZHVzdHJ5Iiwic2VsZWN0ZWRTdHlsZSIsInN0eWxlUHJlZmVyZW5jZSIsImNvbG9ySW5wdXQiLCJjb2xvclByZWZlcmVuY2VzIiwibG9nb1R5cGUiLCJ0YXJnZXRBdWRpZW5jZSIsImJyaWVmIiwiaW5zdHJ1Y3Rpb25zIiwiYWRkaXRpb25hbEluc3RydWN0aW9ucyIsImdlbmVyYXRpb25SZXN1bHQiLCJsb2dvUHJvbXB0IiwiY3JlYXRlQ29uc29saWRhdGVkTG9nb1Byb21wdCIsInJlc3BvbnNlIiwiZmV0Y2giLCJtZXRob2QiLCJoZWFkZXJzIiwiYm9keSIsIkpTT04iLCJzdHJpbmdpZnkiLCJwcm9tcHQiLCJzdHlsZSIsInNpemUiLCJxdWFsaXR5IiwibnVtYmVyT2ZJbWFnZXMiLCJqc29uIiwic3VjY2VzcyIsImhhc0ltYWdlVXJsIiwiaW1hZ2VVcmwiLCJpbWFnZVVybExlbmd0aCIsImxlbmd0aCIsImltYWdlVXJsUHJldmlldyIsInN1YnN0cmluZyIsInJldmlzZWRQcm9tcHQiLCJjcmVhdGVMb2dvR2VuZXJhdGlvbiIsImxvZ29TdmciLCJidXNpbmVzcyIsInNwZWNpYWxJbnN0cnVjdGlvbnMiLCJzdGF0dXMiLCJzdG9yZUNoYXRNZXNzYWdlIiwicm9sZSIsImNvbnRlbnQiLCJvcGVyYXRpb24iLCJ0eXBlIiwiZGV0YWlscyIsImltYWdlRGF0YSIsInJlc2V0IiwiY3JlYXRlSW1hZ2VuUHJvbXB0IiwiYmFzZVByb21wdCIsImNvbnN0cnVjdG9yIiwiaWQiLCJuYW1lIiwiZGVzY3JpcHRpb24iLCJpY29uIiwidG9vbHMiLCJjb21tYW5kIiwicGFyYW1ldGVycyIsImxvZ29HZW5lcmF0b3JBZ2VudCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./store/agents/logoGeneratorAgent.ts\n"));

/***/ })

});