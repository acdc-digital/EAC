"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("_app-pages-browser_app__components_dashboard_socialPlatforms_xPostEditor_tsx",{

/***/ "(app-pages-browser)/./lib/hooks/useXApi.ts":
/*!******************************!*\
  !*** ./lib/hooks/useXApi.ts ***!
  \******************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useXApi: () => (/* binding */ useXApi)\n/* harmony export */ });\n/* harmony import */ var _convex_generated_api__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/convex/_generated/api */ \"(app-pages-browser)/./convex/_generated/api.js\");\n/* harmony import */ var convex_react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! convex/react */ \"(app-pages-browser)/../node_modules/convex/dist/esm/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"(app-pages-browser)/../node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _useSocialConnectionSync__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./useSocialConnectionSync */ \"(app-pages-browser)/./lib/hooks/useSocialConnectionSync.ts\");\n// X API Integration Hook - Uses Real Convex Social Connections\n// /Users/matthewsimon/Projects/eac/eac/lib/hooks/useXApi.ts\n\n\n\n\nfunction useXApi() {\n    var _twitterConnection_twitterAccessToken;\n    const [isPosting, setIsPosting] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(false);\n    const [isScheduling, setIsScheduling] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(false);\n    const [isUploading, setIsUploading] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(false);\n    // Use centralized social connection sync\n    const { twitterConnection, isLoading: connectionsLoading } = (0,_useSocialConnectionSync__WEBPACK_IMPORTED_MODULE_3__.useSocialConnectionSync)();\n    // Debug what we received from useSocialConnectionSync\n    console.log('🔍 useXApi received from useSocialConnectionSync:', {\n        twitterConnection: twitterConnection ? 'FOUND' : 'NULL',\n        connectionsLoading,\n        twitterConnectionId: twitterConnection === null || twitterConnection === void 0 ? void 0 : twitterConnection._id,\n        twitterConnectionPlatform: twitterConnection === null || twitterConnection === void 0 ? void 0 : twitterConnection.platform,\n        twitterConnectionUsername: twitterConnection === null || twitterConnection === void 0 ? void 0 : twitterConnection.username\n    });\n    // Debug logging with more detail - ALWAYS log to track state changes\n    console.log('🔍 X API Connection Debug (useXApi hook):', {\n        hasConnection: !!twitterConnection,\n        connectionsLoading,\n        twitterConnectionExists: twitterConnection !== null,\n        twitterConnectionUndefined: twitterConnection === undefined,\n        connectionDetails: twitterConnection ? {\n            id: twitterConnection._id,\n            platform: twitterConnection.platform,\n            username: twitterConnection.username,\n            twitterScreenName: twitterConnection.twitterScreenName,\n            hasAccessToken: !!twitterConnection.twitterAccessToken,\n            accessTokenActual: twitterConnection.twitterAccessToken ? 'HAS TOKEN' : 'NO TOKEN',\n            isActive: twitterConnection.isActive,\n            tokenLength: ((_twitterConnection_twitterAccessToken = twitterConnection.twitterAccessToken) === null || _twitterConnection_twitterAccessToken === void 0 ? void 0 : _twitterConnection_twitterAccessToken.length) || 0,\n            createdAt: new Date(twitterConnection.createdAt).toLocaleString(),\n            updatedAt: new Date(twitterConnection.updatedAt).toLocaleString()\n        } : 'NO_CONNECTION_FOUND - twitterConnection is null/undefined'\n    });\n    // Convex actions for X API\n    const createTweetAction = (0,convex_react__WEBPACK_IMPORTED_MODULE_1__.useAction)(_convex_generated_api__WEBPACK_IMPORTED_MODULE_0__.api.xApiActions.createTweet);\n    const uploadMediaAction = (0,convex_react__WEBPACK_IMPORTED_MODULE_1__.useAction)(_convex_generated_api__WEBPACK_IMPORTED_MODULE_0__.api.xApiActions.uploadMedia);\n    const deleteConnectionMutation = (0,convex_react__WEBPACK_IMPORTED_MODULE_1__.useMutation)(_convex_generated_api__WEBPACK_IMPORTED_MODULE_0__.api.x.deleteXConnection);\n    const postTweet = async (args)=>{\n        console.log('🐦 PostTweet called with:', {\n            hasConnection: !!twitterConnection,\n            connectionId: twitterConnection === null || twitterConnection === void 0 ? void 0 : twitterConnection._id\n        });\n        if (!twitterConnection) {\n            console.error('❌ No X connection found.');\n            return {\n                success: false,\n                error: 'No active X connection found. Please connect your X account in Settings → Social Connections.'\n            };\n        }\n        if (!twitterConnection.twitterAccessToken) {\n            console.error('❌ X connection found but no access token:', {\n                connectionId: twitterConnection._id,\n                platform: twitterConnection.platform\n            });\n            return {\n                success: false,\n                error: 'X connection found but not properly authenticated. Please reconnect your X account.'\n            };\n        }\n        try {\n            setIsPosting(true);\n            console.log('🐦 Starting tweet creation...');\n            const mediaIds = [];\n            // Upload media files if provided\n            if (args.media_files && args.media_files.length > 0) {\n                setIsUploading(true);\n                for (const file of args.media_files){\n                    try {\n                        // Convert file to base64 for upload\n                        const base64Data = await fileToBase64(file);\n                        const mediaResult = await uploadMediaAction({\n                            connectionId: twitterConnection._id,\n                            mediaData: base64Data,\n                            mediaType: file.type\n                        });\n                        if (mediaResult.success && mediaResult.media_id_string) {\n                            mediaIds.push(mediaResult.media_id_string);\n                        } else {\n                            console.warn('Failed to upload media:', mediaResult.error);\n                        }\n                    } catch (error) {\n                        console.error('Error uploading media file:', error);\n                    }\n                }\n                setIsUploading(false);\n            }\n            // Handle thread posting\n            if (args.is_thread && args.thread_tweets && args.thread_tweets.length > 1) {\n                var _firstTweet_data;\n                // Post first tweet\n                const firstTweet = await createTweetAction({\n                    connectionId: twitterConnection._id,\n                    text: args.thread_tweets[0],\n                    mediaIds: mediaIds.length > 0 ? [\n                        mediaIds[0]\n                    ] : undefined,\n                    replySettings: args.reply_settings\n                });\n                if (!firstTweet.success) {\n                    throw new Error(firstTweet.error || 'Failed to post first tweet');\n                }\n                let previousTweetId = (_firstTweet_data = firstTweet.data) === null || _firstTweet_data === void 0 ? void 0 : _firstTweet_data.id;\n                // Post remaining tweets as replies\n                for(let i = 1; i < args.thread_tweets.length; i++){\n                    var _threadTweet_data;\n                    const threadTweet = await createTweetAction({\n                        connectionId: twitterConnection._id,\n                        text: args.thread_tweets[i],\n                        replyToId: previousTweetId,\n                        mediaIds: mediaIds[i] ? [\n                            mediaIds[i]\n                        ] : undefined,\n                        replySettings: args.reply_settings\n                    });\n                    if (!threadTweet.success) {\n                        console.error(\"Failed to post tweet \".concat(i + 1, \" in thread:\"), threadTweet.error);\n                        break;\n                    }\n                    previousTweetId = (_threadTweet_data = threadTweet.data) === null || _threadTweet_data === void 0 ? void 0 : _threadTweet_data.id;\n                }\n                return {\n                    success: true,\n                    message: \"Thread posted successfully with \".concat(args.thread_tweets.length, \" tweets\"),\n                    data: firstTweet.data\n                };\n            } else {\n                // Single tweet\n                console.log('🐦 Calling createTweetAction with:', {\n                    connectionId: twitterConnection._id,\n                    text: args.text,\n                    textLength: args.text.length,\n                    mediaCount: mediaIds.length,\n                    replySettings: args.reply_settings\n                });\n                // Validate tweet text\n                if (!args.text || args.text.trim().length === 0) {\n                    console.error('❌ Tweet text is empty');\n                    return {\n                        success: false,\n                        error: 'Tweet text cannot be empty'\n                    };\n                }\n                if (args.text.length > 280) {\n                    console.error('❌ Tweet text too long:', args.text.length);\n                    return {\n                        success: false,\n                        error: \"Tweet text is too long (\".concat(args.text.length, \" characters). Maximum is 280 characters.\")\n                    };\n                }\n                const result = await createTweetAction({\n                    connectionId: twitterConnection._id,\n                    text: args.text,\n                    mediaIds: mediaIds.length > 0 ? mediaIds : undefined,\n                    replySettings: args.reply_settings\n                });\n                console.log('🐦 CreateTweetAction result:', result);\n                return {\n                    success: result.success,\n                    message: result.success ? 'Tweet posted successfully!' : result.error || 'Failed to post tweet',\n                    data: result.data,\n                    error: result.error\n                };\n            }\n        } catch (error) {\n            console.error('Error posting tweet:', error);\n            return {\n                success: false,\n                error: error instanceof Error ? error.message : 'Unknown error occurred'\n            };\n        } finally{\n            setIsPosting(false);\n            setIsUploading(false);\n        }\n    };\n    const schedulePost = async (args)=>{\n        if (!twitterConnection) {\n            return {\n                success: false,\n                error: 'No active X connection found. Please connect your X account first.'\n            };\n        }\n        setIsScheduling(true);\n        try {\n            // For now, store scheduled posts in localStorage \n            // In production, you'd want to use Convex mutations to store in a scheduledPosts table\n            const scheduledData = {\n                ...args,\n                connectionId: twitterConnection._id,\n                createdAt: new Date().toISOString(),\n                status: 'scheduled',\n                scheduledId: \"sched_\".concat(Date.now())\n            };\n            // Store in localStorage for demo purposes\n            const existingScheduled = JSON.parse(localStorage.getItem('scheduledPosts') || '[]');\n            existingScheduled.push(scheduledData);\n            localStorage.setItem('scheduledPosts', JSON.stringify(existingScheduled));\n            return {\n                success: true,\n                message: \"Post scheduled for \".concat(new Date(args.scheduledFor).toLocaleString()),\n                data: {\n                    scheduledId: scheduledData.scheduledId,\n                    scheduledFor: args.scheduledFor,\n                    status: 'scheduled'\n                }\n            };\n        } catch (error) {\n            return {\n                success: false,\n                error: error instanceof Error ? error.message : 'Failed to schedule post'\n            };\n        } finally{\n            setIsScheduling(false);\n        }\n    };\n    const uploadMediaFile = async (file)=>{\n        if (!twitterConnection) {\n            throw new Error('No active X connection');\n        }\n        setIsUploading(true);\n        try {\n            const base64Data = await fileToBase64(file);\n            const result = await uploadMediaAction({\n                connectionId: twitterConnection._id,\n                mediaData: base64Data,\n                mediaType: file.type\n            });\n            return result;\n        } finally{\n            setIsUploading(false);\n        }\n    };\n    const disconnectAccount = async ()=>{\n        console.log('🔌 disconnectAccount function called - START');\n        console.log('🔌 twitterConnection check:', !!twitterConnection);\n        if (!twitterConnection) {\n            console.log('❌ No X connection to disconnect');\n            return {\n                success: false,\n                error: 'No X connection found to disconnect'\n            };\n        }\n        try {\n            console.log('🔌 About to call deleteConnectionMutation with:', {\n                connectionId: twitterConnection._id,\n                connectionIdType: typeof twitterConnection._id\n            });\n            const mutationResult = await deleteConnectionMutation({\n                connectionId: twitterConnection._id\n            });\n            console.log('🔌 deleteConnectionMutation completed:', mutationResult);\n            console.log('✅ X account disconnected successfully');\n            return {\n                success: true,\n                message: 'X account disconnected successfully'\n            };\n        } catch (error) {\n            console.error('❌ Failed to disconnect X account:', error);\n            console.error('❌ Error details:', {\n                name: error instanceof Error ? error.name : 'Unknown',\n                message: error instanceof Error ? error.message : String(error),\n                stack: error instanceof Error ? error.stack : 'No stack'\n            });\n            return {\n                success: false,\n                error: error instanceof Error ? error.message : 'Failed to disconnect X account'\n            };\n        }\n    };\n    const returnValues = {\n        postTweet,\n        schedulePost,\n        uploadMediaFile,\n        disconnectAccount,\n        isPosting,\n        isScheduling,\n        isUploading,\n        hasConnection: !!twitterConnection,\n        connectionInfo: twitterConnection ? {\n            username: twitterConnection.twitterScreenName || twitterConnection.username || 'Unknown',\n            userId: twitterConnection.twitterUserId || 'Unknown',\n            connectionId: twitterConnection._id\n        } : null\n    };\n    console.log('🔍 useXApi returning values:', {\n        hasConnection: returnValues.hasConnection,\n        connectionInfo: returnValues.connectionInfo,\n        twitterConnectionNull: twitterConnection === null,\n        twitterConnectionUndefined: twitterConnection === undefined\n    });\n    return returnValues;\n}\n// Helper function to convert File to base64\nfunction fileToBase64(file) {\n    return new Promise((resolve, reject)=>{\n        const reader = new FileReader();\n        reader.readAsDataURL(file);\n        reader.onload = ()=>{\n            if (typeof reader.result === 'string') {\n                // Remove the data:image/jpeg;base64, prefix\n                const base64Data = reader.result.split(',')[1];\n                resolve(base64Data);\n            } else {\n                reject(new Error('Failed to convert file to base64'));\n            }\n        };\n        reader.onerror = (error)=>reject(error);\n    });\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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WEFwaS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBYIEFQSSBJbnRlZ3JhdGlvbiBIb29rIC0gVXNlcyBSZWFsIENvbnZleCBTb2NpYWwgQ29ubmVjdGlvbnNcbi8vIC9Vc2Vycy9tYXR0aGV3c2ltb24vUHJvamVjdHMvZWFjL2VhYy9saWIvaG9va3MvdXNlWEFwaS50c1xuXG5pbXBvcnQgeyBhcGkgfSBmcm9tIFwiQC9jb252ZXgvX2dlbmVyYXRlZC9hcGlcIjtcbmltcG9ydCB7IElkIH0gZnJvbSBcIkAvY29udmV4L19nZW5lcmF0ZWQvZGF0YU1vZGVsXCI7XG5pbXBvcnQgeyB1c2VBY3Rpb24sIHVzZU11dGF0aW9uIH0gZnJvbSBcImNvbnZleC9yZWFjdFwiO1xuaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IHVzZVNvY2lhbENvbm5lY3Rpb25TeW5jIH0gZnJvbSBcIi4vdXNlU29jaWFsQ29ubmVjdGlvblN5bmNcIjtcblxuaW50ZXJmYWNlIFBvc3RUd2VldEFyZ3Mge1xuICB0ZXh0OiBzdHJpbmc7XG4gIHJlcGx5X3NldHRpbmdzPzogJ2ZvbGxvd2luZycgfCAnbWVudGlvbmVkVXNlcnMnIHwgJ3N1YnNjcmliZXJzJyB8ICd2ZXJpZmllZCc7XG4gIG1lZGlhX2ZpbGVzPzogRmlsZVtdO1xuICBwb2xsPzoge1xuICAgIG9wdGlvbnM6IHN0cmluZ1tdO1xuICAgIGR1cmF0aW9uX21pbnV0ZXM6IG51bWJlcjtcbiAgfTtcbiAgaXNfdGhyZWFkPzogYm9vbGVhbjtcbiAgdGhyZWFkX3R3ZWV0cz86IHN0cmluZ1tdO1xufVxuXG5pbnRlcmZhY2UgU2NoZWR1bGVQb3N0QXJncyBleHRlbmRzIFBvc3RUd2VldEFyZ3Mge1xuICBzY2hlZHVsZWRGb3I6IHN0cmluZztcbiAgZmlsZU5hbWU6IHN0cmluZztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZVhBcGkoKSB7XG4gIGNvbnN0IFtpc1Bvc3RpbmcsIHNldElzUG9zdGluZ10gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtpc1NjaGVkdWxpbmcsIHNldElzU2NoZWR1bGluZ10gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtpc1VwbG9hZGluZywgc2V0SXNVcGxvYWRpbmddID0gdXNlU3RhdGUoZmFsc2UpO1xuXG4gIC8vIFVzZSBjZW50cmFsaXplZCBzb2NpYWwgY29ubmVjdGlvbiBzeW5jXG4gIGNvbnN0IHsgdHdpdHRlckNvbm5lY3Rpb24sIGlzTG9hZGluZzogY29ubmVjdGlvbnNMb2FkaW5nIH0gPSB1c2VTb2NpYWxDb25uZWN0aW9uU3luYygpO1xuICBcbiAgLy8gRGVidWcgd2hhdCB3ZSByZWNlaXZlZCBmcm9tIHVzZVNvY2lhbENvbm5lY3Rpb25TeW5jXG4gIGNvbnNvbGUubG9nKCfwn5SNIHVzZVhBcGkgcmVjZWl2ZWQgZnJvbSB1c2VTb2NpYWxDb25uZWN0aW9uU3luYzonLCB7XG4gICAgdHdpdHRlckNvbm5lY3Rpb246IHR3aXR0ZXJDb25uZWN0aW9uID8gJ0ZPVU5EJyA6ICdOVUxMJyxcbiAgICBjb25uZWN0aW9uc0xvYWRpbmcsXG4gICAgdHdpdHRlckNvbm5lY3Rpb25JZDogdHdpdHRlckNvbm5lY3Rpb24/Ll9pZCxcbiAgICB0d2l0dGVyQ29ubmVjdGlvblBsYXRmb3JtOiB0d2l0dGVyQ29ubmVjdGlvbj8ucGxhdGZvcm0sXG4gICAgdHdpdHRlckNvbm5lY3Rpb25Vc2VybmFtZTogdHdpdHRlckNvbm5lY3Rpb24/LnVzZXJuYW1lXG4gIH0pO1xuICBcbiAgLy8gRGVidWcgbG9nZ2luZyB3aXRoIG1vcmUgZGV0YWlsIC0gQUxXQVlTIGxvZyB0byB0cmFjayBzdGF0ZSBjaGFuZ2VzXG4gIGNvbnNvbGUubG9nKCfwn5SNIFggQVBJIENvbm5lY3Rpb24gRGVidWcgKHVzZVhBcGkgaG9vayk6Jywge1xuICAgIGhhc0Nvbm5lY3Rpb246ICEhdHdpdHRlckNvbm5lY3Rpb24sXG4gICAgY29ubmVjdGlvbnNMb2FkaW5nLFxuICAgIHR3aXR0ZXJDb25uZWN0aW9uRXhpc3RzOiB0d2l0dGVyQ29ubmVjdGlvbiAhPT0gbnVsbCxcbiAgICB0d2l0dGVyQ29ubmVjdGlvblVuZGVmaW5lZDogdHdpdHRlckNvbm5lY3Rpb24gPT09IHVuZGVmaW5lZCxcbiAgICBjb25uZWN0aW9uRGV0YWlsczogdHdpdHRlckNvbm5lY3Rpb24gPyB7XG4gICAgICBpZDogdHdpdHRlckNvbm5lY3Rpb24uX2lkLFxuICAgICAgcGxhdGZvcm06IHR3aXR0ZXJDb25uZWN0aW9uLnBsYXRmb3JtLCBcbiAgICAgIHVzZXJuYW1lOiB0d2l0dGVyQ29ubmVjdGlvbi51c2VybmFtZSxcbiAgICAgIHR3aXR0ZXJTY3JlZW5OYW1lOiB0d2l0dGVyQ29ubmVjdGlvbi50d2l0dGVyU2NyZWVuTmFtZSxcbiAgICAgIGhhc0FjY2Vzc1Rva2VuOiAhIXR3aXR0ZXJDb25uZWN0aW9uLnR3aXR0ZXJBY2Nlc3NUb2tlbixcbiAgICAgIGFjY2Vzc1Rva2VuQWN0dWFsOiB0d2l0dGVyQ29ubmVjdGlvbi50d2l0dGVyQWNjZXNzVG9rZW4gPyAnSEFTIFRPS0VOJyA6ICdOTyBUT0tFTicsXG4gICAgICBpc0FjdGl2ZTogdHdpdHRlckNvbm5lY3Rpb24uaXNBY3RpdmUsXG4gICAgICB0b2tlbkxlbmd0aDogdHdpdHRlckNvbm5lY3Rpb24udHdpdHRlckFjY2Vzc1Rva2VuPy5sZW5ndGggfHwgMCxcbiAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUodHdpdHRlckNvbm5lY3Rpb24uY3JlYXRlZEF0KS50b0xvY2FsZVN0cmluZygpLFxuICAgICAgdXBkYXRlZEF0OiBuZXcgRGF0ZSh0d2l0dGVyQ29ubmVjdGlvbi51cGRhdGVkQXQpLnRvTG9jYWxlU3RyaW5nKClcbiAgICB9IDogJ05PX0NPTk5FQ1RJT05fRk9VTkQgLSB0d2l0dGVyQ29ubmVjdGlvbiBpcyBudWxsL3VuZGVmaW5lZCdcbiAgfSk7XG4gIFxuICAvLyBDb252ZXggYWN0aW9ucyBmb3IgWCBBUElcbiAgY29uc3QgY3JlYXRlVHdlZXRBY3Rpb24gPSB1c2VBY3Rpb24oYXBpLnhBcGlBY3Rpb25zLmNyZWF0ZVR3ZWV0KTtcbiAgY29uc3QgdXBsb2FkTWVkaWFBY3Rpb24gPSB1c2VBY3Rpb24oYXBpLnhBcGlBY3Rpb25zLnVwbG9hZE1lZGlhKTtcbiAgY29uc3QgZGVsZXRlQ29ubmVjdGlvbk11dGF0aW9uID0gdXNlTXV0YXRpb24oYXBpLnguZGVsZXRlWENvbm5lY3Rpb24pO1xuXG4gIGNvbnN0IHBvc3RUd2VldCA9IGFzeW5jIChhcmdzOiBQb3N0VHdlZXRBcmdzKSA9PiB7XG4gICAgY29uc29sZS5sb2coJ/CfkKYgUG9zdFR3ZWV0IGNhbGxlZCB3aXRoOicsIHsgaGFzQ29ubmVjdGlvbjogISF0d2l0dGVyQ29ubmVjdGlvbiwgY29ubmVjdGlvbklkOiB0d2l0dGVyQ29ubmVjdGlvbj8uX2lkIH0pO1xuICAgIFxuICAgIGlmICghdHdpdHRlckNvbm5lY3Rpb24pIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBObyBYIGNvbm5lY3Rpb24gZm91bmQuJyk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6ICdObyBhY3RpdmUgWCBjb25uZWN0aW9uIGZvdW5kLiBQbGVhc2UgY29ubmVjdCB5b3VyIFggYWNjb3VudCBpbiBTZXR0aW5ncyDihpIgU29jaWFsIENvbm5lY3Rpb25zLidcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKCF0d2l0dGVyQ29ubmVjdGlvbi50d2l0dGVyQWNjZXNzVG9rZW4pIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBYIGNvbm5lY3Rpb24gZm91bmQgYnV0IG5vIGFjY2VzcyB0b2tlbjonLCB7IGNvbm5lY3Rpb25JZDogdHdpdHRlckNvbm5lY3Rpb24uX2lkLCBwbGF0Zm9ybTogdHdpdHRlckNvbm5lY3Rpb24ucGxhdGZvcm0gfSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6ICdYIGNvbm5lY3Rpb24gZm91bmQgYnV0IG5vdCBwcm9wZXJseSBhdXRoZW50aWNhdGVkLiBQbGVhc2UgcmVjb25uZWN0IHlvdXIgWCBhY2NvdW50LidcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHNldElzUG9zdGluZyh0cnVlKTtcbiAgICAgIGNvbnNvbGUubG9nKCfwn5CmIFN0YXJ0aW5nIHR3ZWV0IGNyZWF0aW9uLi4uJyk7XG5cbiAgICAgIGNvbnN0IG1lZGlhSWRzOiBzdHJpbmdbXSA9IFtdO1xuXG4gICAgICAvLyBVcGxvYWQgbWVkaWEgZmlsZXMgaWYgcHJvdmlkZWRcbiAgICAgIGlmIChhcmdzLm1lZGlhX2ZpbGVzICYmIGFyZ3MubWVkaWFfZmlsZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBzZXRJc1VwbG9hZGluZyh0cnVlKTtcbiAgICAgICAgXG4gICAgICAgIGZvciAoY29uc3QgZmlsZSBvZiBhcmdzLm1lZGlhX2ZpbGVzKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIENvbnZlcnQgZmlsZSB0byBiYXNlNjQgZm9yIHVwbG9hZFxuICAgICAgICAgICAgY29uc3QgYmFzZTY0RGF0YSA9IGF3YWl0IGZpbGVUb0Jhc2U2NChmaWxlKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY29uc3QgbWVkaWFSZXN1bHQgPSBhd2FpdCB1cGxvYWRNZWRpYUFjdGlvbih7XG4gICAgICAgICAgICAgIGNvbm5lY3Rpb25JZDogdHdpdHRlckNvbm5lY3Rpb24uX2lkIGFzIElkPFwic29jaWFsQ29ubmVjdGlvbnNcIj4sXG4gICAgICAgICAgICAgIG1lZGlhRGF0YTogYmFzZTY0RGF0YSxcbiAgICAgICAgICAgICAgbWVkaWFUeXBlOiBmaWxlLnR5cGUsXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKG1lZGlhUmVzdWx0LnN1Y2Nlc3MgJiYgbWVkaWFSZXN1bHQubWVkaWFfaWRfc3RyaW5nKSB7XG4gICAgICAgICAgICAgIG1lZGlhSWRzLnB1c2gobWVkaWFSZXN1bHQubWVkaWFfaWRfc3RyaW5nKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUud2FybignRmFpbGVkIHRvIHVwbG9hZCBtZWRpYTonLCBtZWRpYVJlc3VsdC5lcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHVwbG9hZGluZyBtZWRpYSBmaWxlOicsIGVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2V0SXNVcGxvYWRpbmcoZmFsc2UpO1xuICAgICAgfVxuXG4gICAgICAvLyBIYW5kbGUgdGhyZWFkIHBvc3RpbmdcbiAgICAgIGlmIChhcmdzLmlzX3RocmVhZCAmJiBhcmdzLnRocmVhZF90d2VldHMgJiYgYXJncy50aHJlYWRfdHdlZXRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgLy8gUG9zdCBmaXJzdCB0d2VldFxuICAgICAgICBjb25zdCBmaXJzdFR3ZWV0ID0gYXdhaXQgY3JlYXRlVHdlZXRBY3Rpb24oe1xuICAgICAgICAgIGNvbm5lY3Rpb25JZDogdHdpdHRlckNvbm5lY3Rpb24uX2lkIGFzIElkPFwic29jaWFsQ29ubmVjdGlvbnNcIj4sXG4gICAgICAgICAgdGV4dDogYXJncy50aHJlYWRfdHdlZXRzWzBdLFxuICAgICAgICAgIG1lZGlhSWRzOiBtZWRpYUlkcy5sZW5ndGggPiAwID8gW21lZGlhSWRzWzBdXSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICByZXBseVNldHRpbmdzOiBhcmdzLnJlcGx5X3NldHRpbmdzLFxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoIWZpcnN0VHdlZXQuc3VjY2Vzcykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihmaXJzdFR3ZWV0LmVycm9yIHx8ICdGYWlsZWQgdG8gcG9zdCBmaXJzdCB0d2VldCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHByZXZpb3VzVHdlZXRJZCA9IGZpcnN0VHdlZXQuZGF0YT8uaWQ7XG5cbiAgICAgICAgLy8gUG9zdCByZW1haW5pbmcgdHdlZXRzIGFzIHJlcGxpZXNcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBhcmdzLnRocmVhZF90d2VldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCB0aHJlYWRUd2VldCA9IGF3YWl0IGNyZWF0ZVR3ZWV0QWN0aW9uKHtcbiAgICAgICAgICAgIGNvbm5lY3Rpb25JZDogdHdpdHRlckNvbm5lY3Rpb24uX2lkIGFzIElkPFwic29jaWFsQ29ubmVjdGlvbnNcIj4sXG4gICAgICAgICAgICB0ZXh0OiBhcmdzLnRocmVhZF90d2VldHNbaV0sXG4gICAgICAgICAgICByZXBseVRvSWQ6IHByZXZpb3VzVHdlZXRJZCxcbiAgICAgICAgICAgIG1lZGlhSWRzOiBtZWRpYUlkc1tpXSA/IFttZWRpYUlkc1tpXV0gOiB1bmRlZmluZWQsXG4gICAgICAgICAgICByZXBseVNldHRpbmdzOiBhcmdzLnJlcGx5X3NldHRpbmdzLFxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKCF0aHJlYWRUd2VldC5zdWNjZXNzKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBGYWlsZWQgdG8gcG9zdCB0d2VldCAke2kgKyAxfSBpbiB0aHJlYWQ6YCwgdGhyZWFkVHdlZXQuZXJyb3IpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcHJldmlvdXNUd2VldElkID0gdGhyZWFkVHdlZXQuZGF0YT8uaWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgbWVzc2FnZTogYFRocmVhZCBwb3N0ZWQgc3VjY2Vzc2Z1bGx5IHdpdGggJHthcmdzLnRocmVhZF90d2VldHMubGVuZ3RofSB0d2VldHNgLFxuICAgICAgICAgIGRhdGE6IGZpcnN0VHdlZXQuZGF0YVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gU2luZ2xlIHR3ZWV0XG4gICAgICAgIGNvbnNvbGUubG9nKCfwn5CmIENhbGxpbmcgY3JlYXRlVHdlZXRBY3Rpb24gd2l0aDonLCB7IFxuICAgICAgICAgIGNvbm5lY3Rpb25JZDogdHdpdHRlckNvbm5lY3Rpb24uX2lkLCBcbiAgICAgICAgICB0ZXh0OiBhcmdzLnRleHQsIFxuICAgICAgICAgIHRleHRMZW5ndGg6IGFyZ3MudGV4dC5sZW5ndGgsXG4gICAgICAgICAgbWVkaWFDb3VudDogbWVkaWFJZHMubGVuZ3RoLFxuICAgICAgICAgIHJlcGx5U2V0dGluZ3M6IGFyZ3MucmVwbHlfc2V0dGluZ3MgXG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgLy8gVmFsaWRhdGUgdHdlZXQgdGV4dFxuICAgICAgICBpZiAoIWFyZ3MudGV4dCB8fCBhcmdzLnRleHQudHJpbSgpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBUd2VldCB0ZXh0IGlzIGVtcHR5Jyk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgZXJyb3I6ICdUd2VldCB0ZXh0IGNhbm5vdCBiZSBlbXB0eScsXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYgKGFyZ3MudGV4dC5sZW5ndGggPiAyODApIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgVHdlZXQgdGV4dCB0b28gbG9uZzonLCBhcmdzLnRleHQubGVuZ3RoKTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICBlcnJvcjogYFR3ZWV0IHRleHQgaXMgdG9vIGxvbmcgKCR7YXJncy50ZXh0Lmxlbmd0aH0gY2hhcmFjdGVycykuIE1heGltdW0gaXMgMjgwIGNoYXJhY3RlcnMuYCxcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjcmVhdGVUd2VldEFjdGlvbih7XG4gICAgICAgICAgY29ubmVjdGlvbklkOiB0d2l0dGVyQ29ubmVjdGlvbi5faWQgYXMgSWQ8XCJzb2NpYWxDb25uZWN0aW9uc1wiPixcbiAgICAgICAgICB0ZXh0OiBhcmdzLnRleHQsXG4gICAgICAgICAgbWVkaWFJZHM6IG1lZGlhSWRzLmxlbmd0aCA+IDAgPyBtZWRpYUlkcyA6IHVuZGVmaW5lZCxcbiAgICAgICAgICByZXBseVNldHRpbmdzOiBhcmdzLnJlcGx5X3NldHRpbmdzLFxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zb2xlLmxvZygn8J+QpiBDcmVhdGVUd2VldEFjdGlvbiByZXN1bHQ6JywgcmVzdWx0KTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN1Y2Nlc3M6IHJlc3VsdC5zdWNjZXNzLFxuICAgICAgICAgIG1lc3NhZ2U6IHJlc3VsdC5zdWNjZXNzID8gJ1R3ZWV0IHBvc3RlZCBzdWNjZXNzZnVsbHkhJyA6IHJlc3VsdC5lcnJvciB8fCAnRmFpbGVkIHRvIHBvc3QgdHdlZXQnLFxuICAgICAgICAgIGRhdGE6IHJlc3VsdC5kYXRhLFxuICAgICAgICAgIGVycm9yOiByZXN1bHQuZXJyb3JcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBwb3N0aW5nIHR3ZWV0OicsIGVycm9yKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBlcnJvcjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvciBvY2N1cnJlZCdcbiAgICAgIH07XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHNldElzUG9zdGluZyhmYWxzZSk7XG4gICAgICBzZXRJc1VwbG9hZGluZyhmYWxzZSk7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IHNjaGVkdWxlUG9zdCA9IGFzeW5jIChhcmdzOiBTY2hlZHVsZVBvc3RBcmdzKSA9PiB7XG4gICAgaWYgKCF0d2l0dGVyQ29ubmVjdGlvbikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgIGVycm9yOiAnTm8gYWN0aXZlIFggY29ubmVjdGlvbiBmb3VuZC4gUGxlYXNlIGNvbm5lY3QgeW91ciBYIGFjY291bnQgZmlyc3QuJ1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBzZXRJc1NjaGVkdWxpbmcodHJ1ZSk7XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIC8vIEZvciBub3csIHN0b3JlIHNjaGVkdWxlZCBwb3N0cyBpbiBsb2NhbFN0b3JhZ2UgXG4gICAgICAvLyBJbiBwcm9kdWN0aW9uLCB5b3UnZCB3YW50IHRvIHVzZSBDb252ZXggbXV0YXRpb25zIHRvIHN0b3JlIGluIGEgc2NoZWR1bGVkUG9zdHMgdGFibGVcbiAgICAgIGNvbnN0IHNjaGVkdWxlZERhdGEgPSB7XG4gICAgICAgIC4uLmFyZ3MsXG4gICAgICAgIGNvbm5lY3Rpb25JZDogdHdpdHRlckNvbm5lY3Rpb24uX2lkLFxuICAgICAgICBcbiAgICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgIHN0YXR1czogJ3NjaGVkdWxlZCcgYXMgY29uc3QsXG4gICAgICAgIHNjaGVkdWxlZElkOiBgc2NoZWRfJHtEYXRlLm5vdygpfWBcbiAgICAgIH07XG5cbiAgICAgIC8vIFN0b3JlIGluIGxvY2FsU3RvcmFnZSBmb3IgZGVtbyBwdXJwb3Nlc1xuICAgICAgY29uc3QgZXhpc3RpbmdTY2hlZHVsZWQgPSBKU09OLnBhcnNlKGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdzY2hlZHVsZWRQb3N0cycpIHx8ICdbXScpO1xuICAgICAgZXhpc3RpbmdTY2hlZHVsZWQucHVzaChzY2hlZHVsZWREYXRhKTtcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdzY2hlZHVsZWRQb3N0cycsIEpTT04uc3RyaW5naWZ5KGV4aXN0aW5nU2NoZWR1bGVkKSk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgIG1lc3NhZ2U6IGBQb3N0IHNjaGVkdWxlZCBmb3IgJHtuZXcgRGF0ZShhcmdzLnNjaGVkdWxlZEZvcikudG9Mb2NhbGVTdHJpbmcoKX1gLFxuICAgICAgICBkYXRhOiB7IFxuICAgICAgICAgIHNjaGVkdWxlZElkOiBzY2hlZHVsZWREYXRhLnNjaGVkdWxlZElkLCBcbiAgICAgICAgICBzY2hlZHVsZWRGb3I6IGFyZ3Muc2NoZWR1bGVkRm9yLFxuICAgICAgICAgIHN0YXR1czogJ3NjaGVkdWxlZCdcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ0ZhaWxlZCB0byBzY2hlZHVsZSBwb3N0J1xuICAgICAgfTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgc2V0SXNTY2hlZHVsaW5nKGZhbHNlKTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgdXBsb2FkTWVkaWFGaWxlID0gYXN5bmMgKGZpbGU6IEZpbGUpID0+IHtcbiAgICBpZiAoIXR3aXR0ZXJDb25uZWN0aW9uKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGFjdGl2ZSBYIGNvbm5lY3Rpb24nKTtcbiAgICB9XG5cbiAgICBzZXRJc1VwbG9hZGluZyh0cnVlKTtcbiAgICBcbiAgICB0cnkge1xuICAgICAgY29uc3QgYmFzZTY0RGF0YSA9IGF3YWl0IGZpbGVUb0Jhc2U2NChmaWxlKTtcbiAgICAgIFxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdXBsb2FkTWVkaWFBY3Rpb24oe1xuICAgICAgICBjb25uZWN0aW9uSWQ6IHR3aXR0ZXJDb25uZWN0aW9uLl9pZCBhcyBJZDxcInNvY2lhbENvbm5lY3Rpb25zXCI+LFxuICAgICAgICBtZWRpYURhdGE6IGJhc2U2NERhdGEsXG4gICAgICAgIG1lZGlhVHlwZTogZmlsZS50eXBlLFxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHNldElzVXBsb2FkaW5nKGZhbHNlKTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgZGlzY29ubmVjdEFjY291bnQgPSBhc3luYyAoKSA9PiB7XG4gICAgY29uc29sZS5sb2coJ/CflIwgZGlzY29ubmVjdEFjY291bnQgZnVuY3Rpb24gY2FsbGVkIC0gU1RBUlQnKTtcbiAgICBjb25zb2xlLmxvZygn8J+UjCB0d2l0dGVyQ29ubmVjdGlvbiBjaGVjazonLCAhIXR3aXR0ZXJDb25uZWN0aW9uKTtcbiAgICBcbiAgICBpZiAoIXR3aXR0ZXJDb25uZWN0aW9uKSB7XG4gICAgICBjb25zb2xlLmxvZygn4p2MIE5vIFggY29ubmVjdGlvbiB0byBkaXNjb25uZWN0Jyk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6ICdObyBYIGNvbm5lY3Rpb24gZm91bmQgdG8gZGlzY29ubmVjdCdcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnNvbGUubG9nKCfwn5SMIEFib3V0IHRvIGNhbGwgZGVsZXRlQ29ubmVjdGlvbk11dGF0aW9uIHdpdGg6JywgeyBcbiAgICAgICAgY29ubmVjdGlvbklkOiB0d2l0dGVyQ29ubmVjdGlvbi5faWQsXG4gICAgICAgIGNvbm5lY3Rpb25JZFR5cGU6IHR5cGVvZiB0d2l0dGVyQ29ubmVjdGlvbi5faWQgXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgY29uc3QgbXV0YXRpb25SZXN1bHQgPSBhd2FpdCBkZWxldGVDb25uZWN0aW9uTXV0YXRpb24oe1xuICAgICAgICBjb25uZWN0aW9uSWQ6IHR3aXR0ZXJDb25uZWN0aW9uLl9pZCBhcyBJZDxcInNvY2lhbENvbm5lY3Rpb25zXCI+XG4gICAgICB9KTtcblxuICAgICAgY29uc29sZS5sb2coJ/CflIwgZGVsZXRlQ29ubmVjdGlvbk11dGF0aW9uIGNvbXBsZXRlZDonLCBtdXRhdGlvblJlc3VsdCk7XG4gICAgICBjb25zb2xlLmxvZygn4pyFIFggYWNjb3VudCBkaXNjb25uZWN0ZWQgc3VjY2Vzc2Z1bGx5Jyk7XG4gICAgICBcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgIG1lc3NhZ2U6ICdYIGFjY291bnQgZGlzY29ubmVjdGVkIHN1Y2Nlc3NmdWxseSdcbiAgICAgIH07XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBGYWlsZWQgdG8gZGlzY29ubmVjdCBYIGFjY291bnQ6JywgZXJyb3IpO1xuICAgICAgY29uc29sZS5lcnJvcign4p2MIEVycm9yIGRldGFpbHM6Jywge1xuICAgICAgICBuYW1lOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubmFtZSA6ICdVbmtub3duJyxcbiAgICAgICAgbWVzc2FnZTogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpLFxuICAgICAgICBzdGFjazogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLnN0YWNrIDogJ05vIHN0YWNrJ1xuICAgICAgfSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ0ZhaWxlZCB0byBkaXNjb25uZWN0IFggYWNjb3VudCdcbiAgICAgIH07XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IHJldHVyblZhbHVlcyA9IHtcbiAgICBwb3N0VHdlZXQsXG4gICAgc2NoZWR1bGVQb3N0LFxuICAgIHVwbG9hZE1lZGlhRmlsZSxcbiAgICBkaXNjb25uZWN0QWNjb3VudCxcbiAgICBpc1Bvc3RpbmcsXG4gICAgaXNTY2hlZHVsaW5nLFxuICAgIGlzVXBsb2FkaW5nLFxuICAgIGhhc0Nvbm5lY3Rpb246ICEhdHdpdHRlckNvbm5lY3Rpb24sXG4gICAgY29ubmVjdGlvbkluZm86IHR3aXR0ZXJDb25uZWN0aW9uID8ge1xuICAgICAgdXNlcm5hbWU6IHR3aXR0ZXJDb25uZWN0aW9uLnR3aXR0ZXJTY3JlZW5OYW1lIHx8IHR3aXR0ZXJDb25uZWN0aW9uLnVzZXJuYW1lIHx8ICdVbmtub3duJyxcbiAgICAgIHVzZXJJZDogdHdpdHRlckNvbm5lY3Rpb24udHdpdHRlclVzZXJJZCB8fCAnVW5rbm93bicsXG4gICAgICBjb25uZWN0aW9uSWQ6IHR3aXR0ZXJDb25uZWN0aW9uLl9pZCxcbiAgICB9IDogbnVsbCxcbiAgfTtcblxuICBjb25zb2xlLmxvZygn8J+UjSB1c2VYQXBpIHJldHVybmluZyB2YWx1ZXM6Jywge1xuICAgIGhhc0Nvbm5lY3Rpb246IHJldHVyblZhbHVlcy5oYXNDb25uZWN0aW9uLFxuICAgIGNvbm5lY3Rpb25JbmZvOiByZXR1cm5WYWx1ZXMuY29ubmVjdGlvbkluZm8sXG4gICAgdHdpdHRlckNvbm5lY3Rpb25OdWxsOiB0d2l0dGVyQ29ubmVjdGlvbiA9PT0gbnVsbCxcbiAgICB0d2l0dGVyQ29ubmVjdGlvblVuZGVmaW5lZDogdHdpdHRlckNvbm5lY3Rpb24gPT09IHVuZGVmaW5lZFxuICB9KTtcblxuICByZXR1cm4gcmV0dXJuVmFsdWVzO1xufVxuXG4vLyBIZWxwZXIgZnVuY3Rpb24gdG8gY29udmVydCBGaWxlIHRvIGJhc2U2NFxuZnVuY3Rpb24gZmlsZVRvQmFzZTY0KGZpbGU6IEZpbGUpOiBQcm9taXNlPHN0cmluZz4ge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgcmVhZGVyLnJlYWRBc0RhdGFVUkwoZmlsZSk7XG4gICAgcmVhZGVyLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgIGlmICh0eXBlb2YgcmVhZGVyLnJlc3VsdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBkYXRhOmltYWdlL2pwZWc7YmFzZTY0LCBwcmVmaXhcbiAgICAgICAgY29uc3QgYmFzZTY0RGF0YSA9IHJlYWRlci5yZXN1bHQuc3BsaXQoJywnKVsxXTtcbiAgICAgICAgcmVzb2x2ZShiYXNlNjREYXRhKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ0ZhaWxlZCB0byBjb252ZXJ0IGZpbGUgdG8gYmFzZTY0JykpO1xuICAgICAgfVxuICAgIH07XG4gICAgcmVhZGVyLm9uZXJyb3IgPSBlcnJvciA9PiByZWplY3QoZXJyb3IpO1xuICB9KTtcbn1cbiJdLCJuYW1lcyI6WyJhcGkiLCJ1c2VBY3Rpb24iLCJ1c2VNdXRhdGlvbiIsInVzZVN0YXRlIiwidXNlU29jaWFsQ29ubmVjdGlvblN5bmMiLCJ1c2VYQXBpIiwidHdpdHRlckNvbm5lY3Rpb24iLCJpc1Bvc3RpbmciLCJzZXRJc1Bvc3RpbmciLCJpc1NjaGVkdWxpbmciLCJzZXRJc1NjaGVkdWxpbmciLCJpc1VwbG9hZGluZyIsInNldElzVXBsb2FkaW5nIiwiaXNMb2FkaW5nIiwiY29ubmVjdGlvbnNMb2FkaW5nIiwiY29uc29sZSIsImxvZyIsInR3aXR0ZXJDb25uZWN0aW9uSWQiLCJfaWQiLCJ0d2l0dGVyQ29ubmVjdGlvblBsYXRmb3JtIiwicGxhdGZvcm0iLCJ0d2l0dGVyQ29ubmVjdGlvblVzZXJuYW1lIiwidXNlcm5hbWUiLCJoYXNDb25uZWN0aW9uIiwidHdpdHRlckNvbm5lY3Rpb25FeGlzdHMiLCJ0d2l0dGVyQ29ubmVjdGlvblVuZGVmaW5lZCIsInVuZGVmaW5lZCIsImNvbm5lY3Rpb25EZXRhaWxzIiwiaWQiLCJ0d2l0dGVyU2NyZWVuTmFtZSIsImhhc0FjY2Vzc1Rva2VuIiwidHdpdHRlckFjY2Vzc1Rva2VuIiwiYWNjZXNzVG9rZW5BY3R1YWwiLCJpc0FjdGl2ZSIsInRva2VuTGVuZ3RoIiwibGVuZ3RoIiwiY3JlYXRlZEF0IiwiRGF0ZSIsInRvTG9jYWxlU3RyaW5nIiwidXBkYXRlZEF0IiwiY3JlYXRlVHdlZXRBY3Rpb24iLCJ4QXBpQWN0aW9ucyIsImNyZWF0ZVR3ZWV0IiwidXBsb2FkTWVkaWFBY3Rpb24iLCJ1cGxvYWRNZWRpYSIsImRlbGV0ZUNvbm5lY3Rpb25NdXRhdGlvbiIsIngiLCJkZWxldGVYQ29ubmVjdGlvbiIsInBvc3RUd2VldCIsImFyZ3MiLCJjb25uZWN0aW9uSWQiLCJlcnJvciIsInN1Y2Nlc3MiLCJtZWRpYUlkcyIsIm1lZGlhX2ZpbGVzIiwiZmlsZSIsImJhc2U2NERhdGEiLCJmaWxlVG9CYXNlNjQiLCJtZWRpYVJlc3VsdCIsIm1lZGlhRGF0YSIsIm1lZGlhVHlwZSIsInR5cGUiLCJtZWRpYV9pZF9zdHJpbmciLCJwdXNoIiwid2FybiIsImlzX3RocmVhZCIsInRocmVhZF90d2VldHMiLCJmaXJzdFR3ZWV0IiwidGV4dCIsInJlcGx5U2V0dGluZ3MiLCJyZXBseV9zZXR0aW5ncyIsIkVycm9yIiwicHJldmlvdXNUd2VldElkIiwiZGF0YSIsImkiLCJ0aHJlYWRUd2VldCIsInJlcGx5VG9JZCIsIm1lc3NhZ2UiLCJ0ZXh0TGVuZ3RoIiwibWVkaWFDb3VudCIsInRyaW0iLCJyZXN1bHQiLCJzY2hlZHVsZVBvc3QiLCJzY2hlZHVsZWREYXRhIiwidG9JU09TdHJpbmciLCJzdGF0dXMiLCJzY2hlZHVsZWRJZCIsIm5vdyIsImV4aXN0aW5nU2NoZWR1bGVkIiwiSlNPTiIsInBhcnNlIiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsInNldEl0ZW0iLCJzdHJpbmdpZnkiLCJzY2hlZHVsZWRGb3IiLCJ1cGxvYWRNZWRpYUZpbGUiLCJkaXNjb25uZWN0QWNjb3VudCIsImNvbm5lY3Rpb25JZFR5cGUiLCJtdXRhdGlvblJlc3VsdCIsIm5hbWUiLCJTdHJpbmciLCJzdGFjayIsInJldHVyblZhbHVlcyIsImNvbm5lY3Rpb25JbmZvIiwidXNlcklkIiwidHdpdHRlclVzZXJJZCIsInR3aXR0ZXJDb25uZWN0aW9uTnVsbCIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwicmVhZGVyIiwiRmlsZVJlYWRlciIsInJlYWRBc0RhdGFVUkwiLCJvbmxvYWQiLCJzcGxpdCIsIm9uZXJyb3IiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/hooks/useXApi.ts\n"));

/***/ })

});