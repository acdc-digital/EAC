/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("_app-pages-browser_app__components_terminal_terminal_tsx",{

/***/ "(app-pages-browser)/./app/_components/terminal/_components/chatMessages.tsx":
/*!***************************************************************!*\
  !*** ./app/_components/terminal/_components/chatMessages.tsx ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("// Simplified Chat Messages Component - No Slash Commands// /Users/matthewsimon/Projects/eac/eac/app/_components/terminal/_components/chatMessages.tsx\"use client\";import { api } from \"@/convex/_generated/api\";import { useChat } from \"@/lib/hooks/useChat\";import { useInstructionContext, useInstructions } from \"@/lib/hooks/useInstructions\";import { useMCP } from \"@/lib/hooks/useMCP\";import { useAgentStore } from \"@/store\";import { useChatStore } from \"@/store/terminal/chat\";import { useSessionStore } from \"@/store/terminal/session\";import { useUser } from \"@clerk/nextjs\";import { useMutation, useQuery } from \"convex/react\";import React, { useEffect, useRef, useState } from \"react\";import { ToolSelector } from \"./toolSelector\";import { ToolsToggle } from \"./toolsToggle\";export function ChatMessages() {  const scrollRef = useRef<HTMLDivElement>(null);  const inputRef = useRef<HTMLInputElement>(null);  const [message, setMessage] = useState(\"\");    const { user, isLoaded } = useUser();  const { initializeUserSession, addTerminalFeedback, setSessionId } = useChatStore();  const { activeSessionId } = useSessionStore();  const {     messages,     isLoading: chatLoading,     sendMessage,     sessionId,     storeChatMessage,     addTerminalFeedback: useTerminalFeedback,    messageCount,    isNearSessionLimit,    isAtSessionLimit,    canAddMessages,    getSessionStatus,    startNewSession  } = useChat();  const {    isConnected: mcpConnected,    isLoading: mcpLoading,    error: mcpError,    availableTools,    processNaturalLanguage,  } = useMCP();    // Agent execution and mutations  const { agents, activeAgentId, setActiveAgent, executeAgentTool } = useAgentStore();  const createInstruction = useMutation(api.instructions.createInstructionFile);  const ensureInstructionsProject = useMutation(api.instructions.ensureInstructionsProject);  const upsertPost = useMutation(api.twitter.upsertPost);  const { instructionContext } = useInstructionContext();  const { instructions, isLoading: instructionsLoading } = useInstructions();  const isLoading = chatLoading || mcpLoading || instructionsLoading;  // Auto-scroll to bottom when new messages arrive  useEffect(() => {    if (scrollRef.current) {      scrollRef.current.scrollTop = scrollRef.current.scrollHeight;    }  }, [messages]);  // Initialize user session when component mounts and user is loaded  useEffect(() => {    if (isLoaded && user && !sessionId) {      console.log(\"üîÑ Initializing user session...\", { userId: user.id });      initializeUserSession(user.id);    }  }, [user, isLoaded, sessionId, initializeUserSession]);  // Sync session ID if active session changes  useEffect(() => {    if (activeSessionId && activeSessionId !== sessionId) {      console.log(\"üîÑ Syncing to active session:\", activeSessionId);      setSessionId(activeSessionId);    }  }, [activeSessionId, sessionId, setSessionId]);  // Helper function to strip markdown formatting  const stripMarkdown = (text: string): string => {    return text      .replace(/#{1,6}\\s*/g, '') // Remove headers      .replace(/\\*\\*(.*?)\\*\\*/g, '$1') // Remove **bold**      .replace(/\\*(.*?)\\*/g, '$1') // Remove *italic*      .replace(/`([^`]+)`/g, '$1') // Remove `code`      .replace(/^\\s*[-*+]\\s+/gm, '‚Ä¢ ') // Convert markdown lists to bullet points      .replace(/^\\s*\\d+\\.\\s+/gm, '‚Ä¢ ') // Convert numbered lists to bullet points      .replace(/\\n\\s*\\n\\s*\\n/g, '\\n\\n') // Reduce multiple blank lines to double      .split('\\n') // Split into lines for processing      .map(line => {        // Add spacing after section headers (lines that don't start with bullet points)        if (line.trim() && !line.startsWith('‚Ä¢') && !line.startsWith(' ') && line.length > 0) {          return line + '\\n'; // Add extra newline after headers        }        return line;      })      .join('\\n')      .replace(/\\n{3,}/g, '\\n\\n') // Clean up excessive newlines      .trim();  };  // Helper function to detect MCP-related queries (excluding direct tool commands)  const isMCPQuery = (text: string): boolean => {    // Don't treat direct tool commands as NLP queries    if (text.startsWith('/')) return false;        // Look for keywords that suggest MCP analysis would be helpful    const mcpKeywords = [      'analyze', 'examine', 'review', 'explain', 'understand', 'architecture',      'structure', 'code', 'component', 'function', 'implementation', 'pattern',      'best practice', 'issue', 'bug', 'error', 'performance', 'optimization',      'refactor', 'improvement', 'documentation', 'overview', 'summary',      'how does', 'what is', 'why is', 'where is', 'when is', 'which'    ];        const lowerText = text.toLowerCase();    return mcpKeywords.some(keyword => lowerText.includes(keyword));  };  const handleToolSelectorClose = () => {    setMessage(\"\");    inputRef.current?.focus();  };  const handleSubmit = async (e: React.FormEvent) => {    e.preventDefault();        // Check session limit before processing    if (!canAddMessages()) {      console.warn(\"Cannot send message: Session limit reached\");      // Add a terminal feedback message about the limit      await storeChatMessage({        role: \"terminal\",        content: `[${new Date().toLocaleTimeString('en-US', {           hour12: false,           hour: '2-digit',           minute: '2-digit',           second: '2-digit'         })}] üö® Message not sent: Session limit reached (500 messages)Please start a new session to continue chatting.`,        sessionId,      });      return;    }        if (message.trim() && !isLoading) {      const messageContent = message.trim();      setMessage(\"\");            // Check if this looks like a natural language MCP query      if (mcpConnected && isMCPQuery(messageContent)) {        try {          const mcpResponse = await processNaturalLanguage(messageContent);                    if (mcpResponse.success && mcpResponse.content && mcpResponse.content.length > 0) {            // Extract the actual text content from the MCP response            const textContent = mcpResponse.content[0].text;                        // Strip markdown formatting and convert to plain text            const plainText = stripMarkdown(textContent);                        // Send the MCP response with clean text content            await sendMessage(`ü§ñ MCP Analysis:\\n\\n${plainText}`);          } else {            await sendMessage(messageContent);          }        } catch (error) {          console.error('MCP Error:', error);          // Fall back to regular chat          await sendMessage(messageContent);        }      } else {        // Regular chat message - add instruction context if available        let contextualMessage = messageContent;        if (instructionContext) {          contextualMessage = `${instructionContext}\\n\\n---\\n\\n${messageContent}`;        }                // Use the useChat hook which will call the sendChatMessage action        await sendMessage(contextualMessage, messageContent);      }    }  };  const handleKeyDown = (e: React.KeyboardEvent) => {    if (e.key === 'Enter' && !e.shiftKey) {      e.preventDefault();      handleSubmit(e);    }  };  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {    const value = e.target.value;    setMessage(value);  };  return (    <div       ref={scrollRef}       className=\"flex-1 overflow-y-auto bg-[#0e0e0e] p-2 min-h-0 scrollbar-hidden\"    >      <div className=\"font-mono text-xs space-y-2 min-h-full\">        {/* Terminal Welcome Text */}        <div className=\"text-[#cccccc] space-y-1 mb-4\">          <div>EAC Financial Dashboard - AI Assistant</div>          <div className=\"text-[#4ec9b0]\">‚ñ≤ Next.js 15.0.0 + Convex Backend</div>          <div>- Anthropic Claude 3.5 Sonnet Integration</div>          <div className={`text-xs ${mcpConnected ? 'text-[#4ec9b0]' : 'text-[#f48771]'}`}>            üîå MCP Server: {mcpConnected ? 'Connected' : 'Disconnected'}            {mcpConnected && ` (${availableTools.length} tools)`}          </div>          <div className={`text-xs ${activeAgentId ? 'text-[#4ec9b0]' : 'text-[#858585]'}`}>            ü§ñ Agents: {activeAgentId ? `Active (${agents.find(a => a.id === activeAgentId)?.name})` : 'None selected'}            {activeAgentId && ` (${agents.find(a => a.id === activeAgentId)?.tools.length || 0} tools)`}          </div>          {mcpError && (            <div className=\"text-[#f48771] text-xs\">MCP Error: {mcpError}</div>          )}          <div className=\"text-[#858585] mt-2\">AI Assistant ready for EAC project questions.</div>          <div className=\"text-[#858585] text-xs\">Session: {sessionId.slice(-8)}</div>                    {/* Session Status and Limits */}          <div className=\"text-[#858585] text-xs\">            Messages: {messageCount}/500            {isNearSessionLimit && (              <span className=\"text-[#f48771] ml-2\">‚ö†Ô∏è Approaching limit</span>            )}            {isAtSessionLimit && (              <span className=\"text-[#f48771] ml-2\">üö® Session full</span>            )}          </div>        </div>        {/* Messages */}        {messages.map((msg, index) => (          <div key={index} className=\"space-y-1\">            {msg.role === 'user' && (              <div className=\"text-[#007acc]\">                <span className=\"text-[#007acc]\">$ user:</span>                <span className=\"ml-1 text-[#cccccc]\">{msg.content}</span>              </div>            )}            {msg.role === 'assistant' && (              <div className=\"text-[#4ec9b0]\">                <span className=\"text-[#4ec9b0]\">ü§ñ assistant:</span>                <div className=\"ml-1 text-[#cccccc] whitespace-pre-wrap\">{msg.content}</div>              </div>            )}            {msg.role === 'terminal' && (              <div className=\"text-[#858585]\">                <div className=\"text-[#585858] whitespace-pre-wrap bg-[#1a1a1a] p-1 rounded text-[10px] border-l-2 border-[#333]\">                  {msg.content}                </div>              </div>            )}          </div>        ))}        {/* Loading indicator */}        {isLoading && (          <div className=\"text-[#4ec9b0]\">            <span className=\"text-[#4ec9b0]\">ü§ñ assistant:</span>            <span className=\"ml-1 text-[#858585]\">thinking...</span>          </div>        )}        {/* Input area */}        <div className=\"sticky bottom-0 bg-[#0e0e0e] pt-2\">          <div className=\"flex items-center\">            <span className=\"text-[#007acc]\">$ user:</span>            <form onSubmit={handleSubmit} className=\"flex-1 ml-1\">              <input                ref={inputRef}                type=\"text\"                value={message}                onChange={handleInputChange}                onKeyDown={handleKeyDown}                placeholder={                  isAtSessionLimit                     ? \"Session limit reached - Start new session to continue...\"                     : isLoading                       ? \"AI is thinking...\"                       : \"Ask about your EAC project...\"                }                disabled={isLoading || isAtSessionLimit}                className={`w-full bg-transparent border-none outline-none placeholder:text-[#858585] disabled:opacity-50 disabled:cursor-not-allowed caret-[#cccccc] ${                  isAtSessionLimit ? 'text-[#f48771]' : 'text-[#cccccc]'                }`}              />            </form>          </div>        </div>      </div>    </div>  );}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9fY29tcG9uZW50cy90ZXJtaW5hbC9fY29tcG9uZW50cy9jaGF0TWVzc2FnZXMudHN4IiwibWFwcGluZ3MiOiJBQUFBLDJwV0FBMnBXIiwic291cmNlcyI6WyIvVXNlcnMvbWF0dGhld3NpbW9uL1Byb2plY3RzL2VhYy9lYWMvYXBwL19jb21wb25lbnRzL3Rlcm1pbmFsL19jb21wb25lbnRzL2NoYXRNZXNzYWdlcy50c3giXSwic291cmNlc0NvbnRlbnQiOlsiLy8gU2ltcGxpZmllZCBDaGF0IE1lc3NhZ2VzIENvbXBvbmVudCAtIE5vIFNsYXNoIENvbW1hbmRzLy8gL1VzZXJzL21hdHRoZXdzaW1vbi9Qcm9qZWN0cy9lYWMvZWFjL2FwcC9fY29tcG9uZW50cy90ZXJtaW5hbC9fY29tcG9uZW50cy9jaGF0TWVzc2FnZXMudHN4XCJ1c2UgY2xpZW50XCI7aW1wb3J0IHsgYXBpIH0gZnJvbSBcIkAvY29udmV4L19nZW5lcmF0ZWQvYXBpXCI7aW1wb3J0IHsgdXNlQ2hhdCB9IGZyb20gXCJAL2xpYi9ob29rcy91c2VDaGF0XCI7aW1wb3J0IHsgdXNlSW5zdHJ1Y3Rpb25Db250ZXh0LCB1c2VJbnN0cnVjdGlvbnMgfSBmcm9tIFwiQC9saWIvaG9va3MvdXNlSW5zdHJ1Y3Rpb25zXCI7aW1wb3J0IHsgdXNlTUNQIH0gZnJvbSBcIkAvbGliL2hvb2tzL3VzZU1DUFwiO2ltcG9ydCB7IHVzZUFnZW50U3RvcmUgfSBmcm9tIFwiQC9zdG9yZVwiO2ltcG9ydCB7IHVzZUNoYXRTdG9yZSB9IGZyb20gXCJAL3N0b3JlL3Rlcm1pbmFsL2NoYXRcIjtpbXBvcnQgeyB1c2VTZXNzaW9uU3RvcmUgfSBmcm9tIFwiQC9zdG9yZS90ZXJtaW5hbC9zZXNzaW9uXCI7aW1wb3J0IHsgdXNlVXNlciB9IGZyb20gXCJAY2xlcmsvbmV4dGpzXCI7aW1wb3J0IHsgdXNlTXV0YXRpb24sIHVzZVF1ZXJ5IH0gZnJvbSBcImNvbnZleC9yZWFjdFwiO2ltcG9ydCBSZWFjdCwgeyB1c2VFZmZlY3QsIHVzZVJlZiwgdXNlU3RhdGUgfSBmcm9tIFwicmVhY3RcIjtpbXBvcnQgeyBUb29sU2VsZWN0b3IgfSBmcm9tIFwiLi90b29sU2VsZWN0b3JcIjtpbXBvcnQgeyBUb29sc1RvZ2dsZSB9IGZyb20gXCIuL3Rvb2xzVG9nZ2xlXCI7ZXhwb3J0IGZ1bmN0aW9uIENoYXRNZXNzYWdlcygpIHsgIGNvbnN0IHNjcm9sbFJlZiA9IHVzZVJlZjxIVE1MRGl2RWxlbWVudD4obnVsbCk7ICBjb25zdCBpbnB1dFJlZiA9IHVzZVJlZjxIVE1MSW5wdXRFbGVtZW50PihudWxsKTsgIGNvbnN0IFttZXNzYWdlLCBzZXRNZXNzYWdlXSA9IHVzZVN0YXRlKFwiXCIpOyAgICBjb25zdCB7IHVzZXIsIGlzTG9hZGVkIH0gPSB1c2VVc2VyKCk7ICBjb25zdCB7IGluaXRpYWxpemVVc2VyU2Vzc2lvbiwgYWRkVGVybWluYWxGZWVkYmFjaywgc2V0U2Vzc2lvbklkIH0gPSB1c2VDaGF0U3RvcmUoKTsgIGNvbnN0IHsgYWN0aXZlU2Vzc2lvbklkIH0gPSB1c2VTZXNzaW9uU3RvcmUoKTsgIGNvbnN0IHsgICAgIG1lc3NhZ2VzLCAgICAgaXNMb2FkaW5nOiBjaGF0TG9hZGluZywgICAgIHNlbmRNZXNzYWdlLCAgICAgc2Vzc2lvbklkLCAgICAgc3RvcmVDaGF0TWVzc2FnZSwgICAgIGFkZFRlcm1pbmFsRmVlZGJhY2s6IHVzZVRlcm1pbmFsRmVlZGJhY2ssICAgIG1lc3NhZ2VDb3VudCwgICAgaXNOZWFyU2Vzc2lvbkxpbWl0LCAgICBpc0F0U2Vzc2lvbkxpbWl0LCAgICBjYW5BZGRNZXNzYWdlcywgICAgZ2V0U2Vzc2lvblN0YXR1cywgICAgc3RhcnROZXdTZXNzaW9uICB9ID0gdXNlQ2hhdCgpOyAgY29uc3QgeyAgICBpc0Nvbm5lY3RlZDogbWNwQ29ubmVjdGVkLCAgICBpc0xvYWRpbmc6IG1jcExvYWRpbmcsICAgIGVycm9yOiBtY3BFcnJvciwgICAgYXZhaWxhYmxlVG9vbHMsICAgIHByb2Nlc3NOYXR1cmFsTGFuZ3VhZ2UsICB9ID0gdXNlTUNQKCk7ICAgIC8vIEFnZW50IGV4ZWN1dGlvbiBhbmQgbXV0YXRpb25zICBjb25zdCB7IGFnZW50cywgYWN0aXZlQWdlbnRJZCwgc2V0QWN0aXZlQWdlbnQsIGV4ZWN1dGVBZ2VudFRvb2wgfSA9IHVzZUFnZW50U3RvcmUoKTsgIGNvbnN0IGNyZWF0ZUluc3RydWN0aW9uID0gdXNlTXV0YXRpb24oYXBpLmluc3RydWN0aW9ucy5jcmVhdGVJbnN0cnVjdGlvbkZpbGUpOyAgY29uc3QgZW5zdXJlSW5zdHJ1Y3Rpb25zUHJvamVjdCA9IHVzZU11dGF0aW9uKGFwaS5pbnN0cnVjdGlvbnMuZW5zdXJlSW5zdHJ1Y3Rpb25zUHJvamVjdCk7ICBjb25zdCB1cHNlcnRQb3N0ID0gdXNlTXV0YXRpb24oYXBpLnR3aXR0ZXIudXBzZXJ0UG9zdCk7ICBjb25zdCB7IGluc3RydWN0aW9uQ29udGV4dCB9ID0gdXNlSW5zdHJ1Y3Rpb25Db250ZXh0KCk7ICBjb25zdCB7IGluc3RydWN0aW9ucywgaXNMb2FkaW5nOiBpbnN0cnVjdGlvbnNMb2FkaW5nIH0gPSB1c2VJbnN0cnVjdGlvbnMoKTsgIGNvbnN0IGlzTG9hZGluZyA9IGNoYXRMb2FkaW5nIHx8IG1jcExvYWRpbmcgfHwgaW5zdHJ1Y3Rpb25zTG9hZGluZzsgIC8vIEF1dG8tc2Nyb2xsIHRvIGJvdHRvbSB3aGVuIG5ldyBtZXNzYWdlcyBhcnJpdmUgIHVzZUVmZmVjdCgoKSA9PiB7ICAgIGlmIChzY3JvbGxSZWYuY3VycmVudCkgeyAgICAgIHNjcm9sbFJlZi5jdXJyZW50LnNjcm9sbFRvcCA9IHNjcm9sbFJlZi5jdXJyZW50LnNjcm9sbEhlaWdodDsgICAgfSAgfSwgW21lc3NhZ2VzXSk7ICAvLyBJbml0aWFsaXplIHVzZXIgc2Vzc2lvbiB3aGVuIGNvbXBvbmVudCBtb3VudHMgYW5kIHVzZXIgaXMgbG9hZGVkICB1c2VFZmZlY3QoKCkgPT4geyAgICBpZiAoaXNMb2FkZWQgJiYgdXNlciAmJiAhc2Vzc2lvbklkKSB7ICAgICAgY29uc29sZS5sb2coXCLwn5SEIEluaXRpYWxpemluZyB1c2VyIHNlc3Npb24uLi5cIiwgeyB1c2VySWQ6IHVzZXIuaWQgfSk7ICAgICAgaW5pdGlhbGl6ZVVzZXJTZXNzaW9uKHVzZXIuaWQpOyAgICB9ICB9LCBbdXNlciwgaXNMb2FkZWQsIHNlc3Npb25JZCwgaW5pdGlhbGl6ZVVzZXJTZXNzaW9uXSk7ICAvLyBTeW5jIHNlc3Npb24gSUQgaWYgYWN0aXZlIHNlc3Npb24gY2hhbmdlcyAgdXNlRWZmZWN0KCgpID0+IHsgICAgaWYgKGFjdGl2ZVNlc3Npb25JZCAmJiBhY3RpdmVTZXNzaW9uSWQgIT09IHNlc3Npb25JZCkgeyAgICAgIGNvbnNvbGUubG9nKFwi8J+UhCBTeW5jaW5nIHRvIGFjdGl2ZSBzZXNzaW9uOlwiLCBhY3RpdmVTZXNzaW9uSWQpOyAgICAgIHNldFNlc3Npb25JZChhY3RpdmVTZXNzaW9uSWQpOyAgICB9ICB9LCBbYWN0aXZlU2Vzc2lvbklkLCBzZXNzaW9uSWQsIHNldFNlc3Npb25JZF0pOyAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIHN0cmlwIG1hcmtkb3duIGZvcm1hdHRpbmcgIGNvbnN0IHN0cmlwTWFya2Rvd24gPSAodGV4dDogc3RyaW5nKTogc3RyaW5nID0+IHsgICAgcmV0dXJuIHRleHQgICAgICAucmVwbGFjZSgvI3sxLDZ9XFxzKi9nLCAnJykgLy8gUmVtb3ZlIGhlYWRlcnMgICAgICAucmVwbGFjZSgvXFwqXFwqKC4qPylcXCpcXCovZywgJyQxJykgLy8gUmVtb3ZlICoqYm9sZCoqICAgICAgLnJlcGxhY2UoL1xcKiguKj8pXFwqL2csICckMScpIC8vIFJlbW92ZSAqaXRhbGljKiAgICAgIC5yZXBsYWNlKC9gKFteYF0rKWAvZywgJyQxJykgLy8gUmVtb3ZlIGBjb2RlYCAgICAgIC5yZXBsYWNlKC9eXFxzKlstKitdXFxzKy9nbSwgJ+KAoiAnKSAvLyBDb252ZXJ0IG1hcmtkb3duIGxpc3RzIHRvIGJ1bGxldCBwb2ludHMgICAgICAucmVwbGFjZSgvXlxccypcXGQrXFwuXFxzKy9nbSwgJ+KAoiAnKSAvLyBDb252ZXJ0IG51bWJlcmVkIGxpc3RzIHRvIGJ1bGxldCBwb2ludHMgICAgICAucmVwbGFjZSgvXFxuXFxzKlxcblxccypcXG4vZywgJ1xcblxcbicpIC8vIFJlZHVjZSBtdWx0aXBsZSBibGFuayBsaW5lcyB0byBkb3VibGUgICAgICAuc3BsaXQoJ1xcbicpIC8vIFNwbGl0IGludG8gbGluZXMgZm9yIHByb2Nlc3NpbmcgICAgICAubWFwKGxpbmUgPT4geyAgICAgICAgLy8gQWRkIHNwYWNpbmcgYWZ0ZXIgc2VjdGlvbiBoZWFkZXJzIChsaW5lcyB0aGF0IGRvbid0IHN0YXJ0IHdpdGggYnVsbGV0IHBvaW50cykgICAgICAgIGlmIChsaW5lLnRyaW0oKSAmJiAhbGluZS5zdGFydHNXaXRoKCfigKInKSAmJiAhbGluZS5zdGFydHNXaXRoKCcgJykgJiYgbGluZS5sZW5ndGggPiAwKSB7ICAgICAgICAgIHJldHVybiBsaW5lICsgJ1xcbic7IC8vIEFkZCBleHRyYSBuZXdsaW5lIGFmdGVyIGhlYWRlcnMgICAgICAgIH0gICAgICAgIHJldHVybiBsaW5lOyAgICAgIH0pICAgICAgLmpvaW4oJ1xcbicpICAgICAgLnJlcGxhY2UoL1xcbnszLH0vZywgJ1xcblxcbicpIC8vIENsZWFuIHVwIGV4Y2Vzc2l2ZSBuZXdsaW5lcyAgICAgIC50cmltKCk7ICB9OyAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGRldGVjdCBNQ1AtcmVsYXRlZCBxdWVyaWVzIChleGNsdWRpbmcgZGlyZWN0IHRvb2wgY29tbWFuZHMpICBjb25zdCBpc01DUFF1ZXJ5ID0gKHRleHQ6IHN0cmluZyk6IGJvb2xlYW4gPT4geyAgICAvLyBEb24ndCB0cmVhdCBkaXJlY3QgdG9vbCBjb21tYW5kcyBhcyBOTFAgcXVlcmllcyAgICBpZiAodGV4dC5zdGFydHNXaXRoKCcvJykpIHJldHVybiBmYWxzZTsgICAgICAgIC8vIExvb2sgZm9yIGtleXdvcmRzIHRoYXQgc3VnZ2VzdCBNQ1AgYW5hbHlzaXMgd291bGQgYmUgaGVscGZ1bCAgICBjb25zdCBtY3BLZXl3b3JkcyA9IFsgICAgICAnYW5hbHl6ZScsICdleGFtaW5lJywgJ3JldmlldycsICdleHBsYWluJywgJ3VuZGVyc3RhbmQnLCAnYXJjaGl0ZWN0dXJlJywgICAgICAnc3RydWN0dXJlJywgJ2NvZGUnLCAnY29tcG9uZW50JywgJ2Z1bmN0aW9uJywgJ2ltcGxlbWVudGF0aW9uJywgJ3BhdHRlcm4nLCAgICAgICdiZXN0IHByYWN0aWNlJywgJ2lzc3VlJywgJ2J1ZycsICdlcnJvcicsICdwZXJmb3JtYW5jZScsICdvcHRpbWl6YXRpb24nLCAgICAgICdyZWZhY3RvcicsICdpbXByb3ZlbWVudCcsICdkb2N1bWVudGF0aW9uJywgJ292ZXJ2aWV3JywgJ3N1bW1hcnknLCAgICAgICdob3cgZG9lcycsICd3aGF0IGlzJywgJ3doeSBpcycsICd3aGVyZSBpcycsICd3aGVuIGlzJywgJ3doaWNoJyAgICBdOyAgICAgICAgY29uc3QgbG93ZXJUZXh0ID0gdGV4dC50b0xvd2VyQ2FzZSgpOyAgICByZXR1cm4gbWNwS2V5d29yZHMuc29tZShrZXl3b3JkID0+IGxvd2VyVGV4dC5pbmNsdWRlcyhrZXl3b3JkKSk7ICB9OyAgY29uc3QgaGFuZGxlVG9vbFNlbGVjdG9yQ2xvc2UgPSAoKSA9PiB7ICAgIHNldE1lc3NhZ2UoXCJcIik7ICAgIGlucHV0UmVmLmN1cnJlbnQ/LmZvY3VzKCk7ICB9OyAgY29uc3QgaGFuZGxlU3VibWl0ID0gYXN5bmMgKGU6IFJlYWN0LkZvcm1FdmVudCkgPT4geyAgICBlLnByZXZlbnREZWZhdWx0KCk7ICAgICAgICAvLyBDaGVjayBzZXNzaW9uIGxpbWl0IGJlZm9yZSBwcm9jZXNzaW5nICAgIGlmICghY2FuQWRkTWVzc2FnZXMoKSkgeyAgICAgIGNvbnNvbGUud2FybihcIkNhbm5vdCBzZW5kIG1lc3NhZ2U6IFNlc3Npb24gbGltaXQgcmVhY2hlZFwiKTsgICAgICAvLyBBZGQgYSB0ZXJtaW5hbCBmZWVkYmFjayBtZXNzYWdlIGFib3V0IHRoZSBsaW1pdCAgICAgIGF3YWl0IHN0b3JlQ2hhdE1lc3NhZ2UoeyAgICAgICAgcm9sZTogXCJ0ZXJtaW5hbFwiLCAgICAgICAgY29udGVudDogYFske25ldyBEYXRlKCkudG9Mb2NhbGVUaW1lU3RyaW5nKCdlbi1VUycsIHsgICAgICAgICAgIGhvdXIxMjogZmFsc2UsICAgICAgICAgICBob3VyOiAnMi1kaWdpdCcsICAgICAgICAgICBtaW51dGU6ICcyLWRpZ2l0JywgICAgICAgICAgIHNlY29uZDogJzItZGlnaXQnICAgICAgICAgfSl9XSDwn5qoIE1lc3NhZ2Ugbm90IHNlbnQ6IFNlc3Npb24gbGltaXQgcmVhY2hlZCAoNTAwIG1lc3NhZ2VzKVBsZWFzZSBzdGFydCBhIG5ldyBzZXNzaW9uIHRvIGNvbnRpbnVlIGNoYXR0aW5nLmAsICAgICAgICBzZXNzaW9uSWQsICAgICAgfSk7ICAgICAgcmV0dXJuOyAgICB9ICAgICAgICBpZiAobWVzc2FnZS50cmltKCkgJiYgIWlzTG9hZGluZykgeyAgICAgIGNvbnN0IG1lc3NhZ2VDb250ZW50ID0gbWVzc2FnZS50cmltKCk7ICAgICAgc2V0TWVzc2FnZShcIlwiKTsgICAgICAgICAgICAvLyBDaGVjayBpZiB0aGlzIGxvb2tzIGxpa2UgYSBuYXR1cmFsIGxhbmd1YWdlIE1DUCBxdWVyeSAgICAgIGlmIChtY3BDb25uZWN0ZWQgJiYgaXNNQ1BRdWVyeShtZXNzYWdlQ29udGVudCkpIHsgICAgICAgIHRyeSB7ICAgICAgICAgIGNvbnN0IG1jcFJlc3BvbnNlID0gYXdhaXQgcHJvY2Vzc05hdHVyYWxMYW5ndWFnZShtZXNzYWdlQ29udGVudCk7ICAgICAgICAgICAgICAgICAgICBpZiAobWNwUmVzcG9uc2Uuc3VjY2VzcyAmJiBtY3BSZXNwb25zZS5jb250ZW50ICYmIG1jcFJlc3BvbnNlLmNvbnRlbnQubGVuZ3RoID4gMCkgeyAgICAgICAgICAgIC8vIEV4dHJhY3QgdGhlIGFjdHVhbCB0ZXh0IGNvbnRlbnQgZnJvbSB0aGUgTUNQIHJlc3BvbnNlICAgICAgICAgICAgY29uc3QgdGV4dENvbnRlbnQgPSBtY3BSZXNwb25zZS5jb250ZW50WzBdLnRleHQ7ICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3RyaXAgbWFya2Rvd24gZm9ybWF0dGluZyBhbmQgY29udmVydCB0byBwbGFpbiB0ZXh0ICAgICAgICAgICAgY29uc3QgcGxhaW5UZXh0ID0gc3RyaXBNYXJrZG93bih0ZXh0Q29udGVudCk7ICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2VuZCB0aGUgTUNQIHJlc3BvbnNlIHdpdGggY2xlYW4gdGV4dCBjb250ZW50ICAgICAgICAgICAgYXdhaXQgc2VuZE1lc3NhZ2UoYPCfpJYgTUNQIEFuYWx5c2lzOlxcblxcbiR7cGxhaW5UZXh0fWApOyAgICAgICAgICB9IGVsc2UgeyAgICAgICAgICAgIGF3YWl0IHNlbmRNZXNzYWdlKG1lc3NhZ2VDb250ZW50KTsgICAgICAgICAgfSAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHsgICAgICAgICAgY29uc29sZS5lcnJvcignTUNQIEVycm9yOicsIGVycm9yKTsgICAgICAgICAgLy8gRmFsbCBiYWNrIHRvIHJlZ3VsYXIgY2hhdCAgICAgICAgICBhd2FpdCBzZW5kTWVzc2FnZShtZXNzYWdlQ29udGVudCk7ICAgICAgICB9ICAgICAgfSBlbHNlIHsgICAgICAgIC8vIFJlZ3VsYXIgY2hhdCBtZXNzYWdlIC0gYWRkIGluc3RydWN0aW9uIGNvbnRleHQgaWYgYXZhaWxhYmxlICAgICAgICBsZXQgY29udGV4dHVhbE1lc3NhZ2UgPSBtZXNzYWdlQ29udGVudDsgICAgICAgIGlmIChpbnN0cnVjdGlvbkNvbnRleHQpIHsgICAgICAgICAgY29udGV4dHVhbE1lc3NhZ2UgPSBgJHtpbnN0cnVjdGlvbkNvbnRleHR9XFxuXFxuLS0tXFxuXFxuJHttZXNzYWdlQ29udGVudH1gOyAgICAgICAgfSAgICAgICAgICAgICAgICAvLyBVc2UgdGhlIHVzZUNoYXQgaG9vayB3aGljaCB3aWxsIGNhbGwgdGhlIHNlbmRDaGF0TWVzc2FnZSBhY3Rpb24gICAgICAgIGF3YWl0IHNlbmRNZXNzYWdlKGNvbnRleHR1YWxNZXNzYWdlLCBtZXNzYWdlQ29udGVudCk7ICAgICAgfSAgICB9ICB9OyAgY29uc3QgaGFuZGxlS2V5RG93biA9IChlOiBSZWFjdC5LZXlib2FyZEV2ZW50KSA9PiB7ICAgIGlmIChlLmtleSA9PT0gJ0VudGVyJyAmJiAhZS5zaGlmdEtleSkgeyAgICAgIGUucHJldmVudERlZmF1bHQoKTsgICAgICBoYW5kbGVTdWJtaXQoZSk7ICAgIH0gIH07ICBjb25zdCBoYW5kbGVJbnB1dENoYW5nZSA9IChlOiBSZWFjdC5DaGFuZ2VFdmVudDxIVE1MSW5wdXRFbGVtZW50PikgPT4geyAgICBjb25zdCB2YWx1ZSA9IGUudGFyZ2V0LnZhbHVlOyAgICBzZXRNZXNzYWdlKHZhbHVlKTsgIH07ICByZXR1cm4gKCAgICA8ZGl2ICAgICAgIHJlZj17c2Nyb2xsUmVmfSAgICAgICBjbGFzc05hbWU9XCJmbGV4LTEgb3ZlcmZsb3cteS1hdXRvIGJnLVsjMGUwZTBlXSBwLTIgbWluLWgtMCBzY3JvbGxiYXItaGlkZGVuXCIgICAgPiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZm9udC1tb25vIHRleHQteHMgc3BhY2UteS0yIG1pbi1oLWZ1bGxcIj4gICAgICAgIHsvKiBUZXJtaW5hbCBXZWxjb21lIFRleHQgKi99ICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInRleHQtWyNjY2NjY2NdIHNwYWNlLXktMSBtYi00XCI+ICAgICAgICAgIDxkaXY+RUFDIEZpbmFuY2lhbCBEYXNoYm9hcmQgLSBBSSBBc3Npc3RhbnQ8L2Rpdj4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ0ZXh0LVsjNGVjOWIwXVwiPuKWsiBOZXh0LmpzIDE1LjAuMCArIENvbnZleCBCYWNrZW5kPC9kaXY+ICAgICAgICAgIDxkaXY+LSBBbnRocm9waWMgQ2xhdWRlIDMuNSBTb25uZXQgSW50ZWdyYXRpb248L2Rpdj4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2B0ZXh0LXhzICR7bWNwQ29ubmVjdGVkID8gJ3RleHQtWyM0ZWM5YjBdJyA6ICd0ZXh0LVsjZjQ4NzcxXSd9YH0+ICAgICAgICAgICAg8J+UjCBNQ1AgU2VydmVyOiB7bWNwQ29ubmVjdGVkID8gJ0Nvbm5lY3RlZCcgOiAnRGlzY29ubmVjdGVkJ30gICAgICAgICAgICB7bWNwQ29ubmVjdGVkICYmIGAgKCR7YXZhaWxhYmxlVG9vbHMubGVuZ3RofSB0b29scylgfSAgICAgICAgICA8L2Rpdj4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2B0ZXh0LXhzICR7YWN0aXZlQWdlbnRJZCA/ICd0ZXh0LVsjNGVjOWIwXScgOiAndGV4dC1bIzg1ODU4NV0nfWB9PiAgICAgICAgICAgIPCfpJYgQWdlbnRzOiB7YWN0aXZlQWdlbnRJZCA/IGBBY3RpdmUgKCR7YWdlbnRzLmZpbmQoYSA9PiBhLmlkID09PSBhY3RpdmVBZ2VudElkKT8ubmFtZX0pYCA6ICdOb25lIHNlbGVjdGVkJ30gICAgICAgICAgICB7YWN0aXZlQWdlbnRJZCAmJiBgICgke2FnZW50cy5maW5kKGEgPT4gYS5pZCA9PT0gYWN0aXZlQWdlbnRJZCk/LnRvb2xzLmxlbmd0aCB8fCAwfSB0b29scylgfSAgICAgICAgICA8L2Rpdj4gICAgICAgICAge21jcEVycm9yICYmICggICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInRleHQtWyNmNDg3NzFdIHRleHQteHNcIj5NQ1AgRXJyb3I6IHttY3BFcnJvcn08L2Rpdj4gICAgICAgICAgKX0gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ0ZXh0LVsjODU4NTg1XSBtdC0yXCI+QUkgQXNzaXN0YW50IHJlYWR5IGZvciBFQUMgcHJvamVjdCBxdWVzdGlvbnMuPC9kaXY+ICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidGV4dC1bIzg1ODU4NV0gdGV4dC14c1wiPlNlc3Npb246IHtzZXNzaW9uSWQuc2xpY2UoLTgpfTwvZGl2PiAgICAgICAgICAgICAgICAgICAgey8qIFNlc3Npb24gU3RhdHVzIGFuZCBMaW1pdHMgKi99ICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidGV4dC1bIzg1ODU4NV0gdGV4dC14c1wiPiAgICAgICAgICAgIE1lc3NhZ2VzOiB7bWVzc2FnZUNvdW50fS81MDAgICAgICAgICAgICB7aXNOZWFyU2Vzc2lvbkxpbWl0ICYmICggICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cInRleHQtWyNmNDg3NzFdIG1sLTJcIj7imqDvuI8gQXBwcm9hY2hpbmcgbGltaXQ8L3NwYW4+ICAgICAgICAgICAgKX0gICAgICAgICAgICB7aXNBdFNlc3Npb25MaW1pdCAmJiAoICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJ0ZXh0LVsjZjQ4NzcxXSBtbC0yXCI+8J+aqCBTZXNzaW9uIGZ1bGw8L3NwYW4+ICAgICAgICAgICAgKX0gICAgICAgICAgPC9kaXY+ICAgICAgICA8L2Rpdj4gICAgICAgIHsvKiBNZXNzYWdlcyAqL30gICAgICAgIHttZXNzYWdlcy5tYXAoKG1zZywgaW5kZXgpID0+ICggICAgICAgICAgPGRpdiBrZXk9e2luZGV4fSBjbGFzc05hbWU9XCJzcGFjZS15LTFcIj4gICAgICAgICAgICB7bXNnLnJvbGUgPT09ICd1c2VyJyAmJiAoICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInRleHQtWyMwMDdhY2NdXCI+ICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cInRleHQtWyMwMDdhY2NdXCI+JCB1c2VyOjwvc3Bhbj4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwibWwtMSB0ZXh0LVsjY2NjY2NjXVwiPnttc2cuY29udGVudH08L3NwYW4+ICAgICAgICAgICAgICA8L2Rpdj4gICAgICAgICAgICApfSAgICAgICAgICAgIHttc2cucm9sZSA9PT0gJ2Fzc2lzdGFudCcgJiYgKCAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ0ZXh0LVsjNGVjOWIwXVwiPiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJ0ZXh0LVsjNGVjOWIwXVwiPvCfpJYgYXNzaXN0YW50Ojwvc3Bhbj4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJtbC0xIHRleHQtWyNjY2NjY2NdIHdoaXRlc3BhY2UtcHJlLXdyYXBcIj57bXNnLmNvbnRlbnR9PC9kaXY+ICAgICAgICAgICAgICA8L2Rpdj4gICAgICAgICAgICApfSAgICAgICAgICAgIHttc2cucm9sZSA9PT0gJ3Rlcm1pbmFsJyAmJiAoICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInRleHQtWyM4NTg1ODVdXCI+ICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidGV4dC1bIzU4NTg1OF0gd2hpdGVzcGFjZS1wcmUtd3JhcCBiZy1bIzFhMWExYV0gcC0xIHJvdW5kZWQgdGV4dC1bMTBweF0gYm9yZGVyLWwtMiBib3JkZXItWyMzMzNdXCI+ICAgICAgICAgICAgICAgICAge21zZy5jb250ZW50fSAgICAgICAgICAgICAgICA8L2Rpdj4gICAgICAgICAgICAgIDwvZGl2PiAgICAgICAgICAgICl9ICAgICAgICAgIDwvZGl2PiAgICAgICAgKSl9ICAgICAgICB7LyogTG9hZGluZyBpbmRpY2F0b3IgKi99ICAgICAgICB7aXNMb2FkaW5nICYmICggICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ0ZXh0LVsjNGVjOWIwXVwiPiAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cInRleHQtWyM0ZWM5YjBdXCI+8J+kliBhc3Npc3RhbnQ6PC9zcGFuPiAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cIm1sLTEgdGV4dC1bIzg1ODU4NV1cIj50aGlua2luZy4uLjwvc3Bhbj4gICAgICAgICAgPC9kaXY+ICAgICAgICApfSAgICAgICAgey8qIElucHV0IGFyZWEgKi99ICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInN0aWNreSBib3R0b20tMCBiZy1bIzBlMGUwZV0gcHQtMlwiPiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggaXRlbXMtY2VudGVyXCI+ICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwidGV4dC1bIzAwN2FjY11cIj4kIHVzZXI6PC9zcGFuPiAgICAgICAgICAgIDxmb3JtIG9uU3VibWl0PXtoYW5kbGVTdWJtaXR9IGNsYXNzTmFtZT1cImZsZXgtMSBtbC0xXCI+ICAgICAgICAgICAgICA8aW5wdXQgICAgICAgICAgICAgICAgcmVmPXtpbnB1dFJlZn0gICAgICAgICAgICAgICAgdHlwZT1cInRleHRcIiAgICAgICAgICAgICAgICB2YWx1ZT17bWVzc2FnZX0gICAgICAgICAgICAgICAgb25DaGFuZ2U9e2hhbmRsZUlucHV0Q2hhbmdlfSAgICAgICAgICAgICAgICBvbktleURvd249e2hhbmRsZUtleURvd259ICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyPXsgICAgICAgICAgICAgICAgICBpc0F0U2Vzc2lvbkxpbWl0ICAgICAgICAgICAgICAgICAgICAgPyBcIlNlc3Npb24gbGltaXQgcmVhY2hlZCAtIFN0YXJ0IG5ldyBzZXNzaW9uIHRvIGNvbnRpbnVlLi4uXCIgICAgICAgICAgICAgICAgICAgICA6IGlzTG9hZGluZyAgICAgICAgICAgICAgICAgICAgICAgPyBcIkFJIGlzIHRoaW5raW5nLi4uXCIgICAgICAgICAgICAgICAgICAgICAgIDogXCJBc2sgYWJvdXQgeW91ciBFQUMgcHJvamVjdC4uLlwiICAgICAgICAgICAgICAgIH0gICAgICAgICAgICAgICAgZGlzYWJsZWQ9e2lzTG9hZGluZyB8fCBpc0F0U2Vzc2lvbkxpbWl0fSAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2B3LWZ1bGwgYmctdHJhbnNwYXJlbnQgYm9yZGVyLW5vbmUgb3V0bGluZS1ub25lIHBsYWNlaG9sZGVyOnRleHQtWyM4NTg1ODVdIGRpc2FibGVkOm9wYWNpdHktNTAgZGlzYWJsZWQ6Y3Vyc29yLW5vdC1hbGxvd2VkIGNhcmV0LVsjY2NjY2NjXSAkeyAgICAgICAgICAgICAgICAgIGlzQXRTZXNzaW9uTGltaXQgPyAndGV4dC1bI2Y0ODc3MV0nIDogJ3RleHQtWyNjY2NjY2NdJyAgICAgICAgICAgICAgICB9YH0gICAgICAgICAgICAgIC8+ICAgICAgICAgICAgPC9mb3JtPiAgICAgICAgICA8L2Rpdj4gICAgICAgIDwvZGl2PiAgICAgIDwvZGl2PiAgICA8L2Rpdj4gICk7fSJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/_components/terminal/_components/chatMessages.tsx\n"));

/***/ })

});