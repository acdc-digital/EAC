"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("_app-pages-browser_app__components_dashboard_socialPlatforms_xPostEditor_tsx",{

/***/ "(app-pages-browser)/./lib/hooks/useXApi.ts":
/*!******************************!*\
  !*** ./lib/hooks/useXApi.ts ***!
  \******************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useXApi: () => (/* binding */ useXApi)\n/* harmony export */ });\n/* harmony import */ var _convex_generated_api__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/convex/_generated/api */ \"(app-pages-browser)/./convex/_generated/api.js\");\n/* harmony import */ var convex_react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! convex/react */ \"(app-pages-browser)/../node_modules/convex/dist/esm/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"(app-pages-browser)/../node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _useSocialConnectionSync__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./useSocialConnectionSync */ \"(app-pages-browser)/./lib/hooks/useSocialConnectionSync.ts\");\n// X API Integration Hook - Uses Real Convex Social Connections\n// /Users/matthewsimon/Projects/eac/eac/lib/hooks/useXApi.ts\n\n\n\n\nfunction useXApi() {\n    var _twitterConnection_twitterAccessToken;\n    const [isPosting, setIsPosting] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(false);\n    const [isScheduling, setIsScheduling] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(false);\n    const [isUploading, setIsUploading] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(false);\n    // Use centralized social connection sync\n    const { twitterConnection, isLoading: connectionsLoading } = (0,_useSocialConnectionSync__WEBPACK_IMPORTED_MODULE_3__.useSocialConnectionSync)();\n    // Debug what we received from useSocialConnectionSync\n    console.log('🔍 useXApi received from useSocialConnectionSync:', {\n        twitterConnection: twitterConnection ? 'FOUND' : 'NULL',\n        connectionsLoading,\n        twitterConnectionId: twitterConnection === null || twitterConnection === void 0 ? void 0 : twitterConnection._id,\n        twitterConnectionPlatform: twitterConnection === null || twitterConnection === void 0 ? void 0 : twitterConnection.platform,\n        twitterConnectionUsername: twitterConnection === null || twitterConnection === void 0 ? void 0 : twitterConnection.username\n    });\n    // Debug logging with more detail - ALWAYS log to track state changes\n    console.log('🔍 X API Connection Debug (useXApi hook):', {\n        hasConnection: !!twitterConnection,\n        connectionsLoading,\n        twitterConnectionExists: twitterConnection !== null,\n        twitterConnectionUndefined: twitterConnection === undefined,\n        connectionDetails: twitterConnection ? {\n            id: twitterConnection._id,\n            platform: twitterConnection.platform,\n            username: twitterConnection.username,\n            twitterScreenName: twitterConnection.twitterScreenName,\n            hasAccessToken: !!twitterConnection.twitterAccessToken,\n            accessTokenActual: twitterConnection.twitterAccessToken ? 'HAS TOKEN' : 'NO TOKEN',\n            isActive: twitterConnection.isActive,\n            tokenLength: ((_twitterConnection_twitterAccessToken = twitterConnection.twitterAccessToken) === null || _twitterConnection_twitterAccessToken === void 0 ? void 0 : _twitterConnection_twitterAccessToken.length) || 0,\n            createdAt: new Date(twitterConnection.createdAt).toLocaleString(),\n            updatedAt: new Date(twitterConnection.updatedAt).toLocaleString()\n        } : 'NO_CONNECTION_FOUND - twitterConnection is null/undefined'\n    });\n    // Convex actions for X API\n    const createTweetAction = (0,convex_react__WEBPACK_IMPORTED_MODULE_1__.useAction)(_convex_generated_api__WEBPACK_IMPORTED_MODULE_0__.api.xApiActions.createTweet);\n    const uploadMediaAction = (0,convex_react__WEBPACK_IMPORTED_MODULE_1__.useAction)(_convex_generated_api__WEBPACK_IMPORTED_MODULE_0__.api.xApiActions.uploadMedia);\n    const deleteConnectionMutation = (0,convex_react__WEBPACK_IMPORTED_MODULE_1__.useMutation)(_convex_generated_api__WEBPACK_IMPORTED_MODULE_0__.api.x.deleteXConnection);\n    const postTweet = async (args)=>{\n        console.log('🐦 PostTweet called with:', {\n            hasConnection: !!twitterConnection,\n            connectionId: twitterConnection === null || twitterConnection === void 0 ? void 0 : twitterConnection._id\n        });\n        if (!twitterConnection) {\n            console.error('❌ No X connection found.');\n            return {\n                success: false,\n                error: 'No active X connection found. Please connect your X account in Settings → Social Connections.'\n            };\n        }\n        if (!twitterConnection.twitterAccessToken) {\n            console.error('❌ X connection found but no access token:', {\n                connectionId: twitterConnection._id,\n                platform: twitterConnection.platform\n            });\n            return {\n                success: false,\n                error: 'X connection found but not properly authenticated. Please reconnect your X account.'\n            };\n        }\n        try {\n            setIsPosting(true);\n            console.log('🐦 Starting tweet creation...');\n            const mediaIds = [];\n            // Upload media files if provided\n            if (args.media_files && args.media_files.length > 0) {\n                setIsUploading(true);\n                for (const file of args.media_files){\n                    try {\n                        // Convert file to base64 for upload\n                        const base64Data = await fileToBase64(file);\n                        const mediaResult = await uploadMediaAction({\n                            connectionId: twitterConnection._id,\n                            mediaData: base64Data,\n                            mediaType: file.type\n                        });\n                        if (mediaResult.success && mediaResult.media_id_string) {\n                            mediaIds.push(mediaResult.media_id_string);\n                        } else {\n                            console.warn('Failed to upload media:', mediaResult.error);\n                        }\n                    } catch (error) {\n                        console.error('Error uploading media file:', error);\n                    }\n                }\n                setIsUploading(false);\n            }\n            // Handle thread posting\n            if (args.is_thread && args.thread_tweets && args.thread_tweets.length > 1) {\n                var _firstTweet_data;\n                // Post first tweet\n                const firstTweet = await createTweetAction({\n                    connectionId: twitterConnection._id,\n                    text: args.thread_tweets[0],\n                    mediaIds: mediaIds.length > 0 ? [\n                        mediaIds[0]\n                    ] : undefined,\n                    replySettings: args.reply_settings\n                });\n                if (!firstTweet.success) {\n                    throw new Error(firstTweet.error || 'Failed to post first tweet');\n                }\n                let previousTweetId = (_firstTweet_data = firstTweet.data) === null || _firstTweet_data === void 0 ? void 0 : _firstTweet_data.id;\n                // Post remaining tweets as replies\n                for(let i = 1; i < args.thread_tweets.length; i++){\n                    var _threadTweet_data;\n                    const threadTweet = await createTweetAction({\n                        connectionId: twitterConnection._id,\n                        text: args.thread_tweets[i],\n                        replyToId: previousTweetId,\n                        mediaIds: mediaIds[i] ? [\n                            mediaIds[i]\n                        ] : undefined,\n                        replySettings: args.reply_settings\n                    });\n                    if (!threadTweet.success) {\n                        console.error(\"Failed to post tweet \".concat(i + 1, \" in thread:\"), threadTweet.error);\n                        break;\n                    }\n                    previousTweetId = (_threadTweet_data = threadTweet.data) === null || _threadTweet_data === void 0 ? void 0 : _threadTweet_data.id;\n                }\n                return {\n                    success: true,\n                    message: \"Thread posted successfully with \".concat(args.thread_tweets.length, \" tweets\"),\n                    data: firstTweet.data\n                };\n            } else {\n                // Single tweet\n                console.log('🐦 Calling createTweetAction with:', {\n                    connectionId: twitterConnection._id,\n                    text: args.text,\n                    textLength: args.text.length,\n                    mediaCount: mediaIds.length,\n                    replySettings: args.reply_settings\n                });\n                // Validate tweet text\n                if (!args.text || args.text.trim().length === 0) {\n                    console.error('❌ Tweet text is empty');\n                    return {\n                        success: false,\n                        error: 'Tweet text cannot be empty'\n                    };\n                }\n                if (args.text.length > 280) {\n                    console.error('❌ Tweet text too long:', args.text.length);\n                    return {\n                        success: false,\n                        error: \"Tweet text is too long (\".concat(args.text.length, \" characters). Maximum is 280 characters.\")\n                    };\n                }\n                const result = await createTweetAction({\n                    connectionId: twitterConnection._id,\n                    text: args.text,\n                    mediaIds: mediaIds.length > 0 ? mediaIds : undefined,\n                    replySettings: args.reply_settings\n                });\n                console.log('🐦 CreateTweetAction result:', result);\n                return {\n                    success: result.success,\n                    message: result.success ? 'Tweet posted successfully!' : result.error || 'Failed to post tweet',\n                    data: result.data,\n                    error: result.error\n                };\n            }\n        } catch (error) {\n            console.error('Error posting tweet:', error);\n            return {\n                success: false,\n                error: error instanceof Error ? error.message : 'Unknown error occurred'\n            };\n        } finally{\n            setIsPosting(false);\n            setIsUploading(false);\n        }\n    };\n    const schedulePost = async (args)=>{\n        if (!twitterConnection) {\n            return {\n                success: false,\n                error: 'No active X connection found. Please connect your X account first.'\n            };\n        }\n        setIsScheduling(true);\n        try {\n            // For now, store scheduled posts in localStorage \n            // In production, you'd want to use Convex mutations to store in a scheduledPosts table\n            const scheduledData = {\n                ...args,\n                connectionId: twitterConnection._id,\n                createdAt: new Date().toISOString(),\n                status: 'scheduled',\n                scheduledId: \"sched_\".concat(Date.now())\n            };\n            // Store in localStorage for demo purposes\n            const existingScheduled = JSON.parse(localStorage.getItem('scheduledPosts') || '[]');\n            existingScheduled.push(scheduledData);\n            localStorage.setItem('scheduledPosts', JSON.stringify(existingScheduled));\n            return {\n                success: true,\n                message: \"Post scheduled for \".concat(new Date(args.scheduledFor).toLocaleString()),\n                data: {\n                    scheduledId: scheduledData.scheduledId,\n                    scheduledFor: args.scheduledFor,\n                    status: 'scheduled'\n                }\n            };\n        } catch (error) {\n            return {\n                success: false,\n                error: error instanceof Error ? error.message : 'Failed to schedule post'\n            };\n        } finally{\n            setIsScheduling(false);\n        }\n    };\n    const uploadMediaFile = async (file)=>{\n        if (!twitterConnection) {\n            throw new Error('No active X connection');\n        }\n        setIsUploading(true);\n        try {\n            const base64Data = await fileToBase64(file);\n            const result = await uploadMediaAction({\n                connectionId: twitterConnection._id,\n                mediaData: base64Data,\n                mediaType: file.type\n            });\n            return result;\n        } finally{\n            setIsUploading(false);\n        }\n    };\n    const disconnectAccount = async ()=>{\n        console.log('🔌 disconnectAccount function called - START');\n        console.log('🔌 twitterConnection check:', !!twitterConnection);\n        if (!twitterConnection) {\n            console.log('❌ No X connection to disconnect');\n            return {\n                success: false,\n                error: 'No X connection found to disconnect'\n            };\n        }\n        try {\n            console.log('🔌 About to call deleteConnectionMutation with:', {\n                connectionId: twitterConnection._id,\n                connectionIdType: typeof twitterConnection._id\n            });\n            const mutationResult = await deleteConnectionMutation({\n                connectionId: twitterConnection._id\n            });\n            console.log('🔌 deleteConnectionMutation completed:', mutationResult);\n            console.log('✅ X account disconnected successfully');\n            return {\n                success: true,\n                message: 'X account disconnected successfully'\n            };\n        } catch (error) {\n            console.error('❌ Failed to disconnect X account:', error);\n            console.error('❌ Error details:', {\n                name: error instanceof Error ? error.name : 'Unknown',\n                message: error instanceof Error ? error.message : String(error),\n                stack: error instanceof Error ? error.stack : 'No stack'\n            });\n            return {\n                success: false,\n                error: error instanceof Error ? error.message : 'Failed to disconnect X account'\n            };\n        }\n    };\n    const returnValues = {\n        postTweet,\n        schedulePost,\n        uploadMediaFile,\n        disconnectAccount,\n        isPosting,\n        isScheduling,\n        isUploading,\n        hasConnection: !!twitterConnection,\n        connectionInfo: twitterConnection ? {\n            username: twitterConnection.twitterScreenName || twitterConnection.username || 'Unknown',\n            userId: twitterConnection.twitterUserId || 'Unknown',\n            connectionId: twitterConnection._id\n        } : null\n    };\n    console.log('🔍 useXApi returning values:', {\n        hasConnection: returnValues.hasConnection,\n        connectionInfo: returnValues.connectionInfo,\n        twitterConnectionNull: twitterConnection === null,\n        twitterConnectionUndefined: twitterConnection === undefined\n    });\n    return returnValues;\n}\n// Helper function to convert File to base64\nfunction fileToBase64(file) {\n    return new Promise((resolve, reject)=>{\n        const reader = new FileReader();\n        reader.readAsDataURL(file);\n        reader.onload = ()=>{\n            if (typeof reader.result === 'string') {\n                // Remove the data:image/jpeg;base64, prefix\n                const base64Data = reader.result.split(',')[1];\n                resolve(base64Data);\n            } else {\n                reject(new Error('Failed to convert file to base64'));\n            }\n        };\n        reader.onerror = (error)=>reject(error);\n    });\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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WEFwaS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBYIEFQSSBJbnRlZ3JhdGlvbiBIb29rIC0gVXNlcyBSZWFsIENvbnZleCBTb2NpYWwgQ29ubmVjdGlvbnNcbi8vIC9Vc2Vycy9tYXR0aGV3c2ltb24vUHJvamVjdHMvZWFjL2VhYy9saWIvaG9va3MvdXNlWEFwaS50c1xuXG5pbXBvcnQgeyBhcGkgfSBmcm9tIFwiQC9jb252ZXgvX2dlbmVyYXRlZC9hcGlcIjtcbmltcG9ydCB7IElkIH0gZnJvbSBcIkAvY29udmV4L19nZW5lcmF0ZWQvZGF0YU1vZGVsXCI7XG5pbXBvcnQgeyB1c2VBY3Rpb24sIHVzZU11dGF0aW9uIH0gZnJvbSBcImNvbnZleC9yZWFjdFwiO1xuaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IHVzZVNvY2lhbENvbm5lY3Rpb25TeW5jIH0gZnJvbSBcIi4vdXNlU29jaWFsQ29ubmVjdGlvblN5bmNcIjtcblxuaW50ZXJmYWNlIFBvc3RUd2VldEFyZ3Mge1xuICB0ZXh0OiBzdHJpbmc7XG4gIHJlcGx5X3NldHRpbmdzPzogJ2V2ZXJ5b25lJyB8ICdtZW50aW9uZWRVc2VycycgfCAnZm9sbG93ZXJzJztcbiAgbWVkaWFfZmlsZXM/OiBGaWxlW107XG4gIHBvbGw/OiB7XG4gICAgb3B0aW9uczogc3RyaW5nW107XG4gICAgZHVyYXRpb25fbWludXRlczogbnVtYmVyO1xuICB9O1xuICBpc190aHJlYWQ/OiBib29sZWFuO1xuICB0aHJlYWRfdHdlZXRzPzogc3RyaW5nW107XG59XG5cbmludGVyZmFjZSBTY2hlZHVsZVBvc3RBcmdzIGV4dGVuZHMgUG9zdFR3ZWV0QXJncyB7XG4gIHNjaGVkdWxlZEZvcjogc3RyaW5nO1xuICBmaWxlTmFtZTogc3RyaW5nO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlWEFwaSgpIHtcbiAgY29uc3QgW2lzUG9zdGluZywgc2V0SXNQb3N0aW5nXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW2lzU2NoZWR1bGluZywgc2V0SXNTY2hlZHVsaW5nXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW2lzVXBsb2FkaW5nLCBzZXRJc1VwbG9hZGluZ10gPSB1c2VTdGF0ZShmYWxzZSk7XG5cbiAgLy8gVXNlIGNlbnRyYWxpemVkIHNvY2lhbCBjb25uZWN0aW9uIHN5bmNcbiAgY29uc3QgeyB0d2l0dGVyQ29ubmVjdGlvbiwgaXNMb2FkaW5nOiBjb25uZWN0aW9uc0xvYWRpbmcgfSA9IHVzZVNvY2lhbENvbm5lY3Rpb25TeW5jKCk7XG4gIFxuICAvLyBEZWJ1ZyB3aGF0IHdlIHJlY2VpdmVkIGZyb20gdXNlU29jaWFsQ29ubmVjdGlvblN5bmNcbiAgY29uc29sZS5sb2coJ/CflI0gdXNlWEFwaSByZWNlaXZlZCBmcm9tIHVzZVNvY2lhbENvbm5lY3Rpb25TeW5jOicsIHtcbiAgICB0d2l0dGVyQ29ubmVjdGlvbjogdHdpdHRlckNvbm5lY3Rpb24gPyAnRk9VTkQnIDogJ05VTEwnLFxuICAgIGNvbm5lY3Rpb25zTG9hZGluZyxcbiAgICB0d2l0dGVyQ29ubmVjdGlvbklkOiB0d2l0dGVyQ29ubmVjdGlvbj8uX2lkLFxuICAgIHR3aXR0ZXJDb25uZWN0aW9uUGxhdGZvcm06IHR3aXR0ZXJDb25uZWN0aW9uPy5wbGF0Zm9ybSxcbiAgICB0d2l0dGVyQ29ubmVjdGlvblVzZXJuYW1lOiB0d2l0dGVyQ29ubmVjdGlvbj8udXNlcm5hbWVcbiAgfSk7XG4gIFxuICAvLyBEZWJ1ZyBsb2dnaW5nIHdpdGggbW9yZSBkZXRhaWwgLSBBTFdBWVMgbG9nIHRvIHRyYWNrIHN0YXRlIGNoYW5nZXNcbiAgY29uc29sZS5sb2coJ/CflI0gWCBBUEkgQ29ubmVjdGlvbiBEZWJ1ZyAodXNlWEFwaSBob29rKTonLCB7XG4gICAgaGFzQ29ubmVjdGlvbjogISF0d2l0dGVyQ29ubmVjdGlvbixcbiAgICBjb25uZWN0aW9uc0xvYWRpbmcsXG4gICAgdHdpdHRlckNvbm5lY3Rpb25FeGlzdHM6IHR3aXR0ZXJDb25uZWN0aW9uICE9PSBudWxsLFxuICAgIHR3aXR0ZXJDb25uZWN0aW9uVW5kZWZpbmVkOiB0d2l0dGVyQ29ubmVjdGlvbiA9PT0gdW5kZWZpbmVkLFxuICAgIGNvbm5lY3Rpb25EZXRhaWxzOiB0d2l0dGVyQ29ubmVjdGlvbiA/IHtcbiAgICAgIGlkOiB0d2l0dGVyQ29ubmVjdGlvbi5faWQsXG4gICAgICBwbGF0Zm9ybTogdHdpdHRlckNvbm5lY3Rpb24ucGxhdGZvcm0sIFxuICAgICAgdXNlcm5hbWU6IHR3aXR0ZXJDb25uZWN0aW9uLnVzZXJuYW1lLFxuICAgICAgdHdpdHRlclNjcmVlbk5hbWU6IHR3aXR0ZXJDb25uZWN0aW9uLnR3aXR0ZXJTY3JlZW5OYW1lLFxuICAgICAgaGFzQWNjZXNzVG9rZW46ICEhdHdpdHRlckNvbm5lY3Rpb24udHdpdHRlckFjY2Vzc1Rva2VuLFxuICAgICAgYWNjZXNzVG9rZW5BY3R1YWw6IHR3aXR0ZXJDb25uZWN0aW9uLnR3aXR0ZXJBY2Nlc3NUb2tlbiA/ICdIQVMgVE9LRU4nIDogJ05PIFRPS0VOJyxcbiAgICAgIGlzQWN0aXZlOiB0d2l0dGVyQ29ubmVjdGlvbi5pc0FjdGl2ZSxcbiAgICAgIHRva2VuTGVuZ3RoOiB0d2l0dGVyQ29ubmVjdGlvbi50d2l0dGVyQWNjZXNzVG9rZW4/Lmxlbmd0aCB8fCAwLFxuICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSh0d2l0dGVyQ29ubmVjdGlvbi5jcmVhdGVkQXQpLnRvTG9jYWxlU3RyaW5nKCksXG4gICAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKHR3aXR0ZXJDb25uZWN0aW9uLnVwZGF0ZWRBdCkudG9Mb2NhbGVTdHJpbmcoKVxuICAgIH0gOiAnTk9fQ09OTkVDVElPTl9GT1VORCAtIHR3aXR0ZXJDb25uZWN0aW9uIGlzIG51bGwvdW5kZWZpbmVkJ1xuICB9KTtcbiAgXG4gIC8vIENvbnZleCBhY3Rpb25zIGZvciBYIEFQSVxuICBjb25zdCBjcmVhdGVUd2VldEFjdGlvbiA9IHVzZUFjdGlvbihhcGkueEFwaUFjdGlvbnMuY3JlYXRlVHdlZXQpO1xuICBjb25zdCB1cGxvYWRNZWRpYUFjdGlvbiA9IHVzZUFjdGlvbihhcGkueEFwaUFjdGlvbnMudXBsb2FkTWVkaWEpO1xuICBjb25zdCBkZWxldGVDb25uZWN0aW9uTXV0YXRpb24gPSB1c2VNdXRhdGlvbihhcGkueC5kZWxldGVYQ29ubmVjdGlvbik7XG5cbiAgY29uc3QgcG9zdFR3ZWV0ID0gYXN5bmMgKGFyZ3M6IFBvc3RUd2VldEFyZ3MpID0+IHtcbiAgICBjb25zb2xlLmxvZygn8J+QpiBQb3N0VHdlZXQgY2FsbGVkIHdpdGg6JywgeyBoYXNDb25uZWN0aW9uOiAhIXR3aXR0ZXJDb25uZWN0aW9uLCBjb25uZWN0aW9uSWQ6IHR3aXR0ZXJDb25uZWN0aW9uPy5faWQgfSk7XG4gICAgXG4gICAgaWYgKCF0d2l0dGVyQ29ubmVjdGlvbikge1xuICAgICAgY29uc29sZS5lcnJvcign4p2MIE5vIFggY29ubmVjdGlvbiBmb3VuZC4nKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBlcnJvcjogJ05vIGFjdGl2ZSBYIGNvbm5lY3Rpb24gZm91bmQuIFBsZWFzZSBjb25uZWN0IHlvdXIgWCBhY2NvdW50IGluIFNldHRpbmdzIOKGkiBTb2NpYWwgQ29ubmVjdGlvbnMuJ1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAoIXR3aXR0ZXJDb25uZWN0aW9uLnR3aXR0ZXJBY2Nlc3NUb2tlbikge1xuICAgICAgY29uc29sZS5lcnJvcign4p2MIFggY29ubmVjdGlvbiBmb3VuZCBidXQgbm8gYWNjZXNzIHRva2VuOicsIHsgY29ubmVjdGlvbklkOiB0d2l0dGVyQ29ubmVjdGlvbi5faWQsIHBsYXRmb3JtOiB0d2l0dGVyQ29ubmVjdGlvbi5wbGF0Zm9ybSB9KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBlcnJvcjogJ1ggY29ubmVjdGlvbiBmb3VuZCBidXQgbm90IHByb3Blcmx5IGF1dGhlbnRpY2F0ZWQuIFBsZWFzZSByZWNvbm5lY3QgeW91ciBYIGFjY291bnQuJ1xuICAgICAgfTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgc2V0SXNQb3N0aW5nKHRydWUpO1xuICAgICAgY29uc29sZS5sb2coJ/CfkKYgU3RhcnRpbmcgdHdlZXQgY3JlYXRpb24uLi4nKTtcblxuICAgICAgY29uc3QgbWVkaWFJZHM6IHN0cmluZ1tdID0gW107XG5cbiAgICAgIC8vIFVwbG9hZCBtZWRpYSBmaWxlcyBpZiBwcm92aWRlZFxuICAgICAgaWYgKGFyZ3MubWVkaWFfZmlsZXMgJiYgYXJncy5tZWRpYV9maWxlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHNldElzVXBsb2FkaW5nKHRydWUpO1xuICAgICAgICBcbiAgICAgICAgZm9yIChjb25zdCBmaWxlIG9mIGFyZ3MubWVkaWFfZmlsZXMpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gQ29udmVydCBmaWxlIHRvIGJhc2U2NCBmb3IgdXBsb2FkXG4gICAgICAgICAgICBjb25zdCBiYXNlNjREYXRhID0gYXdhaXQgZmlsZVRvQmFzZTY0KGZpbGUpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBjb25zdCBtZWRpYVJlc3VsdCA9IGF3YWl0IHVwbG9hZE1lZGlhQWN0aW9uKHtcbiAgICAgICAgICAgICAgY29ubmVjdGlvbklkOiB0d2l0dGVyQ29ubmVjdGlvbi5faWQgYXMgSWQ8XCJzb2NpYWxDb25uZWN0aW9uc1wiPixcbiAgICAgICAgICAgICAgbWVkaWFEYXRhOiBiYXNlNjREYXRhLFxuICAgICAgICAgICAgICBtZWRpYVR5cGU6IGZpbGUudHlwZSxcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAobWVkaWFSZXN1bHQuc3VjY2VzcyAmJiBtZWRpYVJlc3VsdC5tZWRpYV9pZF9zdHJpbmcpIHtcbiAgICAgICAgICAgICAgbWVkaWFJZHMucHVzaChtZWRpYVJlc3VsdC5tZWRpYV9pZF9zdHJpbmcpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdGYWlsZWQgdG8gdXBsb2FkIG1lZGlhOicsIG1lZGlhUmVzdWx0LmVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgdXBsb2FkaW5nIG1lZGlhIGZpbGU6JywgZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzZXRJc1VwbG9hZGluZyhmYWxzZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIEhhbmRsZSB0aHJlYWQgcG9zdGluZ1xuICAgICAgaWYgKGFyZ3MuaXNfdGhyZWFkICYmIGFyZ3MudGhyZWFkX3R3ZWV0cyAmJiBhcmdzLnRocmVhZF90d2VldHMubGVuZ3RoID4gMSkge1xuICAgICAgICAvLyBQb3N0IGZpcnN0IHR3ZWV0XG4gICAgICAgIGNvbnN0IGZpcnN0VHdlZXQgPSBhd2FpdCBjcmVhdGVUd2VldEFjdGlvbih7XG4gICAgICAgICAgY29ubmVjdGlvbklkOiB0d2l0dGVyQ29ubmVjdGlvbi5faWQgYXMgSWQ8XCJzb2NpYWxDb25uZWN0aW9uc1wiPixcbiAgICAgICAgICB0ZXh0OiBhcmdzLnRocmVhZF90d2VldHNbMF0sXG4gICAgICAgICAgbWVkaWFJZHM6IG1lZGlhSWRzLmxlbmd0aCA+IDAgPyBbbWVkaWFJZHNbMF1dIDogdW5kZWZpbmVkLFxuICAgICAgICAgIHJlcGx5U2V0dGluZ3M6IGFyZ3MucmVwbHlfc2V0dGluZ3MsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICghZmlyc3RUd2VldC5zdWNjZXNzKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGZpcnN0VHdlZXQuZXJyb3IgfHwgJ0ZhaWxlZCB0byBwb3N0IGZpcnN0IHR3ZWV0Jyk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgcHJldmlvdXNUd2VldElkID0gZmlyc3RUd2VldC5kYXRhPy5pZDtcblxuICAgICAgICAvLyBQb3N0IHJlbWFpbmluZyB0d2VldHMgYXMgcmVwbGllc1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGFyZ3MudGhyZWFkX3R3ZWV0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IHRocmVhZFR3ZWV0ID0gYXdhaXQgY3JlYXRlVHdlZXRBY3Rpb24oe1xuICAgICAgICAgICAgY29ubmVjdGlvbklkOiB0d2l0dGVyQ29ubmVjdGlvbi5faWQgYXMgSWQ8XCJzb2NpYWxDb25uZWN0aW9uc1wiPixcbiAgICAgICAgICAgIHRleHQ6IGFyZ3MudGhyZWFkX3R3ZWV0c1tpXSxcbiAgICAgICAgICAgIHJlcGx5VG9JZDogcHJldmlvdXNUd2VldElkLFxuICAgICAgICAgICAgbWVkaWFJZHM6IG1lZGlhSWRzW2ldID8gW21lZGlhSWRzW2ldXSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHJlcGx5U2V0dGluZ3M6IGFyZ3MucmVwbHlfc2V0dGluZ3MsXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiAoIXRocmVhZFR3ZWV0LnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEZhaWxlZCB0byBwb3N0IHR3ZWV0ICR7aSArIDF9IGluIHRocmVhZDpgLCB0aHJlYWRUd2VldC5lcnJvcik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwcmV2aW91c1R3ZWV0SWQgPSB0aHJlYWRUd2VldC5kYXRhPy5pZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICBtZXNzYWdlOiBgVGhyZWFkIHBvc3RlZCBzdWNjZXNzZnVsbHkgd2l0aCAke2FyZ3MudGhyZWFkX3R3ZWV0cy5sZW5ndGh9IHR3ZWV0c2AsXG4gICAgICAgICAgZGF0YTogZmlyc3RUd2VldC5kYXRhXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBTaW5nbGUgdHdlZXRcbiAgICAgICAgY29uc29sZS5sb2coJ/CfkKYgQ2FsbGluZyBjcmVhdGVUd2VldEFjdGlvbiB3aXRoOicsIHsgXG4gICAgICAgICAgY29ubmVjdGlvbklkOiB0d2l0dGVyQ29ubmVjdGlvbi5faWQsIFxuICAgICAgICAgIHRleHQ6IGFyZ3MudGV4dCwgXG4gICAgICAgICAgdGV4dExlbmd0aDogYXJncy50ZXh0Lmxlbmd0aCxcbiAgICAgICAgICBtZWRpYUNvdW50OiBtZWRpYUlkcy5sZW5ndGgsXG4gICAgICAgICAgcmVwbHlTZXR0aW5nczogYXJncy5yZXBseV9zZXR0aW5ncyBcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICAvLyBWYWxpZGF0ZSB0d2VldCB0ZXh0XG4gICAgICAgIGlmICghYXJncy50ZXh0IHx8IGFyZ3MudGV4dC50cmltKCkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcign4p2MIFR3ZWV0IHRleHQgaXMgZW1wdHknKTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICBlcnJvcjogJ1R3ZWV0IHRleHQgY2Fubm90IGJlIGVtcHR5JyxcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAoYXJncy50ZXh0Lmxlbmd0aCA+IDI4MCkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBUd2VldCB0ZXh0IHRvbyBsb25nOicsIGFyZ3MudGV4dC5sZW5ndGgpO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgIGVycm9yOiBgVHdlZXQgdGV4dCBpcyB0b28gbG9uZyAoJHthcmdzLnRleHQubGVuZ3RofSBjaGFyYWN0ZXJzKS4gTWF4aW11bSBpcyAyODAgY2hhcmFjdGVycy5gLFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNyZWF0ZVR3ZWV0QWN0aW9uKHtcbiAgICAgICAgICBjb25uZWN0aW9uSWQ6IHR3aXR0ZXJDb25uZWN0aW9uLl9pZCBhcyBJZDxcInNvY2lhbENvbm5lY3Rpb25zXCI+LFxuICAgICAgICAgIHRleHQ6IGFyZ3MudGV4dCxcbiAgICAgICAgICBtZWRpYUlkczogbWVkaWFJZHMubGVuZ3RoID4gMCA/IG1lZGlhSWRzIDogdW5kZWZpbmVkLFxuICAgICAgICAgIHJlcGx5U2V0dGluZ3M6IGFyZ3MucmVwbHlfc2V0dGluZ3MsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnNvbGUubG9nKCfwn5CmIENyZWF0ZVR3ZWV0QWN0aW9uIHJlc3VsdDonLCByZXN1bHQpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3VjY2VzczogcmVzdWx0LnN1Y2Nlc3MsXG4gICAgICAgICAgbWVzc2FnZTogcmVzdWx0LnN1Y2Nlc3MgPyAnVHdlZXQgcG9zdGVkIHN1Y2Nlc3NmdWxseSEnIDogcmVzdWx0LmVycm9yIHx8ICdGYWlsZWQgdG8gcG9zdCB0d2VldCcsXG4gICAgICAgICAgZGF0YTogcmVzdWx0LmRhdGEsXG4gICAgICAgICAgZXJyb3I6IHJlc3VsdC5lcnJvclxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHBvc3RpbmcgdHdlZXQ6JywgZXJyb3IpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgIGVycm9yOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yIG9jY3VycmVkJ1xuICAgICAgfTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgc2V0SXNQb3N0aW5nKGZhbHNlKTtcbiAgICAgIHNldElzVXBsb2FkaW5nKGZhbHNlKTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3Qgc2NoZWR1bGVQb3N0ID0gYXN5bmMgKGFyZ3M6IFNjaGVkdWxlUG9zdEFyZ3MpID0+IHtcbiAgICBpZiAoIXR3aXR0ZXJDb25uZWN0aW9uKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6ICdObyBhY3RpdmUgWCBjb25uZWN0aW9uIGZvdW5kLiBQbGVhc2UgY29ubmVjdCB5b3VyIFggYWNjb3VudCBmaXJzdC4nXG4gICAgICB9O1xuICAgIH1cblxuICAgIHNldElzU2NoZWR1bGluZyh0cnVlKTtcbiAgICBcbiAgICB0cnkge1xuICAgICAgLy8gRm9yIG5vdywgc3RvcmUgc2NoZWR1bGVkIHBvc3RzIGluIGxvY2FsU3RvcmFnZSBcbiAgICAgIC8vIEluIHByb2R1Y3Rpb24sIHlvdSdkIHdhbnQgdG8gdXNlIENvbnZleCBtdXRhdGlvbnMgdG8gc3RvcmUgaW4gYSBzY2hlZHVsZWRQb3N0cyB0YWJsZVxuICAgICAgY29uc3Qgc2NoZWR1bGVkRGF0YSA9IHtcbiAgICAgICAgLi4uYXJncyxcbiAgICAgICAgY29ubmVjdGlvbklkOiB0d2l0dGVyQ29ubmVjdGlvbi5faWQsXG4gICAgICAgIFxuICAgICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgc3RhdHVzOiAnc2NoZWR1bGVkJyBhcyBjb25zdCxcbiAgICAgICAgc2NoZWR1bGVkSWQ6IGBzY2hlZF8ke0RhdGUubm93KCl9YFxuICAgICAgfTtcblxuICAgICAgLy8gU3RvcmUgaW4gbG9jYWxTdG9yYWdlIGZvciBkZW1vIHB1cnBvc2VzXG4gICAgICBjb25zdCBleGlzdGluZ1NjaGVkdWxlZCA9IEpTT04ucGFyc2UobG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3NjaGVkdWxlZFBvc3RzJykgfHwgJ1tdJyk7XG4gICAgICBleGlzdGluZ1NjaGVkdWxlZC5wdXNoKHNjaGVkdWxlZERhdGEpO1xuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ3NjaGVkdWxlZFBvc3RzJywgSlNPTi5zdHJpbmdpZnkoZXhpc3RpbmdTY2hlZHVsZWQpKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgbWVzc2FnZTogYFBvc3Qgc2NoZWR1bGVkIGZvciAke25ldyBEYXRlKGFyZ3Muc2NoZWR1bGVkRm9yKS50b0xvY2FsZVN0cmluZygpfWAsXG4gICAgICAgIGRhdGE6IHsgXG4gICAgICAgICAgc2NoZWR1bGVkSWQ6IHNjaGVkdWxlZERhdGEuc2NoZWR1bGVkSWQsIFxuICAgICAgICAgIHNjaGVkdWxlZEZvcjogYXJncy5zY2hlZHVsZWRGb3IsXG4gICAgICAgICAgc3RhdHVzOiAnc2NoZWR1bGVkJ1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBlcnJvcjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnRmFpbGVkIHRvIHNjaGVkdWxlIHBvc3QnXG4gICAgICB9O1xuICAgIH0gZmluYWxseSB7XG4gICAgICBzZXRJc1NjaGVkdWxpbmcoZmFsc2UpO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCB1cGxvYWRNZWRpYUZpbGUgPSBhc3luYyAoZmlsZTogRmlsZSkgPT4ge1xuICAgIGlmICghdHdpdHRlckNvbm5lY3Rpb24pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gYWN0aXZlIFggY29ubmVjdGlvbicpO1xuICAgIH1cblxuICAgIHNldElzVXBsb2FkaW5nKHRydWUpO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICBjb25zdCBiYXNlNjREYXRhID0gYXdhaXQgZmlsZVRvQmFzZTY0KGZpbGUpO1xuICAgICAgXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB1cGxvYWRNZWRpYUFjdGlvbih7XG4gICAgICAgIGNvbm5lY3Rpb25JZDogdHdpdHRlckNvbm5lY3Rpb24uX2lkIGFzIElkPFwic29jaWFsQ29ubmVjdGlvbnNcIj4sXG4gICAgICAgIG1lZGlhRGF0YTogYmFzZTY0RGF0YSxcbiAgICAgICAgbWVkaWFUeXBlOiBmaWxlLnR5cGUsXG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgc2V0SXNVcGxvYWRpbmcoZmFsc2UpO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBkaXNjb25uZWN0QWNjb3VudCA9IGFzeW5jICgpID0+IHtcbiAgICBjb25zb2xlLmxvZygn8J+UjCBkaXNjb25uZWN0QWNjb3VudCBmdW5jdGlvbiBjYWxsZWQgLSBTVEFSVCcpO1xuICAgIGNvbnNvbGUubG9nKCfwn5SMIHR3aXR0ZXJDb25uZWN0aW9uIGNoZWNrOicsICEhdHdpdHRlckNvbm5lY3Rpb24pO1xuICAgIFxuICAgIGlmICghdHdpdHRlckNvbm5lY3Rpb24pIHtcbiAgICAgIGNvbnNvbGUubG9nKCfinYwgTm8gWCBjb25uZWN0aW9uIHRvIGRpc2Nvbm5lY3QnKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBlcnJvcjogJ05vIFggY29ubmVjdGlvbiBmb3VuZCB0byBkaXNjb25uZWN0J1xuICAgICAgfTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgY29uc29sZS5sb2coJ/CflIwgQWJvdXQgdG8gY2FsbCBkZWxldGVDb25uZWN0aW9uTXV0YXRpb24gd2l0aDonLCB7IFxuICAgICAgICBjb25uZWN0aW9uSWQ6IHR3aXR0ZXJDb25uZWN0aW9uLl9pZCxcbiAgICAgICAgY29ubmVjdGlvbklkVHlwZTogdHlwZW9mIHR3aXR0ZXJDb25uZWN0aW9uLl9pZCBcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBjb25zdCBtdXRhdGlvblJlc3VsdCA9IGF3YWl0IGRlbGV0ZUNvbm5lY3Rpb25NdXRhdGlvbih7XG4gICAgICAgIGNvbm5lY3Rpb25JZDogdHdpdHRlckNvbm5lY3Rpb24uX2lkIGFzIElkPFwic29jaWFsQ29ubmVjdGlvbnNcIj5cbiAgICAgIH0pO1xuXG4gICAgICBjb25zb2xlLmxvZygn8J+UjCBkZWxldGVDb25uZWN0aW9uTXV0YXRpb24gY29tcGxldGVkOicsIG11dGF0aW9uUmVzdWx0KTtcbiAgICAgIGNvbnNvbGUubG9nKCfinIUgWCBhY2NvdW50IGRpc2Nvbm5lY3RlZCBzdWNjZXNzZnVsbHknKTtcbiAgICAgIFxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgbWVzc2FnZTogJ1ggYWNjb3VudCBkaXNjb25uZWN0ZWQgc3VjY2Vzc2Z1bGx5J1xuICAgICAgfTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcign4p2MIEZhaWxlZCB0byBkaXNjb25uZWN0IFggYWNjb3VudDonLCBlcnJvcik7XG4gICAgICBjb25zb2xlLmVycm9yKCfinYwgRXJyb3IgZGV0YWlsczonLCB7XG4gICAgICAgIG5hbWU6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5uYW1lIDogJ1Vua25vd24nLFxuICAgICAgICBtZXNzYWdlOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvciksXG4gICAgICAgIHN0YWNrOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3Iuc3RhY2sgOiAnTm8gc3RhY2snXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBlcnJvcjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnRmFpbGVkIHRvIGRpc2Nvbm5lY3QgWCBhY2NvdW50J1xuICAgICAgfTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgcmV0dXJuVmFsdWVzID0ge1xuICAgIHBvc3RUd2VldCxcbiAgICBzY2hlZHVsZVBvc3QsXG4gICAgdXBsb2FkTWVkaWFGaWxlLFxuICAgIGRpc2Nvbm5lY3RBY2NvdW50LFxuICAgIGlzUG9zdGluZyxcbiAgICBpc1NjaGVkdWxpbmcsXG4gICAgaXNVcGxvYWRpbmcsXG4gICAgaGFzQ29ubmVjdGlvbjogISF0d2l0dGVyQ29ubmVjdGlvbixcbiAgICBjb25uZWN0aW9uSW5mbzogdHdpdHRlckNvbm5lY3Rpb24gPyB7XG4gICAgICB1c2VybmFtZTogdHdpdHRlckNvbm5lY3Rpb24udHdpdHRlclNjcmVlbk5hbWUgfHwgdHdpdHRlckNvbm5lY3Rpb24udXNlcm5hbWUgfHwgJ1Vua25vd24nLFxuICAgICAgdXNlcklkOiB0d2l0dGVyQ29ubmVjdGlvbi50d2l0dGVyVXNlcklkIHx8ICdVbmtub3duJyxcbiAgICAgIGNvbm5lY3Rpb25JZDogdHdpdHRlckNvbm5lY3Rpb24uX2lkLFxuICAgIH0gOiBudWxsLFxuICB9O1xuXG4gIGNvbnNvbGUubG9nKCfwn5SNIHVzZVhBcGkgcmV0dXJuaW5nIHZhbHVlczonLCB7XG4gICAgaGFzQ29ubmVjdGlvbjogcmV0dXJuVmFsdWVzLmhhc0Nvbm5lY3Rpb24sXG4gICAgY29ubmVjdGlvbkluZm86IHJldHVyblZhbHVlcy5jb25uZWN0aW9uSW5mbyxcbiAgICB0d2l0dGVyQ29ubmVjdGlvbk51bGw6IHR3aXR0ZXJDb25uZWN0aW9uID09PSBudWxsLFxuICAgIHR3aXR0ZXJDb25uZWN0aW9uVW5kZWZpbmVkOiB0d2l0dGVyQ29ubmVjdGlvbiA9PT0gdW5kZWZpbmVkXG4gIH0pO1xuXG4gIHJldHVybiByZXR1cm5WYWx1ZXM7XG59XG5cbi8vIEhlbHBlciBmdW5jdGlvbiB0byBjb252ZXJ0IEZpbGUgdG8gYmFzZTY0XG5mdW5jdGlvbiBmaWxlVG9CYXNlNjQoZmlsZTogRmlsZSk6IFByb21pc2U8c3RyaW5nPiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgY29uc3QgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICByZWFkZXIucmVhZEFzRGF0YVVSTChmaWxlKTtcbiAgICByZWFkZXIub25sb2FkID0gKCkgPT4ge1xuICAgICAgaWYgKHR5cGVvZiByZWFkZXIucmVzdWx0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAvLyBSZW1vdmUgdGhlIGRhdGE6aW1hZ2UvanBlZztiYXNlNjQsIHByZWZpeFxuICAgICAgICBjb25zdCBiYXNlNjREYXRhID0gcmVhZGVyLnJlc3VsdC5zcGxpdCgnLCcpWzFdO1xuICAgICAgICByZXNvbHZlKGJhc2U2NERhdGEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignRmFpbGVkIHRvIGNvbnZlcnQgZmlsZSB0byBiYXNlNjQnKSk7XG4gICAgICB9XG4gICAgfTtcbiAgICByZWFkZXIub25lcnJvciA9IGVycm9yID0+IHJlamVjdChlcnJvcik7XG4gIH0pO1xufVxuIl0sIm5hbWVzIjpbImFwaSIsInVzZUFjdGlvbiIsInVzZU11dGF0aW9uIiwidXNlU3RhdGUiLCJ1c2VTb2NpYWxDb25uZWN0aW9uU3luYyIsInVzZVhBcGkiLCJ0d2l0dGVyQ29ubmVjdGlvbiIsImlzUG9zdGluZyIsInNldElzUG9zdGluZyIsImlzU2NoZWR1bGluZyIsInNldElzU2NoZWR1bGluZyIsImlzVXBsb2FkaW5nIiwic2V0SXNVcGxvYWRpbmciLCJpc0xvYWRpbmciLCJjb25uZWN0aW9uc0xvYWRpbmciLCJjb25zb2xlIiwibG9nIiwidHdpdHRlckNvbm5lY3Rpb25JZCIsIl9pZCIsInR3aXR0ZXJDb25uZWN0aW9uUGxhdGZvcm0iLCJwbGF0Zm9ybSIsInR3aXR0ZXJDb25uZWN0aW9uVXNlcm5hbWUiLCJ1c2VybmFtZSIsImhhc0Nvbm5lY3Rpb24iLCJ0d2l0dGVyQ29ubmVjdGlvbkV4aXN0cyIsInR3aXR0ZXJDb25uZWN0aW9uVW5kZWZpbmVkIiwidW5kZWZpbmVkIiwiY29ubmVjdGlvbkRldGFpbHMiLCJpZCIsInR3aXR0ZXJTY3JlZW5OYW1lIiwiaGFzQWNjZXNzVG9rZW4iLCJ0d2l0dGVyQWNjZXNzVG9rZW4iLCJhY2Nlc3NUb2tlbkFjdHVhbCIsImlzQWN0aXZlIiwidG9rZW5MZW5ndGgiLCJsZW5ndGgiLCJjcmVhdGVkQXQiLCJEYXRlIiwidG9Mb2NhbGVTdHJpbmciLCJ1cGRhdGVkQXQiLCJjcmVhdGVUd2VldEFjdGlvbiIsInhBcGlBY3Rpb25zIiwiY3JlYXRlVHdlZXQiLCJ1cGxvYWRNZWRpYUFjdGlvbiIsInVwbG9hZE1lZGlhIiwiZGVsZXRlQ29ubmVjdGlvbk11dGF0aW9uIiwieCIsImRlbGV0ZVhDb25uZWN0aW9uIiwicG9zdFR3ZWV0IiwiYXJncyIsImNvbm5lY3Rpb25JZCIsImVycm9yIiwic3VjY2VzcyIsIm1lZGlhSWRzIiwibWVkaWFfZmlsZXMiLCJmaWxlIiwiYmFzZTY0RGF0YSIsImZpbGVUb0Jhc2U2NCIsIm1lZGlhUmVzdWx0IiwibWVkaWFEYXRhIiwibWVkaWFUeXBlIiwidHlwZSIsIm1lZGlhX2lkX3N0cmluZyIsInB1c2giLCJ3YXJuIiwiaXNfdGhyZWFkIiwidGhyZWFkX3R3ZWV0cyIsImZpcnN0VHdlZXQiLCJ0ZXh0IiwicmVwbHlTZXR0aW5ncyIsInJlcGx5X3NldHRpbmdzIiwiRXJyb3IiLCJwcmV2aW91c1R3ZWV0SWQiLCJkYXRhIiwiaSIsInRocmVhZFR3ZWV0IiwicmVwbHlUb0lkIiwibWVzc2FnZSIsInRleHRMZW5ndGgiLCJtZWRpYUNvdW50IiwidHJpbSIsInJlc3VsdCIsInNjaGVkdWxlUG9zdCIsInNjaGVkdWxlZERhdGEiLCJ0b0lTT1N0cmluZyIsInN0YXR1cyIsInNjaGVkdWxlZElkIiwibm93IiwiZXhpc3RpbmdTY2hlZHVsZWQiLCJKU09OIiwicGFyc2UiLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwic2V0SXRlbSIsInN0cmluZ2lmeSIsInNjaGVkdWxlZEZvciIsInVwbG9hZE1lZGlhRmlsZSIsImRpc2Nvbm5lY3RBY2NvdW50IiwiY29ubmVjdGlvbklkVHlwZSIsIm11dGF0aW9uUmVzdWx0IiwibmFtZSIsIlN0cmluZyIsInN0YWNrIiwicmV0dXJuVmFsdWVzIiwiY29ubmVjdGlvbkluZm8iLCJ1c2VySWQiLCJ0d2l0dGVyVXNlcklkIiwidHdpdHRlckNvbm5lY3Rpb25OdWxsIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJyZWFkZXIiLCJGaWxlUmVhZGVyIiwicmVhZEFzRGF0YVVSTCIsIm9ubG9hZCIsInNwbGl0Iiwib25lcnJvciJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/hooks/useXApi.ts\n"));

/***/ })

});